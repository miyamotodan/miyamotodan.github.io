var Eee = Object.defineProperty;
var DI = (u) => {
  throw TypeError(u);
};
var Oee = (u, r, o) => r in u ? Eee(u, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : u[r] = o;
var Ft = (u, r, o) => Oee(u, typeof r != "symbol" ? r + "" : r, o), j4 = (u, r, o) => r.has(u) || DI("Cannot " + o);
var ce = (u, r, o) => (j4(u, r, "read from private field"), o ? o.call(u) : r.get(u)), It = (u, r, o) => r.has(u) ? DI("Cannot add the same private member more than once") : r instanceof WeakSet ? r.add(u) : r.set(u, o), ct = (u, r, o, a) => (j4(u, r, "write to private field"), a ? a.call(u, o) : r.set(u, o), o), at = (u, r, o) => (j4(u, r, "access private method"), o);
var Ww = (u, r, o, a) => ({
  set _(t) {
    ct(u, r, t, o);
  },
  get _() {
    return ce(u, r, a);
  }
});
const xee = "5";
var VX;
typeof window < "u" && ((VX = window.__svelte ?? (window.__svelte = {})).v ?? (VX.v = /* @__PURE__ */ new Set())).add(xee);
let eh = !1, Iee = !1;
function Ree() {
  eh = !0;
}
Ree();
const Fee = 1, Nee = 2, Pee = 16, Dee = 1, Lee = 2, jee = 4, Mee = 8, Cee = 16, qee = 1, Bee = 2, gx = "[", mx = "[!", vx = "]", C0 = {}, fn = Symbol(), $ee = "http://www.w3.org/1999/xhtml", LI = !1;
var YT = Array.isArray, Uee = Array.prototype.indexOf, Tx = Array.from, pS = Object.keys, PT = Object.defineProperty, Ha = Object.getOwnPropertyDescriptor, Vee = Object.getOwnPropertyDescriptors, Qee = Object.prototype, Hee = Array.prototype, QX = Object.getPrototypeOf, jI = Object.isExtensible;
const q0 = () => {
};
function Gee(u) {
  return u();
}
function bS(u) {
  for (var r = 0; r < u.length; r++)
    u[r]();
}
const $n = 2, HX = 4, IS = 8, wx = 16, va = 32, Zf = 64, Sx = 128, En = 256, yS = 512, xn = 1024, ba = 2048, Ka = 4096, fa = 8192, Ax = 16384, GX = 32768, Ex = 65536, zee = 1 << 17, MI = 1 << 18, kee = 1 << 19, zX = 1 << 20, LO = 1 << 21, ha = Symbol("$state"), kX = Symbol("legacy props"), Xee = Symbol(""), XX = 3, DT = 8;
function JX(u) {
  return u === this.v;
}
function KX(u, r) {
  return u != u ? r == r : u !== r || u !== null && typeof u == "object" || typeof u == "function";
}
function Ox(u) {
  return !KX(u, this.v);
}
function Jee(u) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Kee() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function Wee(u) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Yee() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Zee() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function ete(u) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function tte() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function rte() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function nte() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function WX(u) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
let er = null;
function CI(u) {
  er = u;
}
function RS(u, r = !1, o) {
  var a = er = {
    p: er,
    c: null,
    d: !1,
    e: null,
    m: !1,
    s: u,
    x: null,
    l: null
  };
  eh && !r && (er.l = {
    s: null,
    u: null,
    r1: [],
    r2: U0(!1)
  }), ew(() => {
    a.d = !0;
  });
}
function FS(u) {
  const r = er;
  if (r !== null) {
    u !== void 0 && (r.x = u);
    const n = r.e;
    if (n !== null) {
      var o = qt, a = Dt;
      r.e = null;
      try {
        for (var t = 0; t < n.length; t++) {
          var e = n[t];
          ka(e.effect), Di(e.reaction), xx(e.fn);
        }
      } finally {
        ka(o), Di(a);
      }
    }
    er = r.p, r.m = !0;
  }
  return u || /** @type {T} */
  {};
}
function ZT() {
  return !eh || er !== null && er.l === null;
}
function L0(u) {
  if (typeof u != "object" || u === null || ha in u)
    return u;
  const r = QX(u);
  if (r !== Qee && r !== Hee)
    return u;
  var o = /* @__PURE__ */ new Map(), a = YT(u), t = /* @__PURE__ */ Ia(0), e = Dt, n = (i) => {
    var c = Dt;
    Di(e);
    var s = i();
    return Di(c), s;
  };
  return a && o.set("length", /* @__PURE__ */ Ia(
    /** @type {any[]} */
    u.length
  )), new Proxy(
    /** @type {any} */
    u,
    {
      defineProperty(i, c, s) {
        (!("value" in s) || s.configurable === !1 || s.enumerable === !1 || s.writable === !1) && tte();
        var d = o.get(c);
        return d === void 0 ? d = n(() => {
          var l = /* @__PURE__ */ Ia(s.value);
          return o.set(c, l), l;
        }) : St(d, s.value, !0), !0;
      },
      deleteProperty(i, c) {
        var s = o.get(c);
        if (s === void 0) {
          if (c in i) {
            const f = n(() => /* @__PURE__ */ Ia(fn));
            o.set(c, f), M4(t);
          }
        } else {
          if (a && typeof c == "string") {
            var d = (
              /** @type {Source<number>} */
              o.get("length")
            ), l = Number(c);
            Number.isInteger(l) && l < d.v && St(d, l);
          }
          St(s, fn), M4(t);
        }
        return !0;
      },
      get(i, c, s) {
        var h;
        if (c === ha)
          return u;
        var d = o.get(c), l = c in i;
        if (d === void 0 && (!l || (h = Ha(i, c)) != null && h.writable) && (d = n(() => {
          var p = L0(l ? i[c] : fn), b = /* @__PURE__ */ Ia(p);
          return b;
        }), o.set(c, d)), d !== void 0) {
          var f = Pe(d);
          return f === fn ? void 0 : f;
        }
        return Reflect.get(i, c, s);
      },
      getOwnPropertyDescriptor(i, c) {
        var s = Reflect.getOwnPropertyDescriptor(i, c);
        if (s && "value" in s) {
          var d = o.get(c);
          d && (s.value = Pe(d));
        } else if (s === void 0) {
          var l = o.get(c), f = l == null ? void 0 : l.v;
          if (l !== void 0 && f !== fn)
            return {
              enumerable: !0,
              configurable: !0,
              value: f,
              writable: !0
            };
        }
        return s;
      },
      has(i, c) {
        var f;
        if (c === ha)
          return !0;
        var s = o.get(c), d = s !== void 0 && s.v !== fn || Reflect.has(i, c);
        if (s !== void 0 || qt !== null && (!d || (f = Ha(i, c)) != null && f.writable)) {
          s === void 0 && (s = n(() => {
            var h = d ? L0(i[c]) : fn, p = /* @__PURE__ */ Ia(h);
            return p;
          }), o.set(c, s));
          var l = Pe(s);
          if (l === fn)
            return !1;
        }
        return d;
      },
      set(i, c, s, d) {
        var g;
        var l = o.get(c), f = c in i;
        if (a && c === "length")
          for (var h = s; h < /** @type {Source<number>} */
          l.v; h += 1) {
            var p = o.get(h + "");
            p !== void 0 ? St(p, fn) : h in i && (p = n(() => /* @__PURE__ */ Ia(fn)), o.set(h + "", p));
          }
        if (l === void 0)
          (!f || (g = Ha(i, c)) != null && g.writable) && (l = n(() => /* @__PURE__ */ Ia(void 0)), St(l, L0(s)), o.set(c, l));
        else {
          f = l.v !== fn;
          var b = n(() => L0(s));
          St(l, b);
        }
        var _ = Reflect.getOwnPropertyDescriptor(i, c);
        if (_ != null && _.set && _.set.call(d, s), !f) {
          if (a && typeof c == "string") {
            var y = (
              /** @type {Source<number>} */
              o.get("length")
            ), m = Number(c);
            Number.isInteger(m) && m >= y.v && St(y, m + 1);
          }
          M4(t);
        }
        return !0;
      },
      ownKeys(i) {
        Pe(t);
        var c = Reflect.ownKeys(i).filter((l) => {
          var f = o.get(l);
          return f === void 0 || f.v !== fn;
        });
        for (var [s, d] of o)
          d.v !== fn && !(s in i) && c.push(s);
        return c;
      },
      setPrototypeOf() {
        rte();
      }
    }
  );
}
function M4(u, r = 1) {
  St(u, u.v + r);
}
function qI(u) {
  try {
    if (u !== null && typeof u == "object" && ha in u)
      return u[ha];
  } catch {
  }
  return u;
}
function ite(u, r) {
  return Object.is(qI(u), qI(r));
}
// @__NO_SIDE_EFFECTS__
function LT(u) {
  var r = $n | ba, o = Dt !== null && (Dt.f & $n) !== 0 ? (
    /** @type {Derived} */
    Dt
  ) : null;
  return qt === null || o !== null && (o.f & En) !== 0 ? r |= En : qt.f |= zX, {
    ctx: er,
    deps: null,
    effects: null,
    equals: JX,
    f: r,
    fn: u,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      null
    ),
    wv: 0,
    parent: o ?? qt
  };
}
// @__NO_SIDE_EFFECTS__
function B0(u) {
  const r = /* @__PURE__ */ LT(u);
  return r.equals = Ox, r;
}
function YX(u) {
  var r = u.effects;
  if (r !== null) {
    u.effects = null;
    for (var o = 0; o < r.length; o += 1)
      _a(
        /** @type {Effect} */
        r[o]
      );
  }
}
function ate(u) {
  for (var r = u.parent; r !== null; ) {
    if ((r.f & $n) === 0)
      return (
        /** @type {Effect} */
        r
      );
    r = r.parent;
  }
  return null;
}
function ZX(u) {
  var r, o = qt;
  ka(ate(u));
  try {
    YX(u), r = TJ(u);
  } finally {
    ka(o);
  }
  return r;
}
function eJ(u) {
  var r = ZX(u);
  if (u.equals(r) || (u.v = r, u.wv = mJ()), !rh) {
    var o = (Va || (u.f & En) !== 0) && u.deps !== null ? Ka : xn;
    _i(u, o);
  }
}
const jT = /* @__PURE__ */ new Map();
function U0(u, r) {
  var o = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: u,
    reactions: null,
    equals: JX,
    rv: 0,
    wv: 0
  };
  return o;
}
// @__NO_SIDE_EFFECTS__
function Ia(u, r) {
  const o = U0(u);
  return _te(o), o;
}
// @__NO_SIDE_EFFECTS__
function kr(u, r = !1, o = !0) {
  var t;
  const a = U0(u);
  return r || (a.equals = Ox), eh && o && er !== null && er.l !== null && ((t = er.l).s ?? (t.s = [])).push(a), a;
}
function St(u, r, o = !1) {
  Dt !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Fi || (Dt.f & MI) !== 0) && ZT() && (Dt.f & ($n | wx | MI)) !== 0 && !(Ir != null && Ir[1].includes(u) && Ir[0] === Dt) && nte();
  let a = o ? L0(r) : r;
  return tJ(u, a);
}
function tJ(u, r) {
  if (!u.equals(r)) {
    var o = u.v;
    rh ? jT.set(u, r) : jT.set(u, o), u.v = r, (u.f & $n) !== 0 && ((u.f & ba) !== 0 && ZX(
      /** @type {Derived} */
      u
    ), _i(u, (u.f & En) === 0 ? xn : Ka)), u.wv = mJ(), rJ(u, ba), ZT() && qt !== null && (qt.f & xn) !== 0 && (qt.f & (va | Zf)) === 0 && (Ln === null ? gte([u]) : Ln.push(u));
  }
  return r;
}
function rJ(u, r) {
  var o = u.reactions;
  if (o !== null)
    for (var a = ZT(), t = o.length, e = 0; e < t; e++) {
      var n = o[e], i = n.f;
      (i & ba) === 0 && (!a && n === qt || (_i(n, r), (i & (xn | En)) !== 0 && ((i & $n) !== 0 ? rJ(
        /** @type {Derived} */
        n,
        Ka
      ) : Nx(
        /** @type {Effect} */
        n
      ))));
    }
}
function NS(u) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function ute() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
let Ut = !1;
function la(u) {
  Ut = u;
}
let Vt;
function yi(u) {
  if (u === null)
    throw NS(), C0;
  return Vt = u;
}
function PS() {
  return yi(
    /** @type {TemplateNode} */
    /* @__PURE__ */ Ta(Vt)
  );
}
function _r(u) {
  if (Ut) {
    if (/* @__PURE__ */ Ta(Vt) !== null)
      throw NS(), C0;
    Vt = u;
  }
}
function BI(u = 1) {
  if (Ut) {
    for (var r = u, o = Vt; r--; )
      o = /** @type {TemplateNode} */
      /* @__PURE__ */ Ta(o);
    Vt = o;
  }
}
function jO() {
  for (var u = 0, r = Vt; ; ) {
    if (r.nodeType === DT) {
      var o = (
        /** @type {Comment} */
        r.data
      );
      if (o === vx) {
        if (u === 0) return r;
        u -= 1;
      } else (o === gx || o === mx) && (u += 1);
    }
    var a = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ta(r)
    );
    r.remove(), r = a;
  }
}
function nJ(u) {
  if (!u || u.nodeType !== DT)
    throw NS(), C0;
  return (
    /** @type {Comment} */
    u.data
  );
}
var $I, iJ, aJ, uJ;
function MO() {
  if ($I === void 0) {
    $I = window, iJ = /Firefox/.test(navigator.userAgent);
    var u = Element.prototype, r = Node.prototype, o = Text.prototype;
    aJ = Ha(r, "firstChild").get, uJ = Ha(r, "nextSibling").get, jI(u) && (u.__click = void 0, u.__className = void 0, u.__attributes = null, u.__style = void 0, u.__e = void 0), jI(o) && (o.__t = void 0);
  }
}
function V0(u = "") {
  return document.createTextNode(u);
}
// @__NO_SIDE_EFFECTS__
function ya(u) {
  return aJ.call(u);
}
// @__NO_SIDE_EFFECTS__
function Ta(u) {
  return uJ.call(u);
}
function Ar(u, r) {
  if (!Ut)
    return /* @__PURE__ */ ya(u);
  var o = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ ya(Vt)
  );
  if (o === null)
    o = Vt.appendChild(V0());
  else if (r && o.nodeType !== XX) {
    var a = V0();
    return o == null || o.before(a), yi(a), a;
  }
  return yi(o), o;
}
function _S(u, r) {
  if (!Ut) {
    var o = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ ya(
        /** @type {Node} */
        u
      )
    );
    return o instanceof Comment && o.data === "" ? /* @__PURE__ */ Ta(o) : o;
  }
  return Vt;
}
function pi(u, r = 1, o = !1) {
  let a = Ut ? Vt : u;
  for (var t; r--; )
    t = a, a = /** @type {TemplateNode} */
    /* @__PURE__ */ Ta(a);
  if (!Ut)
    return a;
  if (o && (a == null ? void 0 : a.nodeType) !== XX) {
    var e = V0();
    return a === null ? t == null || t.after(e) : a.before(e), yi(e), e;
  }
  return yi(a), /** @type {TemplateNode} */
  a;
}
function oJ(u) {
  u.textContent = "";
}
function sJ(u) {
  qt === null && Dt === null && Wee(), Dt !== null && (Dt.f & En) !== 0 && qt === null && Kee(), rh && Jee();
}
function ote(u, r) {
  var o = r.last;
  o === null ? r.last = r.first = u : (o.next = u, u.prev = o, r.last = u);
}
function e0(u, r, o, a = !0) {
  var t = qt, e = {
    ctx: er,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: u | ba,
    first: null,
    fn: r,
    last: null,
    next: null,
    parent: t,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  if (o)
    try {
      DS(e), e.f |= GX;
    } catch (c) {
      throw _a(e), c;
    }
  else r !== null && Nx(e);
  var n = o && e.deps === null && e.first === null && e.nodes_start === null && e.teardown === null && (e.f & (zX | Sx)) === 0;
  if (!n && a && (t !== null && ote(e, t), Dt !== null && (Dt.f & $n) !== 0)) {
    var i = (
      /** @type {Derived} */
      Dt
    );
    (i.effects ?? (i.effects = [])).push(e);
  }
  return e;
}
function ew(u) {
  const r = e0(IS, null, !1);
  return _i(r, xn), r.teardown = u, r;
}
function CO(u) {
  sJ();
  var r = qt !== null && (qt.f & va) !== 0 && er !== null && !er.m;
  if (r) {
    var o = (
      /** @type {ComponentContext} */
      er
    );
    (o.e ?? (o.e = [])).push({
      fn: u,
      effect: qt,
      reaction: Dt
    });
  } else {
    var a = xx(u);
    return a;
  }
}
function ste(u) {
  return sJ(), th(u);
}
function cte(u) {
  const r = e0(Zf, u, !0);
  return () => {
    _a(r);
  };
}
function dte(u) {
  const r = e0(Zf, u, !0);
  return (o = {}) => new Promise((a) => {
    o.outro ? gS(r, () => {
      _a(r), a(void 0);
    }) : (_a(r), a(void 0));
  });
}
function xx(u) {
  return e0(HX, u, !1);
}
function qO(u, r) {
  var o = (
    /** @type {ComponentContextLegacy} */
    er
  ), a = { effect: null, ran: !1 };
  o.l.r1.push(a), a.effect = th(() => {
    u(), !a.ran && (a.ran = !0, St(o.l.r2, !0), nt(r));
  });
}
function cJ() {
  var u = (
    /** @type {ComponentContextLegacy} */
    er
  );
  th(() => {
    if (Pe(u.l.r2)) {
      for (var r of u.l.r1) {
        var o = r.effect;
        (o.f & xn) !== 0 && _i(o, Ka), tw(o) && DS(o), r.ran = !1;
      }
      u.l.r2.v = !1;
    }
  });
}
function th(u) {
  return e0(IS, u, !0);
}
function Gf(u, r = [], o = LT) {
  const a = r.map(o);
  return Ix(() => u(...a.map(Pe)));
}
function Ix(u, r = 0) {
  return e0(IS | wx | r, u, !0);
}
function MT(u, r = !0) {
  return e0(IS | va, u, !0, r);
}
function dJ(u) {
  var r = u.teardown;
  if (r !== null) {
    const o = rh, a = Dt;
    UI(!0), Di(null);
    try {
      r.call(null);
    } finally {
      UI(o), Di(a);
    }
  }
}
function lJ(u, r = !1) {
  var o = u.first;
  for (u.first = u.last = null; o !== null; ) {
    var a = o.next;
    (o.f & Zf) !== 0 ? o.parent = null : _a(o, r), o = a;
  }
}
function lte(u) {
  for (var r = u.first; r !== null; ) {
    var o = r.next;
    (r.f & va) === 0 && _a(r), r = o;
  }
}
function _a(u, r = !0) {
  var o = !1;
  (r || (u.f & kee) !== 0) && u.nodes_start !== null && u.nodes_end !== null && (fte(
    u.nodes_start,
    /** @type {TemplateNode} */
    u.nodes_end
  ), o = !0), lJ(u, r && !o), TS(u, 0), _i(u, Ax);
  var a = u.transitions;
  if (a !== null)
    for (const e of a)
      e.stop();
  dJ(u);
  var t = u.parent;
  t !== null && t.first !== null && fJ(u), u.next = u.prev = u.teardown = u.ctx = u.deps = u.fn = u.nodes_start = u.nodes_end = null;
}
function fte(u, r) {
  for (; u !== null; ) {
    var o = u === r ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ta(u)
    );
    u.remove(), u = o;
  }
}
function fJ(u) {
  var r = u.parent, o = u.prev, a = u.next;
  o !== null && (o.next = a), a !== null && (a.prev = o), r !== null && (r.first === u && (r.first = a), r.last === u && (r.last = o));
}
function gS(u, r) {
  var o = [];
  Rx(u, o, !0), hJ(o, () => {
    _a(u), r && r();
  });
}
function hJ(u, r) {
  var o = u.length;
  if (o > 0) {
    var a = () => --o || r();
    for (var t of u)
      t.out(a);
  } else
    r();
}
function Rx(u, r, o) {
  if ((u.f & fa) === 0) {
    if (u.f ^= fa, u.transitions !== null)
      for (const n of u.transitions)
        (n.is_global || o) && r.push(n);
    for (var a = u.first; a !== null; ) {
      var t = a.next, e = (a.f & Ex) !== 0 || (a.f & va) !== 0;
      Rx(a, r, e ? o : !1), a = t;
    }
  }
}
function mS(u) {
  pJ(u, !0);
}
function pJ(u, r) {
  if ((u.f & fa) !== 0) {
    u.f ^= fa;
    for (var o = u.first; o !== null; ) {
      var a = o.next, t = (o.f & Ex) !== 0 || (o.f & va) !== 0;
      pJ(o, t ? r : !1), o = a;
    }
    if (u.transitions !== null)
      for (const e of u.transitions)
        (e.is_global || r) && e.in();
  }
}
const hte = typeof requestIdleCallback > "u" ? (u) => setTimeout(u, 1) : requestIdleCallback;
let CT = [], qT = [];
function bJ() {
  var u = CT;
  CT = [], bS(u);
}
function yJ() {
  var u = qT;
  qT = [], bS(u);
}
function Fx(u) {
  CT.length === 0 && queueMicrotask(bJ), CT.push(u);
}
function pte(u) {
  qT.length === 0 && hte(yJ), qT.push(u);
}
function bte() {
  CT.length > 0 && bJ(), qT.length > 0 && yJ();
}
function yte(u) {
  var r = (
    /** @type {Effect} */
    qt
  );
  if ((r.f & GX) === 0) {
    if ((r.f & Sx) === 0)
      throw u;
    r.fn(u);
  } else
    _J(u, r);
}
function _J(u, r) {
  for (; r !== null; ) {
    if ((r.f & Sx) !== 0)
      try {
        r.fn(u);
        return;
      } catch {
      }
    r = r.parent;
  }
  throw u;
}
let BT = !1, $T = null, Xf = !1, rh = !1;
function UI(u) {
  rh = u;
}
let IT = [];
let Dt = null, Fi = !1;
function Di(u) {
  Dt = u;
}
let qt = null;
function ka(u) {
  qt = u;
}
let Ir = null;
function _te(u) {
  Dt !== null && Dt.f & LO && (Ir === null ? Ir = [Dt, [u]] : Ir[1].push(u));
}
let rn = null, wn = 0, Ln = null;
function gte(u) {
  Ln = u;
}
let gJ = 1, vS = 0, Va = !1;
function mJ() {
  return ++gJ;
}
function tw(u) {
  var l;
  var r = u.f;
  if ((r & ba) !== 0)
    return !0;
  if ((r & Ka) !== 0) {
    var o = u.deps, a = (r & En) !== 0;
    if (o !== null) {
      var t, e, n = (r & yS) !== 0, i = a && qt !== null && !Va, c = o.length;
      if (n || i) {
        var s = (
          /** @type {Derived} */
          u
        ), d = s.parent;
        for (t = 0; t < c; t++)
          e = o[t], (n || !((l = e == null ? void 0 : e.reactions) != null && l.includes(s))) && (e.reactions ?? (e.reactions = [])).push(s);
        n && (s.f ^= yS), i && d !== null && (d.f & En) === 0 && (s.f ^= En);
      }
      for (t = 0; t < c; t++)
        if (e = o[t], tw(
          /** @type {Derived} */
          e
        ) && eJ(
          /** @type {Derived} */
          e
        ), e.wv > u.wv)
          return !0;
    }
    (!a || qt !== null && !Va) && _i(u, xn);
  }
  return !1;
}
function vJ(u, r, o = !0) {
  var a = u.reactions;
  if (a !== null)
    for (var t = 0; t < a.length; t++) {
      var e = a[t];
      Ir != null && Ir[1].includes(u) && Ir[0] === Dt || ((e.f & $n) !== 0 ? vJ(
        /** @type {Derived} */
        e,
        r,
        !1
      ) : r === e && (o ? _i(e, ba) : (e.f & xn) !== 0 && _i(e, Ka), Nx(
        /** @type {Effect} */
        e
      )));
    }
}
function TJ(u) {
  var h;
  var r = rn, o = wn, a = Ln, t = Dt, e = Va, n = Ir, i = er, c = Fi, s = u.f;
  rn = /** @type {null | Value[]} */
  null, wn = 0, Ln = null, Va = (s & En) !== 0 && (Fi || !Xf || Dt === null), Dt = (s & (va | Zf)) === 0 ? u : null, Ir = null, CI(u.ctx), Fi = !1, vS++, u.f |= LO;
  try {
    var d = (
      /** @type {Function} */
      (0, u.fn)()
    ), l = u.deps;
    if (rn !== null) {
      var f;
      if (TS(u, wn), l !== null && wn > 0)
        for (l.length = wn + rn.length, f = 0; f < rn.length; f++)
          l[wn + f] = rn[f];
      else
        u.deps = l = rn;
      if (!Va || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (s & $n) !== 0 && /** @type {import('#client').Derived} */
      u.reactions !== null)
        for (f = wn; f < l.length; f++)
          ((h = l[f]).reactions ?? (h.reactions = [])).push(u);
    } else l !== null && wn < l.length && (TS(u, wn), l.length = wn);
    if (ZT() && Ln !== null && !Fi && l !== null && (u.f & ($n | Ka | ba)) === 0)
      for (f = 0; f < /** @type {Source[]} */
      Ln.length; f++)
        vJ(
          Ln[f],
          /** @type {Effect} */
          u
        );
    return t !== null && t !== u && (vS++, Ln !== null && (a === null ? a = Ln : a.push(.../** @type {Source[]} */
    Ln))), d;
  } catch (p) {
    yte(p);
  } finally {
    rn = r, wn = o, Ln = a, Dt = t, Va = e, Ir = n, CI(i), Fi = c, u.f ^= LO;
  }
}
function mte(u, r) {
  let o = r.reactions;
  if (o !== null) {
    var a = Uee.call(o, u);
    if (a !== -1) {
      var t = o.length - 1;
      t === 0 ? o = r.reactions = null : (o[a] = o[t], o.pop());
    }
  }
  o === null && (r.f & $n) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (rn === null || !rn.includes(r)) && (_i(r, Ka), (r.f & (En | yS)) === 0 && (r.f ^= yS), YX(
    /** @type {Derived} **/
    r
  ), TS(
    /** @type {Derived} **/
    r,
    0
  ));
}
function TS(u, r) {
  var o = u.deps;
  if (o !== null)
    for (var a = r; a < o.length; a++)
      mte(u, o[a]);
}
function DS(u) {
  var r = u.f;
  if ((r & Ax) === 0) {
    _i(u, xn);
    var o = qt, a = Xf;
    qt = u, Xf = !0;
    try {
      (r & wx) !== 0 ? lte(u) : lJ(u), dJ(u);
      var t = TJ(u);
      u.teardown = typeof t == "function" ? t : null, u.wv = gJ;
      var e;
      LI && Iee && (u.f & ba) !== 0 && u.deps;
    } finally {
      Xf = a, qt = o;
    }
  }
}
function vte() {
  try {
    Yee();
  } catch (u) {
    if ($T !== null)
      _J(u, $T);
    else
      throw u;
  }
}
function wJ() {
  var u = Xf;
  try {
    var r = 0;
    for (Xf = !0; IT.length > 0; ) {
      r++ > 1e3 && vte();
      var o = IT, a = o.length;
      IT = [];
      for (var t = 0; t < a; t++) {
        var e = wte(o[t]);
        Tte(e);
      }
      jT.clear();
    }
  } finally {
    BT = !1, Xf = u, $T = null;
  }
}
function Tte(u) {
  var r = u.length;
  if (r !== 0)
    for (var o = 0; o < r; o++) {
      var a = u[o];
      (a.f & (Ax | fa)) === 0 && tw(a) && (DS(a), a.deps === null && a.first === null && a.nodes_start === null && (a.teardown === null ? fJ(a) : a.fn = null));
    }
}
function Nx(u) {
  BT || (BT = !0, queueMicrotask(wJ));
  for (var r = $T = u; r.parent !== null; ) {
    r = r.parent;
    var o = r.f;
    if ((o & (Zf | va)) !== 0) {
      if ((o & xn) === 0) return;
      r.f ^= xn;
    }
  }
  IT.push(r);
}
function wte(u) {
  for (var r = [], o = u; o !== null; ) {
    var a = o.f, t = (a & (va | Zf)) !== 0, e = t && (a & xn) !== 0;
    if (!e && (a & fa) === 0) {
      (a & HX) !== 0 ? r.push(o) : t ? o.f ^= xn : tw(o) && DS(o);
      var n = o.first;
      if (n !== null) {
        o = n;
        continue;
      }
    }
    var i = o.parent;
    for (o = o.next; o === null && i !== null; )
      o = i.next, i = i.parent;
  }
  return r;
}
function Ste(u) {
  for (var r; ; ) {
    if (bte(), IT.length === 0)
      return BT = !1, $T = null, /** @type {T} */
      r;
    BT = !0, wJ();
  }
}
function Pe(u) {
  var r = u.f, o = (r & $n) !== 0;
  if (Dt !== null && !Fi) {
    if (!(Ir != null && Ir[1].includes(u)) || Ir[0] !== Dt) {
      var a = Dt.deps;
      u.rv < vS && (u.rv = vS, rn === null && a !== null && a[wn] === u ? wn++ : rn === null ? rn = [u] : (!Va || !rn.includes(u)) && rn.push(u));
    }
  } else if (o && /** @type {Derived} */
  u.deps === null && /** @type {Derived} */
  u.effects === null) {
    var t = (
      /** @type {Derived} */
      u
    ), e = t.parent;
    e !== null && (e.f & En) === 0 && (t.f ^= En);
  }
  return o && (t = /** @type {Derived} */
  u, tw(t) && eJ(t)), rh && jT.has(u) ? jT.get(u) : u.v;
}
function nt(u) {
  var r = Fi;
  try {
    return Fi = !0, u();
  } finally {
    Fi = r;
  }
}
const Ate = -7169;
function _i(u, r) {
  u.f = u.f & Ate | r;
}
function j0(u) {
  if (!(typeof u != "object" || !u || u instanceof EventTarget)) {
    if (ha in u)
      BO(u);
    else if (!Array.isArray(u))
      for (let r in u) {
        const o = u[r];
        typeof o == "object" && o && ha in o && BO(o);
      }
  }
}
function BO(u, r = /* @__PURE__ */ new Set()) {
  if (typeof u == "object" && u !== null && // We don't want to traverse DOM elements
  !(u instanceof EventTarget) && !r.has(u)) {
    r.add(u), u instanceof Date && u.getTime();
    for (let a in u)
      try {
        BO(u[a], r);
      } catch {
      }
    const o = QX(u);
    if (o !== Object.prototype && o !== Array.prototype && o !== Map.prototype && o !== Set.prototype && o !== Date.prototype) {
      const a = Vee(o);
      for (let t in a) {
        const e = a[t].get;
        if (e)
          try {
            e.call(u);
          } catch {
          }
      }
    }
  }
}
let VI = !1;
function SJ() {
  VI || (VI = !0, document.addEventListener(
    "reset",
    (u) => {
      Promise.resolve().then(() => {
        var r;
        if (!u.defaultPrevented)
          for (
            const o of
            /**@type {HTMLFormElement} */
            u.target.elements
          )
            (r = o.__on_r) == null || r.call(o);
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function AJ(u) {
  var r = Dt, o = qt;
  Di(null), ka(null);
  try {
    return u();
  } finally {
    Di(r), ka(o);
  }
}
function Ete(u, r, o, a = o) {
  u.addEventListener(r, () => AJ(o));
  const t = u.__on_r;
  t ? u.__on_r = () => {
    t(), a(!0);
  } : u.__on_r = () => a(!0), SJ();
}
const Ote = /* @__PURE__ */ new Set(), QI = /* @__PURE__ */ new Set();
function xte(u, r, o, a = {}) {
  function t(e) {
    if (a.capture || lT.call(r, e), !e.cancelBubble)
      return AJ(() => o == null ? void 0 : o.call(this, e));
  }
  return u.startsWith("pointer") || u.startsWith("touch") || u === "wheel" ? Fx(() => {
    r.addEventListener(u, t, a);
  }) : r.addEventListener(u, t, a), t;
}
function jn(u, r, o, a, t) {
  var e = { capture: a, passive: t }, n = xte(u, r, o, e);
  (r === document.body || // @ts-ignore
  r === window || // @ts-ignore
  r === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  r instanceof HTMLMediaElement) && ew(() => {
    r.removeEventListener(u, n, e);
  });
}
function lT(u) {
  var m;
  var r = this, o = (
    /** @type {Node} */
    r.ownerDocument
  ), a = u.type, t = ((m = u.composedPath) == null ? void 0 : m.call(u)) || [], e = (
    /** @type {null | Element} */
    t[0] || u.target
  ), n = 0, i = u.__root;
  if (i) {
    var c = t.indexOf(i);
    if (c !== -1 && (r === document || r === /** @type {any} */
    window)) {
      u.__root = r;
      return;
    }
    var s = t.indexOf(r);
    if (s === -1)
      return;
    c <= s && (n = c);
  }
  if (e = /** @type {Element} */
  t[n] || u.target, e !== r) {
    PT(u, "currentTarget", {
      configurable: !0,
      get() {
        return e || o;
      }
    });
    var d = Dt, l = qt;
    Di(null), ka(null);
    try {
      for (var f, h = []; e !== null; ) {
        var p = e.assignedSlot || e.parentNode || /** @type {any} */
        e.host || null;
        try {
          var b = e["__" + a];
          if (b != null && (!/** @type {any} */
          e.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          u.target === e))
            if (YT(b)) {
              var [_, ...y] = b;
              _.apply(e, [u, ...y]);
            } else
              b.call(e, u);
        } catch (g) {
          f ? h.push(g) : f = g;
        }
        if (u.cancelBubble || p === r || p === null)
          break;
        e = p;
      }
      if (f) {
        for (let g of h)
          queueMicrotask(() => {
            throw g;
          });
        throw f;
      }
    } finally {
      u.__root = r, delete u.currentTarget, Di(d), ka(l);
    }
  }
}
function EJ(u) {
  var r = document.createElement("template");
  return r.innerHTML = u.replaceAll("<!>", "<!---->"), r.content;
}
function Ga(u, r) {
  var o = (
    /** @type {Effect} */
    qt
  );
  o.nodes_start === null && (o.nodes_start = u, o.nodes_end = r);
}
// @__NO_SIDE_EFFECTS__
function Qn(u, r) {
  var o = (r & qee) !== 0, a = (r & Bee) !== 0, t, e = !u.startsWith("<!>");
  return () => {
    if (Ut)
      return Ga(Vt, null), Vt;
    t === void 0 && (t = EJ(e ? u : "<!>" + u), o || (t = /** @type {Node} */
    /* @__PURE__ */ ya(t)));
    var n = (
      /** @type {TemplateNode} */
      a || iJ ? document.importNode(t, !0) : t.cloneNode(!0)
    );
    if (o) {
      var i = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ya(n)
      ), c = (
        /** @type {TemplateNode} */
        n.lastChild
      );
      Ga(i, c);
    } else
      Ga(n, n);
    return n;
  };
}
// @__NO_SIDE_EFFECTS__
function Ite(u, r, o = "svg") {
  var a = !u.startsWith("<!>"), t = `<${o}>${a ? u : "<!>" + u}</${o}>`, e;
  return () => {
    if (Ut)
      return Ga(Vt, null), Vt;
    if (!e) {
      var n = (
        /** @type {DocumentFragment} */
        EJ(t)
      ), i = (
        /** @type {Element} */
        /* @__PURE__ */ ya(n)
      );
      e = /** @type {Element} */
      /* @__PURE__ */ ya(i);
    }
    var c = (
      /** @type {TemplateNode} */
      e.cloneNode(!0)
    );
    return Ga(c, c), c;
  };
}
// @__NO_SIDE_EFFECTS__
function OJ(u, r) {
  return /* @__PURE__ */ Ite(u, r, "svg");
}
function Rte() {
  if (Ut)
    return Ga(Vt, null), Vt;
  var u = document.createDocumentFragment(), r = document.createComment(""), o = V0();
  return u.append(r, o), Ga(r, o), u;
}
function zr(u, r) {
  if (Ut) {
    qt.nodes_end = Vt, PS();
    return;
  }
  u !== null && u.before(
    /** @type {Node} */
    r
  );
}
const Fte = ["touchstart", "touchmove"];
function Nte(u) {
  return Fte.includes(u);
}
function RT(u, r) {
  var o = r == null ? "" : typeof r == "object" ? r + "" : r;
  o !== (u.__t ?? (u.__t = u.nodeValue)) && (u.__t = o, u.nodeValue = o + "");
}
function xJ(u, r) {
  return IJ(u, r);
}
function Pte(u, r) {
  MO(), r.intro = r.intro ?? !1;
  const o = r.target, a = Ut, t = Vt;
  try {
    for (var e = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ya(o)
    ); e && (e.nodeType !== DT || /** @type {Comment} */
    e.data !== gx); )
      e = /** @type {TemplateNode} */
      /* @__PURE__ */ Ta(e);
    if (!e)
      throw C0;
    la(!0), yi(
      /** @type {Comment} */
      e
    ), PS();
    const n = IJ(u, { ...r, anchor: e });
    if (Vt === null || Vt.nodeType !== DT || /** @type {Comment} */
    Vt.data !== vx)
      throw NS(), C0;
    return la(!1), /**  @type {Exports} */
    n;
  } catch (n) {
    if (n === C0)
      return r.recover === !1 && Zee(), MO(), oJ(o), la(!1), xJ(u, r);
    throw n;
  } finally {
    la(a), yi(t);
  }
}
const y0 = /* @__PURE__ */ new Map();
function IJ(u, { target: r, anchor: o, props: a = {}, events: t, context: e, intro: n = !0 }) {
  MO();
  var i = /* @__PURE__ */ new Set(), c = (l) => {
    for (var f = 0; f < l.length; f++) {
      var h = l[f];
      if (!i.has(h)) {
        i.add(h);
        var p = Nte(h);
        r.addEventListener(h, lT, { passive: p });
        var b = y0.get(h);
        b === void 0 ? (document.addEventListener(h, lT, { passive: p }), y0.set(h, 1)) : y0.set(h, b + 1);
      }
    }
  };
  c(Tx(Ote)), QI.add(c);
  var s = void 0, d = dte(() => {
    var l = o ?? r.appendChild(V0());
    return MT(() => {
      if (e) {
        RS({});
        var f = (
          /** @type {ComponentContext} */
          er
        );
        f.c = e;
      }
      t && (a.$$events = t), Ut && Ga(
        /** @type {TemplateNode} */
        l,
        null
      ), s = u(l, a) || {}, Ut && (qt.nodes_end = Vt), e && FS();
    }), () => {
      var p;
      for (var f of i) {
        r.removeEventListener(f, lT);
        var h = (
          /** @type {number} */
          y0.get(f)
        );
        --h === 0 ? (document.removeEventListener(f, lT), y0.delete(f)) : y0.set(f, h);
      }
      QI.delete(c), l !== o && ((p = l.parentNode) == null || p.removeChild(l));
    };
  });
  return $O.set(s, d), s;
}
let $O = /* @__PURE__ */ new WeakMap();
function Dte(u, r) {
  const o = $O.get(u);
  return o ? ($O.delete(u), o(r)) : Promise.resolve();
}
function Px(u) {
  er === null && WX(), eh && er.l !== null ? jte(er).m.push(u) : CO(() => {
    const r = nt(u);
    if (typeof r == "function") return (
      /** @type {() => void} */
      r
    );
  });
}
function Lte(u) {
  er === null && WX(), Px(() => () => nt(u));
}
function jte(u) {
  var r = (
    /** @type {ComponentContextLegacy} */
    u.l
  );
  return r.u ?? (r.u = { a: [], b: [], m: [] });
}
function Pi(u, r, [o, a] = [0, 0]) {
  Ut && o === 0 && PS();
  var t = u, e = null, n = null, i = fn, c = o > 0 ? Ex : 0, s = !1;
  const d = (f, h = !0) => {
    s = !0, l(h, f);
  }, l = (f, h) => {
    if (i === (i = f)) return;
    let p = !1;
    if (Ut && a !== -1) {
      if (o === 0) {
        const _ = nJ(t);
        _ === gx ? a = 0 : _ === mx ? a = 1 / 0 : (a = parseInt(_.substring(1)), a !== a && (a = i ? 1 / 0 : -1));
      }
      const b = a > o;
      !!i === b && (t = jO(), yi(t), la(!1), p = !0, a = -1);
    }
    i ? (e ? mS(e) : h && (e = MT(() => h(t))), n && gS(n, () => {
      n = null;
    })) : (n ? mS(n) : h && (n = MT(() => h(t, [o + 1, a]))), e && gS(e, () => {
      e = null;
    })), p && la(!0);
  };
  Ix(() => {
    s = !1, r(d), s || l(null, null);
  }, c), Ut && (t = Vt);
}
function Mte(u, r) {
  return r;
}
function Cte(u, r, o, a) {
  for (var t = [], e = r.length, n = 0; n < e; n++)
    Rx(r[n].e, t, !0);
  var i = e > 0 && t.length === 0 && o !== null;
  if (i) {
    var c = (
      /** @type {Element} */
      /** @type {Element} */
      o.parentNode
    );
    oJ(c), c.append(
      /** @type {Element} */
      o
    ), a.clear(), Ba(u, r[0].prev, r[e - 1].next);
  }
  hJ(t, () => {
    for (var s = 0; s < e; s++) {
      var d = r[s];
      i || (a.delete(d.k), Ba(u, d.prev, d.next)), _a(d.e, !i);
    }
  });
}
function HI(u, r, o, a, t, e = null) {
  var n = u, i = { flags: r, items: /* @__PURE__ */ new Map(), first: null };
  {
    var c = (
      /** @type {Element} */
      u
    );
    n = Ut ? yi(
      /** @type {Comment | Text} */
      /* @__PURE__ */ ya(c)
    ) : c.appendChild(V0());
  }
  Ut && PS();
  var s = null, d = !1, l = /* @__PURE__ */ B0(() => {
    var f = o();
    return YT(f) ? f : f == null ? [] : Tx(f);
  });
  Ix(() => {
    var f = Pe(l), h = f.length;
    if (d && h === 0)
      return;
    d = h === 0;
    let p = !1;
    if (Ut) {
      var b = nJ(n) === mx;
      b !== (h === 0) && (n = jO(), yi(n), la(!1), p = !0);
    }
    if (Ut) {
      for (var _ = null, y, m = 0; m < h; m++) {
        if (Vt.nodeType === DT && /** @type {Comment} */
        Vt.data === vx) {
          n = /** @type {Comment} */
          Vt, p = !0, la(!1);
          break;
        }
        var g = f[m], T = a(g, m);
        y = RJ(
          Vt,
          i,
          _,
          null,
          g,
          T,
          m,
          t,
          r,
          o
        ), i.items.set(T, y), _ = y;
      }
      h > 0 && yi(jO());
    }
    Ut || qte(f, i, n, t, r, a, o), e !== null && (h === 0 ? s ? mS(s) : s = MT(() => e(n)) : s !== null && gS(s, () => {
      s = null;
    })), p && la(!0), Pe(l);
  }), Ut && (n = Vt);
}
function qte(u, r, o, a, t, e, n) {
  var i = u.length, c = r.items, s = r.first, d = s, l, f = null, h = [], p = [], b, _, y, m;
  for (m = 0; m < i; m += 1) {
    if (b = u[m], _ = e(b, m), y = c.get(_), y === void 0) {
      var g = d ? (
        /** @type {TemplateNode} */
        d.e.nodes_start
      ) : o;
      f = RJ(
        g,
        r,
        f,
        f === null ? r.first : f.next,
        b,
        _,
        m,
        a,
        t,
        n
      ), c.set(_, f), h = [], p = [], d = f.next;
      continue;
    }
    if (Bte(y, b, m), (y.e.f & fa) !== 0 && mS(y.e), y !== d) {
      if (l !== void 0 && l.has(y)) {
        if (h.length < p.length) {
          var T = p[0], v;
          f = T.prev;
          var E = h[0], R = h[h.length - 1];
          for (v = 0; v < h.length; v += 1)
            GI(h[v], T, o);
          for (v = 0; v < p.length; v += 1)
            l.delete(p[v]);
          Ba(r, E.prev, R.next), Ba(r, f, E), Ba(r, R, T), d = T, f = R, m -= 1, h = [], p = [];
        } else
          l.delete(y), GI(y, d, o), Ba(r, y.prev, y.next), Ba(r, y, f === null ? r.first : f.next), Ba(r, f, y), f = y;
        continue;
      }
      for (h = [], p = []; d !== null && d.k !== _; )
        (d.e.f & fa) === 0 && (l ?? (l = /* @__PURE__ */ new Set())).add(d), p.push(d), d = d.next;
      if (d === null)
        continue;
      y = d;
    }
    h.push(y), f = y, d = y.next;
  }
  if (d !== null || l !== void 0) {
    for (var L = l === void 0 ? [] : Tx(l); d !== null; )
      (d.e.f & fa) === 0 && L.push(d), d = d.next;
    var A = L.length;
    if (A > 0) {
      var w = i === 0 ? o : null;
      Cte(r, L, w, c);
    }
  }
  qt.first = r.first && r.first.e, qt.last = f && f.e;
}
function Bte(u, r, o, a) {
  tJ(u.v, r), u.i = o;
}
function RJ(u, r, o, a, t, e, n, i, c, s) {
  var d = (c & Fee) !== 0, l = (c & Pee) === 0, f = d ? l ? /* @__PURE__ */ kr(t, !1, !1) : U0(t) : t, h = (c & Nee) === 0 ? n : U0(n), p = {
    i: h,
    v: f,
    k: e,
    a: null,
    // @ts-expect-error
    e: null,
    prev: o,
    next: a
  };
  try {
    return p.e = MT(() => i(u, f, h, s), Ut), p.e.prev = o && o.e, p.e.next = a && a.e, o === null ? r.first = p : (o.next = p, o.e.next = p.e), a !== null && (a.prev = p, a.e.prev = p.e), p;
  } finally {
  }
}
function GI(u, r, o) {
  for (var a = u.next ? (
    /** @type {TemplateNode} */
    u.next.e.nodes_start
  ) : o, t = r ? (
    /** @type {TemplateNode} */
    r.e.nodes_start
  ) : o, e = (
    /** @type {TemplateNode} */
    u.e.nodes_start
  ); e !== a; ) {
    var n = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ta(e)
    );
    t.before(e), e = n;
  }
}
function Ba(u, r, o) {
  r === null ? u.first = o : (r.next = o, r.e.next = o && o.e), o !== null && (o.prev = r, o.e.prev = r && r.e);
}
function LS(u, r) {
  Fx(() => {
    var o = u.getRootNode(), a = (
      /** @type {ShadowRoot} */
      o.host ? (
        /** @type {ShadowRoot} */
        o
      ) : (
        /** @type {Document} */
        o.head ?? /** @type {Document} */
        o.ownerDocument.head
      )
    );
    if (!a.querySelector("#" + r.hash)) {
      const t = document.createElement("style");
      t.id = r.hash, t.textContent = r.code, a.appendChild(t);
    }
  });
}
const zI = [...` 	
\r\fÂ \v\uFEFF`];
function $te(u, r, o) {
  var a = u == null ? "" : "" + u;
  if (r && (a = a ? a + " " + r : r), o) {
    for (var t in o)
      if (o[t])
        a = a ? a + " " + t : t;
      else if (a.length)
        for (var e = t.length, n = 0; (n = a.indexOf(t, n)) >= 0; ) {
          var i = n + e;
          (n === 0 || zI.includes(a[n - 1])) && (i === a.length || zI.includes(a[i])) ? a = (n === 0 ? "" : a.substring(0, n)) + a.substring(i + 1) : n = i;
        }
  }
  return a === "" ? null : a;
}
function UO(u, r, o, a, t, e) {
  var n = u.__className;
  if (Ut || n !== o || n === void 0) {
    var i = $te(o, a, e);
    (!Ut || i !== u.getAttribute("class")) && (i == null ? u.removeAttribute("class") : u.className = i), u.__className = o;
  } else if (e && t !== e)
    for (var c in e) {
      var s = !!e[c];
      (t == null || s !== !!t[c]) && u.classList.toggle(c, s);
    }
  return e;
}
function FJ(u, r, o) {
  if (u.multiple) {
    if (r == null)
      return;
    if (!YT(r))
      return ute();
    for (var a of u.options)
      a.selected = r.includes(kI(a));
    return;
  }
  for (a of u.options) {
    var t = kI(a);
    if (ite(t, r)) {
      a.selected = !0;
      return;
    }
  }
  u.selectedIndex = -1;
}
function Ute(u) {
  var r = new MutationObserver(() => {
    FJ(u, u.__value);
  });
  r.observe(u, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), ew(() => {
    r.disconnect();
  });
}
function kI(u) {
  return "__value" in u ? u.__value : u.value;
}
const Vte = Symbol("is custom element"), Qte = Symbol("is html");
function J6(u) {
  if (Ut) {
    var r = !1, o = () => {
      if (!r) {
        if (r = !0, u.hasAttribute("value")) {
          var a = u.value;
          JI(u, "value", null), u.value = a;
        }
        if (u.hasAttribute("checked")) {
          var t = u.checked;
          JI(u, "checked", null), u.checked = t;
        }
      }
    };
    u.__on_r = o, pte(o), SJ();
  }
}
function Hte(u, r) {
  var o = Dx(u);
  o.value === (o.value = // treat null and undefined the same for the initial value
  r ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  u.value === r && (r !== 0 || u.nodeName !== "PROGRESS") || (u.value = r ?? "");
}
function XI(u, r) {
  var o = Dx(u);
  o.checked !== (o.checked = // treat null and undefined the same for the initial value
  r ?? void 0) && (u.checked = r);
}
function JI(u, r, o, a) {
  var t = Dx(u);
  Ut && (t[r] = u.getAttribute(r), r === "src" || r === "srcset" || r === "href" && u.nodeName === "LINK") || t[r] !== (t[r] = o) && (r === "loading" && (u[Xee] = o), u.removeAttribute(r));
}
function Dx(u) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    u.__attributes ?? (u.__attributes = {
      [Vte]: u.nodeName.includes("-"),
      [Qte]: u.namespaceURI === $ee
    })
  );
}
function Gte(u, r, o = r) {
  var a = ZT();
  Ete(u, "input", (t) => {
    var e = t ? u.defaultValue : u.value;
    if (e = C4(u) ? q4(e) : e, o(e), a && e !== (e = r())) {
      var n = u.selectionStart, i = u.selectionEnd;
      u.value = e ?? "", i !== null && (u.selectionStart = n, u.selectionEnd = Math.min(i, u.value.length));
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ut && u.defaultValue !== u.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  nt(r) == null && u.value) && o(C4(u) ? q4(u.value) : u.value), th(() => {
    var t = r();
    C4(u) && t === q4(u.value) || u.type === "date" && !t && !u.value || t !== u.value && (u.value = t ?? "");
  });
}
function C4(u) {
  var r = u.type;
  return r === "number" || r === "range";
}
function q4(u) {
  return u === "" ? null : +u;
}
function Cn(u, r, o) {
  var a = Ha(u, r);
  a && a.set && (u[r] = o, ew(() => {
    u[r] = null;
  }));
}
function KI(u, r) {
  return u === r || (u == null ? void 0 : u[ha]) === r;
}
function VO(u = {}, r, o, a) {
  return xx(() => {
    var t, e;
    return th(() => {
      t = e, e = [], nt(() => {
        u !== o(...e) && (r(u, ...e), t && KI(o(...t), u) && r(null, ...t));
      });
    }), () => {
      Fx(() => {
        e && KI(o(...e), u) && r(null, ...e);
      });
    };
  }), u;
}
function Yw(u) {
  return function(...r) {
    var o = (
      /** @type {Event} */
      r[0]
    );
    return o.stopPropagation(), u == null ? void 0 : u.apply(this, r);
  };
}
function Lx(u = !1) {
  const r = (
    /** @type {ComponentContextLegacy} */
    er
  ), o = r.l.u;
  if (!o) return;
  let a = () => j0(r.s);
  if (u) {
    let t = 0, e = (
      /** @type {Record<string, any>} */
      {}
    );
    const n = /* @__PURE__ */ LT(() => {
      let i = !1;
      const c = r.s;
      for (const s in c)
        c[s] !== e[s] && (e[s] = c[s], i = !0);
      return i && t++, t;
    });
    a = () => Pe(n);
  }
  o.b.length && ste(() => {
    WI(r, a), bS(o.b);
  }), CO(() => {
    const t = nt(() => o.m.map(Gee));
    return () => {
      for (const e of t)
        typeof e == "function" && e();
    };
  }), o.a.length && CO(() => {
    WI(r, a), bS(o.a);
  });
}
function WI(u, r) {
  if (u.l.s)
    for (const o of u.l.s) Pe(o);
  r();
}
function zte(u) {
  var r = U0(0);
  return function() {
    return arguments.length === 1 ? (St(r, Pe(r) + 1), arguments[0]) : (Pe(r), u());
  };
}
function Zw(u, r) {
  var e;
  var o = (
    /** @type {Record<string, Function[] | Function>} */
    (e = u.$$events) == null ? void 0 : e[r.type]
  ), a = YT(o) ? o.slice() : o == null ? [] : [o];
  for (var t of a)
    t.call(this, r);
}
function NJ(u, r, o) {
  if (u == null)
    return r(void 0), q0;
  const a = nt(
    () => u.subscribe(
      r,
      // @ts-expect-error
      o
    )
  );
  return a.unsubscribe ? () => a.unsubscribe() : a;
}
const _0 = [];
function kte(u, r = q0) {
  let o = null;
  const a = /* @__PURE__ */ new Set();
  function t(i) {
    if (KX(u, i) && (u = i, o)) {
      const c = !_0.length;
      for (const s of a)
        s[1](), _0.push(s, u);
      if (c) {
        for (let s = 0; s < _0.length; s += 2)
          _0[s][0](_0[s + 1]);
        _0.length = 0;
      }
    }
  }
  function e(i) {
    t(i(
      /** @type {T} */
      u
    ));
  }
  function n(i, c = q0) {
    const s = [i, c];
    return a.add(s), a.size === 1 && (o = r(t, e) || q0), i(
      /** @type {T} */
      u
    ), () => {
      a.delete(s), a.size === 0 && o && (o(), o = null);
    };
  }
  return { set: t, update: e, subscribe: n };
}
function Xte(u) {
  let r;
  return NJ(u, (o) => r = o)(), r;
}
let e6 = !1, QO = Symbol();
function PJ(u, r, o) {
  const a = o[r] ?? (o[r] = {
    store: null,
    source: /* @__PURE__ */ kr(void 0),
    unsubscribe: q0
  });
  if (a.store !== u && !(QO in o))
    if (a.unsubscribe(), a.store = u ?? null, u == null)
      a.source.v = void 0, a.unsubscribe = q0;
    else {
      var t = !0;
      a.unsubscribe = NJ(u, (e) => {
        t ? a.source.v = e : St(a.source, e);
      }), t = !1;
    }
  return u && QO in o ? Xte(u) : Pe(a.source);
}
function Eh(u, r) {
  return u.set(r), r;
}
function DJ() {
  const u = {};
  function r() {
    ew(() => {
      for (var o in u)
        u[o].unsubscribe();
      PT(u, QO, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [u, r];
}
function fr(u, r, o) {
  return u.set(o), r;
}
function Jte(u) {
  var r = e6;
  try {
    return e6 = !1, [u(), e6];
  } finally {
    e6 = r;
  }
}
function YI(u) {
  var r;
  return ((r = u.ctx) == null ? void 0 : r.d) ?? !1;
}
function ca(u, r, o, a) {
  var E;
  var t = (o & Dee) !== 0, e = !eh || (o & Lee) !== 0, n = (o & Mee) !== 0, i = (o & Cee) !== 0, c = !1, s;
  n ? [s, c] = Jte(() => (
    /** @type {V} */
    u[r]
  )) : s = /** @type {V} */
  u[r];
  var d = ha in u || kX in u, l = n && (((E = Ha(u, r)) == null ? void 0 : E.set) ?? (d && r in u && ((R) => u[r] = R))) || void 0, f = (
    /** @type {V} */
    a
  ), h = !0, p = !1, b = () => (p = !0, h && (h = !1, i ? f = nt(
    /** @type {() => V} */
    a
  ) : f = /** @type {V} */
  a), f);
  s === void 0 && a !== void 0 && (l && e && ete(), s = b(), l && l(s));
  var _;
  if (e)
    _ = () => {
      var R = (
        /** @type {V} */
        u[r]
      );
      return R === void 0 ? b() : (h = !0, p = !1, R);
    };
  else {
    var y = (t ? LT : B0)(
      () => (
        /** @type {V} */
        u[r]
      )
    );
    y.f |= zee, _ = () => {
      var R = Pe(y);
      return R !== void 0 && (f = /** @type {V} */
      void 0), R === void 0 ? f : R;
    };
  }
  if ((o & jee) === 0 && e)
    return _;
  if (l) {
    var m = u.$$legacy;
    return function(R, L) {
      return arguments.length > 0 ? ((!e || !L || m || c) && l(L ? _() : R), R) : _();
    };
  }
  var g = !1, T = /* @__PURE__ */ kr(s), v = /* @__PURE__ */ LT(() => {
    var R = _(), L = Pe(T);
    return g ? (g = !1, L) : T.v = R;
  });
  return n && Pe(v), t || (v.equals = Ox), function(R, L) {
    if (arguments.length > 0) {
      const A = L ? Pe(v) : e && n ? L0(R) : R;
      if (!v.equals(A)) {
        if (g = !0, St(T, A), p && f !== void 0 && (f = A), YI(v))
          return R;
        nt(() => Pe(v));
      }
      return R;
    }
    return YI(v) ? v.v : Pe(v);
  };
}
function Kte(u) {
  return new Wte(u);
}
var da, Mn;
class Wte {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(r) {
    /** @type {any} */
    It(this, da);
    /** @type {Record<string, any>} */
    It(this, Mn);
    var e;
    var o = /* @__PURE__ */ new Map(), a = (n, i) => {
      var c = /* @__PURE__ */ kr(i, !1, !1);
      return o.set(n, c), c;
    };
    const t = new Proxy(
      { ...r.props || {}, $$events: {} },
      {
        get(n, i) {
          return Pe(o.get(i) ?? a(i, Reflect.get(n, i)));
        },
        has(n, i) {
          return i === kX ? !0 : (Pe(o.get(i) ?? a(i, Reflect.get(n, i))), Reflect.has(n, i));
        },
        set(n, i, c) {
          return St(o.get(i) ?? a(i, c), c), Reflect.set(n, i, c);
        }
      }
    );
    ct(this, Mn, (r.hydrate ? Pte : xJ)(r.component, {
      target: r.target,
      anchor: r.anchor,
      props: t,
      context: r.context,
      intro: r.intro ?? !1,
      recover: r.recover
    })), (!((e = r == null ? void 0 : r.props) != null && e.$$host) || r.sync === !1) && Ste(), ct(this, da, t.$$events);
    for (const n of Object.keys(ce(this, Mn)))
      n === "$set" || n === "$destroy" || n === "$on" || PT(this, n, {
        get() {
          return ce(this, Mn)[n];
        },
        /** @param {any} value */
        set(i) {
          ce(this, Mn)[n] = i;
        },
        enumerable: !0
      });
    ce(this, Mn).$set = /** @param {Record<string, any>} next */
    (n) => {
      Object.assign(t, n);
    }, ce(this, Mn).$destroy = () => {
      Dte(ce(this, Mn));
    };
  }
  /** @param {Record<string, any>} props */
  $set(r) {
    ce(this, Mn).$set(r);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(r, o) {
    ce(this, da)[r] = ce(this, da)[r] || [];
    const a = (...t) => o.call(this, ...t);
    return ce(this, da)[r].push(a), () => {
      ce(this, da)[r] = ce(this, da)[r].filter(
        /** @param {any} fn */
        (t) => t !== a
      );
    };
  }
  $destroy() {
    ce(this, Mn).$destroy();
  }
}
da = new WeakMap(), Mn = new WeakMap();
let LJ;
typeof HTMLElement == "function" && (LJ = class extends HTMLElement {
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {*} use_shadow_dom
   */
  constructor(r, o, a) {
    super();
    /** The Svelte component constructor */
    Ft(this, "$$ctor");
    /** Slots */
    Ft(this, "$$s");
    /** @type {any} The Svelte component instance */
    Ft(this, "$$c");
    /** Whether or not the custom element is connected */
    Ft(this, "$$cn", !1);
    /** @type {Record<string, any>} Component props data */
    Ft(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    Ft(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    Ft(this, "$$p_d", {});
    /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    Ft(this, "$$l", {});
    /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    Ft(this, "$$l_u", /* @__PURE__ */ new Map());
    /** @type {any} The managed render effect for reflecting attributes */
    Ft(this, "$$me");
    this.$$ctor = r, this.$$s = o, a && this.attachShadow({ mode: "open" });
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(r, o, a) {
    if (this.$$l[r] = this.$$l[r] || [], this.$$l[r].push(o), this.$$c) {
      const t = this.$$c.$on(r, o);
      this.$$l_u.set(o, t);
    }
    super.addEventListener(r, o, a);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(r, o, a) {
    if (super.removeEventListener(r, o, a), this.$$c) {
      const t = this.$$l_u.get(o);
      t && (t(), this.$$l_u.delete(o));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let o = function(e) {
        return (n) => {
          const i = document.createElement("slot");
          e !== "default" && (i.name = e), zr(n, i);
        };
      };
      var r = o;
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const a = {}, t = Yte(this);
      for (const e of this.$$s)
        e in t && (e === "default" && !this.$$d.children ? (this.$$d.children = o(e), a.default = !0) : a[e] = o(e));
      for (const e of this.attributes) {
        const n = this.$$g_p(e.name);
        n in this.$$d || (this.$$d[n] = K6(n, e.value, this.$$p_d, "toProp"));
      }
      for (const e in this.$$p_d)
        !(e in this.$$d) && this[e] !== void 0 && (this.$$d[e] = this[e], delete this[e]);
      this.$$c = Kte({
        component: this.$$ctor,
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: a,
          $$host: this
        }
      }), this.$$me = cte(() => {
        th(() => {
          var e;
          this.$$r = !0;
          for (const n of pS(this.$$c)) {
            if (!((e = this.$$p_d[n]) != null && e.reflect)) continue;
            this.$$d[n] = this.$$c[n];
            const i = K6(
              n,
              this.$$d[n],
              this.$$p_d,
              "toAttribute"
            );
            i == null ? this.removeAttribute(this.$$p_d[n].attribute || n) : this.setAttribute(this.$$p_d[n].attribute || n, i);
          }
          this.$$r = !1;
        });
      });
      for (const e in this.$$l)
        for (const n of this.$$l[e]) {
          const i = this.$$c.$on(e, n);
          this.$$l_u.set(n, i);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(r, o, a) {
    var t;
    this.$$r || (r = this.$$g_p(r), this.$$d[r] = K6(r, a, this.$$p_d, "toProp"), (t = this.$$c) == null || t.$set({ [r]: this.$$d[r] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(r) {
    return pS(this.$$p_d).find(
      (o) => this.$$p_d[o].attribute === r || !this.$$p_d[o].attribute && o.toLowerCase() === r
    ) || r;
  }
});
function K6(u, r, o, a) {
  var e;
  const t = (e = o[u]) == null ? void 0 : e.type;
  if (r = t === "Boolean" && typeof r != "boolean" ? r != null : r, !a || !o[u])
    return r;
  if (a === "toAttribute")
    switch (t) {
      case "Object":
      case "Array":
        return r == null ? null : JSON.stringify(r);
      case "Boolean":
        return r ? "" : null;
      case "Number":
        return r ?? null;
      default:
        return r;
    }
  else
    switch (t) {
      case "Object":
      case "Array":
        return r && JSON.parse(r);
      case "Boolean":
        return r;
      // conversion already handled above
      case "Number":
        return r != null ? +r : r;
      default:
        return r;
    }
}
function Yte(u) {
  const r = {};
  return u.childNodes.forEach((o) => {
    r[
      /** @type {Element} node */
      o.slot || "default"
    ] = !0;
  }), r;
}
function Zte(u, r, o, a, t, e) {
  let n = class extends LJ {
    constructor() {
      super(u, o, t), this.$$p_d = r;
    }
    static get observedAttributes() {
      return pS(r).map(
        (i) => (r[i].attribute || i).toLowerCase()
      );
    }
  };
  return pS(r).forEach((i) => {
    PT(n.prototype, i, {
      get() {
        return this.$$c && i in this.$$c ? this.$$c[i] : this.$$d[i];
      },
      set(c) {
        var l;
        c = K6(i, c, r), this.$$d[i] = c;
        var s = this.$$c;
        if (s) {
          var d = (l = Ha(s, i)) == null ? void 0 : l.get;
          d ? s[i] = c : s.$set({ [i]: c });
        }
      }
    });
  }), a.forEach((i) => {
    PT(n.prototype, i, {
      get() {
        var c;
        return (c = this.$$c) == null ? void 0 : c[i];
      }
    });
  }), u.element = /** @type {any} */
  n, n;
}
var zf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ere(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function jx(u) {
  if (Object.prototype.hasOwnProperty.call(u, "__esModule")) return u;
  var r = u.default;
  if (typeof r == "function") {
    var o = function a() {
      return this instanceof a ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    o.prototype = r.prototype;
  } else o = {};
  return Object.defineProperty(o, "__esModule", { value: !0 }), Object.keys(u).forEach(function(a) {
    var t = Object.getOwnPropertyDescriptor(u, a);
    Object.defineProperty(o, a, t.get ? t : {
      enumerable: !0,
      get: function() {
        return u[a];
      }
    });
  }), o;
}
var mu = {}, Oh = {}, vu = {}, xh = {}, Tu = {}, Ih = {}, wu = {}, Su = {}, rw = "delete", Zt = 5, qn = 1 << Zt, an = qn - 1, Rt = {};
function HO() {
  return { value: !1 };
}
function Bn(u) {
  u && (u.value = !0);
}
function Mx() {
}
function Q0(u) {
  return u.size === void 0 && (u.size = u.__iterate(jJ)), u.size;
}
function Xa(u, r) {
  if (typeof r != "number") {
    var o = r >>> 0;
    if ("" + o !== r || o === 4294967295)
      return NaN;
    r = o;
  }
  return r < 0 ? Q0(u) + r : r;
}
function jJ() {
  return !0;
}
function nw(u, r, o) {
  return (u === 0 && !CJ(u) || o !== void 0 && u <= -o) && (r === void 0 || o !== void 0 && r >= o);
}
function nh(u, r) {
  return MJ(u, r, 0);
}
function iw(u, r) {
  return MJ(u, r, r);
}
function MJ(u, r, o) {
  return u === void 0 ? o : CJ(u) ? r === 1 / 0 ? r : Math.max(0, r + u) | 0 : r === void 0 || r === u ? u : Math.min(r, u) | 0;
}
function CJ(u) {
  return u < 0 || u === 0 && 1 / u === -1 / 0;
}
var qJ = "@@__IMMUTABLE_ITERABLE__@@";
function Xr(u) {
  return !!(u && u[qJ]);
}
var BJ = "@@__IMMUTABLE_KEYED__@@";
function zt(u) {
  return !!(u && u[BJ]);
}
var $J = "@@__IMMUTABLE_INDEXED__@@";
function Br(u) {
  return !!(u && u[$J]);
}
function ih(u) {
  return zt(u) || Br(u);
}
var tr = function(r) {
  return Xr(r) ? r : Jr(r);
}, Hn = /* @__PURE__ */ function(u) {
  function r(o) {
    return zt(o) ? o : Ya(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r;
}(tr), t0 = /* @__PURE__ */ function(u) {
  function r(o) {
    return Br(o) ? o : Gn(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r;
}(tr), ah = /* @__PURE__ */ function(u) {
  function r(o) {
    return Xr(o) && !ih(o) ? o : sh(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r;
}(tr);
tr.Keyed = Hn;
tr.Indexed = t0;
tr.Set = ah;
var UJ = "@@__IMMUTABLE_SEQ__@@";
function aw(u) {
  return !!(u && u[UJ]);
}
var VJ = "@@__IMMUTABLE_RECORD__@@";
function Wa(u) {
  return !!(u && u[VJ]);
}
function In(u) {
  return Xr(u) || Wa(u);
}
var uh = "@@__IMMUTABLE_ORDERED__@@";
function On(u) {
  return !!(u && u[uh]);
}
var uw = 0, gi = 1, Un = 2, GO = typeof Symbol == "function" && Symbol.iterator, QJ = "@@iterator", jS = GO || QJ, Lt = function(r) {
  this.next = r;
};
Lt.prototype.toString = function() {
  return "[Iterator]";
};
Lt.KEYS = uw;
Lt.VALUES = gi;
Lt.ENTRIES = Un;
Lt.prototype.inspect = Lt.prototype.toSource = function() {
  return this.toString();
};
Lt.prototype[jS] = function() {
  return this;
};
function rr(u, r, o, a) {
  var t = u === 0 ? r : u === 1 ? o : [r, o];
  return a ? a.value = t : a = {
    value: t,
    done: !1
  }, a;
}
function un() {
  return { value: void 0, done: !0 };
}
function Cx(u) {
  return Array.isArray(u) ? !0 : !!MS(u);
}
function ZI(u) {
  return u && typeof u.next == "function";
}
function zO(u) {
  var r = MS(u);
  return r && r.call(u);
}
function MS(u) {
  var r = u && (GO && u[GO] || u[QJ]);
  if (typeof r == "function")
    return r;
}
function tre(u) {
  var r = MS(u);
  return r && r === u.entries;
}
function rre(u) {
  var r = MS(u);
  return r && r === u.keys;
}
var oh = Object.prototype.hasOwnProperty;
function qx(u) {
  return Array.isArray(u) || typeof u == "string" ? !0 : u && typeof u == "object" && Number.isInteger(u.length) && u.length >= 0 && (u.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(u).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    u.hasOwnProperty(u.length - 1)
  ));
}
var Jr = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? $x() : In(o) ? o.toSeq() : ire(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.toSeq = function() {
    return this;
  }, r.prototype.toString = function() {
    return this.__toString("Seq {", "}");
  }, r.prototype.cacheResult = function() {
    return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), this.size = this._cache.length), this;
  }, r.prototype.__iterate = function(a, t) {
    var e = this._cache;
    if (e) {
      for (var n = e.length, i = 0; i !== n; ) {
        var c = e[t ? n - ++i : i++];
        if (a(c[1], c[0], this) === !1)
          break;
      }
      return i;
    }
    return this.__iterateUncached(a, t);
  }, r.prototype.__iterator = function(a, t) {
    var e = this._cache;
    if (e) {
      var n = e.length, i = 0;
      return new Lt(function() {
        if (i === n)
          return un();
        var c = e[t ? n - ++i : i++];
        return rr(a, c[0], c[1]);
      });
    }
    return this.__iteratorUncached(a, t);
  }, r;
}(tr), Ya = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? $x().toKeyedSeq() : Xr(o) ? zt(o) ? o.toSeq() : o.fromEntrySeq() : Wa(o) ? o.toSeq() : Ux(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.toKeyedSeq = function() {
    return this;
  }, r;
}(Jr), Gn = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? $x() : Xr(o) ? zt(o) ? o.entrySeq() : o.toIndexedSeq() : Wa(o) ? o.toSeq().entrySeq() : HJ(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return r(arguments);
  }, r.prototype.toIndexedSeq = function() {
    return this;
  }, r.prototype.toString = function() {
    return this.__toString("Seq [", "]");
  }, r;
}(Jr), sh = /* @__PURE__ */ function(u) {
  function r(o) {
    return (Xr(o) && !ih(o) ? o : Gn(o)).toSetSeq();
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return r(arguments);
  }, r.prototype.toSetSeq = function() {
    return this;
  }, r;
}(Jr);
Jr.isSeq = aw;
Jr.Keyed = Ya;
Jr.Set = sh;
Jr.Indexed = Gn;
Jr.prototype[UJ] = !0;
var Jf = /* @__PURE__ */ function(u) {
  function r(o) {
    this._array = o, this.size = o.length;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.get = function(a, t) {
    return this.has(a) ? this._array[Xa(this, a)] : t;
  }, r.prototype.__iterate = function(a, t) {
    for (var e = this._array, n = e.length, i = 0; i !== n; ) {
      var c = t ? n - ++i : i++;
      if (a(e[c], c, this) === !1)
        break;
    }
    return i;
  }, r.prototype.__iterator = function(a, t) {
    var e = this._array, n = e.length, i = 0;
    return new Lt(function() {
      if (i === n)
        return un();
      var c = t ? n - ++i : i++;
      return rr(a, c, e[c]);
    });
  }, r;
}(Gn), Bx = /* @__PURE__ */ function(u) {
  function r(o) {
    var a = Object.keys(o).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(o) : []
    );
    this._object = o, this._keys = a, this.size = a.length;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.get = function(a, t) {
    return t !== void 0 && !this.has(a) ? t : this._object[a];
  }, r.prototype.has = function(a) {
    return oh.call(this._object, a);
  }, r.prototype.__iterate = function(a, t) {
    for (var e = this._object, n = this._keys, i = n.length, c = 0; c !== i; ) {
      var s = n[t ? i - ++c : c++];
      if (a(e[s], s, this) === !1)
        break;
    }
    return c;
  }, r.prototype.__iterator = function(a, t) {
    var e = this._object, n = this._keys, i = n.length, c = 0;
    return new Lt(function() {
      if (c === i)
        return un();
      var s = n[t ? i - ++c : c++];
      return rr(a, s, e[s]);
    });
  }, r;
}(Ya);
Bx.prototype[uh] = !0;
var nre = /* @__PURE__ */ function(u) {
  function r(o) {
    this._collection = o, this.size = o.length || o.size;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.__iterateUncached = function(a, t) {
    if (t)
      return this.cacheResult().__iterate(a, t);
    var e = this._collection, n = zO(e), i = 0;
    if (ZI(n))
      for (var c; !(c = n.next()).done && a(c.value, i++, this) !== !1; )
        ;
    return i;
  }, r.prototype.__iteratorUncached = function(a, t) {
    if (t)
      return this.cacheResult().__iterator(a, t);
    var e = this._collection, n = zO(e);
    if (!ZI(n))
      return new Lt(un);
    var i = 0;
    return new Lt(function() {
      var c = n.next();
      return c.done ? c : rr(a, i++, c.value);
    });
  }, r;
}(Gn), e5;
function $x() {
  return e5 || (e5 = new Jf([]));
}
function Ux(u) {
  var r = Vx(u);
  if (r)
    return r.fromEntrySeq();
  if (typeof u == "object")
    return new Bx(u);
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + u
  );
}
function HJ(u) {
  var r = Vx(u);
  if (r)
    return r;
  throw new TypeError(
    "Expected Array or collection object of values: " + u
  );
}
function ire(u) {
  var r = Vx(u);
  if (r)
    return tre(u) ? r.fromEntrySeq() : rre(u) ? r.toSetSeq() : r;
  if (typeof u == "object")
    return new Bx(u);
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + u
  );
}
function Vx(u) {
  return qx(u) ? new Jf(u) : Cx(u) ? new nre(u) : void 0;
}
var GJ = "@@__IMMUTABLE_MAP__@@";
function ow(u) {
  return !!(u && u[GJ]);
}
function CS(u) {
  return ow(u) && On(u);
}
function wS(u) {
  return !!(u && typeof u.equals == "function" && typeof u.hashCode == "function");
}
function Er(u, r) {
  if (u === r || u !== u && r !== r)
    return !0;
  if (!u || !r)
    return !1;
  if (typeof u.valueOf == "function" && typeof r.valueOf == "function") {
    if (u = u.valueOf(), r = r.valueOf(), u === r || u !== u && r !== r)
      return !0;
    if (!u || !r)
      return !1;
  }
  return !!(wS(u) && wS(r) && u.equals(r));
}
var Rh = typeof Math.imul == "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function(r, o) {
  r |= 0, o |= 0;
  var a = r & 65535, t = o & 65535;
  return a * t + ((r >>> 16) * t + a * (o >>> 16) << 16 >>> 0) | 0;
};
function qS(u) {
  return u >>> 1 & 1073741824 | u & 3221225471;
}
var are = Object.prototype.valueOf;
function nn(u) {
  if (u == null)
    return t5(u);
  if (typeof u.hashCode == "function")
    return qS(u.hashCode(u));
  var r = lre(u);
  if (r == null)
    return t5(r);
  switch (typeof r) {
    case "boolean":
      return r ? 1108378657 : 1108378656;
    case "number":
      return ure(r);
    case "string":
      return r.length > fre ? ore(r) : kO(r);
    case "object":
    case "function":
      return cre(r);
    case "symbol":
      return sre(r);
    default:
      if (typeof r.toString == "function")
        return kO(r.toString());
      throw new Error("Value type " + typeof r + " cannot be hashed.");
  }
}
function t5(u) {
  return u === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function ure(u) {
  if (u !== u || u === 1 / 0)
    return 0;
  var r = u | 0;
  for (r !== u && (r ^= u * 4294967295); u > 4294967295; )
    u /= 4294967295, r ^= u;
  return qS(r);
}
function ore(u) {
  var r = U4[u];
  return r === void 0 && (r = kO(u), $4 === hre && ($4 = 0, U4 = {}), $4++, U4[u] = r), r;
}
function kO(u) {
  for (var r = 0, o = 0; o < u.length; o++)
    r = 31 * r + u.charCodeAt(o) | 0;
  return qS(r);
}
function sre(u) {
  var r = i5[u];
  return r !== void 0 || (r = zJ(), i5[u] = r), r;
}
function cre(u) {
  var r;
  if (XO && (r = JO.get(u), r !== void 0) || (r = u[Qf], r !== void 0) || !n5 && (r = u.propertyIsEnumerable && u.propertyIsEnumerable[Qf], r !== void 0 || (r = dre(u), r !== void 0)))
    return r;
  if (r = zJ(), XO)
    JO.set(u, r);
  else {
    if (r5 !== void 0 && r5(u) === !1)
      throw new Error("Non-extensible objects are not allowed as keys.");
    if (n5)
      Object.defineProperty(u, Qf, {
        enumerable: !1,
        configurable: !1,
        writable: !1,
        value: r
      });
    else if (u.propertyIsEnumerable !== void 0 && u.propertyIsEnumerable === u.constructor.prototype.propertyIsEnumerable)
      u.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(
          this,
          arguments
        );
      }, u.propertyIsEnumerable[Qf] = r;
    else if (u.nodeType !== void 0)
      u[Qf] = r;
    else
      throw new Error("Unable to set a non-enumerable property on object.");
  }
  return r;
}
var r5 = Object.isExtensible, n5 = function() {
  try {
    return Object.defineProperty({}, "@", {}), !0;
  } catch {
    return !1;
  }
}();
function dre(u) {
  if (u && u.nodeType > 0)
    switch (u.nodeType) {
      case 1:
        return u.uniqueID;
      case 9:
        return u.documentElement && u.documentElement.uniqueID;
    }
}
function lre(u) {
  return u.valueOf !== are && typeof u.valueOf == "function" ? u.valueOf(u) : u;
}
function zJ() {
  var u = ++B4;
  return B4 & 1073741824 && (B4 = 0), u;
}
var XO = typeof WeakMap == "function", JO;
XO && (JO = /* @__PURE__ */ new WeakMap());
var i5 = /* @__PURE__ */ Object.create(null), B4 = 0, Qf = "__immutablehash__";
typeof Symbol == "function" && (Qf = Symbol(Qf));
var fre = 16, hre = 255, $4 = 0, U4 = {}, BS = /* @__PURE__ */ function(u) {
  function r(o, a) {
    this._iter = o, this._useKeys = a, this.size = o.size;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.get = function(a, t) {
    return this._iter.get(a, t);
  }, r.prototype.has = function(a) {
    return this._iter.has(a);
  }, r.prototype.valueSeq = function() {
    return this._iter.valueSeq();
  }, r.prototype.reverse = function() {
    var a = this, t = Qx(this, !0);
    return this._useKeys || (t.valueSeq = function() {
      return a._iter.toSeq().reverse();
    }), t;
  }, r.prototype.map = function(a, t) {
    var e = this, n = WJ(this, a, t);
    return this._useKeys || (n.valueSeq = function() {
      return e._iter.toSeq().map(a, t);
    }), n;
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    return this._iter.__iterate(function(n, i) {
      return a(n, i, e);
    }, t);
  }, r.prototype.__iterator = function(a, t) {
    return this._iter.__iterator(a, t);
  }, r;
}(Ya);
BS.prototype[uh] = !0;
var kJ = /* @__PURE__ */ function(u) {
  function r(o) {
    this._iter = o, this.size = o.size;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.includes = function(a) {
    return this._iter.includes(a);
  }, r.prototype.__iterate = function(a, t) {
    var e = this, n = 0;
    return t && Q0(this), this._iter.__iterate(
      function(i) {
        return a(i, t ? e.size - ++n : n++, e);
      },
      t
    );
  }, r.prototype.__iterator = function(a, t) {
    var e = this, n = this._iter.__iterator(gi, t), i = 0;
    return t && Q0(this), new Lt(function() {
      var c = n.next();
      return c.done ? c : rr(
        a,
        t ? e.size - ++i : i++,
        c.value,
        c
      );
    });
  }, r;
}(Gn), XJ = /* @__PURE__ */ function(u) {
  function r(o) {
    this._iter = o, this.size = o.size;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.has = function(a) {
    return this._iter.includes(a);
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    return this._iter.__iterate(function(n) {
      return a(n, n, e);
    }, t);
  }, r.prototype.__iterator = function(a, t) {
    var e = this._iter.__iterator(gi, t);
    return new Lt(function() {
      var n = e.next();
      return n.done ? n : rr(a, n.value, n.value, n);
    });
  }, r;
}(sh), JJ = /* @__PURE__ */ function(u) {
  function r(o) {
    this._iter = o, this.size = o.size;
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.entrySeq = function() {
    return this._iter.toSeq();
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    return this._iter.__iterate(function(n) {
      if (n) {
        u5(n);
        var i = Xr(n);
        return a(
          i ? n.get(1) : n[1],
          i ? n.get(0) : n[0],
          e
        );
      }
    }, t);
  }, r.prototype.__iterator = function(a, t) {
    var e = this._iter.__iterator(gi, t);
    return new Lt(function() {
      for (; ; ) {
        var n = e.next();
        if (n.done)
          return n;
        var i = n.value;
        if (i) {
          u5(i);
          var c = Xr(i);
          return rr(
            a,
            c ? i.get(0) : i[0],
            c ? i.get(1) : i[1],
            n
          );
        }
      }
    });
  }, r;
}(Ya);
kJ.prototype.cacheResult = BS.prototype.cacheResult = XJ.prototype.cacheResult = JJ.prototype.cacheResult = zx;
function KJ(u) {
  var r = Li(u);
  return r._iter = u, r.size = u.size, r.flip = function() {
    return u;
  }, r.reverse = function() {
    var o = u.reverse.apply(this);
    return o.flip = function() {
      return u.reverse();
    }, o;
  }, r.has = function(o) {
    return u.includes(o);
  }, r.includes = function(o) {
    return u.has(o);
  }, r.cacheResult = zx, r.__iterateUncached = function(o, a) {
    var t = this;
    return u.__iterate(function(e, n) {
      return o(n, e, t) !== !1;
    }, a);
  }, r.__iteratorUncached = function(o, a) {
    if (o === Un) {
      var t = u.__iterator(o, a);
      return new Lt(function() {
        var e = t.next();
        if (!e.done) {
          var n = e.value[0];
          e.value[0] = e.value[1], e.value[1] = n;
        }
        return e;
      });
    }
    return u.__iterator(
      o === gi ? uw : gi,
      a
    );
  }, r;
}
function WJ(u, r, o) {
  var a = Li(u);
  return a.size = u.size, a.has = function(t) {
    return u.has(t);
  }, a.get = function(t, e) {
    var n = u.get(t, Rt);
    return n === Rt ? e : r.call(o, n, t, u);
  }, a.__iterateUncached = function(t, e) {
    var n = this;
    return u.__iterate(
      function(i, c, s) {
        return t(r.call(o, i, c, s), c, n) !== !1;
      },
      e
    );
  }, a.__iteratorUncached = function(t, e) {
    var n = u.__iterator(Un, e);
    return new Lt(function() {
      var i = n.next();
      if (i.done)
        return i;
      var c = i.value, s = c[0];
      return rr(
        t,
        s,
        r.call(o, c[1], s, u),
        i
      );
    });
  }, a;
}
function Qx(u, r) {
  var o = this, a = Li(u);
  return a._iter = u, a.size = u.size, a.reverse = function() {
    return u;
  }, u.flip && (a.flip = function() {
    var t = KJ(u);
    return t.reverse = function() {
      return u.flip();
    }, t;
  }), a.get = function(t, e) {
    return u.get(r ? t : -1 - t, e);
  }, a.has = function(t) {
    return u.has(r ? t : -1 - t);
  }, a.includes = function(t) {
    return u.includes(t);
  }, a.cacheResult = zx, a.__iterate = function(t, e) {
    var n = this, i = 0;
    return e && Q0(u), u.__iterate(
      function(c, s) {
        return t(c, r ? s : e ? n.size - ++i : i++, n);
      },
      !e
    );
  }, a.__iterator = function(t, e) {
    var n = 0;
    e && Q0(u);
    var i = u.__iterator(Un, !e);
    return new Lt(function() {
      var c = i.next();
      if (c.done)
        return c;
      var s = c.value;
      return rr(
        t,
        r ? s[0] : e ? o.size - ++n : n++,
        s[1],
        c
      );
    });
  }, a;
}
function YJ(u, r, o, a) {
  var t = Li(u);
  return a && (t.has = function(e) {
    var n = u.get(e, Rt);
    return n !== Rt && !!r.call(o, n, e, u);
  }, t.get = function(e, n) {
    var i = u.get(e, Rt);
    return i !== Rt && r.call(o, i, e, u) ? i : n;
  }), t.__iterateUncached = function(e, n) {
    var i = this, c = 0;
    return u.__iterate(function(s, d, l) {
      if (r.call(o, s, d, l))
        return c++, e(s, a ? d : c - 1, i);
    }, n), c;
  }, t.__iteratorUncached = function(e, n) {
    var i = u.__iterator(Un, n), c = 0;
    return new Lt(function() {
      for (; ; ) {
        var s = i.next();
        if (s.done)
          return s;
        var d = s.value, l = d[0], f = d[1];
        if (r.call(o, f, l, u))
          return rr(e, a ? l : c++, f, s);
      }
    });
  }, t;
}
function pre(u, r, o) {
  var a = eu().asMutable();
  return u.__iterate(function(t, e) {
    a.update(r.call(o, t, e, u), 0, function(n) {
      return n + 1;
    });
  }), a.asImmutable();
}
function bre(u, r, o) {
  var a = zt(u), t = (On(u) ? mi() : eu()).asMutable();
  u.__iterate(function(n, i) {
    t.update(
      r.call(o, n, i, u),
      function(c) {
        return c = c || [], c.push(a ? [i, n] : n), c;
      }
    );
  });
  var e = Gx(u);
  return t.map(function(n) {
    return Gt(u, e(n));
  }).asImmutable();
}
function yre(u, r, o) {
  var a = zt(u), t = [[], []];
  u.__iterate(function(n, i) {
    t[r.call(o, n, i, u) ? 1 : 0].push(
      a ? [i, n] : n
    );
  });
  var e = Gx(u);
  return t.map(function(n) {
    return Gt(u, e(n));
  });
}
function Hx(u, r, o, a) {
  var t = u.size;
  if (nw(r, o, t))
    return u;
  if (typeof t > "u" && (r < 0 || o < 0))
    return Hx(u.toSeq().cacheResult(), r, o, a);
  var e = nh(r, t), n = iw(o, t), i = n - e, c;
  i === i && (c = i < 0 ? 0 : i);
  var s = Li(u);
  return s.size = c === 0 ? c : u.size && c || void 0, !a && aw(u) && c >= 0 && (s.get = function(d, l) {
    return d = Xa(this, d), d >= 0 && d < c ? u.get(d + e, l) : l;
  }), s.__iterateUncached = function(d, l) {
    var f = this;
    if (c === 0)
      return 0;
    if (l)
      return this.cacheResult().__iterate(d, l);
    var h = 0, p = !0, b = 0;
    return u.__iterate(function(_, y) {
      if (!(p && (p = h++ < e)))
        return b++, d(_, a ? y : b - 1, f) !== !1 && b !== c;
    }), b;
  }, s.__iteratorUncached = function(d, l) {
    if (c !== 0 && l)
      return this.cacheResult().__iterator(d, l);
    if (c === 0)
      return new Lt(un);
    var f = u.__iterator(d, l), h = 0, p = 0;
    return new Lt(function() {
      for (; h++ < e; )
        f.next();
      if (++p > c)
        return un();
      var b = f.next();
      return a || d === gi || b.done ? b : d === uw ? rr(d, p - 1, void 0, b) : rr(d, p - 1, b.value[1], b);
    });
  }, s;
}
function _re(u, r, o) {
  var a = Li(u);
  return a.__iterateUncached = function(t, e) {
    var n = this;
    if (e)
      return this.cacheResult().__iterate(t, e);
    var i = 0;
    return u.__iterate(
      function(c, s, d) {
        return r.call(o, c, s, d) && ++i && t(c, s, n);
      }
    ), i;
  }, a.__iteratorUncached = function(t, e) {
    var n = this;
    if (e)
      return this.cacheResult().__iterator(t, e);
    var i = u.__iterator(Un, e), c = !0;
    return new Lt(function() {
      if (!c)
        return un();
      var s = i.next();
      if (s.done)
        return s;
      var d = s.value, l = d[0], f = d[1];
      return r.call(o, f, l, n) ? t === Un ? s : rr(t, l, f, s) : (c = !1, un());
    });
  }, a;
}
function ZJ(u, r, o, a) {
  var t = Li(u);
  return t.__iterateUncached = function(e, n) {
    var i = this;
    if (n)
      return this.cacheResult().__iterate(e, n);
    var c = !0, s = 0;
    return u.__iterate(function(d, l, f) {
      if (!(c && (c = r.call(o, d, l, f))))
        return s++, e(d, a ? l : s - 1, i);
    }), s;
  }, t.__iteratorUncached = function(e, n) {
    var i = this;
    if (n)
      return this.cacheResult().__iterator(e, n);
    var c = u.__iterator(Un, n), s = !0, d = 0;
    return new Lt(function() {
      var l, f, h;
      do {
        if (l = c.next(), l.done)
          return a || e === gi ? l : e === uw ? rr(e, d++, void 0, l) : rr(e, d++, l.value[1], l);
        var p = l.value;
        f = p[0], h = p[1], s && (s = r.call(o, h, f, i));
      } while (s);
      return e === Un ? l : rr(e, f, h, l);
    });
  }, t;
}
function gre(u, r) {
  var o = zt(u), a = [u].concat(r).map(function(n) {
    return Xr(n) ? o && (n = Hn(n)) : n = o ? Ux(n) : HJ(Array.isArray(n) ? n : [n]), n;
  }).filter(function(n) {
    return n.size !== 0;
  });
  if (a.length === 0)
    return u;
  if (a.length === 1) {
    var t = a[0];
    if (t === u || o && zt(t) || Br(u) && Br(t))
      return t;
  }
  var e = new Jf(a);
  return o ? e = e.toKeyedSeq() : Br(u) || (e = e.toSetSeq()), e = e.flatten(!0), e.size = a.reduce(function(n, i) {
    if (n !== void 0) {
      var c = i.size;
      if (c !== void 0)
        return n + c;
    }
  }, 0), e;
}
function eK(u, r, o) {
  var a = Li(u);
  return a.__iterateUncached = function(t, e) {
    if (e)
      return this.cacheResult().__iterate(t, e);
    var n = 0, i = !1;
    function c(s, d) {
      s.__iterate(function(l, f) {
        return (!r || d < r) && Xr(l) ? c(l, d + 1) : (n++, t(l, o ? f : n - 1, a) === !1 && (i = !0)), !i;
      }, e);
    }
    return c(u, 0), n;
  }, a.__iteratorUncached = function(t, e) {
    if (e)
      return this.cacheResult().__iterator(t, e);
    var n = u.__iterator(t, e), i = [], c = 0;
    return new Lt(function() {
      for (; n; ) {
        var s = n.next();
        if (s.done !== !1) {
          n = i.pop();
          continue;
        }
        var d = s.value;
        if (t === Un && (d = d[1]), (!r || i.length < r) && Xr(d))
          i.push(n), n = d.__iterator(t, e);
        else
          return o ? s : rr(t, c++, d, s);
      }
      return un();
    });
  }, a;
}
function mre(u, r, o) {
  var a = Gx(u);
  return u.toSeq().map(function(t, e) {
    return a(r.call(o, t, e, u));
  }).flatten(!0);
}
function vre(u, r) {
  var o = Li(u);
  return o.size = u.size && u.size * 2 - 1, o.__iterateUncached = function(a, t) {
    var e = this, n = 0;
    return u.__iterate(
      function(i) {
        return (!n || a(r, n++, e) !== !1) && a(i, n++, e) !== !1;
      },
      t
    ), n;
  }, o.__iteratorUncached = function(a, t) {
    var e = u.__iterator(gi, t), n = 0, i;
    return new Lt(function() {
      return (!i || n % 2) && (i = e.next(), i.done) ? i : n % 2 ? rr(a, n++, r) : rr(a, n++, i.value, i);
    });
  }, o;
}
function H0(u, r, o) {
  r || (r = tK);
  var a = zt(u), t = 0, e = u.toSeq().map(function(n, i) {
    return [i, n, t++, o ? o(n, i, u) : n];
  }).valueSeq().toArray();
  return e.sort(function(n, i) {
    return r(n[3], i[3]) || n[2] - i[2];
  }).forEach(
    a ? function(n, i) {
      e[i].length = 2;
    } : function(n, i) {
      e[i] = n[1];
    }
  ), a ? Ya(e) : Br(u) ? Gn(e) : sh(e);
}
function t6(u, r, o) {
  if (r || (r = tK), o) {
    var a = u.toSeq().map(function(t, e) {
      return [t, o(t, e, u)];
    }).reduce(function(t, e) {
      return a5(r, t[1], e[1]) ? e : t;
    });
    return a && a[0];
  }
  return u.reduce(function(t, e) {
    return a5(r, t, e) ? e : t;
  });
}
function a5(u, r, o) {
  var a = u(o, r);
  return a === 0 && o !== r && (o == null || o !== o) || a > 0;
}
function r6(u, r, o, a) {
  var t = Li(u), e = new Jf(o).map(function(n) {
    return n.size;
  });
  return t.size = a ? e.max() : e.min(), t.__iterate = function(n, i) {
    for (var c = this.__iterator(gi, i), s, d = 0; !(s = c.next()).done && n(s.value, d++, this) !== !1; )
      ;
    return d;
  }, t.__iteratorUncached = function(n, i) {
    var c = o.map(
      function(l) {
        return l = tr(l), zO(i ? l.reverse() : l);
      }
    ), s = 0, d = !1;
    return new Lt(function() {
      var l;
      return d || (l = c.map(function(f) {
        return f.next();
      }), d = a ? l.every(function(f) {
        return f.done;
      }) : l.some(function(f) {
        return f.done;
      })), d ? un() : rr(
        n,
        s++,
        r.apply(
          null,
          l.map(function(f) {
            return f.value;
          })
        )
      );
    });
  }, t;
}
function Gt(u, r) {
  return u === r ? u : aw(u) ? r : u.constructor(r);
}
function u5(u) {
  if (u !== Object(u))
    throw new TypeError("Expected [K, V] tuple: " + u);
}
function Gx(u) {
  return zt(u) ? Hn : Br(u) ? t0 : ah;
}
function Li(u) {
  return Object.create(
    (zt(u) ? Ya : Br(u) ? Gn : sh).prototype
  );
}
function zx() {
  return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, this) : Jr.prototype.cacheResult.call(this);
}
function tK(u, r) {
  return u === void 0 && r === void 0 ? 0 : u === void 0 ? 1 : r === void 0 ? -1 : u > r ? 1 : u < r ? -1 : 0;
}
function Ni(u, r) {
  r = r || 0;
  for (var o = Math.max(0, u.length - r), a = new Array(o), t = 0; t < o; t++)
    a[t] = u[t + r];
  return a;
}
function kx(u, r) {
  if (!u)
    throw new Error(r);
}
function Sn(u) {
  kx(
    u !== 1 / 0,
    "Cannot perform this action with an infinite size."
  );
}
function rK(u) {
  if (qx(u) && typeof u != "string")
    return u;
  if (On(u))
    return u.toArray();
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + u
  );
}
var Tre = Object.prototype.toString;
function $S(u) {
  if (!u || typeof u != "object" || Tre.call(u) !== "[object Object]")
    return !1;
  var r = Object.getPrototypeOf(u);
  if (r === null)
    return !0;
  for (var o = r, a = Object.getPrototypeOf(r); a !== null; )
    o = a, a = Object.getPrototypeOf(o);
  return o === r;
}
function Ja(u) {
  return typeof u == "object" && (In(u) || Array.isArray(u) || $S(u));
}
function UT(u) {
  try {
    return typeof u == "string" ? JSON.stringify(u) : String(u);
  } catch {
    return JSON.stringify(u);
  }
}
function Xx(u, r) {
  return In(u) ? u.has(r) : Ja(u) && oh.call(u, r);
}
function US(u, r, o) {
  return In(u) ? u.get(r, o) : Xx(u, r) ? typeof u.get == "function" ? u.get(r) : u[r] : o;
}
function SS(u) {
  if (Array.isArray(u))
    return Ni(u);
  var r = {};
  for (var o in u)
    oh.call(u, o) && (r[o] = u[o]);
  return r;
}
function Jx(u, r) {
  if (!Ja(u))
    throw new TypeError(
      "Cannot update non-data-structure value: " + u
    );
  if (In(u)) {
    if (!u.remove)
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + u
      );
    return u.remove(r);
  }
  if (!oh.call(u, r))
    return u;
  var o = SS(u);
  return Array.isArray(o) ? o.splice(r, 1) : delete o[r], o;
}
function Kx(u, r, o) {
  if (!Ja(u))
    throw new TypeError(
      "Cannot update non-data-structure value: " + u
    );
  if (In(u)) {
    if (!u.set)
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + u
      );
    return u.set(r, o);
  }
  if (oh.call(u, r) && o === u[r])
    return u;
  var a = SS(u);
  return a[r] = o, a;
}
function Za(u, r, o, a) {
  a || (a = o, o = void 0);
  var t = nK(
    In(u),
    u,
    rK(r),
    0,
    o,
    a
  );
  return t === Rt ? o : t;
}
function nK(u, r, o, a, t, e) {
  var n = r === Rt;
  if (a === o.length) {
    var i = n ? t : r, c = e(i);
    return c === i ? r : c;
  }
  if (!n && !Ja(r))
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + o.slice(0, a).map(UT) + "]: " + r
    );
  var s = o[a], d = n ? Rt : US(r, s, Rt), l = nK(
    d === Rt ? u : In(d),
    d,
    o,
    a + 1,
    t,
    e
  );
  return l === d ? r : l === Rt ? Jx(r, s) : Kx(
    n ? u ? bi() : {} : r,
    s,
    l
  );
}
function Wx(u, r, o) {
  return Za(u, r, Rt, function() {
    return o;
  });
}
function Yx(u, r) {
  return Wx(this, u, r);
}
function Zx(u, r) {
  return Za(u, r, function() {
    return Rt;
  });
}
function e8(u) {
  return Zx(this, u);
}
function VS(u, r, o, a) {
  return Za(u, [r], o, a);
}
function t8(u, r, o) {
  return arguments.length === 1 ? u(this) : VS(this, u, r, o);
}
function r8(u, r, o) {
  return Za(this, u, r, o);
}
function iK() {
  for (var u = [], r = arguments.length; r--; ) u[r] = arguments[r];
  return uK(this, u);
}
function aK(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  if (typeof u != "function")
    throw new TypeError("Invalid merger function: " + u);
  return uK(this, r, u);
}
function uK(u, r, o) {
  for (var a = [], t = 0; t < r.length; t++) {
    var e = Hn(r[t]);
    e.size !== 0 && a.push(e);
  }
  return a.length === 0 ? u : u.toSeq().size === 0 && !u.__ownerID && a.length === 1 ? u.constructor(a[0]) : u.withMutations(function(n) {
    for (var i = o ? function(s, d) {
      VS(
        n,
        d,
        Rt,
        function(l) {
          return l === Rt ? s : o(l, s, d);
        }
      );
    } : function(s, d) {
      n.set(d, s);
    }, c = 0; c < a.length; c++)
      a[c].forEach(i);
  });
}
function oK(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  return cw(u, r);
}
function sK(u, r) {
  for (var o = [], a = arguments.length - 2; a-- > 0; ) o[a] = arguments[a + 2];
  return cw(r, o, u);
}
function cK(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  return sw(u, r);
}
function dK(u, r) {
  for (var o = [], a = arguments.length - 2; a-- > 0; ) o[a] = arguments[a + 2];
  return sw(r, o, u);
}
function sw(u, r, o) {
  return cw(u, r, wre(o));
}
function cw(u, r, o) {
  if (!Ja(u))
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + u
    );
  if (In(u))
    return typeof o == "function" && u.mergeWith ? u.mergeWith.apply(u, [o].concat(r)) : u.merge ? u.merge.apply(u, r) : u.concat.apply(u, r);
  for (var a = Array.isArray(u), t = u, e = a ? t0 : Hn, n = a ? function(c) {
    t === u && (t = SS(t)), t.push(c);
  } : function(c, s) {
    var d = oh.call(t, s), l = d && o ? o(t[s], c, s) : c;
    (!d || l !== t[s]) && (t === u && (t = SS(t)), t[s] = l);
  }, i = 0; i < r.length; i++)
    e(r[i]).forEach(n);
  return t;
}
function wre(u) {
  function r(o, a, t) {
    return Ja(o) && Ja(a) && Sre(o, a) ? cw(o, [a], r) : u ? u(o, a, t) : a;
  }
  return r;
}
function Sre(u, r) {
  var o = Jr(u), a = Jr(r);
  return Br(o) === Br(a) && zt(o) === zt(a);
}
function lK() {
  for (var u = [], r = arguments.length; r--; ) u[r] = arguments[r];
  return sw(this, u);
}
function fK(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  return sw(this, r, u);
}
function n8(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  return Za(this, u, bi(), function(a) {
    return cw(a, r);
  });
}
function i8(u) {
  for (var r = [], o = arguments.length - 1; o-- > 0; ) r[o] = arguments[o + 1];
  return Za(
    this,
    u,
    bi(),
    function(a) {
      return sw(a, r);
    }
  );
}
function dw(u) {
  var r = this.asMutable();
  return u(r), r.wasAltered() ? r.__ensureOwner(this.__ownerID) : this;
}
function lw() {
  return this.__ownerID ? this : this.__ensureOwner(new Mx());
}
function fw() {
  return this.__ensureOwner();
}
function a8() {
  return this.__altered;
}
var eu = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? bi() : ow(o) && !On(o) ? o : bi().withMutations(function(a) {
      var t = u(o);
      Sn(t.size), t.forEach(function(e, n) {
        return a.set(n, e);
      });
    });
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    for (var a = [], t = arguments.length; t--; ) a[t] = arguments[t];
    return bi().withMutations(function(e) {
      for (var n = 0; n < a.length; n += 2) {
        if (n + 1 >= a.length)
          throw new Error("Missing value for key: " + a[n]);
        e.set(a[n], a[n + 1]);
      }
    });
  }, r.prototype.toString = function() {
    return this.__toString("Map {", "}");
  }, r.prototype.get = function(a, t) {
    return this._root ? this._root.get(0, void 0, a, t) : t;
  }, r.prototype.set = function(a, t) {
    return c5(this, a, t);
  }, r.prototype.remove = function(a) {
    return c5(this, a, Rt);
  }, r.prototype.deleteAll = function(a) {
    var t = tr(a);
    return t.size === 0 ? this : this.withMutations(function(e) {
      t.forEach(function(n) {
        return e.remove(n);
      });
    });
  }, r.prototype.clear = function() {
    return this.size === 0 ? this : this.__ownerID ? (this.size = 0, this._root = null, this.__hash = void 0, this.__altered = !0, this) : bi();
  }, r.prototype.sort = function(a) {
    return mi(H0(this, a));
  }, r.prototype.sortBy = function(a, t) {
    return mi(H0(this, t, a));
  }, r.prototype.map = function(a, t) {
    var e = this;
    return this.withMutations(function(n) {
      n.forEach(function(i, c) {
        n.set(c, a.call(t, i, c, e));
      });
    });
  }, r.prototype.__iterator = function(a, t) {
    return new Are(this, a, t);
  }, r.prototype.__iterate = function(a, t) {
    var e = this, n = 0;
    return this._root && this._root.iterate(function(i) {
      return n++, a(i[1], i[0], e);
    }, t), n;
  }, r.prototype.__ensureOwner = function(a) {
    return a === this.__ownerID ? this : a ? u8(this.size, this._root, a, this.__hash) : this.size === 0 ? bi() : (this.__ownerID = a, this.__altered = !1, this);
  }, r;
}(Hn);
eu.isMap = ow;
var nr = eu.prototype;
nr[GJ] = !0;
nr[rw] = nr.remove;
nr.removeAll = nr.deleteAll;
nr.setIn = Yx;
nr.removeIn = nr.deleteIn = e8;
nr.update = t8;
nr.updateIn = r8;
nr.merge = nr.concat = iK;
nr.mergeWith = aK;
nr.mergeDeep = lK;
nr.mergeDeepWith = fK;
nr.mergeIn = n8;
nr.mergeDeepIn = i8;
nr.withMutations = dw;
nr.wasAltered = a8;
nr.asImmutable = fw;
nr["@@transducer/init"] = nr.asMutable = lw;
nr["@@transducer/step"] = function(u, r) {
  return u.set(r[0], r[1]);
};
nr["@@transducer/result"] = function(u) {
  return u.asImmutable();
};
var VT = function(r, o) {
  this.ownerID = r, this.entries = o;
};
VT.prototype.get = function(r, o, a, t) {
  for (var e = this.entries, n = 0, i = e.length; n < i; n++)
    if (Er(a, e[n][0]))
      return e[n][1];
  return t;
};
VT.prototype.update = function(r, o, a, t, e, n, i) {
  for (var c = e === Rt, s = this.entries, d = 0, l = s.length; d < l && !Er(t, s[d][0]); d++)
    ;
  var f = d < l;
  if (f ? s[d][1] === e : c)
    return this;
  if (Bn(i), (c || !f) && Bn(n), !(c && s.length === 1)) {
    if (!f && !c && s.length >= Fre)
      return Ere(r, s, t, e);
    var h = r && r === this.ownerID, p = h ? s : Ni(s);
    return f ? c ? d === l - 1 ? p.pop() : p[d] = p.pop() : p[d] = [t, e] : p.push([t, e]), h ? (this.entries = p, this) : new VT(r, p);
  }
};
var G0 = function(r, o, a) {
  this.ownerID = r, this.bitmap = o, this.nodes = a;
};
G0.prototype.get = function(r, o, a, t) {
  o === void 0 && (o = nn(a));
  var e = 1 << ((r === 0 ? o : o >>> r) & an), n = this.bitmap;
  return (n & e) === 0 ? t : this.nodes[hK(n & e - 1)].get(
    r + Zt,
    o,
    a,
    t
  );
};
G0.prototype.update = function(r, o, a, t, e, n, i) {
  a === void 0 && (a = nn(t));
  var c = (o === 0 ? a : a >>> o) & an, s = 1 << c, d = this.bitmap, l = (d & s) !== 0;
  if (!l && e === Rt)
    return this;
  var f = hK(d & s - 1), h = this.nodes, p = l ? h[f] : void 0, b = o8(
    p,
    r,
    o + Zt,
    a,
    t,
    e,
    n,
    i
  );
  if (b === p)
    return this;
  if (!l && b && h.length >= Nre)
    return xre(r, h, d, c, b);
  if (l && !b && h.length === 2 && d5(h[f ^ 1]))
    return h[f ^ 1];
  if (l && b && h.length === 1 && d5(b))
    return b;
  var _ = r && r === this.ownerID, y = l ? b ? d : d ^ s : d | s, m = l ? b ? pK(h, f, b, _) : Rre(h, f, _) : Ire(h, f, b, _);
  return _ ? (this.bitmap = y, this.nodes = m, this) : new G0(r, y, m);
};
var QT = function(r, o, a) {
  this.ownerID = r, this.count = o, this.nodes = a;
};
QT.prototype.get = function(r, o, a, t) {
  o === void 0 && (o = nn(a));
  var e = (r === 0 ? o : o >>> r) & an, n = this.nodes[e];
  return n ? n.get(r + Zt, o, a, t) : t;
};
QT.prototype.update = function(r, o, a, t, e, n, i) {
  a === void 0 && (a = nn(t));
  var c = (o === 0 ? a : a >>> o) & an, s = e === Rt, d = this.nodes, l = d[c];
  if (s && !l)
    return this;
  var f = o8(
    l,
    r,
    o + Zt,
    a,
    t,
    e,
    n,
    i
  );
  if (f === l)
    return this;
  var h = this.count;
  if (!l)
    h++;
  else if (!f && (h--, h < Pre))
    return Ore(r, d, h, c);
  var p = r && r === this.ownerID, b = pK(d, c, f, p);
  return p ? (this.count = h, this.nodes = b, this) : new QT(r, h, b);
};
var z0 = function(r, o, a) {
  this.ownerID = r, this.keyHash = o, this.entries = a;
};
z0.prototype.get = function(r, o, a, t) {
  for (var e = this.entries, n = 0, i = e.length; n < i; n++)
    if (Er(a, e[n][0]))
      return e[n][1];
  return t;
};
z0.prototype.update = function(r, o, a, t, e, n, i) {
  a === void 0 && (a = nn(t));
  var c = e === Rt;
  if (a !== this.keyHash)
    return c ? this : (Bn(i), Bn(n), s8(this, r, o, a, [t, e]));
  for (var s = this.entries, d = 0, l = s.length; d < l && !Er(t, s[d][0]); d++)
    ;
  var f = d < l;
  if (f ? s[d][1] === e : c)
    return this;
  if (Bn(i), (c || !f) && Bn(n), c && l === 2)
    return new ga(r, this.keyHash, s[d ^ 1]);
  var h = r && r === this.ownerID, p = h ? s : Ni(s);
  return f ? c ? d === l - 1 ? p.pop() : p[d] = p.pop() : p[d] = [t, e] : p.push([t, e]), h ? (this.entries = p, this) : new z0(r, this.keyHash, p);
};
var ga = function(r, o, a) {
  this.ownerID = r, this.keyHash = o, this.entry = a;
};
ga.prototype.get = function(r, o, a, t) {
  return Er(a, this.entry[0]) ? this.entry[1] : t;
};
ga.prototype.update = function(r, o, a, t, e, n, i) {
  var c = e === Rt, s = Er(t, this.entry[0]);
  if (s ? e === this.entry[1] : c)
    return this;
  if (Bn(i), c) {
    Bn(n);
    return;
  }
  return s ? r && r === this.ownerID ? (this.entry[1] = e, this) : new ga(r, this.keyHash, [t, e]) : (Bn(n), s8(this, r, o, nn(t), [t, e]));
};
VT.prototype.iterate = z0.prototype.iterate = function(u, r) {
  for (var o = this.entries, a = 0, t = o.length - 1; a <= t; a++)
    if (u(o[r ? t - a : a]) === !1)
      return !1;
};
G0.prototype.iterate = QT.prototype.iterate = function(u, r) {
  for (var o = this.nodes, a = 0, t = o.length - 1; a <= t; a++) {
    var e = o[r ? t - a : a];
    if (e && e.iterate(u, r) === !1)
      return !1;
  }
};
ga.prototype.iterate = function(u, r) {
  return u(this.entry);
};
var Are = /* @__PURE__ */ function(u) {
  function r(o, a, t) {
    this._type = a, this._reverse = t, this._stack = o._root && o5(o._root);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.next = function() {
    for (var a = this._type, t = this._stack; t; ) {
      var e = t.node, n = t.index++, i = void 0;
      if (e.entry) {
        if (n === 0)
          return V4(a, e.entry);
      } else if (e.entries) {
        if (i = e.entries.length - 1, n <= i)
          return V4(
            a,
            e.entries[this._reverse ? i - n : n]
          );
      } else if (i = e.nodes.length - 1, n <= i) {
        var c = e.nodes[this._reverse ? i - n : n];
        if (c) {
          if (c.entry)
            return V4(a, c.entry);
          t = this._stack = o5(c, t);
        }
        continue;
      }
      t = this._stack = this._stack.__prev;
    }
    return un();
  }, r;
}(Lt);
function V4(u, r) {
  return rr(u, r[0], r[1]);
}
function o5(u, r) {
  return {
    node: u,
    index: 0,
    __prev: r
  };
}
function u8(u, r, o, a) {
  var t = Object.create(nr);
  return t.size = u, t._root = r, t.__ownerID = o, t.__hash = a, t.__altered = !1, t;
}
var s5;
function bi() {
  return s5 || (s5 = u8(0));
}
function c5(u, r, o) {
  var a, t;
  if (u._root) {
    var e = HO(), n = HO();
    if (a = o8(
      u._root,
      u.__ownerID,
      0,
      void 0,
      r,
      o,
      e,
      n
    ), !n.value)
      return u;
    t = u.size + (e.value ? o === Rt ? -1 : 1 : 0);
  } else {
    if (o === Rt)
      return u;
    t = 1, a = new VT(u.__ownerID, [[r, o]]);
  }
  return u.__ownerID ? (u.size = t, u._root = a, u.__hash = void 0, u.__altered = !0, u) : a ? u8(t, a) : bi();
}
function o8(u, r, o, a, t, e, n, i) {
  return u ? u.update(
    r,
    o,
    a,
    t,
    e,
    n,
    i
  ) : e === Rt ? u : (Bn(i), Bn(n), new ga(r, a, [t, e]));
}
function d5(u) {
  return u.constructor === ga || u.constructor === z0;
}
function s8(u, r, o, a, t) {
  if (u.keyHash === a)
    return new z0(r, a, [u.entry, t]);
  var e = (o === 0 ? u.keyHash : u.keyHash >>> o) & an, n = (o === 0 ? a : a >>> o) & an, i, c = e === n ? [s8(u, r, o + Zt, a, t)] : (i = new ga(r, a, t), e < n ? [u, i] : [i, u]);
  return new G0(r, 1 << e | 1 << n, c);
}
function Ere(u, r, o, a) {
  u || (u = new Mx());
  for (var t = new ga(u, nn(o), [o, a]), e = 0; e < r.length; e++) {
    var n = r[e];
    t = t.update(u, 0, void 0, n[0], n[1]);
  }
  return t;
}
function Ore(u, r, o, a) {
  for (var t = 0, e = 0, n = new Array(o), i = 0, c = 1, s = r.length; i < s; i++, c <<= 1) {
    var d = r[i];
    d !== void 0 && i !== a && (t |= c, n[e++] = d);
  }
  return new G0(u, t, n);
}
function xre(u, r, o, a, t) {
  for (var e = 0, n = new Array(qn), i = 0; o !== 0; i++, o >>>= 1)
    n[i] = o & 1 ? r[e++] : void 0;
  return n[a] = t, new QT(u, e + 1, n);
}
function hK(u) {
  return u -= u >> 1 & 1431655765, u = (u & 858993459) + (u >> 2 & 858993459), u = u + (u >> 4) & 252645135, u += u >> 8, u += u >> 16, u & 127;
}
function pK(u, r, o, a) {
  var t = a ? u : Ni(u);
  return t[r] = o, t;
}
function Ire(u, r, o, a) {
  var t = u.length + 1;
  if (a && r + 1 === t)
    return u[r] = o, u;
  for (var e = new Array(t), n = 0, i = 0; i < t; i++)
    i === r ? (e[i] = o, n = -1) : e[i] = u[i + n];
  return e;
}
function Rre(u, r, o) {
  var a = u.length - 1;
  if (o && r === a)
    return u.pop(), u;
  for (var t = new Array(a), e = 0, n = 0; n < a; n++)
    n === r && (e = 1), t[n] = u[n + e];
  return t;
}
var Fre = qn / 4, Nre = qn / 2, Pre = qn / 4, bK = "@@__IMMUTABLE_LIST__@@";
function QS(u) {
  return !!(u && u[bK]);
}
var ch = /* @__PURE__ */ function(u) {
  function r(o) {
    var a = W6();
    if (o == null)
      return a;
    if (QS(o))
      return o;
    var t = u(o), e = t.size;
    return e === 0 ? a : (Sn(e), e > 0 && e < qn ? HT(0, e, Zt, null, new za(t.toArray())) : a.withMutations(function(n) {
      n.setSize(e), t.forEach(function(i, c) {
        return n.set(c, i);
      });
    }));
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return this(arguments);
  }, r.prototype.toString = function() {
    return this.__toString("List [", "]");
  }, r.prototype.get = function(a, t) {
    if (a = Xa(this, a), a >= 0 && a < this.size) {
      a += this._origin;
      var e = yK(this, a);
      return e && e.array[a & an];
    }
    return t;
  }, r.prototype.set = function(a, t) {
    return Dre(this, a, t);
  }, r.prototype.remove = function(a) {
    return this.has(a) ? a === 0 ? this.shift() : a === this.size - 1 ? this.pop() : this.splice(a, 1) : this;
  }, r.prototype.insert = function(a, t) {
    return this.splice(a, 0, t);
  }, r.prototype.clear = function() {
    return this.size === 0 ? this : this.__ownerID ? (this.size = this._origin = this._capacity = 0, this._level = Zt, this._root = this._tail = this.__hash = void 0, this.__altered = !0, this) : W6();
  }, r.prototype.push = function() {
    var a = arguments, t = this.size;
    return this.withMutations(function(e) {
      $a(e, 0, t + a.length);
      for (var n = 0; n < a.length; n++)
        e.set(t + n, a[n]);
    });
  }, r.prototype.pop = function() {
    return $a(this, 0, -1);
  }, r.prototype.unshift = function() {
    var a = arguments;
    return this.withMutations(function(t) {
      $a(t, -a.length);
      for (var e = 0; e < a.length; e++)
        t.set(e, a[e]);
    });
  }, r.prototype.shift = function() {
    return $a(this, 1);
  }, r.prototype.concat = function() {
    for (var a = arguments, t = [], e = 0; e < arguments.length; e++) {
      var n = a[e], i = u(
        typeof n != "string" && Cx(n) ? n : [n]
      );
      i.size !== 0 && t.push(i);
    }
    return t.length === 0 ? this : this.size === 0 && !this.__ownerID && t.length === 1 ? this.constructor(t[0]) : this.withMutations(function(c) {
      t.forEach(function(s) {
        return s.forEach(function(d) {
          return c.push(d);
        });
      });
    });
  }, r.prototype.setSize = function(a) {
    return $a(this, 0, a);
  }, r.prototype.map = function(a, t) {
    var e = this;
    return this.withMutations(function(n) {
      for (var i = 0; i < e.size; i++)
        n.set(i, a.call(t, n.get(i), i, e));
    });
  }, r.prototype.slice = function(a, t) {
    var e = this.size;
    return nw(a, t, e) ? this : $a(
      this,
      nh(a, e),
      iw(t, e)
    );
  }, r.prototype.__iterator = function(a, t) {
    var e = t ? this.size : 0, n = l5(this, t);
    return new Lt(function() {
      var i = n();
      return i === FT ? un() : rr(a, t ? --e : e++, i);
    });
  }, r.prototype.__iterate = function(a, t) {
    for (var e = t ? this.size : 0, n = l5(this, t), i; (i = n()) !== FT && a(i, t ? --e : e++, this) !== !1; )
      ;
    return e;
  }, r.prototype.__ensureOwner = function(a) {
    return a === this.__ownerID ? this : a ? HT(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      a,
      this.__hash
    ) : this.size === 0 ? W6() : (this.__ownerID = a, this.__altered = !1, this);
  }, r;
}(t0);
ch.isList = QS;
var mr = ch.prototype;
mr[bK] = !0;
mr[rw] = mr.remove;
mr.merge = mr.concat;
mr.setIn = Yx;
mr.deleteIn = mr.removeIn = e8;
mr.update = t8;
mr.updateIn = r8;
mr.mergeIn = n8;
mr.mergeDeepIn = i8;
mr.withMutations = dw;
mr.wasAltered = a8;
mr.asImmutable = fw;
mr["@@transducer/init"] = mr.asMutable = lw;
mr["@@transducer/step"] = function(u, r) {
  return u.push(r);
};
mr["@@transducer/result"] = function(u) {
  return u.asImmutable();
};
var za = function(r, o) {
  this.array = r, this.ownerID = o;
};
za.prototype.removeBefore = function(r, o, a) {
  if (a === o ? 1 << o : this.array.length === 0)
    return this;
  var t = a >>> o & an;
  if (t >= this.array.length)
    return new za([], r);
  var e = t === 0, n;
  if (o > 0) {
    var i = this.array[t];
    if (n = i && i.removeBefore(r, o - Zt, a), n === i && e)
      return this;
  }
  if (e && !n)
    return this;
  var c = k0(this, r);
  if (!e)
    for (var s = 0; s < t; s++)
      c.array[s] = void 0;
  return n && (c.array[t] = n), c;
};
za.prototype.removeAfter = function(r, o, a) {
  if (a === (o ? 1 << o : 0) || this.array.length === 0)
    return this;
  var t = a - 1 >>> o & an;
  if (t >= this.array.length)
    return this;
  var e;
  if (o > 0) {
    var n = this.array[t];
    if (e = n && n.removeAfter(r, o - Zt, a), e === n && t === this.array.length - 1)
      return this;
  }
  var i = k0(this, r);
  return i.array.splice(t + 1), e && (i.array[t] = e), i;
};
var FT = {};
function l5(u, r) {
  var o = u._origin, a = u._capacity, t = GT(a), e = u._tail;
  return n(u._root, u._level, 0);
  function n(s, d, l) {
    return d === 0 ? i(s, l) : c(s, d, l);
  }
  function i(s, d) {
    var l = d === t ? e && e.array : s && s.array, f = d > o ? 0 : o - d, h = a - d;
    return h > qn && (h = qn), function() {
      if (f === h)
        return FT;
      var p = r ? --h : f++;
      return l && l[p];
    };
  }
  function c(s, d, l) {
    var f, h = s && s.array, p = l > o ? 0 : o - l >> d, b = (a - l >> d) + 1;
    return b > qn && (b = qn), function() {
      for (; ; ) {
        if (f) {
          var _ = f();
          if (_ !== FT)
            return _;
          f = null;
        }
        if (p === b)
          return FT;
        var y = r ? --b : p++;
        f = n(
          h && h[y],
          d - Zt,
          l + (y << d)
        );
      }
    };
  }
}
function HT(u, r, o, a, t, e, n) {
  var i = Object.create(mr);
  return i.size = r - u, i._origin = u, i._capacity = r, i._level = o, i._root = a, i._tail = t, i.__ownerID = e, i.__hash = n, i.__altered = !1, i;
}
var f5;
function W6() {
  return f5 || (f5 = HT(0, 0, Zt));
}
function Dre(u, r, o) {
  if (r = Xa(u, r), r !== r)
    return u;
  if (r >= u.size || r < 0)
    return u.withMutations(function(n) {
      r < 0 ? $a(n, r).set(0, o) : $a(n, 0, r + 1).set(r, o);
    });
  r += u._origin;
  var a = u._tail, t = u._root, e = HO();
  return r >= GT(u._capacity) ? a = KO(a, u.__ownerID, 0, r, o, e) : t = KO(
    t,
    u.__ownerID,
    u._level,
    r,
    o,
    e
  ), e.value ? u.__ownerID ? (u._root = t, u._tail = a, u.__hash = void 0, u.__altered = !0, u) : HT(u._origin, u._capacity, u._level, t, a) : u;
}
function KO(u, r, o, a, t, e) {
  var n = a >>> o & an, i = u && n < u.array.length;
  if (!i && t === void 0)
    return u;
  var c;
  if (o > 0) {
    var s = u && u.array[n], d = KO(
      s,
      r,
      o - Zt,
      a,
      t,
      e
    );
    return d === s ? u : (c = k0(u, r), c.array[n] = d, c);
  }
  return i && u.array[n] === t ? u : (e && Bn(e), c = k0(u, r), t === void 0 && n === c.array.length - 1 ? c.array.pop() : c.array[n] = t, c);
}
function k0(u, r) {
  return r && u && r === u.ownerID ? u : new za(u ? u.array.slice() : [], r);
}
function yK(u, r) {
  if (r >= GT(u._capacity))
    return u._tail;
  if (r < 1 << u._level + Zt) {
    for (var o = u._root, a = u._level; o && a > 0; )
      o = o.array[r >>> a & an], a -= Zt;
    return o;
  }
}
function $a(u, r, o) {
  r !== void 0 && (r |= 0), o !== void 0 && (o |= 0);
  var a = u.__ownerID || new Mx(), t = u._origin, e = u._capacity, n = t + r, i = o === void 0 ? e : o < 0 ? e + o : t + o;
  if (n === t && i === e)
    return u;
  if (n >= i)
    return u.clear();
  for (var c = u._level, s = u._root, d = 0; n + d < 0; )
    s = new za(
      s && s.array.length ? [void 0, s] : [],
      a
    ), c += Zt, d += 1 << c;
  d && (n += d, t += d, i += d, e += d);
  for (var l = GT(e), f = GT(i); f >= 1 << c + Zt; )
    s = new za(
      s && s.array.length ? [s] : [],
      a
    ), c += Zt;
  var h = u._tail, p = f < l ? yK(u, i - 1) : f > l ? new za([], a) : h;
  if (h && f > l && n < e && h.array.length) {
    s = k0(s, a);
    for (var b = s, _ = c; _ > Zt; _ -= Zt) {
      var y = l >>> _ & an;
      b = b.array[y] = k0(b.array[y], a);
    }
    b.array[l >>> Zt & an] = h;
  }
  if (i < e && (p = p && p.removeAfter(a, 0, i)), n >= f)
    n -= f, i -= f, c = Zt, s = null, p = p && p.removeBefore(a, 0, n);
  else if (n > t || f < l) {
    for (d = 0; s; ) {
      var m = n >>> c & an;
      if (m !== f >>> c & an)
        break;
      m && (d += (1 << c) * m), c -= Zt, s = s.array[m];
    }
    s && n > t && (s = s.removeBefore(a, c, n - d)), s && f < l && (s = s.removeAfter(
      a,
      c,
      f - d
    )), d && (n -= d, i -= d);
  }
  return u.__ownerID ? (u.size = i - n, u._origin = n, u._capacity = i, u._level = c, u._root = s, u._tail = p, u.__hash = void 0, u.__altered = !0, u) : HT(n, i, c, s, p);
}
function GT(u) {
  return u < qn ? 0 : u - 1 >>> Zt << Zt;
}
var mi = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? fT() : CS(o) ? o : fT().withMutations(function(a) {
      var t = Hn(o);
      Sn(t.size), t.forEach(function(e, n) {
        return a.set(n, e);
      });
    });
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return this(arguments);
  }, r.prototype.toString = function() {
    return this.__toString("OrderedMap {", "}");
  }, r.prototype.get = function(a, t) {
    var e = this._map.get(a);
    return e !== void 0 ? this._list.get(e)[1] : t;
  }, r.prototype.clear = function() {
    return this.size === 0 ? this : this.__ownerID ? (this.size = 0, this._map.clear(), this._list.clear(), this.__altered = !0, this) : fT();
  }, r.prototype.set = function(a, t) {
    return p5(this, a, t);
  }, r.prototype.remove = function(a) {
    return p5(this, a, Rt);
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    return this._list.__iterate(
      function(n) {
        return n && a(n[1], n[0], e);
      },
      t
    );
  }, r.prototype.__iterator = function(a, t) {
    return this._list.fromEntrySeq().__iterator(a, t);
  }, r.prototype.__ensureOwner = function(a) {
    if (a === this.__ownerID)
      return this;
    var t = this._map.__ensureOwner(a), e = this._list.__ensureOwner(a);
    return a ? c8(t, e, a, this.__hash) : this.size === 0 ? fT() : (this.__ownerID = a, this.__altered = !1, this._map = t, this._list = e, this);
  }, r;
}(eu);
mi.isOrderedMap = CS;
mi.prototype[uh] = !0;
mi.prototype[rw] = mi.prototype.remove;
function c8(u, r, o, a) {
  var t = Object.create(mi.prototype);
  return t.size = u ? u.size : 0, t._map = u, t._list = r, t.__ownerID = o, t.__hash = a, t.__altered = !1, t;
}
var h5;
function fT() {
  return h5 || (h5 = c8(bi(), W6()));
}
function p5(u, r, o) {
  var a = u._map, t = u._list, e = a.get(r), n = e !== void 0, i, c;
  if (o === Rt) {
    if (!n)
      return u;
    t.size >= qn && t.size >= a.size * 2 ? (c = t.filter(function(s, d) {
      return s !== void 0 && e !== d;
    }), i = c.toKeyedSeq().map(function(s) {
      return s[0];
    }).flip().toMap(), u.__ownerID && (i.__ownerID = c.__ownerID = u.__ownerID)) : (i = a.remove(r), c = e === t.size - 1 ? t.pop() : t.set(e, void 0));
  } else if (n) {
    if (o === t.get(e)[1])
      return u;
    i = a, c = t.set(e, [r, o]);
  } else
    i = a.set(r, t.size), c = t.set(t.size, [r, o]);
  return u.__ownerID ? (u.size = i.size, u._map = i, u._list = c, u.__hash = void 0, u.__altered = !0, u) : c8(i, c);
}
var _K = "@@__IMMUTABLE_STACK__@@";
function zT(u) {
  return !!(u && u[_K]);
}
var hw = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? n6() : zT(o) ? o : n6().pushAll(o);
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return this(arguments);
  }, r.prototype.toString = function() {
    return this.__toString("Stack [", "]");
  }, r.prototype.get = function(a, t) {
    var e = this._head;
    for (a = Xa(this, a); e && a--; )
      e = e.next;
    return e ? e.value : t;
  }, r.prototype.peek = function() {
    return this._head && this._head.value;
  }, r.prototype.push = function() {
    var a = arguments;
    if (arguments.length === 0)
      return this;
    for (var t = this.size + arguments.length, e = this._head, n = arguments.length - 1; n >= 0; n--)
      e = {
        value: a[n],
        next: e
      };
    return this.__ownerID ? (this.size = t, this._head = e, this.__hash = void 0, this.__altered = !0, this) : hT(t, e);
  }, r.prototype.pushAll = function(a) {
    if (a = u(a), a.size === 0)
      return this;
    if (this.size === 0 && zT(a))
      return a;
    Sn(a.size);
    var t = this.size, e = this._head;
    return a.__iterate(
      function(n) {
        t++, e = {
          value: n,
          next: e
        };
      },
      /* reverse */
      !0
    ), this.__ownerID ? (this.size = t, this._head = e, this.__hash = void 0, this.__altered = !0, this) : hT(t, e);
  }, r.prototype.pop = function() {
    return this.slice(1);
  }, r.prototype.clear = function() {
    return this.size === 0 ? this : this.__ownerID ? (this.size = 0, this._head = void 0, this.__hash = void 0, this.__altered = !0, this) : n6();
  }, r.prototype.slice = function(a, t) {
    if (nw(a, t, this.size))
      return this;
    var e = nh(a, this.size), n = iw(t, this.size);
    if (n !== this.size)
      return u.prototype.slice.call(this, a, t);
    for (var i = this.size - e, c = this._head; e--; )
      c = c.next;
    return this.__ownerID ? (this.size = i, this._head = c, this.__hash = void 0, this.__altered = !0, this) : hT(i, c);
  }, r.prototype.__ensureOwner = function(a) {
    return a === this.__ownerID ? this : a ? hT(this.size, this._head, a, this.__hash) : this.size === 0 ? n6() : (this.__ownerID = a, this.__altered = !1, this);
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    if (t)
      return new Jf(this.toArray()).__iterate(
        function(c, s) {
          return a(c, s, e);
        },
        t
      );
    for (var n = 0, i = this._head; i && a(i.value, n++, this) !== !1; )
      i = i.next;
    return n;
  }, r.prototype.__iterator = function(a, t) {
    if (t)
      return new Jf(this.toArray()).__iterator(a, t);
    var e = 0, n = this._head;
    return new Lt(function() {
      if (n) {
        var i = n.value;
        return n = n.next, rr(a, e++, i);
      }
      return un();
    });
  }, r;
}(t0);
hw.isStack = zT;
var on = hw.prototype;
on[_K] = !0;
on.shift = on.pop;
on.unshift = on.push;
on.unshiftAll = on.pushAll;
on.withMutations = dw;
on.wasAltered = a8;
on.asImmutable = fw;
on["@@transducer/init"] = on.asMutable = lw;
on["@@transducer/step"] = function(u, r) {
  return u.unshift(r);
};
on["@@transducer/result"] = function(u) {
  return u.asImmutable();
};
function hT(u, r, o, a) {
  var t = Object.create(on);
  return t.size = u, t._head = r, t.__ownerID = o, t.__hash = a, t.__altered = !1, t;
}
var b5;
function n6() {
  return b5 || (b5 = hT(0));
}
var gK = "@@__IMMUTABLE_SET__@@";
function pw(u) {
  return !!(u && u[gK]);
}
function HS(u) {
  return pw(u) && On(u);
}
function d8(u, r) {
  if (u === r)
    return !0;
  if (!Xr(r) || u.size !== void 0 && r.size !== void 0 && u.size !== r.size || u.__hash !== void 0 && r.__hash !== void 0 && u.__hash !== r.__hash || zt(u) !== zt(r) || Br(u) !== Br(r) || On(u) !== On(r))
    return !1;
  if (u.size === 0 && r.size === 0)
    return !0;
  var o = !ih(u);
  if (On(u)) {
    var a = u.entries();
    return r.every(function(c, s) {
      var d = a.next().value;
      return d && Er(d[1], c) && (o || Er(d[0], s));
    }) && a.next().done;
  }
  var t = !1;
  if (u.size === void 0)
    if (r.size === void 0)
      typeof u.cacheResult == "function" && u.cacheResult();
    else {
      t = !0;
      var e = u;
      u = r, r = e;
    }
  var n = !0, i = r.__iterate(function(c, s) {
    if (o ? !u.has(c) : t ? !Er(c, u.get(s, Rt)) : !Er(u.get(s, Rt), c))
      return n = !1, !1;
  });
  return n && u.size === i;
}
function r0(u, r) {
  var o = function(a) {
    u.prototype[a] = r[a];
  };
  return Object.keys(r).forEach(o), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(r).forEach(o), u;
}
function AS(u) {
  if (!u || typeof u != "object")
    return u;
  if (!Xr(u)) {
    if (!Ja(u))
      return u;
    u = Jr(u);
  }
  if (zt(u)) {
    var r = {};
    return u.__iterate(function(a, t) {
      r[t] = AS(a);
    }), r;
  }
  var o = [];
  return u.__iterate(function(a) {
    o.push(AS(a));
  }), o;
}
var dh = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? pT() : pw(o) && !On(o) ? o : pT().withMutations(function(a) {
      var t = u(o);
      Sn(t.size), t.forEach(function(e) {
        return a.add(e);
      });
    });
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return this(arguments);
  }, r.fromKeys = function(a) {
    return this(Hn(a).keySeq());
  }, r.intersect = function(a) {
    return a = tr(a).toArray(), a.length ? $r.intersect.apply(r(a.pop()), a) : pT();
  }, r.union = function(a) {
    return a = tr(a).toArray(), a.length ? $r.union.apply(r(a.pop()), a) : pT();
  }, r.prototype.toString = function() {
    return this.__toString("Set {", "}");
  }, r.prototype.has = function(a) {
    return this._map.has(a);
  }, r.prototype.add = function(a) {
    return i6(this, this._map.set(a, a));
  }, r.prototype.remove = function(a) {
    return i6(this, this._map.remove(a));
  }, r.prototype.clear = function() {
    return i6(this, this._map.clear());
  }, r.prototype.map = function(a, t) {
    var e = this, n = !1, i = i6(
      this,
      this._map.mapEntries(function(c) {
        var s = c[1], d = a.call(t, s, s, e);
        return d !== s && (n = !0), [d, d];
      }, t)
    );
    return n ? i : this;
  }, r.prototype.union = function() {
    for (var a = [], t = arguments.length; t--; ) a[t] = arguments[t];
    return a = a.filter(function(e) {
      return e.size !== 0;
    }), a.length === 0 ? this : this.size === 0 && !this.__ownerID && a.length === 1 ? this.constructor(a[0]) : this.withMutations(function(e) {
      for (var n = 0; n < a.length; n++)
        typeof a[n] == "string" ? e.add(a[n]) : u(a[n]).forEach(function(i) {
          return e.add(i);
        });
    });
  }, r.prototype.intersect = function() {
    for (var a = [], t = arguments.length; t--; ) a[t] = arguments[t];
    if (a.length === 0)
      return this;
    a = a.map(function(n) {
      return u(n);
    });
    var e = [];
    return this.forEach(function(n) {
      a.every(function(i) {
        return i.includes(n);
      }) || e.push(n);
    }), this.withMutations(function(n) {
      e.forEach(function(i) {
        n.remove(i);
      });
    });
  }, r.prototype.subtract = function() {
    for (var a = [], t = arguments.length; t--; ) a[t] = arguments[t];
    if (a.length === 0)
      return this;
    a = a.map(function(n) {
      return u(n);
    });
    var e = [];
    return this.forEach(function(n) {
      a.some(function(i) {
        return i.includes(n);
      }) && e.push(n);
    }), this.withMutations(function(n) {
      e.forEach(function(i) {
        n.remove(i);
      });
    });
  }, r.prototype.sort = function(a) {
    return Kf(H0(this, a));
  }, r.prototype.sortBy = function(a, t) {
    return Kf(H0(this, t, a));
  }, r.prototype.wasAltered = function() {
    return this._map.wasAltered();
  }, r.prototype.__iterate = function(a, t) {
    var e = this;
    return this._map.__iterate(function(n) {
      return a(n, n, e);
    }, t);
  }, r.prototype.__iterator = function(a, t) {
    return this._map.__iterator(a, t);
  }, r.prototype.__ensureOwner = function(a) {
    if (a === this.__ownerID)
      return this;
    var t = this._map.__ensureOwner(a);
    return a ? this.__make(t, a) : this.size === 0 ? this.__empty() : (this.__ownerID = a, this._map = t, this);
  }, r;
}(ah);
dh.isSet = pw;
var $r = dh.prototype;
$r[gK] = !0;
$r[rw] = $r.remove;
$r.merge = $r.concat = $r.union;
$r.withMutations = dw;
$r.asImmutable = fw;
$r["@@transducer/init"] = $r.asMutable = lw;
$r["@@transducer/step"] = function(u, r) {
  return u.add(r);
};
$r["@@transducer/result"] = function(u) {
  return u.asImmutable();
};
$r.__empty = pT;
$r.__make = mK;
function i6(u, r) {
  return u.__ownerID ? (u.size = r.size, u._map = r, u) : r === u._map ? u : r.size === 0 ? u.__empty() : u.__make(r);
}
function mK(u, r) {
  var o = Object.create($r);
  return o.size = u ? u.size : 0, o._map = u, o.__ownerID = r, o;
}
var y5;
function pT() {
  return y5 || (y5 = mK(bi()));
}
var l8 = /* @__PURE__ */ function(u) {
  function r(o, a, t) {
    if (!(this instanceof r))
      return new r(o, a, t);
    if (kx(t !== 0, "Cannot step a Range by 0"), o = o || 0, a === void 0 && (a = 1 / 0), t = t === void 0 ? 1 : Math.abs(t), a < o && (t = -t), this._start = o, this._end = a, this._step = t, this.size = Math.max(0, Math.ceil((a - o) / t - 1) + 1), this.size === 0) {
      if (Q4)
        return Q4;
      Q4 = this;
    }
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.toString = function() {
    return this.size === 0 ? "Range []" : "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  }, r.prototype.get = function(a, t) {
    return this.has(a) ? this._start + Xa(this, a) * this._step : t;
  }, r.prototype.includes = function(a) {
    var t = (a - this._start) / this._step;
    return t >= 0 && t < this.size && t === Math.floor(t);
  }, r.prototype.slice = function(a, t) {
    return nw(a, t, this.size) ? this : (a = nh(a, this.size), t = iw(t, this.size), t <= a ? new r(0, 0) : new r(
      this.get(a, this._end),
      this.get(t, this._end),
      this._step
    ));
  }, r.prototype.indexOf = function(a) {
    var t = a - this._start;
    if (t % this._step === 0) {
      var e = t / this._step;
      if (e >= 0 && e < this.size)
        return e;
    }
    return -1;
  }, r.prototype.lastIndexOf = function(a) {
    return this.indexOf(a);
  }, r.prototype.__iterate = function(a, t) {
    for (var e = this.size, n = this._step, i = t ? this._start + (e - 1) * n : this._start, c = 0; c !== e && a(i, t ? e - ++c : c++, this) !== !1; )
      i += t ? -n : n;
    return c;
  }, r.prototype.__iterator = function(a, t) {
    var e = this.size, n = this._step, i = t ? this._start + (e - 1) * n : this._start, c = 0;
    return new Lt(function() {
      if (c === e)
        return un();
      var s = i;
      return i += t ? -n : n, rr(a, t ? e - ++c : c++, s);
    });
  }, r.prototype.equals = function(a) {
    return a instanceof r ? this._start === a._start && this._end === a._end && this._step === a._step : d8(this, a);
  }, r;
}(Gn), Q4;
function GS(u, r, o) {
  for (var a = rK(r), t = 0; t !== a.length; )
    if (u = US(u, a[t++], Rt), u === Rt)
      return o;
  return u;
}
function vK(u, r) {
  return GS(this, u, r);
}
function f8(u, r) {
  return GS(u, r, Rt) !== Rt;
}
function Lre(u) {
  return f8(this, u);
}
function TK() {
  Sn(this.size);
  var u = {};
  return this.__iterate(function(r, o) {
    u[o] = r;
  }), u;
}
tr.isIterable = Xr;
tr.isKeyed = zt;
tr.isIndexed = Br;
tr.isAssociative = ih;
tr.isOrdered = On;
tr.Iterator = Lt;
r0(tr, {
  // ### Conversion to other types
  toArray: function() {
    Sn(this.size);
    var r = new Array(this.size || 0), o = zt(this), a = 0;
    return this.__iterate(function(t, e) {
      r[a++] = o ? [e, t] : t;
    }), r;
  },
  toIndexedSeq: function() {
    return new kJ(this);
  },
  toJS: function() {
    return AS(this);
  },
  toKeyedSeq: function() {
    return new BS(this, !0);
  },
  toMap: function() {
    return eu(this.toKeyedSeq());
  },
  toObject: TK,
  toOrderedMap: function() {
    return mi(this.toKeyedSeq());
  },
  toOrderedSet: function() {
    return Kf(zt(this) ? this.valueSeq() : this);
  },
  toSet: function() {
    return dh(zt(this) ? this.valueSeq() : this);
  },
  toSetSeq: function() {
    return new XJ(this);
  },
  toSeq: function() {
    return Br(this) ? this.toIndexedSeq() : zt(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function() {
    return hw(zt(this) ? this.valueSeq() : this);
  },
  toList: function() {
    return ch(zt(this) ? this.valueSeq() : this);
  },
  // ### Common JavaScript methods and properties
  toString: function() {
    return "[Collection]";
  },
  __toString: function(r, o) {
    return this.size === 0 ? r + o : r + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + o;
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  concat: function() {
    for (var r = [], o = arguments.length; o--; ) r[o] = arguments[o];
    return Gt(this, gre(this, r));
  },
  includes: function(r) {
    return this.some(function(o) {
      return Er(o, r);
    });
  },
  entries: function() {
    return this.__iterator(Un);
  },
  every: function(r, o) {
    Sn(this.size);
    var a = !0;
    return this.__iterate(function(t, e, n) {
      if (!r.call(o, t, e, n))
        return a = !1, !1;
    }), a;
  },
  filter: function(r, o) {
    return Gt(this, YJ(this, r, o, !0));
  },
  partition: function(r, o) {
    return yre(this, r, o);
  },
  find: function(r, o, a) {
    var t = this.findEntry(r, o);
    return t ? t[1] : a;
  },
  forEach: function(r, o) {
    return Sn(this.size), this.__iterate(o ? r.bind(o) : r);
  },
  join: function(r) {
    Sn(this.size), r = r !== void 0 ? "" + r : ",";
    var o = "", a = !0;
    return this.__iterate(function(t) {
      a ? a = !1 : o += r, o += t != null ? t.toString() : "";
    }), o;
  },
  keys: function() {
    return this.__iterator(uw);
  },
  map: function(r, o) {
    return Gt(this, WJ(this, r, o));
  },
  reduce: function(r, o, a) {
    return _5(
      this,
      r,
      o,
      a,
      arguments.length < 2,
      !1
    );
  },
  reduceRight: function(r, o, a) {
    return _5(
      this,
      r,
      o,
      a,
      arguments.length < 2,
      !0
    );
  },
  reverse: function() {
    return Gt(this, Qx(this, !0));
  },
  slice: function(r, o) {
    return Gt(this, Hx(this, r, o, !0));
  },
  some: function(r, o) {
    Sn(this.size);
    var a = !1;
    return this.__iterate(function(t, e, n) {
      if (r.call(o, t, e, n))
        return a = !0, !1;
    }), a;
  },
  sort: function(r) {
    return Gt(this, H0(this, r));
  },
  values: function() {
    return this.__iterator(gi);
  },
  // ### More sequential methods
  butLast: function() {
    return this.slice(0, -1);
  },
  isEmpty: function() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return !0;
    });
  },
  count: function(r, o) {
    return Q0(
      r ? this.toSeq().filter(r, o) : this
    );
  },
  countBy: function(r, o) {
    return pre(this, r, o);
  },
  equals: function(r) {
    return d8(this, r);
  },
  entrySeq: function() {
    var r = this;
    if (r._cache)
      return new Jf(r._cache);
    var o = r.toSeq().map(Mre).toIndexedSeq();
    return o.fromEntrySeq = function() {
      return r.toSeq();
    }, o;
  },
  filterNot: function(r, o) {
    return this.filter(H4(r), o);
  },
  findEntry: function(r, o, a) {
    var t = a;
    return this.__iterate(function(e, n, i) {
      if (r.call(o, e, n, i))
        return t = [n, e], !1;
    }), t;
  },
  findKey: function(r, o) {
    var a = this.findEntry(r, o);
    return a && a[0];
  },
  findLast: function(r, o, a) {
    return this.toKeyedSeq().reverse().find(r, o, a);
  },
  findLastEntry: function(r, o, a) {
    return this.toKeyedSeq().reverse().findEntry(r, o, a);
  },
  findLastKey: function(r, o) {
    return this.toKeyedSeq().reverse().findKey(r, o);
  },
  first: function(r) {
    return this.find(jJ, null, r);
  },
  flatMap: function(r, o) {
    return Gt(this, mre(this, r, o));
  },
  flatten: function(r) {
    return Gt(this, eK(this, r, !0));
  },
  fromEntrySeq: function() {
    return new JJ(this);
  },
  get: function(r, o) {
    return this.find(function(a, t) {
      return Er(t, r);
    }, void 0, o);
  },
  getIn: vK,
  groupBy: function(r, o) {
    return bre(this, r, o);
  },
  has: function(r) {
    return this.get(r, Rt) !== Rt;
  },
  hasIn: Lre,
  isSubset: function(r) {
    return r = typeof r.includes == "function" ? r : tr(r), this.every(function(o) {
      return r.includes(o);
    });
  },
  isSuperset: function(r) {
    return r = typeof r.isSubset == "function" ? r : tr(r), r.isSubset(this);
  },
  keyOf: function(r) {
    return this.findKey(function(o) {
      return Er(o, r);
    });
  },
  keySeq: function() {
    return this.toSeq().map(jre).toIndexedSeq();
  },
  last: function(r) {
    return this.toSeq().reverse().first(r);
  },
  lastKeyOf: function(r) {
    return this.toKeyedSeq().reverse().keyOf(r);
  },
  max: function(r) {
    return t6(this, r);
  },
  maxBy: function(r, o) {
    return t6(this, o, r);
  },
  min: function(r) {
    return t6(
      this,
      r ? g5(r) : v5
    );
  },
  minBy: function(r, o) {
    return t6(
      this,
      o ? g5(o) : v5,
      r
    );
  },
  rest: function() {
    return this.slice(1);
  },
  skip: function(r) {
    return r === 0 ? this : this.slice(Math.max(0, r));
  },
  skipLast: function(r) {
    return r === 0 ? this : this.slice(0, -Math.max(0, r));
  },
  skipWhile: function(r, o) {
    return Gt(this, ZJ(this, r, o, !0));
  },
  skipUntil: function(r, o) {
    return this.skipWhile(H4(r), o);
  },
  sortBy: function(r, o) {
    return Gt(this, H0(this, o, r));
  },
  take: function(r) {
    return this.slice(0, Math.max(0, r));
  },
  takeLast: function(r) {
    return this.slice(-Math.max(0, r));
  },
  takeWhile: function(r, o) {
    return Gt(this, _re(this, r, o));
  },
  takeUntil: function(r, o) {
    return this.takeWhile(H4(r), o);
  },
  update: function(r) {
    return r(this);
  },
  valueSeq: function() {
    return this.toIndexedSeq();
  },
  // ### Hashable Object
  hashCode: function() {
    return this.__hash || (this.__hash = Cre(this));
  }
  // ### Internal
  // abstract __iterate(fn, reverse)
  // abstract __iterator(type, reverse)
});
var Kr = tr.prototype;
Kr[qJ] = !0;
Kr[jS] = Kr.values;
Kr.toJSON = Kr.toArray;
Kr.__toStringMapper = UT;
Kr.inspect = Kr.toSource = function() {
  return this.toString();
};
Kr.chain = Kr.flatMap;
Kr.contains = Kr.includes;
r0(Hn, {
  // ### More sequential methods
  flip: function() {
    return Gt(this, KJ(this));
  },
  mapEntries: function(r, o) {
    var a = this, t = 0;
    return Gt(
      this,
      this.toSeq().map(function(e, n) {
        return r.call(o, [n, e], t++, a);
      }).fromEntrySeq()
    );
  },
  mapKeys: function(r, o) {
    var a = this;
    return Gt(
      this,
      this.toSeq().flip().map(function(t, e) {
        return r.call(o, t, e, a);
      }).flip()
    );
  }
});
var bw = Hn.prototype;
bw[BJ] = !0;
bw[jS] = Kr.entries;
bw.toJSON = TK;
bw.__toStringMapper = function(u, r) {
  return UT(r) + ": " + UT(u);
};
r0(t0, {
  // ### Conversion to other types
  toKeyedSeq: function() {
    return new BS(this, !1);
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  filter: function(r, o) {
    return Gt(this, YJ(this, r, o, !1));
  },
  findIndex: function(r, o) {
    var a = this.findEntry(r, o);
    return a ? a[0] : -1;
  },
  indexOf: function(r) {
    var o = this.keyOf(r);
    return o === void 0 ? -1 : o;
  },
  lastIndexOf: function(r) {
    var o = this.lastKeyOf(r);
    return o === void 0 ? -1 : o;
  },
  reverse: function() {
    return Gt(this, Qx(this, !1));
  },
  slice: function(r, o) {
    return Gt(this, Hx(this, r, o, !1));
  },
  splice: function(r, o) {
    var a = arguments.length;
    if (o = Math.max(o || 0, 0), a === 0 || a === 2 && !o)
      return this;
    r = nh(r, r < 0 ? this.count() : this.size);
    var t = this.slice(0, r);
    return Gt(
      this,
      a === 1 ? t : t.concat(Ni(arguments, 2), this.slice(r + o))
    );
  },
  // ### More collection methods
  findLastIndex: function(r, o) {
    var a = this.findLastEntry(r, o);
    return a ? a[0] : -1;
  },
  first: function(r) {
    return this.get(0, r);
  },
  flatten: function(r) {
    return Gt(this, eK(this, r, !1));
  },
  get: function(r, o) {
    return r = Xa(this, r), r < 0 || this.size === 1 / 0 || this.size !== void 0 && r > this.size ? o : this.find(function(a, t) {
      return t === r;
    }, void 0, o);
  },
  has: function(r) {
    return r = Xa(this, r), r >= 0 && (this.size !== void 0 ? this.size === 1 / 0 || r < this.size : this.indexOf(r) !== -1);
  },
  interpose: function(r) {
    return Gt(this, vre(this, r));
  },
  interleave: function() {
    var r = [this].concat(Ni(arguments)), o = r6(this.toSeq(), Gn.of, r), a = o.flatten(!0);
    return o.size && (a.size = o.size * r.length), Gt(this, a);
  },
  keySeq: function() {
    return l8(0, this.size);
  },
  last: function(r) {
    return this.get(-1, r);
  },
  skipWhile: function(r, o) {
    return Gt(this, ZJ(this, r, o, !1));
  },
  zip: function() {
    var r = [this].concat(Ni(arguments));
    return Gt(this, r6(this, m5, r));
  },
  zipAll: function() {
    var r = [this].concat(Ni(arguments));
    return Gt(this, r6(this, m5, r, !0));
  },
  zipWith: function(r) {
    var o = Ni(arguments);
    return o[0] = this, Gt(this, r6(this, r, o));
  }
});
var lh = t0.prototype;
lh[$J] = !0;
lh[uh] = !0;
r0(ah, {
  // ### ES6 Collection methods (ES6 Array and Map)
  get: function(r, o) {
    return this.has(r) ? r : o;
  },
  includes: function(r) {
    return this.has(r);
  },
  // ### More sequential methods
  keySeq: function() {
    return this.valueSeq();
  }
});
var X0 = ah.prototype;
X0.has = Kr.includes;
X0.contains = X0.includes;
X0.keys = X0.values;
r0(Ya, bw);
r0(Gn, lh);
r0(sh, X0);
function _5(u, r, o, a, t, e) {
  return Sn(u.size), u.__iterate(function(n, i, c) {
    t ? (t = !1, o = n) : o = r.call(a, o, n, i, c);
  }, e), o;
}
function jre(u, r) {
  return r;
}
function Mre(u, r) {
  return [r, u];
}
function H4(u) {
  return function() {
    return !u.apply(this, arguments);
  };
}
function g5(u) {
  return function() {
    return -u.apply(this, arguments);
  };
}
function m5() {
  return Ni(arguments);
}
function v5(u, r) {
  return u < r ? 1 : u > r ? -1 : 0;
}
function Cre(u) {
  if (u.size === 1 / 0)
    return 0;
  var r = On(u), o = zt(u), a = r ? 1 : 0, t = u.__iterate(
    o ? r ? function(e, n) {
      a = 31 * a + T5(nn(e), nn(n)) | 0;
    } : function(e, n) {
      a = a + T5(nn(e), nn(n)) | 0;
    } : r ? function(e) {
      a = 31 * a + nn(e) | 0;
    } : function(e) {
      a = a + nn(e) | 0;
    }
  );
  return qre(t, a);
}
function qre(u, r) {
  return r = Rh(r, 3432918353), r = Rh(r << 15 | r >>> -15, 461845907), r = Rh(r << 13 | r >>> -13, 5), r = (r + 3864292196 | 0) ^ u, r = Rh(r ^ r >>> 16, 2246822507), r = Rh(r ^ r >>> 13, 3266489909), r = qS(r ^ r >>> 16), r;
}
function T5(u, r) {
  return u ^ r + 2654435769 + (u << 6) + (u >> 2) | 0;
}
var Kf = /* @__PURE__ */ function(u) {
  function r(o) {
    return o == null ? WO() : HS(o) ? o : WO().withMutations(function(a) {
      var t = ah(o);
      Sn(t.size), t.forEach(function(e) {
        return a.add(e);
      });
    });
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.of = function() {
    return this(arguments);
  }, r.fromKeys = function(a) {
    return this(Hn(a).keySeq());
  }, r.prototype.toString = function() {
    return this.__toString("OrderedSet {", "}");
  }, r;
}(dh);
Kf.isOrderedSet = HS;
var n0 = Kf.prototype;
n0[uh] = !0;
n0.zip = lh.zip;
n0.zipWith = lh.zipWith;
n0.zipAll = lh.zipAll;
n0.__empty = WO;
n0.__make = wK;
function wK(u, r) {
  var o = Object.create(n0);
  return o.size = u ? u.size : 0, o._map = u, o.__ownerID = r, o;
}
var w5;
function WO() {
  return w5 || (w5 = wK(fT()));
}
var SK = {
  LeftThenRight: -1,
  RightThenLeft: 1
};
function Bre(u) {
  if (Wa(u))
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  if (In(u))
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  if (u === null || typeof u != "object")
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
}
var vr = function(r, o) {
  var a;
  Bre(r);
  var t = function(i) {
    var c = this;
    if (i instanceof t)
      return i;
    if (!(this instanceof t))
      return new t(i);
    if (!a) {
      a = !0;
      var s = Object.keys(r), d = e._indices = {};
      e._name = o, e._keys = s, e._defaultValues = r;
      for (var l = 0; l < s.length; l++) {
        var f = s[l];
        d[f] = l, e[f] ? typeof console == "object" && console.warn && console.warn(
          "Cannot define " + p8(this) + ' with property "' + f + '" since that property name is part of the Record API.'
        ) : $re(e, f);
      }
    }
    return this.__ownerID = void 0, this._values = ch().withMutations(function(h) {
      h.setSize(c._keys.length), Hn(i).forEach(function(p, b) {
        h.set(c._indices[b], p === c._defaultValues[b] ? void 0 : p);
      });
    }), this;
  }, e = t.prototype = Object.create(Xt);
  return e.constructor = t, o && (t.displayName = o), t;
};
vr.prototype.toString = function() {
  for (var r = p8(this) + " { ", o = this._keys, a, t = 0, e = o.length; t !== e; t++)
    a = o[t], r += (t ? ", " : "") + a + ": " + UT(this.get(a));
  return r + " }";
};
vr.prototype.equals = function(r) {
  return this === r || Wa(r) && J0(this).equals(J0(r));
};
vr.prototype.hashCode = function() {
  return J0(this).hashCode();
};
vr.prototype.has = function(r) {
  return this._indices.hasOwnProperty(r);
};
vr.prototype.get = function(r, o) {
  if (!this.has(r))
    return o;
  var a = this._indices[r], t = this._values.get(a);
  return t === void 0 ? this._defaultValues[r] : t;
};
vr.prototype.set = function(r, o) {
  if (this.has(r)) {
    var a = this._values.set(
      this._indices[r],
      o === this._defaultValues[r] ? void 0 : o
    );
    if (a !== this._values && !this.__ownerID)
      return h8(this, a);
  }
  return this;
};
vr.prototype.remove = function(r) {
  return this.set(r);
};
vr.prototype.clear = function() {
  var r = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : h8(this, r);
};
vr.prototype.wasAltered = function() {
  return this._values.wasAltered();
};
vr.prototype.toSeq = function() {
  return J0(this);
};
vr.prototype.toJS = function() {
  return AS(this);
};
vr.prototype.entries = function() {
  return this.__iterator(Un);
};
vr.prototype.__iterator = function(r, o) {
  return J0(this).__iterator(r, o);
};
vr.prototype.__iterate = function(r, o) {
  return J0(this).__iterate(r, o);
};
vr.prototype.__ensureOwner = function(r) {
  if (r === this.__ownerID)
    return this;
  var o = this._values.__ensureOwner(r);
  return r ? h8(this, o, r) : (this.__ownerID = r, this._values = o, this);
};
vr.isRecord = Wa;
vr.getDescriptiveName = p8;
var Xt = vr.prototype;
Xt[VJ] = !0;
Xt[rw] = Xt.remove;
Xt.deleteIn = Xt.removeIn = e8;
Xt.getIn = vK;
Xt.hasIn = Kr.hasIn;
Xt.merge = iK;
Xt.mergeWith = aK;
Xt.mergeIn = n8;
Xt.mergeDeep = lK;
Xt.mergeDeepWith = fK;
Xt.mergeDeepIn = i8;
Xt.setIn = Yx;
Xt.update = t8;
Xt.updateIn = r8;
Xt.withMutations = dw;
Xt.asMutable = lw;
Xt.asImmutable = fw;
Xt[jS] = Xt.entries;
Xt.toJSON = Xt.toObject = Kr.toObject;
Xt.inspect = Xt.toSource = function() {
  return this.toString();
};
function h8(u, r, o) {
  var a = Object.create(Object.getPrototypeOf(u));
  return a._values = r, a.__ownerID = o, a;
}
function p8(u) {
  return u.constructor.displayName || u.constructor.name || "Record";
}
function J0(u) {
  return Ux(u._keys.map(function(r) {
    return [r, u.get(r)];
  }));
}
function $re(u, r) {
  try {
    Object.defineProperty(u, r, {
      get: function() {
        return this.get(r);
      },
      set: function(o) {
        kx(this.__ownerID, "Cannot set on an immutable record."), this.set(r, o);
      }
    });
  } catch {
  }
}
var AK = /* @__PURE__ */ function(u) {
  function r(o, a) {
    if (!(this instanceof r))
      return new r(o, a);
    if (this._value = o, this.size = a === void 0 ? 1 / 0 : Math.max(0, a), this.size === 0) {
      if (G4)
        return G4;
      G4 = this;
    }
  }
  return u && (r.__proto__ = u), r.prototype = Object.create(u && u.prototype), r.prototype.constructor = r, r.prototype.toString = function() {
    return this.size === 0 ? "Repeat []" : "Repeat [ " + this._value + " " + this.size + " times ]";
  }, r.prototype.get = function(a, t) {
    return this.has(a) ? this._value : t;
  }, r.prototype.includes = function(a) {
    return Er(this._value, a);
  }, r.prototype.slice = function(a, t) {
    var e = this.size;
    return nw(a, t, e) ? this : new r(
      this._value,
      iw(t, e) - nh(a, e)
    );
  }, r.prototype.reverse = function() {
    return this;
  }, r.prototype.indexOf = function(a) {
    return Er(this._value, a) ? 0 : -1;
  }, r.prototype.lastIndexOf = function(a) {
    return Er(this._value, a) ? this.size : -1;
  }, r.prototype.__iterate = function(a, t) {
    for (var e = this.size, n = 0; n !== e && a(this._value, t ? e - ++n : n++, this) !== !1; )
      ;
    return n;
  }, r.prototype.__iterator = function(a, t) {
    var e = this, n = this.size, i = 0;
    return new Lt(
      function() {
        return i === n ? un() : rr(a, t ? n - ++i : i++, e._value);
      }
    );
  }, r.prototype.equals = function(a) {
    return a instanceof r ? Er(this._value, a._value) : d8(this, a);
  }, r;
}(Gn), G4;
function EK(u, r) {
  return OK(
    [],
    r || Ure,
    u,
    "",
    r && r.length > 2 ? [] : void 0,
    { "": u }
  );
}
function OK(u, r, o, a, t, e) {
  if (typeof o != "string" && !In(o) && (qx(o) || Cx(o) || $S(o))) {
    if (~u.indexOf(o))
      throw new TypeError("Cannot convert circular structure to Immutable");
    u.push(o), t && a !== "" && t.push(a);
    var n = r.call(
      e,
      a,
      Jr(o).map(
        function(i, c) {
          return OK(u, r, i, c, t, o);
        }
      ),
      t && t.slice()
    );
    return u.pop(), t && t.pop(), n;
  }
  return o;
}
function Ure(u, r) {
  return Br(r) ? r.toList() : zt(r) ? r.toMap() : r.toSet();
}
var xK = "4.3.7", Vre = {
  version: xK,
  Collection: tr,
  // Note: Iterable is deprecated
  Iterable: tr,
  Seq: Jr,
  Map: eu,
  OrderedMap: mi,
  List: ch,
  Stack: hw,
  Set: dh,
  OrderedSet: Kf,
  PairSorting: SK,
  Record: vr,
  Range: l8,
  Repeat: AK,
  is: Er,
  fromJS: EK,
  hash: nn,
  isImmutable: In,
  isCollection: Xr,
  isKeyed: zt,
  isIndexed: Br,
  isAssociative: ih,
  isOrdered: On,
  isValueObject: wS,
  isPlainObject: $S,
  isSeq: aw,
  isList: QS,
  isMap: ow,
  isOrderedMap: CS,
  isStack: zT,
  isSet: pw,
  isOrderedSet: HS,
  isRecord: Wa,
  get: US,
  getIn: GS,
  has: Xx,
  hasIn: f8,
  merge: oK,
  mergeDeep: cK,
  mergeWith: sK,
  mergeDeepWith: dK,
  remove: Jx,
  removeIn: Zx,
  set: Kx,
  setIn: Wx,
  update: VS,
  updateIn: Za
}, Qre = tr;
const Hre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Collection: tr,
  Iterable: Qre,
  List: ch,
  Map: eu,
  OrderedMap: mi,
  OrderedSet: Kf,
  PairSorting: SK,
  Range: l8,
  Record: vr,
  Repeat: AK,
  Seq: Jr,
  Set: dh,
  Stack: hw,
  default: Vre,
  fromJS: EK,
  get: US,
  getIn: GS,
  has: Xx,
  hasIn: f8,
  hash: nn,
  is: Er,
  isAssociative: ih,
  isCollection: Xr,
  isImmutable: In,
  isIndexed: Br,
  isKeyed: zt,
  isList: QS,
  isMap: ow,
  isOrdered: On,
  isOrderedMap: CS,
  isOrderedSet: HS,
  isPlainObject: $S,
  isRecord: Wa,
  isSeq: aw,
  isSet: pw,
  isStack: zT,
  isValueObject: wS,
  merge: oK,
  mergeDeep: cK,
  mergeDeepWith: dK,
  mergeWith: sK,
  remove: Jx,
  removeIn: Zx,
  set: Kx,
  setIn: Wx,
  update: VS,
  updateIn: Za,
  version: xK
}, Symbol.toStringTag, { value: "Module" })), b8 = /* @__PURE__ */ jx(Hre);
var S5;
function IK() {
  if (S5) return Su;
  S5 = 1, Object.defineProperty(Su, "__esModule", { value: !0 }), Su.ActionContextKey = Su.ActionContext = void 0;
  const u = b8;
  let r = class bT {
    constructor(t = {}) {
      this.map = (0, u.Map)(t);
    }
    /**
     * Will only set the value if the key is not already set.
     */
    setDefault(t, e) {
      return this.has(t) ? this : this.set(t, e);
    }
    set(t, e) {
      return this.setRaw(t.name, e);
    }
    setRaw(t, e) {
      return new bT(this.map.set(t, e));
    }
    delete(t) {
      return new bT(this.map.delete(t.name));
    }
    get(t) {
      return this.getRaw(t.name);
    }
    getRaw(t) {
      return this.map.get(t);
    }
    getSafe(t) {
      if (!this.has(t))
        throw new Error(`Context entry ${t.name} is required but not available`);
      return this.get(t);
    }
    has(t) {
      return this.hasRaw(t.name);
    }
    hasRaw(t) {
      return this.map.has(t);
    }
    merge(...t) {
      let e = this;
      for (const n of t)
        for (const i of n.keys())
          e = e.set(i, n.get(i));
      return e;
    }
    keys() {
      return [...this.map.keys()].map((t) => new o(t));
    }
    toJS() {
      return this.map.toJS();
    }
    toString() {
      return `ActionContext(${JSON.stringify(this.map.toJS())})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `ActionContext(${JSON.stringify(this.map.toJS(), null, "  ")})`;
    }
    /**
     * Convert the given object to an action context object if it is not an action context object yet.
     * If it already is an action context object, return the object as-is.
     * @param maybeActionContext An action context or record.
     * @return {ActionContext} An action context object.
     */
    static ensureActionContext(t) {
      return t instanceof bT ? t : new bT((0, u.Map)(t ?? {}));
    }
  };
  Su.ActionContext = r;
  class o {
    constructor(t) {
      this.name = t;
    }
  }
  return Su.ActionContextKey = o, Su;
}
var Fh = {}, A5;
function RK() {
  if (A5) return Fh;
  A5 = 1, Object.defineProperty(Fh, "__esModule", { value: !0 }), Fh.Bus = void 0;
  let u = class {
    /**
     * All enumerable properties from the `args` object are inherited to this bus.
     *
     * @param {IBusArgs} args Arguments object
     * @param {string} args.name The name for the bus
     * @throws When required arguments are missing.
     */
    constructor(o) {
      this.actors = [], this.observers = [], this.dependencyLinks = /* @__PURE__ */ new Map(), Object.assign(this, o), this.failMessage = `All actors over bus ${this.name} failed to handle an action`;
    }
    /**
     * Subscribe the given actor to the bus.
     * After this, the given actor can be unsubscribed from the bus by calling {@link Bus#unsubscribe}.
     *
     * An actor that is subscribed multiple times will exist that amount of times in the bus.
     *
     * @param {A} actor The actor to subscribe.
     */
    subscribe(o) {
      this.actors.push(o), this.reorderForDependencies();
    }
    /**
     * Subscribe the given observer to the bus.
     * After this, the given observer can be unsubscribed from the bus by calling {@link Bus#unsubscribeObserver}.
     *
     * An observer that is subscribed multiple times will exist that amount of times in the bus.
     *
     * @param {ActionObserver<I, O>} observer The observer to subscribe.
     */
    subscribeObserver(o) {
      this.observers.push(o);
    }
    /**
     * Unsubscribe the given actor from the bus.
     *
     * An actor that is subscribed multiple times will be unsubscribed only once.
     *
     * @param {A} actor The actor to unsubscribe
     * @return {boolean} If the given actor was successfully unsubscribed,
     *         otherwise it was not subscribed before.
     */
    unsubscribe(o) {
      const a = this.actors.indexOf(o);
      return a >= 0 ? (this.actors.splice(a, 1), !0) : !1;
    }
    /**
     * Unsubscribe the given observer from the bus.
     *
     * An observer that is subscribed multiple times will be unsubscribed only once.
     *
     * @param {ActionObserver<I, O>} observer The observer to unsubscribe.
     * @return {boolean} If the given observer was successfully unsubscribed,
     *         otherwise it was not subscribed before.
     */
    unsubscribeObserver(o) {
      const a = this.observers.indexOf(o);
      return a >= 0 ? (this.observers.splice(a, 1), !0) : !1;
    }
    /**
     * Publish an action to all actors in the bus to test if they can run the action.
     *
     * @param {I} action An action to publish
     * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,
     *         O extends IActorOutput>[]}
     *         An array of reply objects. Each object contains a reference to the actor,
     *         and a promise to its {@link Actor#test} result.
     */
    publish(o) {
      return this.actors.map((a) => ({ actor: a, reply: a.test(o) }));
    }
    /**
     * Invoked when an action was run by an actor.
     *
     * @param actor               The action on which the {@link Actor#run} method was invoked.
     * @param {I}          action The original action input.
     * @param {Promise<O>} output A promise resolving to the final action output.
     */
    onRun(o, a, t) {
      for (const e of this.observers)
        e.onRun(o, a, t);
    }
    /**
     * Indicate that the given actor has the given actor dependencies.
     *
     * This will ensure that the given actor will be present in the bus *before* the given dependencies.
     *
     * @param {A} dependent A dependent actor that will be placed before the given actors.
     * @param {A[]} dependencies Actor dependencies that will be placed after the given actor.
     */
    addDependencies(o, a) {
      for (const t of a) {
        let e = this.dependencyLinks.get(t);
        e || (e = [], this.dependencyLinks.set(t, e)), e.push(o);
      }
      this.reorderForDependencies();
    }
    /**
     * Reorder the bus based on all present dependencies.
     */
    reorderForDependencies() {
      if (this.dependencyLinks.size > 0) {
        const o = [];
        for (const a of this.dependencyLinks.keys()) {
          const t = this.actors.indexOf(a);
          t >= 0 && (this.actors.splice(t, 1), o.push(a));
        }
        for (; o.length > 0; ) {
          let a = -1;
          for (let e = 0; e < o.length; e++) {
            let n = !0;
            for (const i of this.dependencyLinks.get(o[e]))
              if (!this.actors.includes(i) && o.includes(i)) {
                n = !1;
                break;
              }
            if (n) {
              a = e;
              break;
            }
          }
          if (a < 0)
            throw new Error(`Cyclic dependency links detected in bus ${this.name}`);
          const t = o.splice(a, 1)[0];
          this.actors.push(t);
        }
      }
    }
  };
  return Fh.Bus = u, Fh;
}
var Nh = {}, E5;
function Gre() {
  if (E5) return Nh;
  E5 = 1, Object.defineProperty(Nh, "__esModule", { value: !0 }), Nh.BusIndexed = void 0;
  const u = /* @__PURE__ */ RK();
  let r = class extends u.Bus {
    /**
     * All enumerable properties from the `args` object are inherited to this bus.
     *
     * @param {IBusIndexedArgs} args Arguments object
     * @param {string} args.name The name for the bus
     * @throws When required arguments are missing.
     */
    constructor(a) {
      super(a), this.actorsIndex = {};
    }
    subscribe(a) {
      const t = this.getActorIdentifiers(a) ?? ["_undefined_"];
      for (const e of t) {
        let n = this.actorsIndex[e];
        n || (n = this.actorsIndex[e] = []), n.push(a), super.subscribe(a);
      }
    }
    unsubscribe(a) {
      const t = this.getActorIdentifiers(a) ?? ["_undefined_"];
      let e = !1;
      for (const n of t) {
        const i = this.actorsIndex[n];
        if (i) {
          const c = i.indexOf(a);
          c >= 0 && i.splice(c, 1), i.length === 0 && delete this.actorsIndex[n];
        }
        e = e || super.unsubscribe(a);
      }
      return e;
    }
    publish(a) {
      const t = this.getActionIdentifier(a);
      return t ? [...this.actorsIndex[t] || [], ...this.actorsIndex._undefined_ || []].map((n) => ({ actor: n, reply: n.test(a) })) : super.publish(a);
    }
    getActorIdentifiers(a) {
      const t = this.actorIdentifierFields.reduce((e, n) => e[n], a);
      if (t)
        return Array.isArray(t) ? t : [t];
    }
    getActionIdentifier(a) {
      return this.actionIdentifierFields.reduce((t, e) => t[e], a);
    }
  };
  return Nh.BusIndexed = r, Nh;
}
var Ph = {}, O5;
function FK() {
  if (O5) return Ph;
  O5 = 1, Object.defineProperty(Ph, "__esModule", { value: !0 }), Ph.CONTEXT_KEY_LOGGER = void 0;
  const u = /* @__PURE__ */ IK();
  return Ph.CONTEXT_KEY_LOGGER = new u.ActionContextKey("@comunica/core:log"), Ph;
}
var Dh = {}, x5;
function zre() {
  if (x5) return Dh;
  x5 = 1, Object.defineProperty(Dh, "__esModule", { value: !0 }), Dh.ActionObserver = void 0;
  let u = class {
    /**
     * All enumerable properties from the `args` object are inherited to this observer.
     *
     * The observer will NOT automatically subscribe to the given bus when this constructor is called.
     *
     * @param {IActionObserverArgs<I extends IAction, O extends IActorOutput>} args Arguments object
     * @throws When required arguments are missing.
     */
    constructor(o) {
      Object.assign(this, o);
    }
  };
  return Dh.ActionObserver = u, Dh;
}
var Lh = {}, I5;
function kre() {
  if (I5) return Lh;
  I5 = 1, Object.defineProperty(Lh, "__esModule", { value: !0 }), Lh.Actor = void 0;
  const u = /* @__PURE__ */ FK();
  let r = class Cf {
    /**
     * All enumerable properties from the `args` object are inherited to this actor.
     *
     * The actor will subscribe to the given bus when this constructor is called.
     *
     * @param {IActorArgs<I extends IAction, T extends IActorTest, O extends IActorOutput>} args Arguments object
     * @param {string} args.name The name for this actor.
     * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus
     *        The bus this actor subscribes to.
     * @throws When required arguments are missing.
     */
    constructor(a) {
      this.beforeActors = [], Object.assign(this, a), this.bus.subscribe(this), this.beforeActors.length > 0 && this.bus.addDependencies(this, this.beforeActors), a.busFailMessage && (this.bus.failMessage = a.busFailMessage);
    }
    /**
     * Get the logger from the given context.
     * @param {ActionContext} context An optional context.
     * @return {Logger} The logger or undefined.
     */
    static getContextLogger(a) {
      return a.get(u.CONTEXT_KEY_LOGGER);
    }
    /**
     * Run the given action on this actor
     * AND invokes the {@link Bus#onRun} method.
     *
     * @param {I} action The action to run.
     * @return {Promise<T>} A promise that resolves to the run result.
     */
    runObservable(a, t) {
      const e = this.run(a, t);
      return this.bus.onRun(this, a, e), e;
    }
    /* Proxy methods for the (optional) logger that is defined in the context */
    getDefaultLogData(a, t) {
      const e = t ? t() : {};
      return e.actor = this.name, e;
    }
    logTrace(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.trace(t, this.getDefaultLogData(a, e));
    }
    logDebug(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.debug(t, this.getDefaultLogData(a, e));
    }
    logInfo(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.info(t, this.getDefaultLogData(a, e));
    }
    logWarn(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.warn(t, this.getDefaultLogData(a, e));
    }
    logError(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.error(t, this.getDefaultLogData(a, e));
    }
    logFatal(a, t, e) {
      const n = Cf.getContextLogger(a);
      n && n.fatal(t, this.getDefaultLogData(a, e));
    }
  };
  return Lh.Actor = r, Lh;
}
var jh = {}, R5;
function Xre() {
  if (R5) return jh;
  R5 = 1, Object.defineProperty(jh, "__esModule", { value: !0 }), jh.Mediator = void 0;
  let u = class YO {
    /**
     * All enumerable properties from the `args` object are inherited to this mediator.
     *
     * @param {IMediatorArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,
     * O extends IActorOutput>} args Arguments object
     * @param {string} args.name The name for this mediator.
     * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus
     *        The bus this mediator will mediate over.
     * @throws When required arguments are missing.
     */
    constructor(o) {
      Object.assign(this, o);
    }
    /**
     * Publish the given action in the bus.
     *
     * This will send the test action on all actors in the bus.
     * All actor replies will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>[]}
     * The list of actor replies.
     */
    publish(o) {
      const a = this.bus.publish(o);
      if (a.length === 0)
        throw new Error(`No actors are able to reply to a message in the bus ${this.bus.name}`);
      return a;
    }
    /**
     * Mediate for the given action to get an actor.
     *
     * This will send the test action on all actors in the bus.
     * The actor that tests _best_ will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {Promise<O extends IActorOutput>} A promise that resolves to the _best_ actor.
     */
    async mediateActor(o) {
      return await this.mediateWith(o, this.publish(o));
    }
    /**
     * Mediate for the given action.
     *
     * This will send the test action on all actors in the bus.
     * The action will be run on the actor that tests _best_,
     * of which the result will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {Promise<O extends IActorOutput>} A promise that resolves to the mediation result.
     */
    async mediateTestable(o) {
      return (await this.mediateActor(o)).mapAsync((t, e) => t.runObservable(o, e));
    }
    /**
     * Mediate for the given action.
     *
     * This will send the test action on all actors in the bus.
     * The action will be run on the actor that tests _best_,
     * of which the result will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {Promise<O extends IActorOutput>} A promise that resolves to the mediation result.
     */
    async mediate(o) {
      return (await this.mediateTestable(o)).getOrThrow();
    }
    /**
     * Construct a human-friendly failure message that accumulates the given actors's failure messages.
     * @param action The action that was executed.
     * @param actorFailures The failure messages that were collected from actor tests based on the given executed action.
     * @protected
     */
    constructFailureMessage(o, a) {
      const t = `
        `;
      return `${this.bus.failMessage.replaceAll(/\$\{(.*?)\}/gu, (n, i) => YO.getObjectValue({ action: o }, i.split(".")) || n)}
    Error messages of failing actors:${t}${a.join(t)}`;
    }
    static getObjectValue(o, a) {
      if (a.length === 0)
        return o;
      if (o)
        return YO.getObjectValue(o[a[0]], a.slice(1));
    }
  };
  return jh.Mediator = u, jh;
}
var jr = {}, F5;
function Jre() {
  if (F5) return jr;
  F5 = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.TestResultFailed = jr.TestResultPassed = jr.failTest = jr.passTestVoidWithSideData = jr.passTestWithSideData = jr.passTestVoid = jr.passTest = void 0;
  function u(i) {
    return new e(i, void 0);
  }
  jr.passTest = u;
  function r() {
    return new e(!0, void 0);
  }
  jr.passTestVoid = r;
  function o(i, c) {
    return new e(i, c);
  }
  jr.passTestWithSideData = o;
  function a(i) {
    return new e(!0, i);
  }
  jr.passTestVoidWithSideData = a;
  function t(i) {
    return new n(i);
  }
  jr.failTest = t;
  class e {
    constructor(c, s) {
      this.value = c, this.sideData = s;
    }
    /**
     * Check if the test has passed.
     * If true, it will contain a value.
     */
    isPassed() {
      return !0;
    }
    /**
     * Check if the test has failed.
     * If true, it will contain a failure message.
     */
    isFailed() {
      return !1;
    }
    /**
     * Get the value of the passed test, or undefined if the test failed.
     */
    get() {
      return this.value;
    }
    /**
     * Get the value of the passed test, or throw an error if the test failed.
     */
    getOrThrow() {
      return this.value;
    }
    /**
     * The side data that will be passed to run.
     */
    getSideData() {
      return this.sideData;
    }
    /**
     * Get the failure message callback of the failed test, or undefined if the test passed.
     */
    getFailMessage() {
    }
    /**
     * For passed tests, map the passed value to another value.
     * Failed tests will remain unchanged.
     *
     * This will not mutate the test result, and instead return a new test result.
     *
     * @param mapper A function that will transform the passed value.
     */
    map(c) {
      return new e(c(this.value, this.sideData), this.sideData);
    }
    /**
     * For passed tests, asynchronously map the passed value to another value.
     * Failed tests will remain unchanged.
     *
     * This will not mutate the test result, and instead return a new test result.
     *
     * @param mapper A function that will transform the passed value.
     */
    async mapAsync(c) {
      return new e(await c(this.value, this.sideData), this.sideData);
    }
  }
  jr.TestResultPassed = e;
  class n {
    constructor(c) {
      this.failMessage = c;
    }
    /**
     * Check if the test has passed.
     * If true, it will contain a value.
     */
    isPassed() {
      return !1;
    }
    /**
     * Check if the test has failed.
     * If true, it will contain a failure message.
     */
    isFailed() {
      return !0;
    }
    /**
     * Get the value of the passed test, or undefined if the test failed.
     */
    get() {
    }
    /**
     * Get the value of the passed test, or throw an error if the test failed.
     */
    getOrThrow() {
      throw new Error(this.getFailMessage());
    }
    /**
     * The side data that will be passed to run.
     */
    getSideData() {
      throw new Error(this.getFailMessage());
    }
    /**
     * Get the failure message callback of the failed test, or undefined if the test passed.
     */
    getFailMessage() {
      return this.failMessage;
    }
    /**
     * For passed tests, map the passed value to another value.
     * Failed tests will remain unchanged.
     *
     * This will not mutate the test result, and instead return a new test result.
     */
    map() {
      return this;
    }
    /**
     * For passed tests, asynchronously map the passed value to another value.
     * Failed tests will remain unchanged.
     *
     * This will not mutate the test result, and instead return a new test result.
     */
    async mapAsync() {
      return this;
    }
  }
  return jr.TestResultFailed = n, jr;
}
var N5;
function _e() {
  return N5 || (N5 = 1, function(u) {
    var r = wu && wu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = wu && wu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ IK(), u), o(/* @__PURE__ */ RK(), u), o(/* @__PURE__ */ Gre(), u), o(/* @__PURE__ */ FK(), u), o(/* @__PURE__ */ zre(), u), o(/* @__PURE__ */ kre(), u), o(/* @__PURE__ */ Xre(), u), o(/* @__PURE__ */ Jre(), u);
  }(wu)), wu;
}
var P5;
function Kre() {
  if (P5) return Ih;
  P5 = 1, Object.defineProperty(Ih, "__esModule", { value: !0 }), Ih.ActorInit = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Initialization failed: none of the configured actors were to initialize} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return Ih.ActorInit = r, Ih;
}
var D5;
function Wre() {
  return D5 || (D5 = 1, function(u) {
    var r = Tu && Tu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Tu && Tu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Kre(), u);
  }(Tu)), Tu;
}
var L5;
function NK() {
  if (L5) return xh;
  L5 = 1, Object.defineProperty(xh, "__esModule", { value: !0 }), xh.ActorInitQueryBase = void 0;
  const u = /* @__PURE__ */ Wre(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorInit {
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      throw new Error("ActorInitSparql#run is not supported in the browser.");
    }
  };
  return xh.ActorInitQueryBase = o, xh;
}
var Mh = {}, z4 = { exports: {} }, j5;
function tu() {
  if (j5) return z4.exports;
  j5 = 1;
  var u = z4.exports = {}, r, o;
  function a() {
    throw new Error("setTimeout has not been defined");
  }
  function t() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? r = setTimeout : r = a;
    } catch {
      r = a;
    }
    try {
      typeof clearTimeout == "function" ? o = clearTimeout : o = t;
    } catch {
      o = t;
    }
  })();
  function e(b) {
    if (r === setTimeout)
      return setTimeout(b, 0);
    if ((r === a || !r) && setTimeout)
      return r = setTimeout, setTimeout(b, 0);
    try {
      return r(b, 0);
    } catch {
      try {
        return r.call(null, b, 0);
      } catch {
        return r.call(this, b, 0);
      }
    }
  }
  function n(b) {
    if (o === clearTimeout)
      return clearTimeout(b);
    if ((o === t || !o) && clearTimeout)
      return o = clearTimeout, clearTimeout(b);
    try {
      return o(b);
    } catch {
      try {
        return o.call(null, b);
      } catch {
        return o.call(this, b);
      }
    }
  }
  var i = [], c = !1, s, d = -1;
  function l() {
    !c || !s || (c = !1, s.length ? i = s.concat(i) : d = -1, i.length && f());
  }
  function f() {
    if (!c) {
      var b = e(l);
      c = !0;
      for (var _ = i.length; _; ) {
        for (s = i, i = []; ++d < _; )
          s && s[d].run();
        d = -1, _ = i.length;
      }
      s = null, c = !1, n(b);
    }
  }
  u.nextTick = function(b) {
    var _ = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var y = 1; y < arguments.length; y++)
        _[y - 1] = arguments[y];
    i.push(new h(b, _)), i.length === 1 && !c && e(f);
  };
  function h(b, _) {
    this.fun = b, this.array = _;
  }
  h.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, u.title = "browser", u.browser = !0, u.env = {}, u.argv = [], u.version = "", u.versions = {};
  function p() {
  }
  return u.on = p, u.addListener = p, u.once = p, u.off = p, u.removeListener = p, u.removeAllListeners = p, u.emit = p, u.prependListener = p, u.prependOnceListener = p, u.listeners = function(b) {
    return [];
  }, u.binding = function(b) {
    throw new Error("process.binding is not supported");
  }, u.cwd = function() {
    return "/";
  }, u.chdir = function(b) {
    throw new Error("process.chdir is not supported");
  }, u.umask = function() {
    return 0;
  }, z4.exports;
}
var M5;
function Yre() {
  if (M5) return Mh;
  M5 = 1, Object.defineProperty(Mh, "__esModule", { value: !0 }), Mh.ActorInitQuery = void 0;
  const u = /* @__PURE__ */ NK();
  typeof process > "u" && (globalThis.process = tu());
  class r extends u.ActorInitQueryBase {
  }
  return Mh.ActorInitQuery = r, Mh;
}
var Ch = {}, Au = {}, Nt = {}, C5;
function PK() {
  if (C5) return Nt;
  C5 = 1, Object.defineProperty(Nt, "__esModule", { value: !0 }), Nt.KeysStatistics = Nt.KeysRdfJoin = Nt.KeysMergeBindingsContext = Nt.KeysRdfUpdateQuads = Nt.KeysQuerySourceIdentify = Nt.KeysRdfParseHtmlScript = Nt.KeysRdfParseJsonLd = Nt.KeysQueryOperation = Nt.KeysExpressionEvaluator = Nt.KeysInitQuery = Nt.KeysHttpProxy = Nt.KeysHttpMemento = Nt.KeysHttpWayback = Nt.KeysHttp = Nt.KeysCore = void 0;
  const u = /* @__PURE__ */ _e();
  return Nt.KeysCore = {
    // We create the core context keys in @comunica/core to avoid a cyclic dependency
    /**
     * A logger instance.
     */
    log: u.CONTEXT_KEY_LOGGER
  }, Nt.KeysHttp = {
    /**
     * Include credentials flags.
     */
    includeCredentials: new u.ActionContextKey("@comunica/bus-http:include-credentials"),
    /**
     * Authentication for a source as a "username:password"-pair.
     */
    auth: new u.ActionContextKey("@comunica/bus-http:auth"),
    /**
     * Fetch function implementation.
     */
    fetch: new u.ActionContextKey("@comunica/bus-http:fetch"),
    /**
     * HTTP request timeout in milliseconds.
     */
    httpTimeout: new u.ActionContextKey("@comunica/bus-http:http-timeout"),
    /**
     * Makes the HTTP timeout not only apply until the response starts streaming in
     * but until the response is fully consumed.
     */
    httpBodyTimeout: new u.ActionContextKey("@comunica/bus-http:http-body-timeout"),
    /**
     * Number of retries to make on failed network calls. This only takes effect
     * on errors thrown during the initial fetch() call and not while streaming the body.
     */
    httpRetryCount: new u.ActionContextKey("@comunica/bus-http:http-retry-count"),
    /**
     * The fallback retry delay in milliseconds. This value is used when a server does not
     * send a delay value in the Retry-After header or if the header value is incorrectly formatted.
     */
    httpRetryDelayFallback: new u.ActionContextKey("@comunica/bus-http:http-retry-delay-fallback"),
    /**
     * The upper limit for the retry delay in milliseconds. When a server requests a delay larger than this,
     * the engine will consider it unavailable until the specified timestamp is close enough.
     */
    httpRetryDelayLimit: new u.ActionContextKey("@comunica/bus-http:http-retry-delay-limit"),
    /**
     * HTTP status codes that should always trigger a retry, regardless of the default behaviour.
     * This can be used to, for example, force retries on server-side errors in the 500 range.
     */
    httpRetryStatusCodes: new u.ActionContextKey("@comunica/bus-http:http-retry-status-codes")
  }, Nt.KeysHttpWayback = {
    /**
     * Use the WayBack machine to get the most recent representation of a file if a link is broken.
     * @default false
     */
    recoverBrokenLinks: new u.ActionContextKey("@comunica/bus-http:recover-broken-links")
  }, Nt.KeysHttpMemento = {
    /**
     * The desired datetime for Memento datetime-negotiation.
     */
    datetime: new u.ActionContextKey("@comunica/actor-http-memento:datetime")
  }, Nt.KeysHttpProxy = {
    /**
     * Interface.
     */
    httpProxyHandler: new u.ActionContextKey("@comunica/actor-http-proxy:httpProxyHandler")
  }, Nt.KeysInitQuery = {
    /**
     * The unidentified sources to query over.
     */
    querySourcesUnidentified: new u.ActionContextKey("@comunica/actor-init-query:querySourcesUnidentified"),
    /**
     * Variables that have to be pre-bound to values in the query.
     */
    initialBindings: new u.ActionContextKey("@comunica/actor-init-query:initialBindings"),
    /**
     * The provided query's format.
     * Defaults to { language: 'sparql', version: '1.1' }
     */
    queryFormat: new u.ActionContextKey("@comunica/actor-init-query:queryFormat"),
    /**
     * Which GraphQL bindings should be singularized.
     */
    graphqlSingularizeVariables: new u.ActionContextKey("@comunica/actor-init-query:singularizeVariables"),
    /**
     * If HTTP and parsing failures are ignored.
     */
    lenient: new u.ActionContextKey("@comunica/actor-init-query:lenient"),
    /**
     * The original query string.
     */
    queryString: new u.ActionContextKey("@comunica/actor-init-query:queryString"),
    /**
     * The original parsed query.
     */
    query: new u.ActionContextKey("@comunica/actor-init-query:query"),
    /**
     * The query's base IRI.
     */
    baseIRI: new u.ActionContextKey("@comunica/actor-init-query:baseIRI"),
    /**
     * Object to cache function argument overload resolutions.
     * Defaults to an object that is reused across query executions.
     */
    functionArgumentsCache: new u.ActionContextKey("@comunica/actor-init-query:functionArgumentsCache"),
    /**
     * A timestamp representing the current time.
     * This is required for certain SPARQL operations such as NOW().
     */
    queryTimestamp: new u.ActionContextKey("@comunica/actor-init-query:queryTimestamp"),
    /**
     * A high resolution timestamp representing the time elapsed since Performance.timeOrigin`.
     * It can be used to precisely measure durations from the start of query execution.
     */
    queryTimestampHighResolution: new u.ActionContextKey("@comunica/actor-init-query:queryTimestampHighResolution"),
    /**
     * @range {functionNamedNode: RDF.NamedNode) => ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined}
     * Extension function creator for a given function IRI.
     * Returned value should be an async function implementation.
     * Undefined may be returned if no implementation exists for the given function IRI.
     *
     * The dictionary-based extensionFunctions context entry may be used instead, but not simultaneously.
     */
    extensionFunctionCreator: new u.ActionContextKey("@comunica/actor-init-query:extensionFunctionCreator"),
    /**
     * Dictionary of extension functions.
     * Key is the IRI of the function, and value is the async function implementation.
     *
     * The callback-based extensionFunctionCreator context entry may be used instead, but not simultaneously.
     */
    extensionFunctions: new u.ActionContextKey("@comunica/actor-init-query:extensionFunctions"),
    /**
     * Enables manipulation of the CLI arguments and their processing.
     */
    cliArgsHandlers: new u.ActionContextKey("@comunica/actor-init-query:cliArgsHandlers"),
    /**
     * Explain mode of the query. Can be 'parsed', 'logical', 'physical', or 'physical-json'.
     */
    explain: new u.ActionContextKey("@comunica/actor-init-query:explain"),
    /**
     * Logs the used physical operators
     */
    physicalQueryPlanLogger: new u.ActionContextKey("@comunica/actor-init-query:physicalQueryPlanLogger"),
    /**
     * The current physical operator within the query plan.
     *              This is used to pass parent-child relationships for invoking the query plan logger.
     */
    physicalQueryPlanNode: new u.ActionContextKey("@comunica/actor-init-query:physicalQueryPlanNode"),
    /**
     * A JSON-LD context
     */
    jsonLdContext: new u.ActionContextKey("@context"),
    /**
     * A boolean value denoting whether caching is disabled or not.
     */
    invalidateCache: new u.ActionContextKey("@comunica/actor-init-query:invalidateCache"),
    /**
     * The data factory for creating terms and quads.
     */
    dataFactory: new u.ActionContextKey("@comunica/actor-init-query:dataFactory"),
    /**
     * A boolean value denoting whether results should be deduplicated or not.
     */
    distinctConstruct: new u.ActionContextKey("@comunica/actor-init-query:distinctConstruct")
  }, Nt.KeysExpressionEvaluator = {
    extensionFunctionCreator: new u.ActionContextKey("@comunica/utils-expression-evaluator:extensionFunctionCreator"),
    superTypeProvider: new u.ActionContextKey("@comunica/utils-expression-evaluator:superTypeProvider"),
    defaultTimeZone: new u.ActionContextKey("@comunica/utils-expression-evaluator:defaultTimeZone"),
    actionContext: new u.ActionContextKey("@comunica/utils-expression-evaluator:actionContext")
  }, Nt.KeysQueryOperation = {
    /**
     * Context entry for the current query operation.
     */
    operation: new u.ActionContextKey("@comunica/bus-query-operation:operation"),
    /**
     * @type {any} The metadata from the left streams within a join operation.
     */
    joinLeftMetadata: new u.ActionContextKey("@comunica/bus-query-operation:joinLeftMetadata"),
    /**
     * An array of metadata from the right streams within a join operation.
     */
    joinRightMetadatas: new u.ActionContextKey("@comunica/bus-query-operation:joinRightMetadatas"),
    /**
     * Indicates the bindings that were used to bind the operation.
     */
    joinBindings: new u.ActionContextKey("@comunica/bus-query-operation:joinBindings"),
    /**
     * Flag for indicating that only read operations are allowed, defaults to false.
     */
    readOnly: new u.ActionContextKey("@comunica/bus-query-operation:readOnly"),
    /**
     * An internal context entry to mark that a property path with arbitrary length and a distinct key is being processed.
     */
    isPathArbitraryLengthDistinctKey: new u.ActionContextKey("@comunica/bus-query-operation:isPathArbitraryLengthDistinct"),
    /**
     * An indicator that the stream will be limited to the given number of elements afterwards.
     */
    limitIndicator: new u.ActionContextKey("@comunica/bus-query-operation:limitIndicator"),
    /**
     * If the default graph should also contain the union of all named graphs.
     */
    unionDefaultGraph: new u.ActionContextKey("@comunica/bus-query-operation:unionDefaultGraph"),
    /**
     * The sources to query over.
     */
    querySources: new u.ActionContextKey("@comunica/bus-query-operation:querySources")
  }, Nt.KeysRdfParseJsonLd = {
    /**
     * @range {IDocumentLoader}
     */
    documentLoader: new u.ActionContextKey("@comunica/actor-rdf-parse-jsonld:documentLoader"),
    /**
     * @range {boolean}
     */
    strictValues: new u.ActionContextKey("@comunica/actor-rdf-parse-jsonld:strictValues"),
    /**
     * @range {Record<string, any>}
     */
    parserOptions: new u.ActionContextKey("@comunica/actor-rdf-parse-jsonld:parserOptions")
  }, Nt.KeysRdfParseHtmlScript = {
    /**
     * An internal context flag to determine if the engine is already processing an HTML script tag.
     */
    processingHtmlScript: new u.ActionContextKey("@comunica/actor-rdf-parse-html-script:processingHtmlScript"),
    /**
     * If all HTML script tags must be considered.
     */
    extractAllScripts: new u.ActionContextKey("extractAllScripts")
  }, Nt.KeysQuerySourceIdentify = {
    /**
     * A map containing unique IDs for each source
     */
    sourceIds: new u.ActionContextKey("@comunica/bus-query-source-identify:sourceIds"),
    /**
     * Hypermedia sources mapping to their aggregated store.
     */
    hypermediaSourcesAggregatedStores: new u.ActionContextKey("@comunica/bus-query-source-identify:hypermediaSourcesAggregatedStores"),
    /**
     * If links may be traversed from this source.
     * This means that sources annotated with this flag are considered incomplete until all links have been traversed.
     */
    traverse: new u.ActionContextKey("@comunica/bus-query-source-identify:traverse")
  }, Nt.KeysRdfUpdateQuads = {
    /**
     * A data destination.
     */
    destination: new u.ActionContextKey("@comunica/bus-rdf-update-quads:destination")
  }, Nt.KeysMergeBindingsContext = {
    /**
     * The data sources required to produce the binding
     */
    sourcesBinding: new u.ActionContextKey("@comunica/bus-merge-bindings-context:sourcesBinding")
  }, Nt.KeysRdfJoin = {
    /**
     * The last physical join actor that was executed.
     */
    lastPhysicalJoin: new u.ActionContextKey("@comunica/bus-rdf-join:lastPhysicalJoin")
  }, Nt.KeysStatistics = {
    /**
     * All discovered links during query execution. Not all of them will necessarily be dereferenced.
     */
    discoveredLinks: new u.ActionContextKey("@comunica/statistic:discoveredLinks"),
    /**
     * Information about what links are dereferenced and when
     */
    dereferencedLinks: new u.ActionContextKey("@comunica/statistic:dereferencedLinks"),
    /**
     * Intermediate results produced during query execution
     */
    intermediateResults: new u.ActionContextKey("@comunica/statistic:intermediateResults")
  }, Nt;
}
var q5;
function Be() {
  return q5 || (q5 = 1, function(u) {
    var r = Au && Au.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Au && Au.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ PK(), u);
  }(Au)), Au;
}
var B5;
function Zre() {
  if (B5) return Ch;
  B5 = 1, Object.defineProperty(Ch, "__esModule", { value: !0 }), Ch.QueryEngineBase = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e();
  let o = class ZO {
    constructor(t) {
      this.actorInitQuery = t;
    }
    async queryBindings(t, e) {
      return this.queryOfType(t, e, "bindings");
    }
    async queryQuads(t, e) {
      return this.queryOfType(t, e, "quads");
    }
    async queryBoolean(t, e) {
      return this.queryOfType(t, e, "boolean");
    }
    async queryVoid(t, e) {
      return this.queryOfType(t, e, "void");
    }
    async queryOfType(t, e, n) {
      const i = await this.query(t, e);
      if (i.resultType === n)
        return await i.execute();
      throw new Error(`Query result type '${n}' was expected, while '${i.resultType}' was found.`);
    }
    /**
     * Evaluate the given query
     * @param query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType>} A promise that resolves to the query output.
     */
    async query(t, e) {
      const n = await this.queryOrExplain(t, e);
      if ("explain" in n)
        throw new Error("Tried to explain a query when in query-only mode");
      return n;
    }
    /**
     * Explain the given query
     * @param query A query string or algebra.
     * @param context An optional query context.
     * @param explainMode The explain mode.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async explain(t, e, n) {
      return e.explain = n, await this.queryOrExplain(t, e);
    }
    /**
     * Evaluate or explain the given query
     * @param query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async queryOrExplain(t, e) {
      const n = r.ActionContext.ensureActionContext(e);
      n.get(u.KeysInitQuery.invalidateCache) && await this.invalidateHttpCache();
      const { result: i } = await this.actorInitQuery.mediatorQueryProcess.mediate({ query: t, context: n });
      return "explain" in i ? i : ZO.internalToFinalResult(i);
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.
     */
    async getResultMediaTypes(t) {
      return t = r.ActionContext.ensureActionContext(t), (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeCombiner.mediate({ context: t, mediaTypes: !0 })).mediaTypes;
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL result media type formats.
     */
    async getResultMediaTypeFormats(t) {
      return t = r.ActionContext.ensureActionContext(t), (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeFormatCombiner.mediate({ context: t, mediaTypeFormats: !0 })).mediaTypeFormats;
    }
    /**
     * Convert a query result to a string stream based on a certain media type.
     * @param {IQueryOperationResult} queryResult A query result.
     * @param {string} mediaType A media type.
     * @param {ActionContext} context An optional context.
     * @return {Promise<IActorQueryResultSerializeOutput>} A text stream.
     */
    async resultToString(t, e, n) {
      if (n = r.ActionContext.ensureActionContext(n), !e)
        switch (t.resultType) {
          case "bindings":
            e = "application/json";
            break;
          case "quads":
            e = "application/trig";
            break;
          default:
            e = "simple";
            break;
        }
      const i = { ...await ZO.finalToInternalResult(t), context: n };
      return (await this.actorInitQuery.mediatorQueryResultSerialize.mediate({ context: n, handle: i, handleMediaType: e })).handle;
    }
    /**
     * Invalidate all internal caches related to the given page URL.
     * If no page URL is given, then all pages will be invalidated.
     * @param {string} url The page URL to invalidate.
     * @param context An optional ActionContext to pass to the actors.
     * @return {Promise<any>} A promise resolving when the caches have been invalidated.
     */
    invalidateHttpCache(t, e) {
      return e = r.ActionContext.ensureActionContext(e), this.actorInitQuery.mediatorHttpInvalidate.mediate({ url: t, context: e });
    }
    /**
     * Convert an internal query result to a final one.
     * @param internalResult An intermediary query result.
     */
    static internalToFinalResult(t) {
      switch (t.type) {
        case "bindings":
          return {
            resultType: "bindings",
            execute: async () => t.bindingsStream,
            metadata: async () => {
              const e = await t.metadata();
              return e.variables = e.variables.map((n) => n.variable), e;
            },
            context: t.context
          };
        case "quads":
          return {
            resultType: "quads",
            execute: async () => t.quadStream,
            metadata: async () => await t.metadata(),
            context: t.context
          };
        case "boolean":
          return {
            resultType: "boolean",
            execute: async () => t.execute(),
            context: t.context
          };
        case "void":
          return {
            resultType: "void",
            execute: async () => t.execute(),
            context: t.context
          };
      }
    }
    /**
     * Convert a final query result to an internal one.
     * @param finalResult A final query result.
     */
    static async finalToInternalResult(t) {
      switch (t.resultType) {
        case "bindings":
          return {
            type: "bindings",
            bindingsStream: await t.execute(),
            metadata: async () => {
              const e = await t.metadata();
              return e.variables = e.variables.map((n) => ({ variable: n, canBeUndef: !1 })), e;
            }
          };
        case "quads":
          return {
            type: "quads",
            quadStream: await t.execute(),
            metadata: async () => await t.metadata()
          };
        case "boolean":
          return {
            type: "boolean",
            execute: () => t.execute()
          };
        case "void":
          return {
            type: "void",
            execute: () => t.execute()
          };
      }
    }
  };
  return Ch.QueryEngineBase = o, Ch;
}
var $5;
function DK() {
  return $5 || ($5 = 1, function(u) {
    var r = vu && vu.__createBinding || (Object.create ? function(t, e, n, i) {
      i === void 0 && (i = n);
      var c = Object.getOwnPropertyDescriptor(e, n);
      (!c || ("get" in c ? !e.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return e[n];
      } }), Object.defineProperty(t, i, c);
    } : function(t, e, n, i) {
      i === void 0 && (i = n), t[i] = e[n];
    }), o = vu && vu.__exportStar || function(t, e) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(e, n) && r(e, t, n);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.QueryEngineBase = void 0, o(/* @__PURE__ */ NK(), u), o(/* @__PURE__ */ Yre(), u);
    var a = /* @__PURE__ */ Zre();
    Object.defineProperty(u, "QueryEngineBase", { enumerable: !0, get: function() {
      return a.QueryEngineBase;
    } });
  }(vu)), vu;
}
var Eu = {}, qh = {}, Ou = {}, k4 = {}, U5;
function ene() {
  return U5 || (U5 = 1, Object.defineProperty(k4, "__esModule", { value: !0 })), k4;
}
var X4 = {}, V5;
function tne() {
  return V5 || (V5 = 1, Object.defineProperty(X4, "__esModule", { value: !0 })), X4;
}
var J4 = {}, Q5;
function rne() {
  return Q5 || (Q5 = 1, Object.defineProperty(J4, "__esModule", { value: !0 })), J4;
}
var K4 = {}, H5;
function nne() {
  return H5 || (H5 = 1, Object.defineProperty(K4, "__esModule", { value: !0 })), K4;
}
var W4 = {}, G5;
function ine() {
  return G5 || (G5 = 1, Object.defineProperty(W4, "__esModule", { value: !0 })), W4;
}
var Y4 = {}, z5;
function ane() {
  return z5 || (z5 = 1, Object.defineProperty(Y4, "__esModule", { value: !0 })), Y4;
}
var Z4 = {}, k5;
function une() {
  return k5 || (k5 = 1, Object.defineProperty(Z4, "__esModule", { value: !0 })), Z4;
}
var eA = {}, X5;
function one() {
  return X5 || (X5 = 1, Object.defineProperty(eA, "__esModule", { value: !0 })), eA;
}
var tA = {}, J5;
function sne() {
  return J5 || (J5 = 1, Object.defineProperty(tA, "__esModule", { value: !0 })), tA;
}
var rA = {}, K5;
function cne() {
  return K5 || (K5 = 1, Object.defineProperty(rA, "__esModule", { value: !0 })), rA;
}
var nA = {}, W5;
function dne() {
  return W5 || (W5 = 1, Object.defineProperty(nA, "__esModule", { value: !0 })), nA;
}
var iA = {}, Y5;
function lne() {
  return Y5 || (Y5 = 1, Object.defineProperty(iA, "__esModule", { value: !0 })), iA;
}
var aA = {}, Z5;
function fne() {
  return Z5 || (Z5 = 1, Object.defineProperty(aA, "__esModule", { value: !0 })), aA;
}
var uA = {}, eR;
function hne() {
  return eR || (eR = 1, Object.defineProperty(uA, "__esModule", { value: !0 })), uA;
}
var oA = {}, tR;
function pne() {
  return tR || (tR = 1, Object.defineProperty(oA, "__esModule", { value: !0 })), oA;
}
var sA = {}, rR;
function bne() {
  return rR || (rR = 1, Object.defineProperty(sA, "__esModule", { value: !0 })), sA;
}
var cA = {}, nR;
function yne() {
  return nR || (nR = 1, Object.defineProperty(cA, "__esModule", { value: !0 })), cA;
}
var dA = {}, iR;
function _ne() {
  return iR || (iR = 1, Object.defineProperty(dA, "__esModule", { value: !0 })), dA;
}
var lA = {}, aR;
function gne() {
  return aR || (aR = 1, Object.defineProperty(lA, "__esModule", { value: !0 })), lA;
}
var Bh = {}, uR;
function mne() {
  if (uR) return Bh;
  uR = 1, Object.defineProperty(Bh, "__esModule", { value: !0 }), Bh.Logger = void 0;
  let u = class LK {
    /**
     * Convert a string-based logging level to a numerical logging level.
     * @param level A string-based logging level
     * @return The numerical logging level, or undefined.
     */
    static getLevelOrdinal(o) {
      return LK.LEVELS[o];
    }
  };
  return Bh.Logger = u, u.LEVELS = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5
  }, Bh;
}
var $h = {}, oR;
function vne() {
  if (oR) return $h;
  oR = 1, Object.defineProperty($h, "__esModule", { value: !0 }), $h.ExpressionType = void 0;
  var u;
  return function(r) {
    r.Aggregate = "aggregate", r.Existence = "existence", r.Operator = "operator", r.Term = "term", r.Variable = "variable";
  }(u || ($h.ExpressionType = u = {})), $h;
}
var sR;
function ru() {
  return sR || (sR = 1, function(u) {
    var r = Ou && Ou.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ou && Ou.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ene(), u), o(/* @__PURE__ */ tne(), u), o(/* @__PURE__ */ rne(), u), o(/* @__PURE__ */ nne(), u), o(/* @__PURE__ */ ine(), u), o(/* @__PURE__ */ ane(), u), o(/* @__PURE__ */ une(), u), o(/* @__PURE__ */ one(), u), o(/* @__PURE__ */ sne(), u), o(/* @__PURE__ */ cne(), u), o(/* @__PURE__ */ dne(), u), o(/* @__PURE__ */ lne(), u), o(/* @__PURE__ */ fne(), u), o(/* @__PURE__ */ hne(), u), o(/* @__PURE__ */ pne(), u), o(/* @__PURE__ */ bne(), u), o(/* @__PURE__ */ yne(), u), o(/* @__PURE__ */ _ne(), u), o(/* @__PURE__ */ gne(), u), o(/* @__PURE__ */ mne(), u), o(/* @__PURE__ */ vne(), u);
  }(Ou)), Ou;
}
var cR;
function Tne() {
  if (cR) return qh;
  cR = 1, Object.defineProperty(qh, "__esModule", { value: !0 }), qh.LoggerVoid = void 0;
  const u = /* @__PURE__ */ ru();
  let r = class extends u.Logger {
    debug() {
    }
    error() {
    }
    fatal() {
    }
    info() {
    }
    trace() {
    }
    warn() {
    }
  };
  return qh.LoggerVoid = r, qh;
}
var dR;
function wne() {
  return dR || (dR = 1, function(u) {
    var r = Eu && Eu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Eu && Eu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Tne(), u);
  }(Eu)), Eu;
}
var xu = {}, Iu = {}, lR;
function jK() {
  if (lR) return Iu;
  lR = 1, Object.defineProperty(Iu, "__esModule", { value: !0 }), Iu.MediatorFunctionFactory = Iu.ActorFunctionFactory = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     * \ @defaultNested {<default_bus> a <cbff:components/BusFunctionFactory.jsonld#BusFunctionFactory>} bus
     * \ @defaultNested {Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(t) {
      super(t);
    }
  };
  Iu.ActorFunctionFactory = r;
  class o extends u.Mediator {
  }
  return Iu.MediatorFunctionFactory = o, Iu;
}
var Uh = {}, fR;
function Sne() {
  if (fR) return Uh;
  fR = 1, Object.defineProperty(Uh, "__esModule", { value: !0 }), Uh.ActorFunctionFactoryDedicated = void 0;
  const u = /* @__PURE__ */ _e(), r = /* @__PURE__ */ jK();
  let o = class extends r.ActorFunctionFactory {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return this.functionNames.includes(t.functionName) && (this.termFunction || !t.requireTermExpression) ? (0, u.passTestVoid)() : (0, u.failTest)(`Actor ${this.name} can not provide implementation for "${t.functionName}", only for ${this.termFunction ? "" : "non-termExpression "}${this.functionNames.join(" and ")}.`);
    }
  };
  return Uh.ActorFunctionFactoryDedicated = o, Uh;
}
var Vh = {}, hR;
function Ane() {
  if (hR) return Vh;
  hR = 1, Object.defineProperty(Vh, "__esModule", { value: !0 }), Vh.BusFunctionFactory = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.BusIndexed {
    constructor(a) {
      super({
        ...a,
        actorIdentifierFields: ["functionNames"],
        actionIdentifierFields: ["functionName"]
      });
    }
  };
  return Vh.BusFunctionFactory = r, Vh;
}
var Ru = {}, fA = {}, Qh = {}, hA = {}, Mr = {}, Fu = {}, Hh = {}, pR;
function MK() {
  if (pR) return Hh;
  pR = 1, Object.defineProperty(Hh, "__esModule", { value: !0 }), Hh.BlankNode = void 0;
  class u {
    constructor(o) {
      this.termType = "BlankNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  }
  return Hh.BlankNode = u, Hh;
}
var Gh = {}, zh = {}, bR;
function CK() {
  if (bR) return zh;
  bR = 1, Object.defineProperty(zh, "__esModule", { value: !0 }), zh.DefaultGraph = void 0;
  class u {
    constructor() {
      this.termType = "DefaultGraph", this.value = "";
    }
    equals(o) {
      return !!o && o.termType === "DefaultGraph";
    }
  }
  return zh.DefaultGraph = u, u.INSTANCE = new u(), zh;
}
var kh = {}, Xh = {}, yR;
function y8() {
  if (yR) return Xh;
  yR = 1, Object.defineProperty(Xh, "__esModule", { value: !0 }), Xh.NamedNode = void 0;
  class u {
    constructor(o) {
      this.termType = "NamedNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "NamedNode" && o.value === this.value;
    }
  }
  return Xh.NamedNode = u, Xh;
}
var _R;
function qK() {
  if (_R) return kh;
  _R = 1, Object.defineProperty(kh, "__esModule", { value: !0 }), kh.Literal = void 0;
  const u = y8();
  class r {
    constructor(a, t) {
      this.termType = "Literal", this.value = a, typeof t == "string" ? (this.language = t, this.datatype = r.RDF_LANGUAGE_STRING) : t ? (this.language = "", this.datatype = t) : (this.language = "", this.datatype = r.XSD_STRING);
    }
    equals(a) {
      return !!a && a.termType === "Literal" && a.value === this.value && a.language === this.language && this.datatype.equals(a.datatype);
    }
  }
  return kh.Literal = r, r.RDF_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), r.XSD_STRING = new u.NamedNode("http://www.w3.org/2001/XMLSchema#string"), kh;
}
var Jh = {}, gR;
function BK() {
  if (gR) return Jh;
  gR = 1, Object.defineProperty(Jh, "__esModule", { value: !0 }), Jh.Quad = void 0;
  class u {
    constructor(o, a, t, e) {
      this.termType = "Quad", this.value = "", this.subject = o, this.predicate = a, this.object = t, this.graph = e;
    }
    equals(o) {
      return !!o && (o.termType === "Quad" || !o.termType) && this.subject.equals(o.subject) && this.predicate.equals(o.predicate) && this.object.equals(o.object) && this.graph.equals(o.graph);
    }
  }
  return Jh.Quad = u, Jh;
}
var Kh = {}, mR;
function $K() {
  if (mR) return Kh;
  mR = 1, Object.defineProperty(Kh, "__esModule", { value: !0 }), Kh.Variable = void 0;
  class u {
    constructor(o) {
      this.termType = "Variable", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "Variable" && o.value === this.value;
    }
  }
  return Kh.Variable = u, Kh;
}
var vR;
function Ene() {
  if (vR) return Gh;
  vR = 1, Object.defineProperty(Gh, "__esModule", { value: !0 }), Gh.DataFactory = void 0;
  const u = MK(), r = CK(), o = qK(), a = y8(), t = BK(), e = $K();
  let n = 0;
  class i {
    constructor(s) {
      this.blankNodeCounter = 0, s = s || {}, this.blankNodePrefix = s.blankNodePrefix || `df_${n++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(s) {
      return new a.NamedNode(s);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(s) {
      return new u.BlankNode(s || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(s, d) {
      return new o.Literal(s, d);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(s) {
      return new e.Variable(s);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
      return r.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(s, d, l, f) {
      return new t.Quad(s, d, l, f || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(s) {
      switch (s.termType) {
        case "NamedNode":
          return this.namedNode(s.value);
        case "BlankNode":
          return this.blankNode(s.value);
        case "Literal":
          return s.language ? this.literal(s.value, s.language) : s.datatype.equals(o.Literal.XSD_STRING) ? this.literal(s.value) : this.literal(s.value, this.fromTerm(s.datatype));
        case "Variable":
          return this.variable(s.value);
        case "DefaultGraph":
          return this.defaultGraph();
        case "Quad":
          return this.quad(this.fromTerm(s.subject), this.fromTerm(s.predicate), this.fromTerm(s.object), this.fromTerm(s.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(s) {
      return this.fromTerm(s);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  }
  return Gh.DataFactory = i, Gh;
}
var TR;
function Or() {
  return TR || (TR = 1, function(u) {
    var r = Fu && Fu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Fu && Fu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(MK(), u), o(Ene(), u), o(CK(), u), o(qK(), u), o(y8(), u), o(BK(), u), o($K(), u);
  }(Fu)), Fu;
}
var wR;
function One() {
  if (wR) return Mr;
  wR = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.stringQuadToQuad = Mr.quadToStringQuad = Mr.stringToTerm = Mr.getLiteralLanguage = Mr.getLiteralType = Mr.getLiteralValue = Mr.termToString = void 0;
  const u = Or(), r = new u.DataFactory();
  function o(s) {
    if (s)
      switch (s.termType) {
        case "NamedNode":
          return s.value;
        case "BlankNode":
          return "_:" + s.value;
        case "Literal":
          const d = s;
          return '"' + d.value + '"' + (d.datatype && d.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" && d.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? "^^" + d.datatype.value : "") + (d.language ? "@" + d.language : "");
        case "Quad":
          return `<<${o(s.subject)} ${o(s.predicate)} ${o(s.object)}${s.graph.termType === "DefaultGraph" ? "" : " " + o(s.graph)}>>`;
        case "Variable":
          return "?" + s.value;
        case "DefaultGraph":
          return s.value;
      }
  }
  Mr.termToString = o;
  function a(s) {
    const d = /^"([^]*)"/.exec(s);
    if (!d)
      throw new Error(s + " is not a literal");
    return d[1];
  }
  Mr.getLiteralValue = a;
  function t(s) {
    const d = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(s);
    if (!d)
      throw new Error(s + " is not a literal");
    return d[1] || (d[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string");
  }
  Mr.getLiteralType = t;
  function e(s) {
    const d = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(s);
    if (!d)
      throw new Error(s + " is not a literal");
    return d[1] ? d[1].toLowerCase() : "";
  }
  Mr.getLiteralLanguage = e;
  function n(s, d) {
    if (d = d || r, !s || !s.length)
      return d.defaultGraph();
    switch (s[0]) {
      case "_":
        return d.blankNode(s.substr(2));
      case "?":
        if (!d.variable)
          throw new Error("Missing 'variable()' method on the given DataFactory");
        return d.variable(s.substr(1));
      case '"':
        const l = e(s), f = d.namedNode(t(s));
        return d.literal(a(s), l || f);
      case "<":
      default:
        if (s[0] === "<" && s.length > 4 && s[1] === "<" && s[s.length - 1] === ">" && s[s.length - 2] === ">") {
          const h = s.slice(2, -2).trim();
          let p = [], b = 0, _ = 0, y = !1;
          for (let m = 0; m < h.length; m++) {
            const g = h[m];
            if (g === "<" && b++, g === ">") {
              if (b === 0)
                throw new Error("Found closing tag without opening tag in " + s);
              b--;
            }
            if (g === '"') {
              let T = !1, v = m;
              for (; v-- > 0 && h[v] === "\\"; )
                T = !T;
              T || (y = !y);
            }
            if (g === " " && !y && b === 0) {
              for (p.push(h.slice(_, m)); h[m + 1] === " "; )
                m += 1;
              _ = m + 1;
            }
          }
          if (b !== 0)
            throw new Error("Found opening tag without closing tag in " + s);
          if (p.push(h.slice(_, h.length)), p.length !== 3 && p.length !== 4)
            throw new Error("Nested quad syntax error " + s);
          return p = p.map((m) => m.startsWith("<") && !m.includes(" ") ? m.slice(1, -1) : m), d.quad(n(p[0]), n(p[1]), n(p[2]), p[3] ? n(p[3]) : void 0);
        }
        return d.namedNode(s);
    }
  }
  Mr.stringToTerm = n;
  function i(s) {
    return {
      subject: o(s.subject),
      predicate: o(s.predicate),
      object: o(s.object),
      graph: o(s.graph)
    };
  }
  Mr.quadToStringQuad = i;
  function c(s, d) {
    return d = d || r, d.quad(n(s.subject, d), n(s.predicate, d), n(s.object, d), n(s.graph, d));
  }
  return Mr.stringQuadToQuad = c, Mr;
}
var SR;
function lr() {
  return SR || (SR = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.termToString = u.stringToTerm = u.stringQuadToQuad = u.quadToStringQuad = u.getLiteralValue = u.getLiteralType = u.getLiteralLanguage = void 0;
    const r = One();
    Object.defineProperty(u, "getLiteralLanguage", { enumerable: !0, get: function() {
      return r.getLiteralLanguage;
    } }), Object.defineProperty(u, "getLiteralType", { enumerable: !0, get: function() {
      return r.getLiteralType;
    } }), Object.defineProperty(u, "getLiteralValue", { enumerable: !0, get: function() {
      return r.getLiteralValue;
    } }), Object.defineProperty(u, "quadToStringQuad", { enumerable: !0, get: function() {
      return r.quadToStringQuad;
    } }), Object.defineProperty(u, "stringQuadToQuad", { enumerable: !0, get: function() {
      return r.stringQuadToQuad;
    } }), Object.defineProperty(u, "stringToTerm", { enumerable: !0, get: function() {
      return r.stringToTerm;
    } }), Object.defineProperty(u, "termToString", { enumerable: !0, get: function() {
      return r.termToString;
    } });
  }(hA)), hA;
}
var Jn = {}, Nn = {}, pA, AR;
function xne() {
  return AR || (AR = 1, pA = function u(r, o) {
    if (r === o) return !0;
    if (r && o && typeof r == "object" && typeof o == "object") {
      if (r.constructor !== o.constructor) return !1;
      var a, t, e;
      if (Array.isArray(r)) {
        if (a = r.length, a != o.length) return !1;
        for (t = a; t-- !== 0; )
          if (!u(r[t], o[t])) return !1;
        return !0;
      }
      if (r instanceof Map && o instanceof Map) {
        if (r.size !== o.size) return !1;
        for (t of r.entries())
          if (!o.has(t[0])) return !1;
        for (t of r.entries())
          if (!u(t[1], o.get(t[0]))) return !1;
        return !0;
      }
      if (r instanceof Set && o instanceof Set) {
        if (r.size !== o.size) return !1;
        for (t of r.entries())
          if (!o.has(t[0])) return !1;
        return !0;
      }
      if (ArrayBuffer.isView(r) && ArrayBuffer.isView(o)) {
        if (a = r.length, a != o.length) return !1;
        for (t = a; t-- !== 0; )
          if (r[t] !== o[t]) return !1;
        return !0;
      }
      if (r.constructor === RegExp) return r.source === o.source && r.flags === o.flags;
      if (r.valueOf !== Object.prototype.valueOf) return r.valueOf() === o.valueOf();
      if (r.toString !== Object.prototype.toString) return r.toString() === o.toString();
      if (e = Object.keys(r), a = e.length, a !== Object.keys(o).length) return !1;
      for (t = a; t-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(o, e[t])) return !1;
      for (t = a; t-- !== 0; ) {
        var n = e[t];
        if (!u(r[n], o[n])) return !1;
      }
      return !0;
    }
    return r !== r && o !== o;
  }), pA;
}
var bA = {}, ER;
function yw() {
  return ER || (ER = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.expressionTypes = u.types = void 0, function(r) {
      r.ALT = "alt", r.ASK = "ask", r.BGP = "bgp", r.CONSTRUCT = "construct", r.DESCRIBE = "describe", r.DISTINCT = "distinct", r.EXPRESSION = "expression", r.EXTEND = "extend", r.FILTER = "filter", r.FROM = "from", r.GRAPH = "graph", r.GROUP = "group", r.INV = "inv", r.JOIN = "join", r.LEFT_JOIN = "leftjoin", r.LINK = "link", r.MINUS = "minus", r.NOP = "nop", r.NPS = "nps", r.ONE_OR_MORE_PATH = "OneOrMorePath", r.ORDER_BY = "orderby", r.PATH = "path", r.PATTERN = "pattern", r.PROJECT = "project", r.REDUCED = "reduced", r.SEQ = "seq", r.SERVICE = "service", r.SLICE = "slice", r.UNION = "union", r.VALUES = "values", r.ZERO_OR_MORE_PATH = "ZeroOrMorePath", r.ZERO_OR_ONE_PATH = "ZeroOrOnePath", r.COMPOSITE_UPDATE = "compositeupdate", r.DELETE_INSERT = "deleteinsert", r.LOAD = "load", r.CLEAR = "clear", r.CREATE = "create", r.DROP = "drop", r.ADD = "add", r.MOVE = "move", r.COPY = "copy";
    }(u.types || (u.types = {})), function(r) {
      r.AGGREGATE = "aggregate", r.EXISTENCE = "existence", r.NAMED = "named", r.OPERATOR = "operator", r.TERM = "term", r.WILDCARD = "wildcard";
    }(u.expressionTypes || (u.expressionTypes = {}));
  }(bA)), bA;
}
var Ai = {}, yA = {}, OR;
function UK() {
  if (OR) return yA;
  OR = 1;
  let u = class {
    constructor() {
      return r || this;
    }
    equals(a) {
      return a && this.termType === a.termType;
    }
  };
  Object.defineProperty(u.prototype, "value", {
    enumerable: !0,
    value: "*"
  }), Object.defineProperty(u.prototype, "termType", {
    enumerable: !0,
    value: "Wildcard"
  });
  var r = new u();
  return yA.Wildcard = u, yA;
}
var _A, xR;
function Ine() {
  if (xR) return _A;
  xR = 1;
  var u = function() {
    var r = function(Fe, Re, Ce, ke) {
      for (Ce = Ce || {}, ke = Fe.length; ke--; Ce[Fe[ke]] = Re) ;
      return Ce;
    }, o = [6, 12, 13, 15, 16, 24, 32, 36, 41, 45, 100, 110, 113, 115, 116, 123, 126, 131, 197, 224, 229, 308, 329, 330, 331, 332, 333], a = [2, 247], t = [100, 110, 113, 115, 116, 123, 126, 131, 329, 330, 331, 332, 333], e = [2, 409], n = [1, 18], i = [1, 27], c = [13, 16, 45, 197, 224, 229, 308], s = [28, 29, 53], d = [28, 53], l = [1, 42], f = [1, 45], h = [1, 41], p = [1, 44], b = [123, 126], _ = [1, 67], y = [39, 45, 87], m = [13, 16, 45, 197, 224, 308], g = [1, 87], T = [2, 281], v = [1, 86], E = [13, 16, 45, 82, 87, 89, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312], R = [6, 28, 29, 53, 63, 70, 73, 81, 83, 85], L = [6, 13, 16, 28, 29, 53, 63, 70, 73, 81, 83, 85, 87, 308], A = [6, 13, 16, 28, 29, 45, 53, 63, 70, 73, 81, 82, 83, 85, 87, 89, 197, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314], w = [6, 13, 16, 28, 29, 31, 39, 45, 47, 48, 53, 63, 70, 73, 81, 82, 83, 85, 87, 89, 109, 112, 121, 123, 126, 128, 159, 160, 161, 163, 164, 174, 193, 197, 224, 229, 231, 232, 242, 246, 250, 263, 265, 272, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314, 317, 318, 335, 337, 338, 340, 341, 342, 343, 344, 345, 346], S = [13, 16, 308], O = [112, 132, 327, 334], x = [13, 16, 112, 132, 308], F = [1, 111], j = [1, 117], q = [112, 132, 327, 328, 334], Q = [13, 16, 112, 132, 308, 328], G = [28, 29, 45, 53, 87], K = [1, 138], U = [1, 151], ae = [1, 128], ye = [1, 127], pe = [1, 129], ee = [1, 140], Te = [1, 141], we = [1, 142], Oe = [1, 143], be = [1, 144], he = [1, 145], V = [1, 147], N = [1, 148], M = [2, 457], I = [1, 158], P = [1, 159], B = [1, 160], z = [1, 152], H = [1, 153], J = [1, 156], k = [1, 171], W = [1, 172], le = [1, 173], fe = [1, 174], me = [1, 175], Ne = [1, 176], xe = [1, 167], ue = [1, 168], $ = [1, 169], D = [1, 170], C = [1, 157], X = [1, 166], te = [1, 161], de = [1, 162], oe = [1, 163], De = [1, 164], Ve = [1, 165], qe = [6, 13, 16, 29, 31, 45, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335], Ke = [1, 195], Y = [6, 31, 73, 81, 83, 85], Ee = [2, 285], Ie = [1, 199], Ue = [1, 201], Le = [6, 31, 70, 73, 81, 83, 85], tt = [2, 283], it = [1, 207], Ye = [1, 218], ht = [1, 223], ne = [1, 219], ie = [1, 225], je = [1, 226], $e = [1, 224], He = [6, 63, 70, 73, 81, 83, 85], At = [1, 236], Qe = [2, 334], bt = [1, 243], Ge = [1, 241], Je = [6, 193], rt = [2, 349], Et = [2, 339], ot = [28, 128], Xe = [47, 48, 193, 272], Ur = [47, 48, 193, 242, 272], ze = [47, 48, 193, 242, 246, 272], se = [47, 48, 193, 242, 246, 250, 263, 265, 272, 290, 297, 298, 299, 300, 301, 302, 341, 342, 343, 344, 345, 346], ge = [39, 47, 48, 193, 242, 246, 250, 263, 265, 272, 290, 297, 298, 299, 300, 301, 302, 338, 341, 342, 343, 344, 345, 346], Se = [1, 271], Ze = [1, 270], et = [6, 13, 16, 29, 31, 39, 45, 47, 48, 70, 73, 76, 78, 81, 82, 83, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 231, 242, 246, 250, 263, 265, 268, 269, 270, 271, 272, 273, 274, 276, 277, 279, 280, 283, 285, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335, 338, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351], Tt = [1, 281], ar = [1, 280], kt = [13, 16, 29, 31, 39, 45, 47, 48, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 174, 193, 197, 224, 229, 231, 232, 242, 246, 250, 263, 265, 272, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314, 317, 318, 335, 338, 341, 342, 343, 344, 345, 346], Ui = [45, 89], yn = [13, 16, 29, 31, 39, 45, 47, 48, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 174, 193, 197, 224, 229, 231, 232, 242, 246, 250, 263, 265, 272, 290, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314, 317, 318, 335, 338, 341, 342, 343, 344, 345, 346], Kt = [13, 16, 31, 82, 174, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 312], Fn = [31, 89], Fr = [48, 87], Xn = [6, 13, 16, 45, 48, 82, 87, 89, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 337, 338], Nr = [6, 13, 16, 39, 45, 48, 82, 87, 89, 231, 263, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 337, 338, 340], cu = [1, 313], Vr = [6, 85], u0 = [6, 31, 81, 83, 85], du = [2, 361], _n = [2, 353], dn = [1, 343], mh = [31, 112, 335], Vi = [13, 16, 29, 31, 45, 48, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 197, 224, 229, 231, 232, 272, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 317, 318, 335], b4 = [13, 16, 29, 31, 45, 48, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 197, 224, 229, 231, 232, 272, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314, 317, 318, 335], iI = [6, 109, 193], lu = [31, 112], gr = [13, 16, 45, 82, 87, 224, 263, 265, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 312, 346, 347, 348, 349, 350, 351], y4 = [1, 390], _4 = [1, 391], Ea = [13, 16, 87, 197, 308, 314], aI = [13, 16, 39, 45, 82, 87, 224, 263, 265, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 312, 346, 347, 348, 349, 350, 351], Lw = [1, 417], jw = [1, 418], uI = [13, 16, 48, 197, 229, 308], Oa = [6, 31, 85], oI = [6, 13, 16, 31, 45, 73, 81, 83, 85, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 308, 346, 347, 348, 349, 350, 351], g4 = [6, 13, 16, 29, 31, 45, 73, 76, 78, 81, 82, 83, 85, 87, 89, 112, 159, 160, 161, 163, 164, 231, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335, 346, 347, 348, 349, 350, 351], fu = [29, 31, 85, 112, 159, 160, 161, 163, 164], Mw = [1, 443], Cw = [1, 444], sI = [1, 449], hu = [31, 112, 193, 232, 318, 335], qw = [13, 16, 45, 48, 82, 87, 89, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312], cI = [13, 16, 31, 45, 48, 82, 87, 89, 112, 193, 231, 232, 272, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 317, 318, 335], m4 = [13, 16, 29, 31, 45, 48, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 231, 232, 272, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 317, 318, 335], vh = [13, 16, 31, 48, 82, 174, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 312], Th = [31, 45], dI = [1, 507], lI = [1, 508], fI = [6, 13, 16, 29, 31, 39, 45, 47, 48, 63, 70, 73, 76, 78, 81, 82, 83, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 231, 242, 246, 250, 263, 265, 268, 269, 270, 271, 272, 273, 274, 276, 277, 279, 280, 283, 285, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335, 336, 338, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351], Bw = [29, 31, 85, 112, 159, 160, 161, 163, 164, 335], pu = [6, 13, 16, 31, 45, 70, 73, 81, 83, 85, 87, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 308, 346, 347, 348, 349, 350, 351], hI = [13, 16, 31, 45, 48, 82, 87, 89, 112, 193, 197, 231, 232, 272, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 317, 318, 335], pI = [2, 352], v4 = [13, 16, 197, 308, 314], bI = [1, 565], o0 = [6, 13, 16, 31, 45, 76, 78, 81, 83, 85, 87, 268, 269, 270, 271, 273, 274, 276, 277, 279, 280, 283, 285, 308, 346, 347, 348, 349, 350, 351], yI = [13, 16, 29, 31, 45, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312], Qi = [13, 16, 29, 31, 45, 82, 85, 87, 89, 112, 159, 160, 161, 163, 164, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335], _I = [13, 16, 87, 308], Hi = [2, 364], s0 = [29, 31, 85, 112, 159, 160, 161, 163, 164, 193, 232, 318, 335], $w = [31, 112, 193, 232, 272, 318, 335], Gi = [2, 359], gI = [13, 16, 48, 82, 174, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 312], Uw = [29, 31, 85, 112, 159, 160, 161, 163, 164, 193, 232, 272, 318, 335], mI = [13, 16, 31, 45, 82, 87, 89, 112, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312], vI = [2, 347], T4 = {
      trace: function() {
      },
      yy: {},
      symbols_: { error: 2, QueryOrUpdate: 3, Prologue: 4, QueryOrUpdate_group0: 5, EOF: 6, Query: 7, Qry: 8, Query_option0: 9, Prologue_repetition0: 10, BaseDecl: 11, BASE: 12, IRIREF: 13, PrefixDecl: 14, PREFIX: 15, PNAME_NS: 16, SelectClauseWildcard: 17, Qry_repetition0: 18, WhereClause: 19, SolutionModifierNoGroup: 20, SelectClauseVars: 21, Qry_repetition1: 22, SolutionModifier: 23, CONSTRUCT: 24, ConstructTemplate: 25, Qry_repetition2: 26, Qry_repetition3: 27, WHERE: 28, "{": 29, Qry_option0: 30, "}": 31, DESCRIBE: 32, Qry_group0: 33, Qry_repetition4: 34, Qry_option1: 35, ASK: 36, Qry_repetition5: 37, SelectClauseBase: 38, "*": 39, SelectClauseVars_repetition_plus0: 40, SELECT: 41, SelectClauseBase_option0: 42, SelectClauseItem: 43, Var: 44, "(": 45, Expression: 46, AS: 47, ")": 48, SubSelect: 49, SubSelect_option0: 50, SubSelect_option1: 51, DatasetClause: 52, FROM: 53, DatasetClause_option0: 54, iri: 55, WhereClause_option0: 56, GroupGraphPattern: 57, SolutionModifier_option0: 58, SolutionModifierNoGroup_option0: 59, SolutionModifierNoGroup_option1: 60, SolutionModifierNoGroup_option2: 61, GroupClause: 62, GROUP: 63, BY: 64, GroupClause_repetition_plus0: 65, GroupCondition: 66, BuiltInCall: 67, FunctionCall: 68, HavingClause: 69, HAVING: 70, HavingClause_repetition_plus0: 71, OrderClause: 72, ORDER: 73, OrderClause_repetition_plus0: 74, OrderCondition: 75, ASC: 76, BrackettedExpression: 77, DESC: 78, Constraint: 79, LimitOffsetClauses: 80, LIMIT: 81, INTEGER: 82, OFFSET: 83, ValuesClause: 84, VALUES: 85, InlineData: 86, VAR: 87, InlineData_repetition0: 88, NIL: 89, InlineData_repetition1: 90, InlineData_repetition_plus2: 91, InlineData_repetition3: 92, DataBlock: 93, DataBlockValueList: 94, DataBlockValueList_repetition_plus0: 95, Update: 96, Update_repetition0: 97, Update1: 98, Update_option0: 99, LOAD: 100, Update1_option0: 101, Update1_option1: 102, Update1_group0: 103, Update1_option2: 104, GraphRefAll: 105, Update1_group1: 106, Update1_option3: 107, GraphOrDefault: 108, TO: 109, CREATE: 110, Update1_option4: 111, GRAPH: 112, INSERTDATA: 113, QuadPattern: 114, DELETEDATA: 115, DELETEWHERE: 116, Update1_option5: 117, InsertDeleteClause: 118, Update1_repetition0: 119, IntoGraphClause: 120, INTO: 121, GraphRef: 122, DELETE: 123, InsertDeleteClause_option0: 124, InsertClause: 125, INSERT: 126, UsingClause: 127, USING: 128, UsingClause_option0: 129, WithClause: 130, WITH: 131, DEFAULT: 132, GraphOrDefault_option0: 133, GraphRefAll_group0: 134, Quads: 135, Quads_option0: 136, Quads_repetition0: 137, QuadsNotTriples: 138, VarOrIri: 139, QuadsNotTriples_option0: 140, QuadsNotTriples_option1: 141, QuadsNotTriples_option2: 142, TriplesTemplate: 143, TriplesTemplate_repetition0: 144, TriplesSameSubject: 145, TriplesTemplate_option0: 146, GroupGraphPatternSub: 147, GroupGraphPatternSub_option0: 148, GroupGraphPatternSub_repetition0: 149, GroupGraphPatternSubTail: 150, GraphPatternNotTriples: 151, GroupGraphPatternSubTail_option0: 152, GroupGraphPatternSubTail_option1: 153, TriplesBlock: 154, TriplesBlock_repetition0: 155, TriplesSameSubjectPath: 156, TriplesBlock_option0: 157, GroupOrUnionGraphPattern: 158, OPTIONAL: 159, MINUS: 160, SERVICE: 161, GraphPatternNotTriples_option0: 162, FILTER: 163, BIND: 164, InlineDataOneVar: 165, InlineDataFull: 166, InlineDataOneVar_repetition0: 167, InlineDataFull_repetition0: 168, InlineDataFull_repetition_plus1: 169, InlineDataFull_repetition2: 170, DataBlockValue: 171, Literal: 172, QuotedTriple: 173, UNDEF: 174, GroupOrUnionGraphPattern_repetition0: 175, ArgList: 176, ArgList_option0: 177, ArgList_repetition0: 178, ExpressionList: 179, ExpressionList_repetition0: 180, ConstructTemplate_option0: 181, ConstructTriples: 182, ConstructTriples_repetition0: 183, ConstructTriples_option0: 184, VarOrTermOrQuotedTP: 185, PropertyListNotEmpty: 186, TriplesNode: 187, PropertyList: 188, PropertyList_option0: 189, VerbObjectList: 190, PropertyListNotEmpty_repetition0: 191, SemiOptionalVerbObjectList: 192, ";": 193, SemiOptionalVerbObjectList_option0: 194, Verb: 195, ObjectList: 196, a: 197, ObjectList_repetition0: 198, Object: 199, GraphNode: 200, Object_option0: 201, PropertyListPathNotEmpty: 202, TriplesNodePath: 203, TriplesSameSubjectPath_option0: 204, O: 205, PropertyListPathNotEmpty_repetition0: 206, PropertyListPathNotEmptyTail: 207, O_group0: 208, ObjectListPath: 209, ObjectListPath_repetition0: 210, ObjectPath: 211, GraphNodePath: 212, ObjectPath_option0: 213, Path: 214, Path_repetition0: 215, PathSequence: 216, PathSequence_repetition0: 217, PathEltOrInverse: 218, PathElt: 219, PathPrimary: 220, PathElt_option0: 221, PathEltOrInverse_option0: 222, IriOrA: 223, "!": 224, PathNegatedPropertySet: 225, PathOneInPropertySet: 226, PathNegatedPropertySet_repetition0: 227, PathNegatedPropertySet_option0: 228, "^": 229, TriplesNode_repetition_plus0: 230, "[": 231, "]": 232, TriplesNodePath_repetition_plus0: 233, VarOrTermOrQuotedTPExpr: 234, VarOrTerm: 235, GraphTerm: 236, BlankNode: 237, ConditionalOrExpression: 238, ConditionalAndExpression: 239, ConditionalOrExpression_repetition0: 240, ConditionalOrExpressionTail: 241, "||": 242, RelationalExpression: 243, ConditionalAndExpression_repetition0: 244, ConditionalAndExpressionTail: 245, "&&": 246, NumericExpression: 247, RelationalExpression_group0: 248, RelationalExpression_option0: 249, IN: 250, MultiplicativeExpression: 251, NumericExpression_repetition0: 252, AdditiveExpressionTail: 253, AdditiveExpressionTail_group0: 254, NumericLiteralPositive: 255, AdditiveExpressionTail_repetition0: 256, NumericLiteralNegative: 257, AdditiveExpressionTail_repetition1: 258, UnaryExpression: 259, MultiplicativeExpression_repetition0: 260, MultiplicativeExpressionTail: 261, MultiplicativeExpressionTail_group0: 262, "+": 263, PrimaryExpression: 264, "-": 265, ExprQuotedTP: 266, Aggregate: 267, FUNC_ARITY0: 268, FUNC_ARITY1: 269, FUNC_ARITY1_SPARQL_STAR: 270, FUNC_ARITY2: 271, ",": 272, FUNC_ARITY3: 273, FUNC_ARITY3_SPARQL_STAR: 274, BuiltInCall_group0: 275, BOUND: 276, BNODE: 277, BuiltInCall_option0: 278, EXISTS: 279, COUNT: 280, Aggregate_option0: 281, Aggregate_group0: 282, FUNC_AGGREGATE: 283, Aggregate_option1: 284, GROUP_CONCAT: 285, Aggregate_option2: 286, Aggregate_option3: 287, GroupConcatSeparator: 288, SEPARATOR: 289, "=": 290, String: 291, LANGTAG: 292, "^^": 293, DECIMAL: 294, DOUBLE: 295, BOOLEAN: 296, INTEGER_POSITIVE: 297, DECIMAL_POSITIVE: 298, DOUBLE_POSITIVE: 299, INTEGER_NEGATIVE: 300, DECIMAL_NEGATIVE: 301, DOUBLE_NEGATIVE: 302, STRING_LITERAL1: 303, STRING_LITERAL2: 304, STRING_LITERAL_LONG1: 305, STRING_LITERAL_LONG2: 306, PrefixedName: 307, PNAME_LN: 308, BLANK_NODE_LABEL: 309, ANON: 310, QuotedTP: 311, "<<": 312, qtSubjectOrObject: 313, ">>": 314, DataValueTerm: 315, AnnotationPattern: 316, "{|": 317, "|}": 318, AnnotationPatternPath: 319, ExprVarOrTerm: 320, QueryOrUpdate_group0_option0: 321, Prologue_repetition0_group0: 322, Qry_group0_repetition_plus0: 323, SelectClauseBase_option0_group0: 324, DISTINCT: 325, REDUCED: 326, NAMED: 327, SILENT: 328, CLEAR: 329, DROP: 330, ADD: 331, MOVE: 332, COPY: 333, ALL: 334, ".": 335, UNION: 336, "|": 337, "/": 338, PathElt_option0_group0: 339, "?": 340, "!=": 341, "<": 342, ">": 343, "<=": 344, ">=": 345, NOT: 346, CONCAT: 347, COALESCE: 348, SUBSTR: 349, REGEX: 350, REPLACE: 351, $accept: 0, $end: 1 },
      terminals_: { 2: "error", 6: "EOF", 12: "BASE", 13: "IRIREF", 15: "PREFIX", 16: "PNAME_NS", 24: "CONSTRUCT", 28: "WHERE", 29: "{", 31: "}", 32: "DESCRIBE", 36: "ASK", 39: "*", 41: "SELECT", 45: "(", 47: "AS", 48: ")", 53: "FROM", 63: "GROUP", 64: "BY", 70: "HAVING", 73: "ORDER", 76: "ASC", 78: "DESC", 81: "LIMIT", 82: "INTEGER", 83: "OFFSET", 85: "VALUES", 87: "VAR", 89: "NIL", 100: "LOAD", 109: "TO", 110: "CREATE", 112: "GRAPH", 113: "INSERTDATA", 115: "DELETEDATA", 116: "DELETEWHERE", 121: "INTO", 123: "DELETE", 126: "INSERT", 128: "USING", 131: "WITH", 132: "DEFAULT", 159: "OPTIONAL", 160: "MINUS", 161: "SERVICE", 163: "FILTER", 164: "BIND", 174: "UNDEF", 193: ";", 197: "a", 224: "!", 229: "^", 231: "[", 232: "]", 242: "||", 246: "&&", 250: "IN", 263: "+", 265: "-", 268: "FUNC_ARITY0", 269: "FUNC_ARITY1", 270: "FUNC_ARITY1_SPARQL_STAR", 271: "FUNC_ARITY2", 272: ",", 273: "FUNC_ARITY3", 274: "FUNC_ARITY3_SPARQL_STAR", 276: "BOUND", 277: "BNODE", 279: "EXISTS", 280: "COUNT", 283: "FUNC_AGGREGATE", 285: "GROUP_CONCAT", 289: "SEPARATOR", 290: "=", 292: "LANGTAG", 293: "^^", 294: "DECIMAL", 295: "DOUBLE", 296: "BOOLEAN", 297: "INTEGER_POSITIVE", 298: "DECIMAL_POSITIVE", 299: "DOUBLE_POSITIVE", 300: "INTEGER_NEGATIVE", 301: "DECIMAL_NEGATIVE", 302: "DOUBLE_NEGATIVE", 303: "STRING_LITERAL1", 304: "STRING_LITERAL2", 305: "STRING_LITERAL_LONG1", 306: "STRING_LITERAL_LONG2", 308: "PNAME_LN", 309: "BLANK_NODE_LABEL", 310: "ANON", 312: "<<", 314: ">>", 317: "{|", 318: "|}", 325: "DISTINCT", 326: "REDUCED", 327: "NAMED", 328: "SILENT", 329: "CLEAR", 330: "DROP", 331: "ADD", 332: "MOVE", 333: "COPY", 334: "ALL", 335: ".", 336: "UNION", 337: "|", 338: "/", 340: "?", 341: "!=", 342: "<", 343: ">", 344: "<=", 345: ">=", 346: "NOT", 347: "CONCAT", 348: "COALESCE", 349: "SUBSTR", 350: "REGEX", 351: "REPLACE" },
      productions_: [0, [3, 3], [7, 2], [4, 1], [11, 2], [14, 3], [8, 4], [8, 4], [8, 5], [8, 7], [8, 5], [8, 4], [17, 2], [21, 2], [38, 2], [43, 1], [43, 5], [49, 4], [49, 4], [52, 3], [19, 2], [23, 2], [20, 3], [62, 3], [66, 1], [66, 1], [66, 3], [66, 5], [66, 1], [69, 2], [72, 3], [75, 2], [75, 2], [75, 1], [75, 1], [80, 2], [80, 2], [80, 4], [80, 4], [84, 2], [86, 4], [86, 4], [86, 6], [86, 2], [94, 3], [96, 3], [98, 4], [98, 3], [98, 5], [98, 4], [98, 2], [98, 2], [98, 2], [98, 5], [120, 2], [118, 3], [118, 1], [125, 2], [127, 3], [130, 2], [108, 1], [108, 2], [122, 2], [105, 1], [105, 1], [114, 3], [135, 2], [138, 7], [143, 3], [57, 3], [57, 3], [147, 2], [150, 3], [154, 3], [151, 1], [151, 2], [151, 2], [151, 3], [151, 4], [151, 2], [151, 6], [151, 1], [93, 1], [93, 1], [165, 4], [166, 4], [166, 6], [171, 1], [171, 1], [171, 1], [171, 1], [158, 2], [79, 1], [79, 1], [79, 1], [68, 2], [176, 1], [176, 5], [179, 1], [179, 4], [25, 3], [182, 3], [145, 2], [145, 2], [188, 1], [186, 2], [192, 2], [190, 2], [195, 1], [195, 1], [196, 2], [199, 2], [156, 2], [156, 2], [202, 2], [207, 1], [207, 2], [205, 2], [209, 2], [211, 2], [214, 2], [216, 2], [219, 2], [218, 2], [220, 1], [220, 2], [220, 3], [225, 1], [225, 1], [225, 4], [226, 1], [226, 2], [187, 3], [187, 3], [203, 3], [203, 3], [200, 1], [200, 1], [212, 1], [212, 1], [234, 1], [235, 1], [235, 1], [139, 1], [139, 1], [44, 1], [236, 1], [236, 1], [236, 1], [236, 1], [46, 1], [238, 2], [241, 2], [239, 2], [245, 2], [243, 1], [243, 3], [243, 4], [247, 2], [253, 2], [253, 2], [253, 2], [251, 2], [261, 2], [259, 2], [259, 2], [259, 2], [259, 1], [264, 1], [264, 1], [264, 1], [264, 1], [264, 1], [264, 1], [264, 1], [77, 3], [67, 1], [67, 2], [67, 4], [67, 4], [67, 6], [67, 8], [67, 8], [67, 2], [67, 4], [67, 2], [67, 4], [67, 3], [267, 5], [267, 5], [267, 6], [288, 4], [172, 1], [172, 2], [172, 3], [172, 1], [172, 1], [172, 1], [172, 1], [172, 1], [172, 1], [255, 1], [255, 1], [255, 1], [257, 1], [257, 1], [257, 1], [291, 1], [291, 1], [291, 1], [291, 1], [55, 1], [55, 1], [307, 1], [307, 1], [237, 1], [237, 1], [311, 5], [173, 5], [313, 1], [313, 1], [313, 1], [313, 1], [313, 1], [315, 1], [315, 1], [315, 1], [185, 1], [185, 1], [185, 1], [316, 3], [319, 3], [266, 5], [320, 1], [320, 1], [320, 1], [223, 1], [223, 1], [321, 0], [321, 1], [5, 1], [5, 1], [5, 1], [9, 0], [9, 1], [322, 1], [322, 1], [10, 0], [10, 2], [18, 0], [18, 2], [22, 0], [22, 2], [26, 0], [26, 2], [27, 0], [27, 2], [30, 0], [30, 1], [323, 1], [323, 2], [33, 1], [33, 1], [34, 0], [34, 2], [35, 0], [35, 1], [37, 0], [37, 2], [40, 1], [40, 2], [324, 1], [324, 1], [42, 0], [42, 1], [50, 0], [50, 1], [51, 0], [51, 1], [54, 0], [54, 1], [56, 0], [56, 1], [58, 0], [58, 1], [59, 0], [59, 1], [60, 0], [60, 1], [61, 0], [61, 1], [65, 1], [65, 2], [71, 1], [71, 2], [74, 1], [74, 2], [88, 0], [88, 2], [90, 0], [90, 2], [91, 1], [91, 2], [92, 0], [92, 2], [95, 1], [95, 2], [97, 0], [97, 4], [99, 0], [99, 2], [101, 0], [101, 1], [102, 0], [102, 1], [103, 1], [103, 1], [104, 0], [104, 1], [106, 1], [106, 1], [106, 1], [107, 0], [107, 1], [111, 0], [111, 1], [117, 0], [117, 1], [119, 0], [119, 2], [124, 0], [124, 1], [129, 0], [129, 1], [133, 0], [133, 1], [134, 1], [134, 1], [134, 1], [136, 0], [136, 1], [137, 0], [137, 2], [140, 0], [140, 1], [141, 0], [141, 1], [142, 0], [142, 1], [144, 0], [144, 3], [146, 0], [146, 1], [148, 0], [148, 1], [149, 0], [149, 2], [152, 0], [152, 1], [153, 0], [153, 1], [155, 0], [155, 3], [157, 0], [157, 1], [162, 0], [162, 1], [167, 0], [167, 2], [168, 0], [168, 2], [169, 1], [169, 2], [170, 0], [170, 2], [175, 0], [175, 3], [177, 0], [177, 1], [178, 0], [178, 3], [180, 0], [180, 3], [181, 0], [181, 1], [183, 0], [183, 3], [184, 0], [184, 1], [189, 0], [189, 1], [191, 0], [191, 2], [194, 0], [194, 1], [198, 0], [198, 3], [201, 0], [201, 1], [204, 0], [204, 1], [206, 0], [206, 2], [208, 1], [208, 1], [210, 0], [210, 3], [213, 0], [213, 1], [215, 0], [215, 3], [217, 0], [217, 3], [339, 1], [339, 1], [339, 1], [221, 0], [221, 1], [222, 0], [222, 1], [227, 0], [227, 3], [228, 0], [228, 1], [230, 1], [230, 2], [233, 1], [233, 2], [240, 0], [240, 2], [244, 0], [244, 2], [248, 1], [248, 1], [248, 1], [248, 1], [248, 1], [248, 1], [249, 0], [249, 1], [252, 0], [252, 2], [254, 1], [254, 1], [256, 0], [256, 2], [258, 0], [258, 2], [260, 0], [260, 2], [262, 1], [262, 1], [275, 1], [275, 1], [275, 1], [275, 1], [275, 1], [278, 0], [278, 1], [281, 0], [281, 1], [282, 1], [282, 1], [284, 0], [284, 1], [286, 0], [286, 1], [287, 0], [287, 1]],
      performAction: function(Re, Ce, ke, st, lt, Z, gn) {
        var re = Z.length - 1;
        switch (lt) {
          case 1:
            if (Z[re - 1] = Z[re - 1] || {}, Ot.base && (Z[re - 1].base = Ot.base), Ot.base = "", Z[re - 1].prefixes = Ot.prefixes, Ot.prefixes = null, Ot.pathOnly) {
              if (Z[re - 1].type === "path" || "termType" in Z[re - 1])
                return Z[re - 1];
              throw new Error("Received full SPARQL query in path only mode");
            } else if (Z[re - 1].type === "path" || "termType" in Z[re - 1])
              throw new Error("Received only path in full SPARQL mode");
            if (Z[re - 1].type === "update") {
              const wt = {};
              for (const jt of Z[re - 1].updates)
                if (jt.updateType === "insert") {
                  const _t = {};
                  for (const Dr of jt.insert)
                    if (Dr.type === "bgp" || Dr.type === "graph")
                      for (const Lr of Dr.triples)
                        Lr.subject.termType === "BlankNode" && (_t[Lr.subject.value] = !0), Lr.predicate.termType === "BlankNode" && (_t[Lr.predicate.value] = !0), Lr.object.termType === "BlankNode" && (_t[Lr.object.value] = !0);
                  for (const Dr of Object.keys(_t)) {
                    if (wt[Dr])
                      throw new Error("Detected reuse blank node across different INSERT DATA clauses");
                    wt[Dr] = !0;
                  }
                }
            }
            return Z[re - 1];
          case 2:
            this.$ = { ...Z[re - 1], ...Z[re], type: "query" };
            break;
          case 4:
            Ot.base = wh(Z[re]);
            break;
          case 5:
            Ot.prefixes || (Ot.prefixes = {}), Z[re - 1] = Z[re - 1].substr(0, Z[re - 1].length - 1), Z[re] = wh(Z[re]), Ot.prefixes[Z[re - 1]] = Z[re];
            break;
          case 6:
            this.$ = { ...Z[re - 3], ..._u(Z[re - 2]), ...Z[re - 1], ...Z[re] };
            break;
          case 7:
            if (!Ot.skipValidation && (R4(Z[re - 3].variables.map((jt) => I4(jt.expression))).some((jt) => jt.aggregation === "count" && !(jt.expression instanceof Vw)) || Z[re].group)) {
              for (const jt of Z[re - 3].variables)
                if (jt.termType === "Variable") {
                  if (!Z[re].group || !Z[re].group.map((_t) => h0(_t)).includes(h0(jt)))
                    throw Error("Projection of ungrouped variable (?" + h0(jt) + ")");
                } else if (I4(jt.expression).length === 0) {
                  const _t = wee(jt.expression);
                  for (const Dr of _t)
                    if (!Z[re].group || !Z[re].group.map || !Z[re].group.map((Lr) => h0(Lr)).includes(h0(Dr)))
                      throw Error("Use of ungrouped variable in projection of operation (?" + h0(Dr) + ")");
                }
            }
            const p0 = Z[re - 1].where.filter((wt) => wt.type === "query");
            if (p0.length > 0) {
              const wt = Z[re - 3].variables.filter((_t) => _t.variable && _t.variable.value).map((_t) => _t.variable.value), jt = R4(p0.map((_t) => _t.variables)).map((_t) => _t.value || _t.variable.value);
              for (const _t of wt)
                if (jt.indexOf(_t) >= 0)
                  throw Error("Target id of 'AS' (?" + _t + ") already used in subquery");
            }
            this.$ = hr(Z[re - 3], _u(Z[re - 2]), Z[re - 1], Z[re]);
            break;
          case 8:
            this.$ = hr({ queryType: "CONSTRUCT", template: Z[re - 3] }, _u(Z[re - 2]), Z[re - 1], Z[re]);
            break;
          case 9:
            this.$ = hr({ queryType: "CONSTRUCT", template: Z[re - 2] = Z[re - 2] ? Z[re - 2].triples : [] }, _u(Z[re - 5]), { where: [{ type: "bgp", triples: c0([], Z[re - 2]) }] }, Z[re]);
            break;
          case 10:
            this.$ = hr({ queryType: "DESCRIBE", variables: Z[re - 3] === "*" ? [new Vw()] : Z[re - 3] }, _u(Z[re - 2]), Z[re - 1], Z[re]);
            break;
          case 11:
            this.$ = hr({ queryType: "ASK" }, _u(Z[re - 2]), Z[re - 1], Z[re]);
            break;
          case 12:
            this.$ = hr(Z[re - 1], { variables: [new Vw()] });
            break;
          case 13:
            const D4 = Z[re].map((wt) => wt.value || wt.variable.value), Xw = See(D4);
            if (Xw.length > 0)
              throw Error("Two or more of the resulting columns have the same name (?" + Xw[0] + ")");
            this.$ = hr(Z[re - 1], { variables: Z[re] });
            break;
          case 14:
            this.$ = hr({ queryType: "SELECT" }, Z[re] && (Z[re - 1] = Yr(Z[re]), Z[re] = {}, Z[re][Z[re - 1]] = !0, Z[re]));
            break;
          case 16:
          case 27:
            this.$ = d0(Z[re - 3], { variable: Z[re - 1] });
            break;
          case 17:
          case 18:
            this.$ = hr(Z[re - 3], Z[re - 2], Z[re - 1], Z[re], { type: "query" });
            break;
          case 19:
          case 58:
            this.$ = { iri: Z[re], named: !!Z[re - 1] };
            break;
          case 20:
            this.$ = { where: Z[re].patterns };
            break;
          case 21:
            this.$ = hr(Z[re - 1], Z[re]);
            break;
          case 22:
            this.$ = hr(Z[re - 2], Z[re - 1], Z[re]);
            break;
          case 23:
            this.$ = { group: Z[re] };
            break;
          case 24:
          case 25:
          case 28:
          case 31:
          case 33:
          case 34:
            this.$ = d0(Z[re]);
            break;
          case 26:
            this.$ = d0(Z[re - 1]);
            break;
          case 29:
            this.$ = { having: Z[re] };
            break;
          case 30:
            this.$ = { order: Z[re] };
            break;
          case 32:
            this.$ = d0(Z[re], { descending: !0 });
            break;
          case 35:
            this.$ = { limit: f0(Z[re]) };
            break;
          case 36:
            this.$ = { offset: f0(Z[re]) };
            break;
          case 37:
            this.$ = { limit: f0(Z[re - 2]), offset: f0(Z[re]) };
            break;
          case 38:
            this.$ = { limit: f0(Z[re]), offset: f0(Z[re - 2]) };
            break;
          case 39:
          case 43:
            this.$ = { type: "values", values: Z[re] };
            break;
          case 40:
          case 84:
            this.$ = Z[re - 1].map((wt) => ({ [Z[re - 3]]: wt }));
            break;
          case 41:
          case 85:
            this.$ = Z[re - 1].map(() => ({}));
            break;
          case 42:
          case 86:
            var xa = Z[re - 4].length;
            Z[re - 4] = Z[re - 4].map(w4), this.$ = Z[re - 1].map(function(wt) {
              if (wt.length !== xa)
                throw Error("Inconsistent VALUES length");
              for (var jt = {}, _t = 0; _t < xa; _t++)
                jt["?" + Z[re - 4][_t].value] = wt[_t];
              return jt;
            });
            break;
          case 44:
          case 65:
          case 100:
          case 126:
          case 175:
            this.$ = Z[re - 1];
            break;
          case 45:
            this.$ = { type: "update", updates: yu(Z[re - 2], Z[re - 1]) };
            break;
          case 46:
            this.$ = hr({ type: "load", silent: !!Z[re - 2], source: Z[re - 1] }, Z[re] && { destination: Z[re] });
            break;
          case 47:
            this.$ = { type: Yr(Z[re - 2]), silent: !!Z[re - 1], graph: Z[re] };
            break;
          case 48:
            this.$ = { type: Yr(Z[re - 4]), silent: !!Z[re - 3], source: Z[re - 2], destination: Z[re] };
            break;
          case 49:
            this.$ = { type: "create", silent: !!Z[re - 2], graph: { type: "graph", name: Z[re] } };
            break;
          case 50:
            this.$ = { updateType: "insert", insert: NI(Z[re]) };
            break;
          case 51:
            this.$ = { updateType: "delete", delete: P4(NI(Z[re])) };
            break;
          case 52:
            this.$ = { updateType: "deletewhere", delete: P4(Z[re]) };
            break;
          case 53:
            this.$ = { updateType: "insertdelete", ...Z[re - 4], ...Z[re - 3], ..._u(Z[re - 2], "using"), where: Z[re].patterns };
            break;
          case 54:
          case 57:
          case 62:
          case 167:
          case 191:
          case 236:
            this.$ = Z[re];
            break;
          case 55:
            this.$ = { delete: P4(Z[re - 1]), insert: Z[re] || [] };
            break;
          case 56:
            this.$ = { delete: [], insert: Z[re] };
            break;
          case 59:
            this.$ = { graph: Z[re] };
            break;
          case 60:
            this.$ = { type: "graph", default: !0 };
            break;
          case 61:
          case 63:
            this.$ = { type: "graph", name: Z[re] };
            break;
          case 64:
            this.$ = { [Yr(Z[re])]: !0 };
            break;
          case 66:
            this.$ = Z[re - 1] ? Ti(Z[re], [Z[re - 1]]) : Ti(Z[re]);
            break;
          case 67:
            var Gw = hr(Z[re - 3] || { triples: [] }, { type: "graph", name: Z[re - 5] });
            this.$ = Z[re] ? [Gw, Z[re]] : [Gw];
            break;
          case 68:
          case 73:
            this.$ = { type: "bgp", triples: Ti(Z[re - 2], [Z[re - 1]]) };
            break;
          case 69:
            this.$ = { type: "group", patterns: [Z[re - 1]] };
            break;
          case 70:
            for (const wt of Z[re - 1].filter((jt) => jt.type === "bind")) {
              const jt = Z[re - 1].indexOf(wt), _t = /* @__PURE__ */ new Set();
              for (const Dr of Z[re - 1].slice(0, jt))
                (Dr.type === "group" || Dr.type === "bgp") && RI(Dr).forEach((Lr) => _t.add(Lr));
              if (_t.has(wt.variable.value))
                throw Error("Variable used to bind is already bound (?" + wt.variable.value + ")");
            }
            this.$ = { type: "group", patterns: Z[re - 1] };
            break;
          case 71:
            this.$ = Z[re - 1] ? Ti([Z[re - 1]], Z[re]) : Ti(Z[re]);
            break;
          case 72:
            this.$ = Z[re] ? [Z[re - 2], Z[re]] : Z[re - 2];
            break;
          case 75:
            this.$ = hr(Z[re], { type: "optional" });
            break;
          case 76:
            this.$ = hr(Z[re], { type: "minus" });
            break;
          case 77:
            this.$ = hr(Z[re], { type: "graph", name: Z[re - 1] });
            break;
          case 78:
            this.$ = hr(Z[re], { type: "service", name: Z[re - 1], silent: !!Z[re - 2] });
            break;
          case 79:
            this.$ = { type: "filter", expression: Z[re] };
            break;
          case 80:
            this.$ = { type: "bind", variable: Z[re - 1], expression: Z[re - 3] };
            break;
          case 89:
            this.$ = Ah(Z[re]);
            break;
          case 90:
            this.$ = void 0;
            break;
          case 91:
            this.$ = Z[re - 1].length ? { type: "union", patterns: Ti(Z[re - 1].map(A4), [A4(Z[re])]) } : Z[re];
            break;
          case 95:
            this.$ = { ...Z[re], function: Z[re - 1] };
            break;
          case 96:
            this.$ = { type: "functionCall", args: [] };
            break;
          case 97:
            this.$ = { type: "functionCall", args: yu(Z[re - 2], Z[re - 1]), distinct: !!Z[re - 3] };
            break;
          case 98:
          case 115:
          case 128:
          case 247:
          case 249:
          case 251:
          case 253:
          case 255:
          case 263:
          case 267:
          case 297:
          case 299:
          case 303:
          case 307:
          case 328:
          case 341:
          case 349:
          case 355:
          case 361:
          case 367:
          case 369:
          case 373:
          case 375:
          case 379:
          case 381:
          case 385:
          case 391:
          case 395:
          case 401:
          case 405:
          case 409:
          case 411:
          case 420:
          case 428:
          case 430:
          case 440:
          case 444:
          case 446:
          case 448:
            this.$ = [];
            break;
          case 99:
            this.$ = yu(Z[re - 2], Z[re - 1]);
            break;
          case 101:
            this.$ = Ti(Z[re - 2], [Z[re - 1]]);
            break;
          case 102:
          case 112:
            this.$ = N4(Z[re].map((wt) => hr(zi(Z[re - 1]), wt)));
            break;
          case 103:
            this.$ = N4(c0(Z[re].map((wt) => hr(zi(Z[re - 1].entity), wt)), Z[re - 1].triples));
            break;
          case 105:
            this.$ = Ti([Z[re - 1]], Z[re]);
            break;
          case 106:
            this.$ = Ti(Z[re]);
            break;
          case 107:
            this.$ = x4(Z[re - 1], Z[re]);
            break;
          case 109:
          case 237:
            this.$ = Ot.factory.namedNode(fee);
            break;
          case 110:
          case 118:
            this.$ = yu(Z[re - 1], Z[re]);
            break;
          case 111:
            this.$ = Z[re] ? { annotation: Z[re], object: Z[re - 1] } : Z[re - 1];
            break;
          case 113:
            this.$ = Z[re] ? N4(c0(Z[re].map((wt) => hr(zi(Z[re - 1].entity), wt)), Z[re - 1].triples)) : Z[re - 1].triples;
            break;
          case 114:
            this.$ = x4(...Z[re - 1], Z[re]);
            break;
          case 116:
            this.$ = x4(...Z[re]);
            break;
          case 117:
          case 159:
          case 163:
            this.$ = [Z[re - 1], Z[re]];
            break;
          case 119:
            this.$ = Z[re] ? { object: Z[re - 1], annotation: Z[re] } : Z[re - 1];
            break;
          case 120:
            this.$ = Z[re - 1].length ? l0("|", yu(Z[re - 1], Z[re])) : Z[re];
            break;
          case 121:
            this.$ = Z[re - 1].length ? l0("/", yu(Z[re - 1], Z[re])) : Z[re];
            break;
          case 122:
            this.$ = Z[re] ? l0(Z[re], [Z[re - 1]]) : Z[re - 1];
            break;
          case 123:
            this.$ = Z[re - 1] ? l0(Z[re - 1], [Z[re]]) : Z[re];
            break;
          case 125:
          case 131:
            this.$ = l0(Z[re - 1], [Z[re]]);
            break;
          case 129:
            this.$ = l0("|", yu(Z[re - 2], Z[re - 1]));
            break;
          case 132:
          case 134:
            this.$ = vee(Z[re - 1]);
            break;
          case 133:
          case 135:
            this.$ = Tee(Z[re - 1]);
            break;
          case 140:
            this.$ = { entity: Z[re], triples: [] };
            break;
          case 145:
            this.$ = w4(Z[re]);
            break;
          case 149:
            this.$ = Ot.factory.namedNode(TI);
            break;
          case 151:
          case 153:
          case 158:
          case 162:
            this.$ = S4(Z[re - 1], Z[re]);
            break;
          case 152:
            this.$ = ["||", Z[re]];
            break;
          case 154:
            this.$ = ["&&", Z[re]];
            break;
          case 156:
            this.$ = Pr(Z[re - 1], [Z[re - 2], Z[re]]);
            break;
          case 157:
            this.$ = Pr(Z[re - 2] ? "notin" : "in", [Z[re - 3], Z[re]]);
            break;
          case 160:
            this.$ = ["+", S4(Z[re - 1], Z[re])];
            break;
          case 161:
            var zw = wi(Z[re - 1].value.replace("-", ""), Z[re - 1].datatype);
            this.$ = ["-", S4(zw, Z[re])];
            break;
          case 164:
            this.$ = Pr("UPLUS", [Z[re]]);
            break;
          case 165:
            this.$ = Pr(Z[re - 1], [Z[re]]);
            break;
          case 166:
            this.$ = Pr("UMINUS", [Z[re]]);
            break;
          case 177:
            this.$ = Pr(Yr(Z[re - 1]));
            break;
          case 178:
            this.$ = Pr(Yr(Z[re - 3]), [Z[re - 1]]);
            break;
          case 179:
            this.$ = Ah(Pr(Yr(Z[re - 3]), [Z[re - 1]]));
            break;
          case 180:
            this.$ = Pr(Yr(Z[re - 5]), [Z[re - 3], Z[re - 1]]);
            break;
          case 181:
            this.$ = Pr(Yr(Z[re - 7]), [Z[re - 5], Z[re - 3], Z[re - 1]]);
            break;
          case 182:
            this.$ = Ah(Pr(Yr(Z[re - 7]), [Z[re - 5], Z[re - 3], Z[re - 1]]));
            break;
          case 183:
            this.$ = Pr(Yr(Z[re - 1]), Z[re]);
            break;
          case 184:
            this.$ = Pr("bound", [w4(Z[re - 1])]);
            break;
          case 185:
            this.$ = Pr(Z[re - 1], []);
            break;
          case 186:
            this.$ = Pr(Z[re - 3], [Z[re - 1]]);
            break;
          case 187:
            this.$ = Pr(Z[re - 2] ? "notexists" : "exists", [A4(Z[re])]);
            break;
          case 188:
          case 189:
            this.$ = d0(Z[re - 1], { type: "aggregate", aggregation: Yr(Z[re - 4]), distinct: !!Z[re - 2] });
            break;
          case 190:
            this.$ = d0(Z[re - 2], { type: "aggregate", aggregation: Yr(Z[re - 5]), distinct: !!Z[re - 3], separator: typeof Z[re - 1] == "string" ? Z[re - 1] : " " });
            break;
          case 192:
            this.$ = wi(Z[re]);
            break;
          case 193:
            this.$ = yee(Z[re - 1], Yr(Z[re].substr(1)));
            break;
          case 194:
            this.$ = wi(Z[re - 2], Z[re]);
            break;
          case 195:
          case 204:
            this.$ = wi(Z[re], wI);
            break;
          case 196:
          case 205:
            this.$ = wi(Z[re], SI);
            break;
          case 197:
          case 206:
            this.$ = wi(Yr(Z[re]), AI);
            break;
          case 200:
            this.$ = wi(Z[re].toLowerCase(), bee);
            break;
          case 201:
            this.$ = wi(Z[re].substr(1), wI);
            break;
          case 202:
            this.$ = wi(Z[re].substr(1), SI);
            break;
          case 203:
            this.$ = wi(Z[re].substr(1).toLowerCase(), AI);
            break;
          case 207:
          case 208:
            this.$ = II(Z[re], 1);
            break;
          case 209:
          case 210:
            this.$ = II(Z[re], 3);
            break;
          case 211:
            this.$ = Ot.factory.namedNode(wh(Z[re]));
            break;
          case 213:
            var kw = Z[re].indexOf(":"), pr = Z[re].substr(0, kw), Si = Ot.prefixes[pr];
            if (!Si) throw new Error("Unknown prefix: " + pr);
            var gu = wh(Si + Z[re].substr(kw + 1));
            this.$ = Ot.factory.namedNode(gu);
            break;
          case 214:
            if (Z[re] = Z[re].substr(0, Z[re].length - 1), !(Z[re] in Ot.prefixes)) throw new Error("Unknown prefix: " + Z[re]);
            var gu = wh(Ot.prefixes[Z[re]]);
            this.$ = Ot.factory.namedNode(gu);
            break;
          case 215:
            this.$ = Sh(Z[re].replace(/^(_:)/, ""));
            break;
          case 216:
            this.$ = Sh();
            break;
          case 217:
          case 218:
          case 232:
            this.$ = Ah(E4(Z[re - 3], Z[re - 2], Z[re - 1]));
            break;
          case 230:
          case 231:
            this.$ = Ah(Z[re - 1]);
            break;
          case 248:
          case 250:
          case 252:
          case 254:
          case 256:
          case 260:
          case 264:
          case 268:
          case 270:
          case 292:
          case 294:
          case 296:
          case 298:
          case 300:
          case 302:
          case 304:
          case 306:
          case 329:
          case 342:
          case 356:
          case 368:
          case 370:
          case 372:
          case 374:
          case 392:
          case 402:
          case 425:
          case 427:
          case 429:
          case 431:
          case 441:
          case 445:
          case 447:
          case 449:
            Z[re - 1].push(Z[re]);
            break;
          case 259:
          case 269:
          case 291:
          case 293:
          case 295:
          case 301:
          case 305:
          case 371:
          case 424:
          case 426:
            this.$ = [Z[re]];
            break;
          case 308:
            Z[re - 3].push(Z[re - 2]);
            break;
          case 350:
          case 362:
          case 376:
          case 380:
          case 382:
          case 386:
          case 396:
          case 406:
          case 410:
          case 412:
          case 421:
            Z[re - 2].push(Z[re - 1]);
            break;
        }
      },
      table: [r(o, a, { 3: 1, 4: 2, 10: 3 }), { 1: [3] }, r(t, [2, 307], { 5: 4, 7: 5, 321: 6, 214: 7, 8: 8, 96: 9, 215: 10, 17: 11, 21: 12, 97: 16, 38: 17, 6: [2, 238], 13: e, 16: e, 45: e, 197: e, 224: e, 229: e, 308: e, 24: [1, 13], 32: [1, 14], 36: [1, 15], 41: n }), r([6, 13, 16, 24, 32, 36, 41, 45, 100, 110, 113, 115, 116, 123, 126, 131, 197, 224, 229, 308, 329, 330, 331, 332, 333], [2, 3], { 322: 19, 11: 20, 14: 21, 12: [1, 22], 15: [1, 23] }), { 6: [1, 24] }, { 6: [2, 240] }, { 6: [2, 241] }, { 6: [2, 242] }, { 6: [2, 243], 9: 25, 84: 26, 85: i }, { 6: [2, 239] }, r(c, [2, 411], { 216: 28, 217: 29 }), r(s, [2, 249], { 18: 30 }), r(s, [2, 251], { 22: 31 }), r(d, [2, 255], { 25: 32, 27: 33, 29: [1, 34] }), { 13: l, 16: f, 33: 35, 39: [1, 37], 44: 39, 55: 40, 87: h, 139: 38, 307: 43, 308: p, 323: 36 }, r(s, [2, 267], { 37: 46 }), r(b, [2, 326], { 98: 47, 103: 49, 106: 50, 117: 55, 130: 61, 100: [1, 48], 110: [1, 51], 113: [1, 52], 115: [1, 53], 116: [1, 54], 131: [1, 62], 329: [1, 56], 330: [1, 57], 331: [1, 58], 332: [1, 59], 333: [1, 60] }), { 39: [1, 63], 40: 64, 43: 65, 44: 66, 45: _, 87: h }, r(y, [2, 273], { 42: 68, 324: 69, 325: [1, 70], 326: [1, 71] }), r(o, [2, 248]), r(o, [2, 245]), r(o, [2, 246]), { 13: [1, 72] }, { 16: [1, 73] }, { 1: [2, 1] }, { 6: [2, 2] }, { 6: [2, 244] }, { 45: [1, 77], 85: [1, 78], 86: 74, 87: [1, 75], 89: [1, 76] }, r([6, 13, 16, 45, 48, 82, 87, 89, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312], [2, 120], { 337: [1, 79] }), r(m, [2, 418], { 218: 80, 222: 81, 229: [1, 82] }), { 19: 83, 28: g, 29: T, 52: 84, 53: v, 56: 85 }, { 19: 88, 28: g, 29: T, 52: 89, 53: v, 56: 85 }, r(s, [2, 253], { 26: 90 }), { 28: [1, 91], 52: 92, 53: v }, r(E, [2, 385], { 181: 93, 182: 94, 183: 95, 31: [2, 383] }), r(R, [2, 263], { 34: 96 }), r(R, [2, 261], { 44: 39, 55: 40, 307: 43, 139: 97, 13: l, 16: f, 87: h, 308: p }), r(R, [2, 262]), r(L, [2, 259]), r(A, [2, 143]), r(A, [2, 144]), r([6, 13, 16, 28, 29, 31, 39, 45, 47, 48, 53, 63, 70, 73, 76, 78, 81, 82, 83, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 197, 224, 229, 231, 232, 242, 246, 250, 263, 265, 268, 269, 270, 271, 272, 273, 274, 276, 277, 279, 280, 283, 285, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 314, 317, 318, 335, 338, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351], [2, 145]), r(w, [2, 211]), r(w, [2, 212]), r(w, [2, 213]), r(w, [2, 214]), { 19: 98, 28: g, 29: T, 52: 99, 53: v, 56: 85 }, { 6: [2, 309], 99: 100, 193: [1, 101] }, r(S, [2, 311], { 101: 102, 328: [1, 103] }), r(O, [2, 317], { 104: 104, 328: [1, 105] }), r(x, [2, 322], { 107: 106, 328: [1, 107] }), { 111: 108, 112: [2, 324], 328: [1, 109] }, { 29: F, 114: 110 }, { 29: F, 114: 112 }, { 29: F, 114: 113 }, { 118: 114, 123: [1, 115], 125: 116, 126: j }, r(q, [2, 315]), r(q, [2, 316]), r(Q, [2, 319]), r(Q, [2, 320]), r(Q, [2, 321]), r(b, [2, 327]), { 13: l, 16: f, 55: 118, 307: 43, 308: p }, r(s, [2, 12]), r(s, [2, 13], { 44: 66, 43: 119, 45: _, 87: h }), r(G, [2, 269]), r(G, [2, 15]), { 13: l, 16: f, 44: 136, 45: K, 46: 120, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(y, [2, 14]), r(y, [2, 274]), r(y, [2, 271]), r(y, [2, 272]), r(o, [2, 4]), { 13: [1, 177] }, r(qe, [2, 39]), { 29: [1, 178] }, { 29: [1, 179] }, { 87: [1, 181], 91: 180 }, { 45: [1, 187], 87: [1, 185], 89: [1, 186], 93: 182, 165: 183, 166: 184 }, r(c, [2, 410]), r([6, 13, 16, 45, 48, 82, 87, 89, 231, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 337], [2, 121], { 338: [1, 188] }), { 13: l, 16: f, 45: [1, 193], 55: 194, 197: Ke, 219: 189, 220: 190, 223: 191, 224: [1, 192], 307: 43, 308: p }, r(m, [2, 419]), r(Y, Ee, { 20: 196, 59: 197, 69: 198, 70: Ie }), r(s, [2, 250]), { 29: Ue, 57: 200 }, r(S, [2, 279], { 54: 202, 327: [1, 203] }), { 29: [2, 282] }, r(Le, tt, { 23: 204, 58: 205, 62: 206, 63: it }), r(s, [2, 252]), { 19: 208, 28: g, 29: T, 52: 209, 53: v, 56: 85 }, { 29: [1, 210] }, r(d, [2, 256]), { 31: [1, 211] }, { 31: [2, 384] }, { 13: l, 16: f, 44: 215, 45: Ye, 55: 220, 82: U, 87: h, 89: ht, 145: 212, 172: 221, 185: 213, 187: 214, 231: ne, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(He, [2, 265], { 56: 85, 35: 227, 52: 228, 19: 229, 28: g, 29: T, 53: v }), r(L, [2, 260]), r(Le, tt, { 58: 205, 62: 206, 23: 230, 63: it }), r(s, [2, 268]), { 6: [2, 45] }, r(o, a, { 10: 3, 4: 231 }), { 13: l, 16: f, 55: 232, 307: 43, 308: p }, r(S, [2, 312]), { 105: 233, 112: At, 122: 234, 132: [1, 237], 134: 235, 327: [1, 238], 334: [1, 239] }, r(O, [2, 318]), r(S, Qe, { 108: 240, 133: 242, 112: bt, 132: Ge }), r(x, [2, 323]), { 112: [1, 244] }, { 112: [2, 325] }, r(Je, [2, 50]), r(E, rt, { 135: 245, 136: 246, 143: 247, 144: 248, 31: Et, 112: Et }), r(Je, [2, 51]), r(Je, [2, 52]), r(ot, [2, 328], { 119: 249 }), { 29: F, 114: 250 }, r(ot, [2, 56]), { 29: F, 114: 251 }, r(b, [2, 59]), r(G, [2, 270]), { 47: [1, 252] }, r(Xe, [2, 150]), r(Ur, [2, 428], { 240: 253 }), r(ze, [2, 430], { 244: 254 }), r(ze, [2, 155], { 248: 255, 249: 256, 250: [2, 438], 290: [1, 257], 341: [1, 258], 342: [1, 259], 343: [1, 260], 344: [1, 261], 345: [1, 262], 346: [1, 263] }), r(se, [2, 440], { 252: 264 }), r(ge, [2, 448], { 260: 265 }), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 255: 154, 257: 155, 264: 266, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 255: 154, 257: 155, 264: 267, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 255: 154, 257: 155, 264: 268, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(ge, [2, 167]), r(ge, [2, 168]), r(ge, [2, 169]), r(ge, [2, 170], { 176: 269, 45: Se, 89: Ze }), r(ge, [2, 171]), r(ge, [2, 172]), r(ge, [2, 173]), r(ge, [2, 174]), { 13: l, 16: f, 44: 136, 45: K, 46: 272, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(et, [2, 176]), { 89: [1, 273] }, { 45: [1, 274] }, { 45: [1, 275] }, { 45: [1, 276] }, { 45: [1, 277] }, { 45: [1, 278] }, { 45: Tt, 89: ar, 179: 279 }, { 45: [1, 282] }, { 45: [1, 284], 89: [1, 283] }, { 279: [1, 285] }, r(kt, [2, 192], { 292: [1, 286], 293: [1, 287] }), r(kt, [2, 195]), r(kt, [2, 196]), r(kt, [2, 197]), r(kt, [2, 198]), r(kt, [2, 199]), r(kt, [2, 200]), { 13: l, 16: f, 44: 39, 55: 40, 82: U, 87: h, 139: 289, 172: 291, 255: 154, 257: 155, 266: 290, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 320: 288 }, { 45: [1, 292] }, { 45: [1, 293] }, { 45: [1, 294] }, r(Ui, [2, 452]), r(Ui, [2, 453]), r(Ui, [2, 454]), r(Ui, [2, 455]), r(Ui, [2, 456]), { 279: [2, 458] }, r(yn, [2, 207]), r(yn, [2, 208]), r(yn, [2, 209]), r(yn, [2, 210]), r(kt, [2, 201]), r(kt, [2, 202]), r(kt, [2, 203]), r(kt, [2, 204]), r(kt, [2, 205]), r(kt, [2, 206]), r(o, [2, 5]), r(Kt, [2, 297], { 88: 295 }), r(Fn, [2, 299], { 90: 296 }), { 48: [1, 297], 87: [1, 298] }, r(Fr, [2, 301]), r(qe, [2, 43]), r(qe, [2, 82]), r(qe, [2, 83]), { 29: [1, 299] }, { 29: [1, 300] }, { 87: [1, 302], 169: 301 }, r(c, [2, 412]), r(Xn, [2, 123]), r(Xn, [2, 416], { 221: 303, 339: 304, 39: [1, 306], 263: [1, 307], 340: [1, 305] }), r(Nr, [2, 124]), { 13: l, 16: f, 45: [1, 311], 55: 194, 89: [1, 310], 197: Ke, 223: 312, 225: 308, 226: 309, 229: cu, 307: 43, 308: p }, r(c, e, { 215: 10, 214: 314 }), r(Nr, [2, 236]), r(Nr, [2, 237]), r(Vr, [2, 6]), r(u0, [2, 287], { 60: 315, 72: 316, 73: [1, 317] }), r(Y, [2, 286]), { 13: l, 16: f, 45: K, 55: 323, 67: 321, 68: 322, 71: 318, 77: 320, 79: 319, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 307: 43, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r([6, 31, 63, 70, 73, 81, 83, 85], [2, 20]), r(E, du, { 38: 17, 49: 324, 147: 325, 17: 326, 21: 327, 148: 328, 154: 329, 155: 330, 29: _n, 31: _n, 85: _n, 112: _n, 159: _n, 160: _n, 161: _n, 163: _n, 164: _n, 41: n }), { 13: l, 16: f, 55: 331, 307: 43, 308: p }, r(S, [2, 280]), r(Vr, [2, 7]), r(Y, Ee, { 59: 197, 69: 198, 20: 332, 70: Ie }), r(Le, [2, 284]), { 64: [1, 333] }, r(Le, tt, { 58: 205, 62: 206, 23: 334, 63: it }), r(s, [2, 254]), r(E, rt, { 144: 248, 30: 335, 143: 336, 31: [2, 257] }), r(s, [2, 100]), { 31: [2, 387], 184: 337, 335: [1, 338] }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 342, 186: 339, 190: 340, 195: 341, 197: dn, 307: 43, 308: p }, r(mh, [2, 389], { 44: 39, 55: 40, 307: 43, 190: 340, 195: 341, 139: 342, 188: 344, 189: 345, 186: 346, 13: l, 16: f, 87: h, 197: dn, 308: p }), r(Vi, [2, 227]), r(Vi, [2, 228]), r(Vi, [2, 229]), { 13: l, 16: f, 44: 215, 45: Ye, 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 187: 350, 200: 348, 230: 347, 231: ne, 234: 349, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 342, 186: 352, 190: 340, 195: 341, 197: dn, 307: 43, 308: p }, r(Vi, [2, 146]), r(Vi, [2, 147]), r(Vi, [2, 148]), r(Vi, [2, 149]), { 13: l, 16: f, 44: 354, 55: 355, 82: U, 87: h, 172: 357, 237: 356, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 358, 312: $e, 313: 353 }, r(b4, [2, 215]), r(b4, [2, 216]), r(Le, tt, { 58: 205, 62: 206, 23: 359, 63: it }), r(R, [2, 264]), r(He, [2, 266]), r(Vr, [2, 11]), r(t, [2, 308], { 6: [2, 310] }), r(Je, [2, 313], { 102: 360, 120: 361, 121: [1, 362] }), r(Je, [2, 47]), r(Je, [2, 63]), r(Je, [2, 64]), { 13: l, 16: f, 55: 363, 307: 43, 308: p }, r(Je, [2, 336]), r(Je, [2, 337]), r(Je, [2, 338]), { 109: [1, 364] }, r(iI, [2, 60]), { 13: l, 16: f, 55: 365, 307: 43, 308: p }, r(S, [2, 335]), { 13: l, 16: f, 55: 366, 307: 43, 308: p }, { 31: [1, 367] }, r(lu, [2, 341], { 137: 368 }), r(lu, [2, 340]), { 13: l, 16: f, 44: 215, 45: Ye, 55: 220, 82: U, 87: h, 89: ht, 145: 369, 172: 221, 185: 213, 187: 214, 231: ne, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, { 28: [1, 370], 127: 371, 128: [1, 372] }, r(ot, [2, 330], { 124: 373, 125: 374, 126: j }), r(ot, [2, 57]), { 44: 375, 87: h }, r(Xe, [2, 151], { 241: 376, 242: [1, 377] }), r(Ur, [2, 153], { 245: 378, 246: [1, 379] }), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 247: 380, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 250: [1, 381] }, r(gr, [2, 432]), r(gr, [2, 433]), r(gr, [2, 434]), r(gr, [2, 435]), r(gr, [2, 436]), r(gr, [2, 437]), { 250: [2, 439] }, r([47, 48, 193, 242, 246, 250, 272, 290, 341, 342, 343, 344, 345, 346], [2, 158], { 253: 382, 254: 383, 255: 384, 257: 385, 263: [1, 386], 265: [1, 387], 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne }), r(se, [2, 162], { 261: 388, 262: 389, 39: y4, 338: _4 }), r(ge, [2, 164]), r(ge, [2, 165]), r(ge, [2, 166]), r(et, [2, 95]), r(et, [2, 96]), r(gr, [2, 377], { 177: 392, 325: [1, 393] }), { 48: [1, 394] }, r(et, [2, 177]), { 13: l, 16: f, 44: 136, 45: K, 46: 395, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 396, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 397, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 398, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 399, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(et, [2, 183]), r(et, [2, 98]), r(gr, [2, 381], { 180: 400 }), { 87: [1, 401] }, r(et, [2, 185]), { 13: l, 16: f, 44: 136, 45: K, 46: 402, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 29: Ue, 57: 403 }, r(kt, [2, 193]), { 13: l, 16: f, 55: 404, 307: 43, 308: p }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 342, 195: 405, 197: dn, 307: 43, 308: p }, r(Ea, [2, 233]), r(Ea, [2, 234]), r(Ea, [2, 235]), r(aI, [2, 459], { 281: 406, 325: [1, 407] }), r(gr, [2, 463], { 284: 408, 325: [1, 409] }), r(gr, [2, 465], { 286: 410, 325: [1, 411] }), { 13: l, 16: f, 31: [1, 412], 55: 414, 82: U, 171: 413, 172: 415, 173: 416, 174: Lw, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: jw }, { 31: [1, 419], 89: [1, 420] }, { 29: [1, 421] }, r(Fr, [2, 302]), r(Kt, [2, 367], { 167: 422 }), r(Fn, [2, 369], { 168: 423 }), { 48: [1, 424], 87: [1, 425] }, r(Fr, [2, 371]), r(Xn, [2, 122]), r(Xn, [2, 417]), r(Xn, [2, 413]), r(Xn, [2, 414]), r(Xn, [2, 415]), r(Nr, [2, 125]), r(Nr, [2, 127]), r(Nr, [2, 128]), r(uI, [2, 420], { 227: 426 }), r(Nr, [2, 130]), { 13: l, 16: f, 55: 194, 197: Ke, 223: 427, 307: 43, 308: p }, { 48: [1, 428] }, r(Oa, [2, 289], { 61: 429, 80: 430, 81: [1, 431], 83: [1, 432] }), r(u0, [2, 288]), { 64: [1, 433] }, r(Y, [2, 29], { 307: 43, 267: 139, 275: 146, 278: 149, 77: 320, 67: 321, 68: 322, 55: 323, 79: 434, 13: l, 16: f, 45: K, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 276: V, 277: N, 279: M, 280: I, 283: P, 285: B, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }), r(oI, [2, 293]), r(g4, [2, 92]), r(g4, [2, 93]), r(g4, [2, 94]), { 45: Se, 89: Ze, 176: 269 }, { 31: [1, 435] }, { 31: [1, 436] }, { 19: 437, 28: g, 29: T, 56: 85 }, { 19: 438, 28: g, 29: T, 56: 85 }, r(fu, [2, 355], { 149: 439 }), r(fu, [2, 354]), { 13: l, 16: f, 44: 215, 45: Mw, 55: 220, 82: U, 87: h, 89: ht, 156: 440, 172: 221, 185: 441, 203: 442, 231: Cw, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(R, [2, 19]), r(Oa, [2, 21]), { 13: l, 16: f, 44: 450, 45: sI, 55: 323, 65: 445, 66: 446, 67: 447, 68: 448, 87: h, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 307: 43, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(Vr, [2, 8]), { 31: [1, 451] }, { 31: [2, 258] }, { 31: [2, 101] }, r(E, [2, 386], { 31: [2, 388] }), r(mh, [2, 102]), r(hu, [2, 391], { 191: 452 }), r(E, [2, 395], { 196: 453, 198: 454 }), r(E, [2, 108]), r(E, [2, 109]), r(mh, [2, 103]), r(mh, [2, 104]), r(mh, [2, 390]), { 13: l, 16: f, 44: 215, 45: Ye, 48: [1, 455], 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 187: 350, 200: 456, 231: ne, 234: 349, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(qw, [2, 424]), r(cI, [2, 136]), r(cI, [2, 137]), r(m4, [2, 140]), { 232: [1, 457] }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 342, 195: 458, 197: dn, 307: 43, 308: p }, r(Ea, [2, 219]), r(Ea, [2, 220]), r(Ea, [2, 221]), r(Ea, [2, 222]), r(Ea, [2, 223]), r(Vr, [2, 10]), r(Je, [2, 46]), r(Je, [2, 314]), { 112: At, 122: 459 }, r(Je, [2, 62]), r(S, Qe, { 133: 242, 108: 460, 112: bt, 132: Ge }), r(iI, [2, 61]), r(Je, [2, 49]), r([6, 28, 126, 128, 193], [2, 65]), { 31: [2, 66], 112: [1, 462], 138: 461 }, r(lu, [2, 351], { 146: 463, 335: [1, 464] }), { 29: Ue, 57: 465 }, r(ot, [2, 329]), r(S, [2, 332], { 129: 466, 327: [1, 467] }), r(ot, [2, 55]), r(ot, [2, 331]), { 48: [1, 468] }, r(Ur, [2, 429]), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 239: 469, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(ze, [2, 431]), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 243: 470, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(ze, [2, 156]), { 45: Tt, 89: ar, 179: 471 }, r(se, [2, 441]), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 251: 472, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(ge, [2, 444], { 256: 473 }), r(ge, [2, 446], { 258: 474 }), r(gr, [2, 442]), r(gr, [2, 443]), r(ge, [2, 449]), { 13: l, 16: f, 44: 136, 45: K, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 255: 154, 257: 155, 259: 475, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(gr, [2, 450]), r(gr, [2, 451]), r(gr, [2, 379], { 178: 476 }), r(gr, [2, 378]), r([6, 13, 16, 29, 31, 39, 45, 47, 48, 73, 76, 78, 81, 82, 83, 85, 87, 89, 112, 159, 160, 161, 163, 164, 193, 231, 242, 246, 250, 263, 265, 268, 269, 270, 271, 272, 273, 274, 276, 277, 279, 280, 283, 285, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 308, 309, 310, 312, 335, 338, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351], [2, 175]), { 48: [1, 477] }, { 48: [1, 478] }, { 272: [1, 479] }, { 272: [1, 480] }, { 272: [1, 481] }, { 13: l, 16: f, 44: 136, 45: K, 46: 482, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 48: [1, 483] }, { 48: [1, 484] }, r(et, [2, 187]), r(kt, [2, 194]), { 13: l, 16: f, 44: 39, 55: 40, 82: U, 87: h, 139: 289, 172: 291, 255: 154, 257: 155, 266: 290, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 320: 485 }, { 13: l, 16: f, 39: [1, 487], 44: 136, 45: K, 46: 488, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 282: 486, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(aI, [2, 460]), { 13: l, 16: f, 44: 136, 45: K, 46: 489, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(gr, [2, 464]), { 13: l, 16: f, 44: 136, 45: K, 46: 490, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(gr, [2, 466]), r(qe, [2, 40]), r(Kt, [2, 298]), r(vh, [2, 87]), r(vh, [2, 88]), r(vh, [2, 89]), r(vh, [2, 90]), { 13: l, 16: f, 55: 492, 82: U, 172: 493, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 311: 494, 312: $e, 315: 491 }, r(qe, [2, 41]), r(Fn, [2, 300]), r(Th, [2, 303], { 92: 495 }), { 13: l, 16: f, 31: [1, 496], 55: 414, 82: U, 171: 497, 172: 415, 173: 416, 174: Lw, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: jw }, { 31: [1, 498], 89: [1, 499] }, { 29: [1, 500] }, r(Fr, [2, 372]), { 13: l, 16: f, 48: [2, 422], 55: 194, 197: Ke, 223: 312, 226: 502, 228: 501, 229: cu, 307: 43, 308: p }, r(Nr, [2, 131]), r(Nr, [2, 126]), r(Oa, [2, 22]), r(Oa, [2, 290]), { 82: [1, 503] }, { 82: [1, 504] }, { 13: l, 16: f, 44: 510, 45: K, 55: 323, 67: 321, 68: 322, 74: 505, 75: 506, 76: dI, 77: 320, 78: lI, 79: 509, 87: h, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 307: 43, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(oI, [2, 294]), r(fI, [2, 69]), r(fI, [2, 70]), r(Y, Ee, { 59: 197, 69: 198, 20: 511, 70: Ie }), r(Le, tt, { 58: 205, 62: 206, 23: 512, 63: it }), { 29: [2, 375], 31: [2, 71], 84: 522, 85: i, 112: [1, 518], 150: 513, 151: 514, 158: 515, 159: [1, 516], 160: [1, 517], 161: [1, 519], 163: [1, 520], 164: [1, 521], 175: 523 }, r(fu, [2, 363], { 157: 524, 335: [1, 525] }), r(c, e, { 215: 10, 202: 526, 205: 527, 208: 528, 214: 529, 44: 530, 87: h }), r(Bw, [2, 399], { 215: 10, 205: 527, 208: 528, 214: 529, 44: 530, 204: 531, 202: 532, 13: e, 16: e, 45: e, 197: e, 224: e, 229: e, 308: e, 87: h }), { 13: l, 16: f, 44: 215, 45: Mw, 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 203: 536, 212: 534, 231: Cw, 233: 533, 234: 535, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(c, e, { 215: 10, 205: 527, 208: 528, 214: 529, 44: 530, 202: 537, 87: h }), r(Le, [2, 23], { 307: 43, 267: 139, 275: 146, 278: 149, 55: 323, 67: 447, 68: 448, 44: 450, 66: 538, 13: l, 16: f, 45: sI, 87: h, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 276: V, 277: N, 279: M, 280: I, 283: P, 285: B, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }), r(pu, [2, 291]), r(pu, [2, 24]), r(pu, [2, 25]), { 13: l, 16: f, 44: 136, 45: K, 46: 539, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(pu, [2, 28]), r(Le, tt, { 58: 205, 62: 206, 23: 540, 63: it }), r([31, 112, 232, 318, 335], [2, 105], { 192: 541, 193: [1, 542] }), r(hu, [2, 107]), { 13: l, 16: f, 44: 215, 45: Ye, 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 187: 350, 199: 543, 200: 544, 231: ne, 234: 349, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(hI, [2, 132]), r(qw, [2, 425]), r(hI, [2, 133]), { 13: l, 16: f, 44: 354, 55: 355, 82: U, 87: h, 172: 357, 237: 356, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 358, 312: $e, 313: 545 }, r(Je, [2, 54]), r(Je, [2, 48]), r(lu, [2, 342]), { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 546, 307: 43, 308: p }, r(lu, [2, 68]), r(E, [2, 350], { 31: pI, 112: pI }), r(Je, [2, 53]), { 13: l, 16: f, 55: 547, 307: 43, 308: p }, r(S, [2, 333]), r(G, [2, 16]), r(Ur, [2, 152]), r(ze, [2, 154]), r(ze, [2, 157]), r(se, [2, 159]), r(se, [2, 160], { 262: 389, 261: 548, 39: y4, 338: _4 }), r(se, [2, 161], { 262: 389, 261: 549, 39: y4, 338: _4 }), r(ge, [2, 163]), { 13: l, 16: f, 44: 136, 45: K, 46: 550, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(et, [2, 178]), r(et, [2, 179]), { 13: l, 16: f, 44: 136, 45: K, 46: 551, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 552, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 553, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 48: [1, 554], 272: [1, 555] }, r(et, [2, 184]), r(et, [2, 186]), { 314: [1, 556] }, { 48: [1, 557] }, { 48: [2, 461] }, { 48: [2, 462] }, { 48: [1, 558] }, { 48: [2, 467], 193: [1, 561], 287: 559, 288: 560 }, { 13: l, 16: f, 55: 194, 197: Ke, 223: 562, 307: 43, 308: p }, r(v4, [2, 224]), r(v4, [2, 225]), r(v4, [2, 226]), { 31: [1, 563], 45: bI, 94: 564 }, r(qe, [2, 84]), r(Kt, [2, 368]), r(qe, [2, 85]), r(Fn, [2, 370]), r(Th, [2, 373], { 170: 566 }), { 48: [1, 567] }, { 48: [2, 423], 337: [1, 568] }, r(Oa, [2, 35], { 83: [1, 569] }), r(Oa, [2, 36], { 81: [1, 570] }), r(u0, [2, 30], { 307: 43, 267: 139, 275: 146, 278: 149, 77: 320, 67: 321, 68: 322, 55: 323, 79: 509, 44: 510, 75: 571, 13: l, 16: f, 45: K, 76: dI, 78: lI, 87: h, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 276: V, 277: N, 279: M, 280: I, 283: P, 285: B, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }), r(o0, [2, 295]), { 45: K, 77: 572 }, { 45: K, 77: 573 }, r(o0, [2, 33]), r(o0, [2, 34]), { 31: [2, 275], 50: 574, 84: 575, 85: i }, { 31: [2, 277], 51: 576, 84: 577, 85: i }, r(fu, [2, 356]), r(yI, [2, 357], { 152: 578, 335: [1, 579] }), r(Qi, [2, 74]), { 29: Ue, 57: 580 }, { 29: Ue, 57: 581 }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 582, 307: 43, 308: p }, r(_I, [2, 365], { 162: 583, 328: [1, 584] }), { 13: l, 16: f, 45: K, 55: 323, 67: 321, 68: 322, 77: 320, 79: 585, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 307: 43, 308: p, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 45: [1, 586] }, r(Qi, [2, 81]), { 29: Ue, 57: 587 }, r(fu, [2, 73]), r(E, [2, 362], { 29: Hi, 31: Hi, 85: Hi, 112: Hi, 159: Hi, 160: Hi, 161: Hi, 163: Hi, 164: Hi }), r(Bw, [2, 112]), r(s0, [2, 401], { 206: 588 }), r(E, [2, 405], { 209: 589, 210: 590 }), r(E, [2, 403]), r(E, [2, 404]), r(Bw, [2, 113]), r(Bw, [2, 400]), { 13: l, 16: f, 44: 215, 45: Mw, 48: [1, 591], 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 203: 536, 212: 592, 231: Cw, 234: 535, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(qw, [2, 426]), r(m4, [2, 138]), r(m4, [2, 139]), { 232: [1, 593] }, r(pu, [2, 292]), { 47: [1, 595], 48: [1, 594] }, r(Vr, [2, 9]), r(hu, [2, 392]), r(hu, [2, 393], { 44: 39, 55: 40, 307: 43, 195: 341, 139: 342, 194: 596, 190: 597, 13: l, 16: f, 87: h, 197: dn, 308: p }), r(hu, [2, 110], { 272: [1, 598] }), r($w, [2, 397], { 201: 599, 316: 600, 317: [1, 601] }), { 314: [1, 602] }, { 29: [1, 603] }, r(ot, [2, 58]), r(ge, [2, 445]), r(ge, [2, 447]), { 48: [1, 604], 272: [1, 605] }, { 48: [1, 606] }, { 272: [1, 607] }, { 272: [1, 608] }, r(et, [2, 99]), r(gr, [2, 382]), r([13, 16, 39, 47, 48, 87, 193, 197, 242, 246, 250, 263, 265, 272, 290, 297, 298, 299, 300, 301, 302, 308, 314, 338, 341, 342, 343, 344, 345, 346], [2, 232]), r(et, [2, 188]), r(et, [2, 189]), { 48: [1, 609] }, { 48: [2, 468] }, { 289: [1, 610] }, { 13: l, 16: f, 55: 492, 82: U, 172: 493, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 311: 494, 312: $e, 315: 611 }, r(qe, [2, 42]), r(Th, [2, 304]), { 13: l, 16: f, 55: 414, 82: U, 95: 612, 171: 613, 172: 415, 173: 416, 174: Lw, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: jw }, { 31: [1, 614], 45: bI, 94: 615 }, r(Nr, [2, 129]), r(uI, [2, 421]), { 82: [1, 616] }, { 82: [1, 617] }, r(o0, [2, 296]), r(o0, [2, 31]), r(o0, [2, 32]), { 31: [2, 17] }, { 31: [2, 276] }, { 31: [2, 18] }, { 31: [2, 278] }, r(E, du, { 155: 330, 153: 618, 154: 619, 29: Gi, 31: Gi, 85: Gi, 112: Gi, 159: Gi, 160: Gi, 161: Gi, 163: Gi, 164: Gi }), r(yI, [2, 358]), r(Qi, [2, 75]), r(Qi, [2, 76]), { 29: Ue, 57: 620 }, { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 621, 307: 43, 308: p }, r(_I, [2, 366]), r(Qi, [2, 79]), { 13: l, 16: f, 44: 136, 45: K, 46: 622, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(Qi, [2, 91], { 336: [1, 623] }), r([29, 31, 85, 112, 159, 160, 161, 163, 164, 232, 318, 335], [2, 114], { 207: 624, 193: [1, 625] }), r(s0, [2, 117]), { 13: l, 16: f, 44: 215, 45: Mw, 55: 220, 82: U, 87: h, 89: ht, 172: 221, 185: 351, 203: 536, 211: 626, 212: 627, 231: Cw, 234: 535, 236: 216, 237: 222, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 309: ie, 310: je, 311: 217, 312: $e }, r(Vi, [2, 134]), r(qw, [2, 427]), r(Vi, [2, 135]), r(pu, [2, 26]), { 44: 628, 87: h }, r(hu, [2, 106]), r(hu, [2, 394]), r(E, [2, 396]), r($w, [2, 111]), r($w, [2, 398]), { 13: l, 16: f, 44: 39, 55: 40, 87: h, 139: 342, 186: 629, 190: 340, 195: 341, 197: dn, 307: 43, 308: p }, r(b4, [2, 217]), r(E, rt, { 144: 248, 140: 630, 143: 631, 31: [2, 343] }), r(et, [2, 97]), r(gr, [2, 380]), r(et, [2, 180]), { 13: l, 16: f, 44: 136, 45: K, 46: 632, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, { 13: l, 16: f, 44: 136, 45: K, 46: 633, 55: 133, 67: 132, 68: 134, 77: 131, 82: U, 87: h, 172: 135, 224: ae, 238: 121, 239: 122, 243: 123, 247: 124, 251: 125, 255: 154, 257: 155, 259: 126, 263: ye, 264: 130, 265: pe, 266: 137, 267: 139, 268: ee, 269: Te, 270: we, 271: Oe, 273: be, 274: he, 275: 146, 276: V, 277: N, 278: 149, 279: M, 280: I, 283: P, 285: B, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: C, 346: X, 347: te, 348: de, 349: oe, 350: De, 351: Ve }, r(et, [2, 190]), { 290: [1, 634] }, { 314: [1, 635] }, { 13: l, 16: f, 48: [1, 636], 55: 414, 82: U, 171: 637, 172: 415, 173: 416, 174: Lw, 255: 154, 257: 155, 291: 150, 294: z, 295: H, 296: J, 297: k, 298: W, 299: le, 300: fe, 301: me, 302: Ne, 303: xe, 304: ue, 305: $, 306: D, 307: 43, 308: p, 312: jw }, r(gI, [2, 305]), r(qe, [2, 86]), r(Th, [2, 374]), r(Oa, [2, 37]), r(Oa, [2, 38]), r(fu, [2, 72]), r(fu, [2, 360]), r(Qi, [2, 77]), { 29: Ue, 57: 638 }, { 47: [1, 639] }, { 29: [2, 376] }, r(s0, [2, 402]), r(s0, [2, 115], { 215: 10, 208: 528, 214: 529, 44: 530, 205: 640, 13: e, 16: e, 45: e, 197: e, 224: e, 229: e, 308: e, 87: h }), r(s0, [2, 118], { 272: [1, 641] }), r(Uw, [2, 407], { 213: 642, 319: 643, 317: [1, 644] }), { 48: [1, 645] }, { 318: [1, 646] }, { 31: [1, 647] }, { 31: [2, 344] }, { 48: [1, 648] }, { 48: [1, 649] }, { 291: 650, 303: xe, 304: ue, 305: $, 306: D }, r(vh, [2, 218]), r(Th, [2, 44]), r(gI, [2, 306]), r(Qi, [2, 78]), { 44: 651, 87: h }, r(s0, [2, 116]), r(E, [2, 406]), r(Uw, [2, 119]), r(Uw, [2, 408]), r(c, e, { 215: 10, 205: 527, 208: 528, 214: 529, 44: 530, 202: 652, 87: h }), r(pu, [2, 27]), r($w, [2, 230]), r(mI, [2, 345], { 141: 653, 335: [1, 654] }), r(et, [2, 181]), r(et, [2, 182]), { 48: [2, 191] }, { 48: [1, 655] }, { 318: [1, 656] }, r(E, rt, { 144: 248, 142: 657, 143: 658, 31: vI, 112: vI }), r(mI, [2, 346]), r(Qi, [2, 80]), r(Uw, [2, 231]), r(lu, [2, 67]), r(lu, [2, 348])],
      defaultActions: { 5: [2, 240], 6: [2, 241], 7: [2, 242], 9: [2, 239], 24: [2, 1], 25: [2, 2], 26: [2, 244], 87: [2, 282], 94: [2, 384], 100: [2, 45], 109: [2, 325], 166: [2, 458], 263: [2, 439], 336: [2, 258], 337: [2, 101], 487: [2, 461], 488: [2, 462], 560: [2, 468], 574: [2, 17], 575: [2, 276], 576: [2, 18], 577: [2, 278], 623: [2, 376], 631: [2, 344], 650: [2, 191] },
      parseError: function(Re, Ce) {
        if (Ce.recoverable)
          this.trace(Re);
        else {
          var ke = new Error(Re);
          throw ke.hash = Ce, ke;
        }
      },
      parse: function(Re) {
        var Ce = this, ke = [0], st = [null], lt = [], Z = this.table, gn = "", re = 0, xa = 0, Gw = 2, zw = 1, kw = lt.slice.call(arguments, 1), pr = Object.create(this.lexer), Si = { yy: {} };
        for (var gu in this.yy)
          Object.prototype.hasOwnProperty.call(this.yy, gu) && (Si.yy[gu] = this.yy[gu]);
        pr.setInput(Re, Si.yy), Si.yy.lexer = pr, Si.yy.parser = this, typeof pr.yylloc > "u" && (pr.yylloc = {});
        var p0 = pr.yylloc;
        lt.push(p0);
        var D4 = pr.options && pr.options.ranges;
        typeof Si.yy.parseError == "function" ? this.parseError = Si.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
        for (var Xw = function() {
          var b0;
          return b0 = pr.lex() || zw, typeof b0 != "number" && (b0 = Ce.symbols_[b0] || b0), b0;
        }, wt, jt, _t, Dr, Lr = {}, Jw, ki, PI, Kw; ; ) {
          if (jt = ke[ke.length - 1], this.defaultActions[jt] ? _t = this.defaultActions[jt] : ((wt === null || typeof wt > "u") && (wt = Xw()), _t = Z[jt] && Z[jt][wt]), typeof _t > "u" || !_t.length || !_t[0]) {
            var L4 = "";
            Kw = [];
            for (Jw in Z[jt])
              this.terminals_[Jw] && Jw > Gw && Kw.push("'" + this.terminals_[Jw] + "'");
            pr.showPosition ? L4 = "Parse error on line " + (re + 1) + `:
` + pr.showPosition() + `
Expecting ` + Kw.join(", ") + ", got '" + (this.terminals_[wt] || wt) + "'" : L4 = "Parse error on line " + (re + 1) + ": Unexpected " + (wt == zw ? "end of input" : "'" + (this.terminals_[wt] || wt) + "'"), this.parseError(L4, {
              text: pr.match,
              token: this.terminals_[wt] || wt,
              line: pr.yylineno,
              loc: p0,
              expected: Kw
            });
          }
          if (_t[0] instanceof Array && _t.length > 1)
            throw new Error("Parse Error: multiple actions possible at state: " + jt + ", token: " + wt);
          switch (_t[0]) {
            case 1:
              ke.push(wt), st.push(pr.yytext), lt.push(pr.yylloc), ke.push(_t[1]), wt = null, xa = pr.yyleng, gn = pr.yytext, re = pr.yylineno, p0 = pr.yylloc;
              break;
            case 2:
              if (ki = this.productions_[_t[1]][1], Lr.$ = st[st.length - ki], Lr._$ = {
                first_line: lt[lt.length - (ki || 1)].first_line,
                last_line: lt[lt.length - 1].last_line,
                first_column: lt[lt.length - (ki || 1)].first_column,
                last_column: lt[lt.length - 1].last_column
              }, D4 && (Lr._$.range = [
                lt[lt.length - (ki || 1)].range[0],
                lt[lt.length - 1].range[1]
              ]), Dr = this.performAction.apply(Lr, [
                gn,
                xa,
                re,
                Si.yy,
                _t[1],
                st,
                lt
              ].concat(kw)), typeof Dr < "u")
                return Dr;
              ki && (ke = ke.slice(0, -1 * ki * 2), st = st.slice(0, -1 * ki), lt = lt.slice(0, -1 * ki)), ke.push(this.productions_[_t[1]][0]), st.push(Lr.$), lt.push(Lr._$), PI = Z[ke[ke.length - 2]][ke[ke.length - 1]], ke.push(PI);
              break;
            case 3:
              return !0;
          }
        }
        return !0;
      }
    }, Vw = UK().Wildcard, Qw = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", fee = Qw + "type", hee = Qw + "first", pee = Qw + "rest", TI = Qw + "nil", Hw = "http://www.w3.org/2001/XMLSchema#", wI = Hw + "integer", SI = Hw + "decimal", AI = Hw + "double", bee = Hw + "boolean", bu = "", EI = "", OI = "";
    function Yr(Fe) {
      return Fe.toLowerCase();
    }
    function yu(Fe, Re) {
      return Fe.push(Re), Fe;
    }
    function c0(Fe, Re) {
      return Fe.push.apply(Fe, Re), Fe;
    }
    function hr(Fe) {
      Fe || (Fe = {});
      for (var Re = 1, Ce = arguments.length, ke; Re < Ce && (ke = arguments[Re] || {}); Re++)
        for (var st in ke)
          Fe[st] = ke[st];
      return Fe;
    }
    function Ti() {
      for (var Fe = [], Re = 0, Ce = arguments.length; Re < Ce; Re++)
        Fe = Fe.concat.apply(Fe, arguments[Re]);
      return Fe;
    }
    function wh(Fe) {
      if (Fe[0] === "<" && (Fe = Fe.substring(1, Fe.length - 1)), /^[a-z][a-z0-9.+-]*:/i.test(Fe))
        return Fe;
      if (!Ot.base)
        throw new Error("Cannot resolve relative IRI " + Fe + " because no base IRI was set.");
      switch (bu !== Ot.base && (bu = Ot.base, EI = bu.replace(/[^\/:]*$/, ""), OI = bu.match(/^(?:[a-z]+:\/*)?[^\/]*/)[0]), Fe[0]) {
        // An empty relative IRI indicates the base IRI
        case void 0:
          return bu;
        // Resolve relative fragment IRIs against the base IRI
        case "#":
          return bu + Fe;
        // Resolve relative query string IRIs by replacing the query string
        case "?":
          return bu.replace(/(?:\?.*)?$/, Fe);
        // Resolve root relative IRIs at the root of the base IRI
        case "/":
          return OI + Fe;
        // Resolve all other IRIs at the base IRI's path
        default:
          return EI + Fe;
      }
    }
    function w4(Fe) {
      if (Fe) {
        var Re = Fe[0];
        if (Re === "?" || Re === "$") return Ot.factory.variable(Fe.substr(1));
      }
      return Fe;
    }
    function Pr(Fe, Re) {
      return { type: "operation", operator: Fe, args: Re || [] };
    }
    function d0(Fe, Re) {
      var Ce = { expression: Fe === "*" ? new Vw() : Fe };
      if (Re)
        for (var ke in Re)
          Ce[ke] = Re[ke];
      return Ce;
    }
    function l0(Fe, Re) {
      return { type: "path", pathType: Fe, items: Re };
    }
    function S4(Fe, Re) {
      for (var Ce = 0, ke = Re.length, st; Ce < ke && (st = Re[Ce]); Ce++)
        Fe = Pr(st[0], [Fe, st[1]]);
      return Fe;
    }
    function _u(Fe, Re) {
      var Ce = [], ke = [], st = Fe.length, lt, Z = {};
      if (!st)
        return null;
      for (var gn = 0; gn < st && (lt = Fe[gn]); gn++)
        (lt.named ? ke : Ce).push(lt.iri);
      return Z[Re || "from"] = { default: Ce, named: ke }, Z;
    }
    function f0(Fe) {
      return parseInt(Fe, 10);
    }
    function A4(Fe) {
      return Fe.type === "group" && Fe.patterns.length === 1 ? Fe.patterns[0] : Fe;
    }
    function wi(Fe, Re) {
      return Re && Re.termType !== "NamedNode" && (Re = Ot.factory.namedNode(Re)), Ot.factory.literal(Fe, Re);
    }
    function yee(Fe, Re) {
      return Ot.factory.literal(Fe, Re);
    }
    function E4(Fe, Re, Ce) {
      if (!("termType" in Re))
        throw new Error("Nested triples cannot contain paths");
      return Ot.factory.quad(Fe, Re, Ce);
    }
    function zi(Fe, Re, Ce, ke) {
      var st = {};
      return Fe != null && (st.subject = Fe), Re != null && (st.predicate = Re), Ce != null && (st.object = Ce), ke != null && (st.annotations = ke), st;
    }
    function Sh(Fe) {
      return typeof Fe == "string" ? Fe.startsWith("e_") ? Ot.factory.blankNode(Fe) : Ot.factory.blankNode("e_" + Fe) : Ot.factory.blankNode("g_" + xI++);
    }
    var xI = 0;
    Ot._resetBlanks = function() {
      xI = 0;
    };
    var _ee = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\(.)/g, gee = {
      "\\": "\\",
      "'": "'",
      '"': '"',
      t: "	",
      b: "\b",
      n: `
`,
      r: "\r",
      f: "\f"
    }, mee = /[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/, O4 = String.fromCharCode;
    function II(Fe, Re) {
      Fe = Fe.substring(Re, Fe.length - Re);
      try {
        Fe = Fe.replace(_ee, function(Ce, ke, st, lt) {
          var Z;
          if (ke) {
            if (Z = parseInt(ke, 16), isNaN(Z)) throw new Error();
            return O4(Z);
          } else if (st) {
            if (Z = parseInt(st, 16), isNaN(Z)) throw new Error();
            return Z < 65535 ? O4(Z) : O4(55296 + ((Z -= 65536) >> 10), 56320 + (Z & 1023));
          } else {
            var gn = gee[lt];
            if (!gn) throw new Error();
            return gn;
          }
        });
      } catch {
        return "";
      }
      if (mee.exec(Fe))
        throw new Error("Invalid unicode codepoint of surrogate pair without corresponding codepoint in " + Fe);
      return Fe;
    }
    function vee(Fe) {
      var Re = Sh(), Ce = Re, ke = [], st, lt = [];
      Fe.forEach(function(xa) {
        ke.push(xa.entity), c0(lt, xa.triples);
      });
      for (var Z = 0, gn = 0, re = ke.length, st = Array(re * 2); Z < re; )
        st[gn++] = zi(Ce, Ot.factory.namedNode(hee), ke[Z]), st[gn++] = zi(Ce, Ot.factory.namedNode(pee), Ce = ++Z < re ? Sh() : Ot.factory.namedNode(TI));
      return { entity: Re, triples: c0(st, lt) };
    }
    function Tee(Fe) {
      var Re = Sh();
      return {
        entity: Re,
        triples: Fe.map(function(Ce) {
          return hr(zi(Re), Ce);
        })
      };
    }
    function x4(Fe, Re, Ce) {
      var ke = [], st = [];
      return Re.forEach(function(lt) {
        let Z = null;
        lt.annotation && (Z = lt.annotation, lt = lt.object), ke.push(zi(null, Fe, lt.entity, Z)), c0(st, lt.triples);
      }), Ti(ke, Ce || [], st);
    }
    function h0(Fe) {
      return Fe.variable ? Fe.variable.value : Fe.value || Fe.expression.value;
    }
    function I4(Fe) {
      if (!Fe)
        return [];
      if (Fe.type === "aggregate")
        return [Fe];
      if (Fe.type === "operation") {
        const Re = [];
        for (const Ce of Fe.args)
          Re.push(...I4(Ce));
        return Re;
      }
      return [];
    }
    function wee(Fe) {
      const Re = /* @__PURE__ */ new Set(), Ce = function(ke) {
        ke && (ke.termType === "Variable" ? Re.add(ke) : ke.type === "operation" && ke.args.forEach(Ce));
      };
      return Ce(Fe), Re;
    }
    function R4(Fe, Re = 1, Ce = []) {
      for (const ke of Fe)
        Re > 0 && ke instanceof Array ? R4(ke, Re - 1, Ce) : Ce.push(ke);
      return Ce;
    }
    function F4(Fe) {
      return Fe.termType === "Variable";
    }
    function RI(Fe) {
      if (Fe.triples) {
        const Re = [];
        for (const Ce of Fe.triples)
          F4(Ce.subject) && Re.push(Ce.subject.value), F4(Ce.predicate) && Re.push(Ce.predicate.value), F4(Ce.object) && Re.push(Ce.object.value);
        return Re;
      } else if (Fe.patterns) {
        const Re = [];
        for (const Ce of Fe.patterns)
          Re.push(...RI(Ce));
        return Re;
      }
      return [];
    }
    function See(Fe) {
      const Re = Fe.slice().sort(), Ce = [];
      for (let ke = 0; ke < Re.length - 1; ke++)
        Re[ke + 1] == Re[ke] && Ce.push(Re[ke]);
      return Ce;
    }
    function Ah(Fe) {
      if (!Ot.sparqlStar)
        throw new Error("SPARQL-star support is not enabled");
      return Fe;
    }
    function FI(Fe, Re, Ce) {
      for (const ke of Re) {
        const st = zi(
          // If the annotation already has a subject then just push the
          // annotation to the upper scope as it is a blank node introduced
          // from a pattern like :s :p :o {| :p1 [ :p2 :o2; :p3 :o3 ] |}
          "subject" in ke ? ke.subject : Fe,
          ke.predicate,
          ke.object
        );
        Ce.push(st), ke.annotations && FI(E4(
          Fe,
          ke.predicate,
          ke.object
        ), ke.annotations, Ce);
      }
    }
    function N4(Fe) {
      if (Ot.sparqlStar) {
        const Re = [];
        return Fe.forEach((Ce) => {
          const ke = zi(Ce.subject, Ce.predicate, Ce.object);
          Re.push(ke), Ce.annotations && FI(E4(Ce.subject, Ce.predicate, Ce.object), Ce.annotations, Re);
        }), Re;
      }
      return Fe;
    }
    function NI(Fe) {
      for (const Re of Fe) {
        if (Re.type === "graph" && Re.name.termType === "Variable")
          throw new Error("Detected illegal variable in GRAPH");
        if (Re.type === "bgp" || Re.type === "graph") {
          for (const Ce of Re.triples)
            if (Ce.subject.termType === "Variable" || Ce.predicate.termType === "Variable" || Ce.object.termType === "Variable")
              throw new Error("Detected illegal variable in BGP");
        }
      }
      return Fe;
    }
    function P4(Fe) {
      for (const Re of Fe)
        if (Re.type === "bgp") {
          for (const Ce of Re.triples)
            if (Ce.subject.termType === "BlankNode" || Ce.predicate.termType === "BlankNode" || Ce.object.termType === "BlankNode")
              throw new Error("Detected illegal blank node in BGP");
        }
      return Fe;
    }
    var Aee = /* @__PURE__ */ function() {
      var Fe = {
        EOF: 1,
        parseError: function(Ce, ke) {
          if (this.yy.parser)
            this.yy.parser.parseError(Ce, ke);
          else
            throw new Error(Ce);
        },
        // resets the lexer, sets new input
        setInput: function(Re, Ce) {
          return this.yy = Ce || this.yy || {}, this._input = Re, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
        },
        // consumes and returns one char from the input
        input: function() {
          var Re = this._input[0];
          this.yytext += Re, this.yyleng++, this.offset++, this.match += Re, this.matched += Re;
          var Ce = Re.match(/(?:\r\n?|\n).*/g);
          return Ce ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Re;
        },
        // unshifts one char (or a string) into the input
        unput: function(Re) {
          var Ce = Re.length, ke = Re.split(/(?:\r\n?|\n)/g);
          this._input = Re + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Ce), this.offset -= Ce;
          var st = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), ke.length - 1 && (this.yylineno -= ke.length - 1);
          var lt = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: ke ? (ke.length === st.length ? this.yylloc.first_column : 0) + st[st.length - ke.length].length - ke[0].length : this.yylloc.first_column - Ce
          }, this.options.ranges && (this.yylloc.range = [lt[0], lt[0] + this.yyleng - Ce]), this.yyleng = this.yytext.length, this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function() {
          return this._more = !0, this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function() {
          if (this.options.backtrack_lexer)
            this._backtrack = !0;
          else
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          return this;
        },
        // retain first n characters of the match
        less: function(Re) {
          this.unput(this.match.slice(Re));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function() {
          var Re = this.matched.substr(0, this.matched.length - this.match.length);
          return (Re.length > 20 ? "..." : "") + Re.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function() {
          var Re = this.match;
          return Re.length < 20 && (Re += this._input.substr(0, 20 - Re.length)), (Re.substr(0, 20) + (Re.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function() {
          var Re = this.pastInput(), Ce = new Array(Re.length + 1).join("-");
          return Re + this.upcomingInput() + `
` + Ce + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function(Re, Ce) {
          var ke, st, lt;
          if (this.options.backtrack_lexer && (lt = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          }, this.options.ranges && (lt.yylloc.range = this.yylloc.range.slice(0))), st = Re[0].match(/(?:\r\n?|\n).*/g), st && (this.yylineno += st.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: st ? st[st.length - 1].length - st[st.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Re[0].length
          }, this.yytext += Re[0], this.match += Re[0], this.matches = Re, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Re[0].length), this.matched += Re[0], ke = this.performAction.call(this, this.yy, this, Ce, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), ke)
            return ke;
          if (this._backtrack) {
            for (var Z in lt)
              this[Z] = lt[Z];
            return !1;
          }
          return !1;
        },
        // return next match in input
        next: function() {
          if (this.done)
            return this.EOF;
          this._input || (this.done = !0);
          var Re, Ce, ke, st;
          this._more || (this.yytext = "", this.match = "");
          for (var lt = this._currentRules(), Z = 0; Z < lt.length; Z++)
            if (ke = this._input.match(this.rules[lt[Z]]), ke && (!Ce || ke[0].length > Ce[0].length)) {
              if (Ce = ke, st = Z, this.options.backtrack_lexer) {
                if (Re = this.test_match(ke, lt[Z]), Re !== !1)
                  return Re;
                if (this._backtrack) {
                  Ce = !1;
                  continue;
                } else
                  return !1;
              } else if (!this.options.flex)
                break;
            }
          return Ce ? (Re = this.test_match(Ce, lt[st]), Re !== !1 ? Re : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        },
        // return next match that has a token
        lex: function() {
          var Ce = this.next();
          return Ce || this.lex();
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function(Ce) {
          this.conditionStack.push(Ce);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function() {
          var Ce = this.conditionStack.length - 1;
          return Ce > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function() {
          return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function(Ce) {
          return Ce = this.conditionStack.length - 1 - Math.abs(Ce || 0), Ce >= 0 ? this.conditionStack[Ce] : "INITIAL";
        },
        // alias for begin(condition)
        pushState: function(Ce) {
          this.begin(Ce);
        },
        // return the number of states currently on the stack
        stateStackSize: function() {
          return this.conditionStack.length;
        },
        options: { flex: !0, "case-insensitive": !0 },
        performAction: function(Ce, ke, st, lt) {
          switch (st) {
            case 0:
              break;
            case 1:
              return 12;
            case 2:
              return 15;
            case 3:
              return 41;
            case 4:
              return 325;
            case 5:
              return 326;
            case 6:
              return 45;
            case 7:
              return 47;
            case 8:
              return 48;
            case 9:
              return 39;
            case 10:
              return 24;
            case 11:
              return 28;
            case 12:
              return 29;
            case 13:
              return 31;
            case 14:
              return 32;
            case 15:
              return 36;
            case 16:
              return 53;
            case 17:
              return 327;
            case 18:
              return 63;
            case 19:
              return 64;
            case 20:
              return 70;
            case 21:
              return 73;
            case 22:
              return 76;
            case 23:
              return 78;
            case 24:
              return 81;
            case 25:
              return 83;
            case 26:
              return 85;
            case 27:
              return 193;
            case 28:
              return 100;
            case 29:
              return 328;
            case 30:
              return 121;
            case 31:
              return 329;
            case 32:
              return 330;
            case 33:
              return 110;
            case 34:
              return 331;
            case 35:
              return 109;
            case 36:
              return 332;
            case 37:
              return 333;
            case 38:
              return 113;
            case 39:
              return 115;
            case 40:
              return 116;
            case 41:
              return 131;
            case 42:
              return 123;
            case 43:
              return 126;
            case 44:
              return 128;
            case 45:
              return 132;
            case 46:
              return 112;
            case 47:
              return 334;
            case 48:
              return 335;
            case 49:
              return 159;
            case 50:
              return 161;
            case 51:
              return 164;
            case 52:
              return 174;
            case 53:
              return 160;
            case 54:
              return 336;
            case 55:
              return 163;
            case 56:
              return 312;
            case 57:
              return 314;
            case 58:
              return 317;
            case 59:
              return 318;
            case 60:
              return 272;
            case 61:
              return 197;
            case 62:
              return 337;
            case 63:
              return 338;
            case 64:
              return 229;
            case 65:
              return 340;
            case 66:
              return 263;
            case 67:
              return 224;
            case 68:
              return 231;
            case 69:
              return 232;
            case 70:
              return 242;
            case 71:
              return 246;
            case 72:
              return 290;
            case 73:
              return 341;
            case 74:
              return 342;
            case 75:
              return 343;
            case 76:
              return 344;
            case 77:
              return 345;
            case 78:
              return 250;
            case 79:
              return 346;
            case 80:
              return 265;
            case 81:
              return 276;
            case 82:
              return 277;
            case 83:
              return 268;
            case 84:
              return 269;
            case 85:
              return 270;
            case 86:
              return 271;
            case 87:
              return 347;
            case 88:
              return 348;
            case 89:
              return 273;
            case 90:
              return 274;
            case 91:
              return 350;
            case 92:
              return 349;
            case 93:
              return 351;
            case 94:
              return 279;
            case 95:
              return 280;
            case 96:
              return 283;
            case 97:
              return 285;
            case 98:
              return 289;
            case 99:
              return 293;
            case 100:
              return 296;
            case 101:
              return 13;
            case 102:
              return 16;
            case 103:
              return 308;
            case 104:
              return 309;
            case 105:
              return 87;
            case 106:
              return 292;
            case 107:
              return 82;
            case 108:
              return 294;
            case 109:
              return 295;
            case 110:
              return 297;
            case 111:
              return 298;
            case 112:
              return 299;
            case 113:
              return 300;
            case 114:
              return 301;
            case 115:
              return 302;
            case 116:
              return "EXPONENT";
            case 117:
              return 303;
            case 118:
              return 304;
            case 119:
              return 305;
            case 120:
              return 306;
            case 121:
              return 89;
            case 122:
              return 310;
            case 123:
              return 6;
            case 124:
              return "INVALID";
            case 125:
              console.log(ke.yytext);
              break;
          }
        },
        rules: [/^(?:\s+|(#[^\n\r]*))/i, /^(?:BASE)/i, /^(?:PREFIX)/i, /^(?:SELECT)/i, /^(?:DISTINCT)/i, /^(?:REDUCED)/i, /^(?:\()/i, /^(?:AS)/i, /^(?:\))/i, /^(?:\*)/i, /^(?:CONSTRUCT)/i, /^(?:WHERE)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:DESCRIBE)/i, /^(?:ASK)/i, /^(?:FROM)/i, /^(?:NAMED)/i, /^(?:GROUP)/i, /^(?:BY)/i, /^(?:HAVING)/i, /^(?:ORDER)/i, /^(?:ASC)/i, /^(?:DESC)/i, /^(?:LIMIT)/i, /^(?:OFFSET)/i, /^(?:VALUES)/i, /^(?:;)/i, /^(?:LOAD)/i, /^(?:SILENT)/i, /^(?:INTO)/i, /^(?:CLEAR)/i, /^(?:DROP)/i, /^(?:CREATE)/i, /^(?:ADD)/i, /^(?:TO)/i, /^(?:MOVE)/i, /^(?:COPY)/i, /^(?:INSERT((\s+|(#[^\n\r]*)\n\r?)+)DATA)/i, /^(?:DELETE((\s+|(#[^\n\r]*)\n\r?)+)DATA)/i, /^(?:DELETE((\s+|(#[^\n\r]*)\n\r?)+)WHERE)/i, /^(?:WITH)/i, /^(?:DELETE)/i, /^(?:INSERT)/i, /^(?:USING)/i, /^(?:DEFAULT)/i, /^(?:GRAPH)/i, /^(?:ALL)/i, /^(?:\.)/i, /^(?:OPTIONAL)/i, /^(?:SERVICE)/i, /^(?:BIND)/i, /^(?:UNDEF)/i, /^(?:MINUS)/i, /^(?:UNION)/i, /^(?:FILTER)/i, /^(?:<<)/i, /^(?:>>)/i, /^(?:\{\|)/i, /^(?:\|\})/i, /^(?:,)/i, /^(?:a)/i, /^(?:\|)/i, /^(?:\/)/i, /^(?:\^)/i, /^(?:\?)/i, /^(?:\+)/i, /^(?:!)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:\|\|)/i, /^(?:&&)/i, /^(?:=)/i, /^(?:!=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:IN)/i, /^(?:NOT)/i, /^(?:-)/i, /^(?:BOUND)/i, /^(?:BNODE)/i, /^(?:(RAND|NOW|UUID|STRUUID))/i, /^(?:(LANG|DATATYPE|IRI|URI|ABS|CEIL|FLOOR|ROUND|STRLEN|STR|UCASE|LCASE|ENCODE_FOR_URI|YEAR|MONTH|DAY|HOURS|MINUTES|SECONDS|TIMEZONE|TZ|MD5|SHA1|SHA256|SHA384|SHA512|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC))/i, /^(?:(SUBJECT|PREDICATE|OBJECT|isTRIPLE))/i, /^(?:(LANGMATCHES|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|STRLANG|STRDT|sameTerm))/i, /^(?:CONCAT)/i, /^(?:COALESCE)/i, /^(?:IF)/i, /^(?:TRIPLE)/i, /^(?:REGEX)/i, /^(?:SUBSTR)/i, /^(?:REPLACE)/i, /^(?:EXISTS)/i, /^(?:COUNT)/i, /^(?:SUM|MIN|MAX|AVG|SAMPLE)/i, /^(?:GROUP_CONCAT)/i, /^(?:SEPARATOR)/i, /^(?:\^\^)/i, /^(?:true|false)/i, /^(?:(<(?:[^<>\"\{\}\|\^`\\\u0000-\u0020])*>))/i, /^(?:((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:))/i, /^(?:(((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:)((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|:|[0-9]|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))*(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%)))))?)))/i, /^(?:(_:(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?))/i, /^(?:([\?\$]((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])*)))/i, /^(?:(@[a-zA-Z]+(?:-[a-zA-Z0-9]+)*))/i, /^(?:([0-9]+))/i, /^(?:([0-9]*\.[0-9]+))/i, /^(?:([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+)))/i, /^(?:(\+([0-9]+)))/i, /^(?:(\+([0-9]*\.[0-9]+)))/i, /^(?:(\+([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i, /^(?:(-([0-9]+)))/i, /^(?:(-([0-9]*\.[0-9]+)))/i, /^(?:(-([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i, /^(?:([eE][+-]?[0-9]+))/i, /^(?:('(?:(?:[^\u0027\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*'))/i, /^(?:("(?:(?:[^\u0022\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*"))/i, /^(?:('''(?:(?:'|'')?(?:[^'\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*'''))/i, /^(?:("""(?:(?:"|"")?(?:[^\"\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*"""))/i, /^(?:(\((\u0020|\u0009|\u000D|\u000A)*\)))/i, /^(?:(\[(\u0020|\u0009|\u000D|\u000A)*\]))/i, /^(?:$)/i, /^(?:.)/i, /^(?:.)/i],
        conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125], inclusive: !0 } }
      };
      return Fe;
    }();
    T4.lexer = Aee;
    function Ot() {
      this.yy = {};
    }
    return Ot.prototype = T4, T4.Parser = Ot, new Ot();
  }();
  return _A = u, _A;
}
var gA, IR;
function Rne() {
  if (IR) return gA;
  IR = 1;
  var u = "http://www.w3.org/2001/XMLSchema#integer", r = "http://www.w3.org/2001/XMLSchema#string";
  function o(f) {
    this._options = f = f || {};
    var h = f.prefixes || {};
    this._prefixByIri = {};
    var p = [];
    for (var b in h) {
      var _ = h[b];
      i(_) && (this._prefixByIri[_] = b, p.push(_));
    }
    var y = p.join("|").replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
    this._prefixRegex = new RegExp("^(" + y + ")([a-zA-Z][\\-_a-zA-Z0-9]*)$"), this._usedPrefixes = {}, this._sparqlStar = f.sparqlStar, this._indent = i(f.indent) ? f.indent : "  ", this._newline = i(f.newline) ? f.newline : `
`, this._explicitDatatype = !!f.explicitDatatype;
  }
  o.prototype.toQuery = function(f) {
    var h = "";
    return f.queryType && (h += f.queryType.toUpperCase() + " "), f.reduced && (h += "REDUCED "), f.distinct && (h += "DISTINCT "), f.variables ? h += d(f.variables, void 0, function(p) {
      return /^[?$]/.test(p) ? p : c(p) ? this.toEntity(p) : "(" + this.toExpression(p.expression) + " AS " + n(p.variable) + ")";
    }, this) + " " : f.template && (h += this.group(f.template, !0) + this._newline), f.from && (h += this.graphs("FROM ", f.from.default) + this.graphs("FROM NAMED ", f.from.named)), f.where && (h += "WHERE " + this.group(f.where, !0) + this._newline), f.updates && (h += d(f.updates, ";" + this._newline, this.toUpdate, this)), f.group && (h += "GROUP BY " + d(f.group, void 0, function(p) {
      var b = c(p.expression) ? this.toEntity(p.expression) : "(" + this.toExpression(p.expression) + ")";
      return p.variable ? "(" + b + " AS " + n(p.variable) + ")" : b;
    }, this) + this._newline), f.having && (h += "HAVING (" + d(f.having, void 0, this.toExpression, this) + ")" + this._newline), f.order && (h += "ORDER BY " + d(f.order, void 0, function(p) {
      var b = "(" + this.toExpression(p.expression) + ")";
      return p.descending ? "DESC " + b : b;
    }, this) + this._newline), f.offset && (h += "OFFSET " + f.offset + this._newline), f.limit && (h += "LIMIT " + f.limit + this._newline), f.values && (h += this.values(f)), h = this.baseAndPrefixes(f) + h, h.trim();
  }, o.prototype.baseAndPrefixes = function(f) {
    var h = f.base ? "BASE <" + f.base + ">" + this._newline : "", p = "";
    for (var b in f.prefixes)
      (this._options.allPrefixes || this._usedPrefixes[b]) && (p += "PREFIX " + b + ": <" + f.prefixes[b] + ">" + this._newline);
    return h + p;
  }, o.prototype.toPattern = function(f) {
    var h = f.type || f instanceof Array && "array" || (f.subject && f.predicate && f.object ? "triple" : "");
    if (!(h in this))
      throw new Error("Unknown entry type: " + h);
    return this[h](f);
  }, o.prototype.triple = function(f) {
    return this.toEntity(f.subject) + " " + this.toEntity(f.predicate) + " " + this.toEntity(f.object) + ".";
  }, o.prototype.array = function(f) {
    return d(f, this._newline, this.toPattern, this);
  }, o.prototype.bgp = function(f) {
    return this.encodeTriples(f.triples);
  }, o.prototype.encodeTriples = function(f) {
    if (!f.length)
      return "";
    for (var h = [], p = void 0, b = void 0, _ = 0; _ < f.length; _++) {
      var y = f[_];
      s(y.subject, p) ? s(y.predicate, b) ? h.push(",") : (b = y.predicate, h.push(";" + this._newline, this._indent, this.toEntity(b))) : (p && h.push("." + this._newline), p = y.subject, b = y.predicate, h.push(this.toEntity(p), " ", this.toEntity(b))), h.push(" ", this.toEntity(y.object));
    }
    return h.push("."), h.join("");
  }, o.prototype.graph = function(f) {
    return "GRAPH " + this.toEntity(f.name) + " " + this.group(f);
  }, o.prototype.graphs = function(f, h) {
    return !h || h.length === 0 ? "" : d(h, "", function(p) {
      return f + this.toEntity(p) + this._newline;
    }, this);
  }, o.prototype.group = function(f, h) {
    return f = h !== !0 ? this.array(f.patterns || f.triples) : this.toPattern(f.type !== "group" ? f : f.patterns), f.indexOf(this._newline) === -1 ? "{ " + f + " }" : "{" + this._newline + this.indent(f) + this._newline + "}";
  }, o.prototype.query = function(f) {
    return this.toQuery(f);
  }, o.prototype.filter = function(f) {
    return "FILTER(" + this.toExpression(f.expression) + ")";
  }, o.prototype.bind = function(f) {
    return "BIND(" + this.toExpression(f.expression) + " AS " + n(f.variable) + ")";
  }, o.prototype.optional = function(f) {
    return "OPTIONAL " + this.group(f);
  }, o.prototype.union = function(f) {
    return d(f.patterns, this._newline + "UNION" + this._newline, function(h) {
      return this.group(h, !0);
    }, this);
  }, o.prototype.minus = function(f) {
    return "MINUS " + this.group(f);
  }, o.prototype.values = function(f) {
    var h = Object.keys(f.values.reduce(function(_, y) {
      for (var m in y) _[m] = !0;
      return _;
    }, {})), p, b;
    return h.length === 1 ? p = b = "" : (p = "(", b = ")"), "VALUES " + p + h.join(" ") + b + " {" + this._newline + d(f.values, this._newline, function(_) {
      return "  " + p + d(h, void 0, function(y) {
        return _[y] ? this.toEntity(_[y]) : "UNDEF";
      }, this) + b;
    }, this) + this._newline + "}";
  }, o.prototype.service = function(f) {
    return "SERVICE " + (f.silent ? "SILENT " : "") + this.toEntity(f.name) + " " + this.group(f);
  }, o.prototype.toExpression = function(f) {
    if (c(f))
      return this.toEntity(f);
    switch (f.type.toLowerCase()) {
      case "aggregate":
        return f.aggregation.toUpperCase() + "(" + (f.distinct ? "DISTINCT " : "") + this.toExpression(f.expression) + (typeof f.separator == "string" ? '; SEPARATOR = "' + f.separator.replace(a, t) + '"' : "") + ")";
      case "functioncall":
        return this.toEntity(f.function) + "(" + d(f.args, ", ", this.toExpression, this) + ")";
      case "operation":
        var h = f.operator.toUpperCase(), p = f.args || [];
        switch (f.operator.toLowerCase()) {
          // Infix operators
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "&&":
          case "||":
          case "=":
          case "!=":
          case "+":
          case "-":
          case "*":
          case "/":
            return (c(p[0]) ? this.toEntity(p[0]) : "(" + this.toExpression(p[0]) + ")") + " " + h + " " + (c(p[1]) ? this.toEntity(p[1]) : "(" + this.toExpression(p[1]) + ")");
          // Unary operators
          case "!":
            return "!(" + this.toExpression(p[0]) + ")";
          case "uplus":
            return "+(" + this.toExpression(p[0]) + ")";
          case "uminus":
            return "-(" + this.toExpression(p[0]) + ")";
          // IN and NOT IN
          case "notin":
            h = "NOT IN";
          case "in":
            return this.toExpression(p[0]) + " " + h + "(" + (i(p[1]) ? p[1] : d(p[1], ", ", this.toExpression, this)) + ")";
          // EXISTS and NOT EXISTS
          case "notexists":
            h = "NOT EXISTS";
          case "exists":
            return h + " " + this.group(p[0], !0);
          // Other expressions
          default:
            return h + "(" + d(p, ", ", this.toExpression, this) + ")";
        }
      default:
        throw new Error("Unknown expression type: " + f.type);
    }
  }, o.prototype.toEntity = function(f) {
    if (c(f))
      switch (f.termType) {
        // variable, * selector, or blank node
        case "Wildcard":
          return "*";
        case "Variable":
          return n(f);
        case "BlankNode":
          return "_:" + f.value;
        // literal
        case "Literal":
          var h = f.value || "", p = f.language || "", b = f.datatype;
          if (f = '"' + h.replace(a, t) + '"', p)
            f += "@" + p;
          else if (b) {
            if (!this._explicitDatatype)
              switch (b.value) {
                case r:
                  return f;
                case u:
                  if (/^\d+$/.test(h))
                    return h + " ";
              }
            f += "^^" + this.encodeIRI(b.value);
          }
          return f;
        case "Quad":
          if (!this._sparqlStar)
            throw new Error("SPARQL* support is not enabled");
          return f.graph && f.graph.termType !== "DefaultGraph" ? "<< GRAPH " + this.toEntity(f.graph) + " { " + this.toEntity(f.subject) + " " + this.toEntity(f.predicate) + " " + this.toEntity(f.object) + " }  >>" : "<< " + this.toEntity(f.subject) + " " + this.toEntity(f.predicate) + " " + this.toEntity(f.object) + " >>";
        // IRI
        default:
          return this.encodeIRI(f.value);
      }
    else {
      var _ = f.items.map(this.toEntity, this), y = f.pathType;
      switch (y) {
        // prefix operator
        case "^":
        case "!":
          return y + _[0];
        // postfix operator
        case "*":
        case "+":
        case "?":
          return "(" + _[0] + y + ")";
        // infix operator
        default:
          return "(" + _.join(y) + ")";
      }
    }
  };
  var a = /["\\\t\n\r\b\f]/g, t = function(f) {
    return e[f];
  }, e = {
    "\\": "\\\\",
    '"': '\\"',
    "	": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\b": "\\b",
    "\f": "\\f"
  };
  o.prototype.encodeIRI = function(f) {
    var h = this._prefixRegex.exec(f);
    if (h) {
      var p = this._prefixByIri[h[1]];
      return this._usedPrefixes[p] = !0, p + ":" + h[2];
    }
    return "<" + f + ">";
  }, o.prototype.toUpdate = function(f) {
    switch (f.type || f.updateType) {
      case "load":
        return "LOAD" + (f.source ? " " + this.toEntity(f.source) : "") + (f.destination ? " INTO GRAPH " + this.toEntity(f.destination) : "");
      case "insert":
        return "INSERT DATA " + this.group(f.insert, !0);
      case "delete":
        return "DELETE DATA " + this.group(f.delete, !0);
      case "deletewhere":
        return "DELETE WHERE " + this.group(f.delete, !0);
      case "insertdelete":
        return (f.graph ? "WITH " + this.toEntity(f.graph) + this._newline : "") + (f.delete.length ? "DELETE " + this.group(f.delete, !0) + this._newline : "") + (f.insert.length ? "INSERT " + this.group(f.insert, !0) + this._newline : "") + (f.using ? this.graphs("USING ", f.using.default) : "") + (f.using ? this.graphs("USING NAMED ", f.using.named) : "") + "WHERE " + this.group(f.where, !0);
      case "add":
      case "copy":
      case "move":
        return f.type.toUpperCase() + " " + (f.silent ? "SILENT " : "") + (f.source.default ? "DEFAULT" : this.toEntity(f.source.name)) + " TO " + this.toEntity(f.destination.name);
      case "create":
      case "clear":
      case "drop":
        return f.type.toUpperCase() + (f.silent ? " SILENT " : " ") + (f.graph.default ? "DEFAULT" : f.graph.named ? "NAMED" : f.graph.all ? "ALL" : "GRAPH " + this.toEntity(f.graph.name));
      default:
        throw new Error("Unknown update query type: " + f.type);
    }
  }, o.prototype.indent = function(f) {
    return f.replace(/^/gm, this._indent);
  };
  function n(f) {
    return "?" + f.value;
  }
  function i(f) {
    return typeof f == "string";
  }
  function c(f) {
    return typeof f.termType == "string";
  }
  function s(f, h) {
    if (!f || !c(f) || !h || !c(h) || f.termType !== h.termType)
      return !1;
    switch (f.termType) {
      case "Literal":
        return f.value === h.value && f.language === h.language && s(f.datatype, h.datatype);
      case "Quad":
        return s(f.subject, h.subject) && s(f.predicate, h.predicate) && s(f.object, h.object) && s(f.graph, h.graph);
      default:
        return f.value === h.value;
    }
  }
  function d(f, h, p, b) {
    return f.map(p, b).join(i(h) ? h : " ");
  }
  function l(f = {}) {
    return {
      stringify: function(h) {
        var p = Object.create(f);
        return p.prefixes = h.prefixes, new o(p).toQuery(h);
      },
      createGenerator: function() {
        return new o(f);
      }
    };
  }
  return gA = {
    Generator: l
  }, gA;
}
var mA, RR;
function _w() {
  if (RR) return mA;
  RR = 1;
  const { Parser: u } = Ine(), { Generator: r } = Rne(), { Wildcard: o } = UK(), { DataFactory: a } = Or();
  function t({
    prefixes: e,
    baseIRI: n,
    factory: i,
    pathOnly: c,
    sparqlStar: s,
    skipValidation: d,
    skipUngroupedVariableCheck: l
  } = {}) {
    const f = {};
    for (const p in e ?? {})
      f[p] = e[p];
    const h = new u();
    return h.parse = function() {
      return u.base = n || "", u.prefixes = Object.create(f), u.factory = i || new a(), u.sparqlStar = !!s, u.pathOnly = !!c, u.skipValidation = !!d || !!l, u.prototype.parse.apply(h, arguments);
    }, h._resetBlanks = u._resetBlanks, h;
  }
  return mA = {
    Parser: t,
    Generator: r,
    Wildcard: o
  }, mA;
}
var FR;
function zS() {
  if (FR) return Ai;
  FR = 1;
  var u = Ai && Ai.__createBinding || (Object.create ? function(c, s, d, l) {
    l === void 0 && (l = d);
    var f = Object.getOwnPropertyDescriptor(s, d);
    (!f || ("get" in f ? !s.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return s[d];
    } }), Object.defineProperty(c, l, f);
  } : function(c, s, d, l) {
    l === void 0 && (l = d), c[l] = s[d];
  }), r = Ai && Ai.__setModuleDefault || (Object.create ? function(c, s) {
    Object.defineProperty(c, "default", { enumerable: !0, value: s });
  } : function(c, s) {
    c.default = s;
  }), o = Ai && Ai.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var s = {};
    if (c != null) for (var d in c) d !== "default" && Object.prototype.hasOwnProperty.call(c, d) && u(s, c, d);
    return r(s, c), s;
  };
  Object.defineProperty(Ai, "__esModule", { value: !0 });
  const a = o(yw()), t = Or(), e = lr(), n = _w();
  class i {
    constructor(s) {
      this.dataFactory = s || new t.DataFactory(), this.stringType = this.createTerm("http://www.w3.org/2001/XMLSchema#string");
    }
    createAlt(s, d = !0) {
      return this.flattenMulti({ type: a.types.ALT, input: s }, d);
    }
    createAsk(s) {
      return { type: a.types.ASK, input: s };
    }
    createBoundAggregate(s, d, l, f, h) {
      const p = this.createAggregateExpression(d, l, f, h);
      return p.variable = s, p;
    }
    createBgp(s) {
      return { type: a.types.BGP, patterns: s };
    }
    createConstruct(s, d) {
      return { type: a.types.CONSTRUCT, input: s, template: d };
    }
    createDescribe(s, d) {
      return { type: a.types.DESCRIBE, input: s, terms: d };
    }
    createDistinct(s) {
      return { type: a.types.DISTINCT, input: s };
    }
    createExtend(s, d, l) {
      return { type: a.types.EXTEND, input: s, variable: d, expression: l };
    }
    createFrom(s, d, l) {
      return { type: a.types.FROM, input: s, default: d, named: l };
    }
    createFilter(s, d) {
      return { type: a.types.FILTER, input: s, expression: d };
    }
    createGraph(s, d) {
      return { type: a.types.GRAPH, input: s, name: d };
    }
    createGroup(s, d, l) {
      return { type: a.types.GROUP, input: s, variables: d, aggregates: l };
    }
    createInv(s) {
      return { type: a.types.INV, path: s };
    }
    createJoin(s, d = !0) {
      return this.flattenMulti({ type: a.types.JOIN, input: s }, d);
    }
    createLeftJoin(s, d, l) {
      return l ? { type: a.types.LEFT_JOIN, input: [s, d], expression: l } : { type: a.types.LEFT_JOIN, input: [s, d] };
    }
    createLink(s) {
      return { type: a.types.LINK, iri: s };
    }
    createMinus(s, d) {
      return { type: a.types.MINUS, input: [s, d] };
    }
    createNop() {
      return { type: a.types.NOP };
    }
    createNps(s) {
      return { type: a.types.NPS, iris: s };
    }
    createOneOrMorePath(s) {
      return { type: a.types.ONE_OR_MORE_PATH, path: s };
    }
    createOrderBy(s, d) {
      return { type: a.types.ORDER_BY, input: s, expressions: d };
    }
    createPath(s, d, l, f) {
      return f ? { type: a.types.PATH, subject: s, predicate: d, object: l, graph: f } : { type: a.types.PATH, subject: s, predicate: d, object: l, graph: this.dataFactory.defaultGraph() };
    }
    createPattern(s, d, l, f) {
      const h = this.dataFactory.quad(s, d, l, f);
      return h.type = a.types.PATTERN, h;
    }
    createProject(s, d) {
      return { type: a.types.PROJECT, input: s, variables: d };
    }
    createReduced(s) {
      return { type: a.types.REDUCED, input: s };
    }
    createSeq(s, d = !0) {
      return this.flattenMulti({ type: a.types.SEQ, input: s }, d);
    }
    createService(s, d, l) {
      return { type: a.types.SERVICE, input: s, name: d, silent: !!l };
    }
    createSlice(s, d, l) {
      return d = d || 0, l !== void 0 ? { type: a.types.SLICE, input: s, start: d, length: l } : { type: a.types.SLICE, input: s, start: d };
    }
    createUnion(s, d = !0) {
      return this.flattenMulti({ type: a.types.UNION, input: s }, d);
    }
    createValues(s, d) {
      return { type: a.types.VALUES, variables: s, bindings: d };
    }
    createZeroOrMorePath(s) {
      return { type: a.types.ZERO_OR_MORE_PATH, path: s };
    }
    createZeroOrOnePath(s) {
      return { type: a.types.ZERO_OR_ONE_PATH, path: s };
    }
    createAggregateExpression(s, d, l, f) {
      return f ? { type: a.types.EXPRESSION, expressionType: a.expressionTypes.AGGREGATE, aggregator: s, expression: d, separator: f, distinct: l } : { type: a.types.EXPRESSION, expressionType: a.expressionTypes.AGGREGATE, aggregator: s, expression: d, distinct: l };
    }
    createExistenceExpression(s, d) {
      return { type: a.types.EXPRESSION, expressionType: a.expressionTypes.EXISTENCE, not: s, input: d };
    }
    createNamedExpression(s, d) {
      return { type: a.types.EXPRESSION, expressionType: a.expressionTypes.NAMED, name: s, args: d };
    }
    createOperatorExpression(s, d) {
      return { type: a.types.EXPRESSION, expressionType: a.expressionTypes.OPERATOR, operator: s, args: d };
    }
    createTermExpression(s) {
      return { type: a.types.EXPRESSION, expressionType: a.expressionTypes.TERM, term: s };
    }
    createWildcardExpression() {
      return { type: a.types.EXPRESSION, expressionType: a.expressionTypes.WILDCARD, wildcard: new n.Wildcard() };
    }
    createTerm(s) {
      return s[0] === "$" && (s = s.replace("$", "?")), (0, e.stringToTerm)(s, this.dataFactory);
    }
    // Update functions
    createCompositeUpdate(s) {
      return { type: a.types.COMPOSITE_UPDATE, updates: s };
    }
    createDeleteInsert(s, d, l) {
      const f = { type: a.types.DELETE_INSERT };
      return s && (f.delete = s), d && (f.insert = d), l && (f.where = l), f;
    }
    createLoad(s, d, l) {
      const f = { type: a.types.LOAD, source: s };
      return d && (f.destination = d), this.addSilent(f, !!l);
    }
    createClear(s, d) {
      return this.addSilent({ type: a.types.CLEAR, source: s }, !!d);
    }
    createCreate(s, d) {
      return this.addSilent({ type: a.types.CREATE, source: s }, !!d);
    }
    createDrop(s, d) {
      return this.addSilent({ type: a.types.DROP, source: s }, !!d);
    }
    createAdd(s, d, l) {
      return this.addSilent({ type: a.types.ADD, source: s, destination: d }, !!l);
    }
    createMove(s, d, l) {
      return this.addSilent({ type: a.types.MOVE, source: s, destination: d }, !!l);
    }
    createCopy(s, d, l) {
      return this.addSilent({ type: a.types.COPY, source: s, destination: d }, !!l);
    }
    addSilent(s, d) {
      return d && (s.silent = d), s;
    }
    flattenMulti(s, d) {
      if (!d)
        return s;
      const l = s.type, f = s.input;
      let h = [];
      for (const p of f)
        p.type === l ? h.push(...p.input) : h.push(p);
      return s.input = h, s;
    }
  }
  return Ai.default = i, Ai;
}
var g0 = {}, Nu = {}, dt = {}, NR;
function VK() {
  if (NR) return dt;
  NR = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.matchPatternMappings = dt.matchPatternComplete = dt.matchPattern = dt.matchTerm = dt.getValueNestedPath = dt.someTermsNested = dt.someTerms = dt.everyTermsNested = dt.everyTerms = dt.reduceTermsNested = dt.reduceTerms = dt.mapTermsNested = dt.mapTerms = dt.filterQuadTermNamesNested = dt.filterQuadTermNames = dt.filterTermsNested = dt.filterTerms = dt.forEachTermsNested = dt.forEachTerms = dt.collectNamedTerms = dt.getNamedTerms = dt.getTermsNested = dt.getTerms = dt.TRIPLE_TERM_NAMES = dt.QUAD_TERM_NAMES = void 0;
  const u = Or(), r = new u.DataFactory();
  dt.QUAD_TERM_NAMES = ["subject", "predicate", "object", "graph"], dt.TRIPLE_TERM_NAMES = ["subject", "predicate", "object"];
  function o(A, w) {
    return w && A.graph.termType === "DefaultGraph" ? [A.subject, A.predicate, A.object] : [A.subject, A.predicate, A.object, A.graph];
  }
  dt.getTerms = o;
  function a(A, w) {
    const S = [];
    for (const O of o(A, w))
      O.termType === "Quad" ? a(O, w).forEach((x) => S.push(x)) : S.push(O);
    return S;
  }
  dt.getTermsNested = a;
  function t(A) {
    return [
      { key: "subject", value: A.subject },
      { key: "predicate", value: A.predicate },
      { key: "object", value: A.object },
      { key: "graph", value: A.graph }
    ];
  }
  dt.getNamedTerms = t;
  function e(A, w, S) {
    const O = {};
    return A.forEach((x) => O[x.key] = x.value), w && (O.subject = O.subject || w("subject"), O.predicate = O.predicate || w("predicate"), O.object = O.object || w("object"), O.graph = O.graph || w("graph")), (S || r).quad(O.subject, O.predicate, O.object, O.graph);
  }
  dt.collectNamedTerms = e;
  function n(A, w) {
    w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph");
  }
  dt.forEachTerms = n;
  function i(A, w, S = []) {
    A.subject.termType === "Quad" ? i(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"]), A.predicate.termType === "Quad" ? i(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"]), A.object.termType === "Quad" ? i(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"]), A.graph.termType === "Quad" ? i(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]);
  }
  dt.forEachTermsNested = i;
  function c(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push(A.subject), w(A.predicate, "predicate") && S.push(A.predicate), w(A.object, "object") && S.push(A.object), w(A.graph, "graph") && S.push(A.graph), S;
  }
  dt.filterTerms = c;
  function s(A, w, S = []) {
    let O = [];
    return A.subject.termType === "Quad" ? O = [...O, ...s(A.subject, w, [...S, "subject"])] : w(A.subject, [...S, "subject"]) && O.push(A.subject), A.predicate.termType === "Quad" ? O = [...O, ...s(A.predicate, w, [...S, "predicate"])] : w(A.predicate, [...S, "predicate"]) && O.push(A.predicate), A.object.termType === "Quad" ? O = [...O, ...s(A.object, w, [...S, "object"])] : w(A.object, [...S, "object"]) && O.push(A.object), A.graph.termType === "Quad" ? O = [...O, ...s(A.graph, w, [...S, "graph"])] : w(A.graph, [...S, "graph"]) && O.push(A.graph), O;
  }
  dt.filterTermsNested = s;
  function d(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push("subject"), w(A.predicate, "predicate") && S.push("predicate"), w(A.object, "object") && S.push("object"), w(A.graph, "graph") && S.push("graph"), S;
  }
  dt.filterQuadTermNames = d;
  function l(A, w, S = []) {
    let O = [];
    const x = [...S, "subject"];
    A.subject.termType === "Quad" ? O = [...O, ...l(A.subject, w, x)] : w(A.subject, x) && O.push(x);
    const F = [...S, "predicate"];
    A.predicate.termType === "Quad" ? O = [...O, ...l(A.predicate, w, F)] : w(A.predicate, F) && O.push(F);
    const j = [...S, "object"];
    A.object.termType === "Quad" ? O = [...O, ...l(A.object, w, j)] : w(A.object, j) && O.push(j);
    const q = [...S, "graph"];
    return A.graph.termType === "Quad" ? O = [...O, ...l(A.graph, w, q)] : w(A.graph, q) && O.push(q), O;
  }
  dt.filterQuadTermNamesNested = l;
  function f(A, w, S) {
    return (S || r).quad(w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph"));
  }
  dt.mapTerms = f;
  function h(A, w, S, O = []) {
    return (S || r).quad(A.subject.termType === "Quad" ? h(A.subject, w, S, [...O, "subject"]) : w(A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? h(A.predicate, w, S, [...O, "predicate"]) : w(A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? h(A.object, w, S, [...O, "object"]) : w(A.object, [...O, "object"]), A.graph.termType === "Quad" ? h(A.graph, w, S, [...O, "graph"]) : w(A.graph, [...O, "graph"]));
  }
  dt.mapTermsNested = h;
  function p(A, w, S) {
    let O = S;
    return O = w(O, A.subject, "subject"), O = w(O, A.predicate, "predicate"), O = w(O, A.object, "object"), w(O, A.graph, "graph");
  }
  dt.reduceTerms = p;
  function b(A, w, S, O = []) {
    let x = S;
    return A.subject.termType === "Quad" ? x = b(A.subject, w, x, [...O, "subject"]) : x = w(x, A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? x = b(A.predicate, w, x, [...O, "predicate"]) : x = w(x, A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? x = b(A.object, w, x, [...O, "object"]) : x = w(x, A.object, [...O, "object"]), A.graph.termType === "Quad" ? x = b(A.graph, w, x, [...O, "graph"]) : x = w(x, A.graph, [...O, "graph"]), x;
  }
  dt.reduceTermsNested = b;
  function _(A, w) {
    return w(A.subject, "subject") && w(A.predicate, "predicate") && w(A.object, "object") && w(A.graph, "graph");
  }
  dt.everyTerms = _;
  function y(A, w, S = []) {
    return (A.subject.termType === "Quad" ? y(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) && (A.predicate.termType === "Quad" ? y(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) && (A.object.termType === "Quad" ? y(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) && (A.graph.termType === "Quad" ? y(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  dt.everyTermsNested = y;
  function m(A, w) {
    return w(A.subject, "subject") || w(A.predicate, "predicate") || w(A.object, "object") || w(A.graph, "graph");
  }
  dt.someTerms = m;
  function g(A, w, S = []) {
    return (A.subject.termType === "Quad" ? g(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) || (A.predicate.termType === "Quad" ? g(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) || (A.object.termType === "Quad" ? g(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) || (A.graph.termType === "Quad" ? g(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  dt.someTermsNested = g;
  function T(A, w) {
    if (w.length === 0)
      return A;
    if (A.termType === "Quad")
      return T(A[w[0]], w.slice(1));
    throw new Error(`Tried to get ${w[0]} from term of type ${A.termType}`);
  }
  dt.getValueNestedPath = T;
  function v(A, w) {
    return !w || w.termType === "Variable" || w.termType === "Quad" && A.termType === "Quad" && R(A, w) || w.equals(A);
  }
  dt.matchTerm = v;
  function E(A, w, S, O, x) {
    return v(A.subject, w) && v(A.predicate, S) && v(A.object, O) && v(A.graph, x);
  }
  dt.matchPattern = E;
  function R(A, w) {
    return E(A, w.subject, w.predicate, w.object, w.graph);
  }
  dt.matchPatternComplete = R;
  function L(A, w, S = {}) {
    const O = {};
    function x(F, j) {
      return _(F, (q, Q) => {
        var G, K;
        const U = j[Q];
        switch (q.termType) {
          case "Variable":
            return S.skipVarMapping && U.termType === "Variable" || ((K = (G = O[q.value]) === null || G === void 0 ? void 0 : G.equals(U)) !== null && K !== void 0 ? K : (O[q.value] = U, !0));
          case "Quad":
            return U.termType === "Quad" && x(q, U);
          default:
            return q.equals(U);
        }
      });
    }
    return x(w, A) && (S.returnMappings ? O : !0);
  }
  return dt.matchPatternMappings = L, dt;
}
var br = {}, PR;
function Fne() {
  if (PR) return br;
  PR = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.getQuads = br.getDefaultGraphs = br.getVariables = br.getLiterals = br.getBlankNodes = br.getNamedNodes = br.getTermsOfType = br.uniqTerms = br.TERM_TYPES = void 0;
  const u = lr();
  br.TERM_TYPES = ["NamedNode", "BlankNode", "Literal", "Variable", "DefaultGraph", "Quad"];
  function r(s) {
    const d = {};
    return s.filter((l) => {
      const f = (0, u.termToString)(l);
      return !(f in d) && (d[f] = !0);
    });
  }
  br.uniqTerms = r;
  function o(s, d) {
    return s.filter((l) => l.termType === d);
  }
  br.getTermsOfType = o;
  function a(s) {
    return o(s, "NamedNode");
  }
  br.getNamedNodes = a;
  function t(s) {
    return o(s, "BlankNode");
  }
  br.getBlankNodes = t;
  function e(s) {
    return o(s, "Literal");
  }
  br.getLiterals = e;
  function n(s) {
    return o(s, "Variable");
  }
  br.getVariables = n;
  function i(s) {
    return o(s, "DefaultGraph");
  }
  br.getDefaultGraphs = i;
  function c(s) {
    return o(s, "Quad");
  }
  return br.getQuads = c, br;
}
var DR;
function zn() {
  return DR || (DR = 1, function(u) {
    var r = Nu && Nu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Nu && Nu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(VK(), u), o(Fne(), u);
  }(Nu)), Nu;
}
var LR;
function _8() {
  if (LR) return g0;
  LR = 1;
  var u = g0 && g0.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(g0, "__esModule", { value: !0 });
  const r = yw(), o = u(zS()), a = zn();
  class t {
    /**
     * Flattens an array of arrays to an array.
     * @param arr - Array of arrays
     */
    static flatten(n) {
      return Array.prototype.concat(...n).filter((i) => i);
    }
    /**
     * Outputs a JSON object corresponding to the input algebra-like.
     */
    static objectify(n) {
      if (n.termType) {
        if (n.termType === "Quad")
          return {
            type: "pattern",
            termType: "Quad",
            subject: t.objectify(n.subject),
            predicate: t.objectify(n.predicate),
            object: t.objectify(n.object),
            graph: t.objectify(n.graph)
          };
        {
          let i = { termType: n.termType, value: n.value };
          return n.language && (i.language = n.language), n.datatype && (i.datatype = t.objectify(n.datatype)), i;
        }
      }
      if (Array.isArray(n))
        return n.map((i) => t.objectify(i));
      if (n === Object(n)) {
        let i = {};
        for (let c of Object.keys(n))
          i[c] = t.objectify(n[c]);
        return i;
      }
      return n;
    }
    /**
     * Detects all in-scope variables.
     * In practice this means iterating through the entire algebra tree, finding all variables,
     * and stopping when a project function is found.
     * @param {Operation} op - Input algebra tree.
     * @returns {Variable[]} - List of unique in-scope variables.
     */
    static inScopeVariables(n) {
      const i = [];
      function c(d) {
        i.find((l) => d.value === l.value) || i.push(d);
      }
      function s(d) {
        d.subject.termType === "Variable" && c(d.subject), d.predicate.termType === "Variable" && c(d.predicate), d.object.termType === "Variable" && c(d.object), d.graph.termType === "Variable" && c(d.graph), d.subject.termType === "Quad" && s(d.subject), d.predicate.termType === "Quad" && s(d.predicate), d.object.termType === "Quad" && s(d.object), d.graph.termType === "Quad" && s(d.graph);
      }
      return t.recurseOperation(n, {
        [r.types.EXPRESSION]: (d) => (d.expressionType === r.expressionTypes.AGGREGATE && d.variable && c(d.variable), !0),
        [r.types.EXTEND]: (d) => (c(d.variable), !0),
        [r.types.GRAPH]: (d) => (d.name.termType === "Variable" && c(d.name), !0),
        [r.types.GROUP]: (d) => (d.variables.forEach(c), !0),
        [r.types.PATH]: (d) => (d.subject.termType === "Variable" && c(d.subject), d.object.termType === "Variable" && c(d.object), d.graph.termType === "Variable" && c(d.graph), d.subject.termType === "Quad" && s(d.subject), d.object.termType === "Quad" && s(d.object), d.graph.termType === "Quad" && s(d.graph), !0),
        [r.types.PATTERN]: (d) => (s(d), !0),
        [r.types.PROJECT]: (d) => (d.variables.forEach(c), !1),
        [r.types.SERVICE]: (d) => (d.name.termType === "Variable" && c(d.name), !0),
        [r.types.VALUES]: (d) => (d.variables.forEach(c), !0)
      }), i;
    }
    /**
     * Recurses through the given algebra tree
     * A map of callback functions can be provided for individual Operation types to gather data.
     * The return value of those callbacks should indicate whether recursion should be applied or not.
     * Making modifications will change the original input object.
     * @param {Operation} op - The Operation to recurse on.
     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.
     */
    static recurseOperation(n, i) {
      let c = n, s = !0;
      const d = i[n.type];
      if (d && (s = d(n)), !s)
        return;
      let l = (f) => t.recurseOperation(f, i);
      switch (c.type) {
        case r.types.ALT:
          c.input.map(l);
          break;
        case r.types.ASK:
          l(c.input);
          break;
        case r.types.BGP:
          c.patterns.forEach(l);
          break;
        case r.types.CONSTRUCT:
          l(c.input), c.template.map(l);
          break;
        case r.types.DESCRIBE:
          l(c.input);
          break;
        case r.types.DISTINCT:
          l(c.input);
          break;
        case r.types.EXPRESSION:
          c.expressionType === r.expressionTypes.EXISTENCE && l(c.input);
          break;
        case r.types.EXTEND:
          l(c.input), l(c.expression);
          break;
        case r.types.FILTER:
          l(c.input), l(c.expression);
          break;
        case r.types.FROM:
          l(c.input);
          break;
        case r.types.GRAPH:
          l(c.input);
          break;
        case r.types.GROUP:
          l(c.input), c.aggregates.forEach(l);
          break;
        case r.types.INV:
          l(c.path);
          break;
        case r.types.JOIN:
          c.input.map(l);
          break;
        case r.types.LEFT_JOIN:
          c.input.map(l), c.expression && l(c.expression);
          break;
        case r.types.LINK:
          break;
        case r.types.MINUS:
          c.input.map(l);
          break;
        case r.types.NOP:
          break;
        case r.types.NPS:
          break;
        case r.types.ONE_OR_MORE_PATH:
          l(c.path);
          break;
        case r.types.ORDER_BY:
          l(c.input), c.expressions.forEach(l);
          break;
        case r.types.PATH:
          l(c.predicate);
          break;
        case r.types.PATTERN:
          break;
        case r.types.PROJECT:
          l(c.input);
          break;
        case r.types.REDUCED:
          l(c.input);
          break;
        case r.types.SEQ:
          c.input.map(l);
          break;
        case r.types.SERVICE:
          l(c.input);
          break;
        case r.types.SLICE:
          l(c.input);
          break;
        case r.types.UNION:
          c.input.map(l);
          break;
        case r.types.VALUES:
          break;
        case r.types.ZERO_OR_MORE_PATH:
          l(c.path);
          break;
        case r.types.ZERO_OR_ONE_PATH:
          l(c.path);
          break;
        // UPDATE operations
        case r.types.COMPOSITE_UPDATE:
          c.updates.forEach((f) => l(f));
          break;
        case r.types.DELETE_INSERT:
          c.delete && c.delete.forEach((f) => l(f)), c.insert && c.insert.forEach((f) => l(f)), c.where && l(c.where);
          break;
        // all of these only have graph IDs as values
        case r.types.LOAD:
          break;
        case r.types.CLEAR:
          break;
        case r.types.CREATE:
          break;
        case r.types.DROP:
          break;
        case r.types.ADD:
          break;
        case r.types.MOVE:
          break;
        case r.types.COPY:
          break;
        default:
          throw new Error(`Unknown Operation type ${c.type}`);
      }
    }
    /**
     * Creates a deep copy of the given Operation.
     * Creates shallow copies of the non-Operation values.
     * A map of callback functions can be provided for individual Operation types
     * to specifically modify the given objects before triggering recursion.
     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.
     * @param {Operation} op - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapOperation(n, i, c) {
      let s = n, d = !0, l = !0;
      c = c || new o.default();
      const f = i[n.type];
      if (f) {
        const b = f(n, c);
        s = b.result, d = b.recurse, l = b.copyMetadata !== !1;
      }
      let h;
      if (l && (s.metadata || n.metadata) && (h = { ...s.metadata, ...n.metadata }), !d)
        return h && (s.metadata = h), s;
      let p = (b) => t.mapOperation(b, i, c);
      switch (s.type) {
        case r.types.ALT:
          s = c.createAlt(s.input.map(p));
          break;
        case r.types.ASK:
          s = c.createAsk(p(s.input));
          break;
        case r.types.BGP:
          s = c.createBgp(s.patterns.map(p));
          break;
        case r.types.CONSTRUCT:
          s = c.createConstruct(p(s.input), s.template.map(p));
          break;
        case r.types.DESCRIBE:
          s = c.createDescribe(p(s.input), s.terms);
          break;
        case r.types.DISTINCT:
          s = c.createDistinct(p(s.input));
          break;
        case r.types.EXPRESSION:
          s = t.mapExpression(s, i, c);
          break;
        case r.types.EXTEND:
          s = c.createExtend(p(s.input), s.variable, p(s.expression));
          break;
        case r.types.FILTER:
          s = c.createFilter(p(s.input), p(s.expression));
          break;
        case r.types.FROM:
          s = c.createFrom(p(s.input), [...s.default], [...s.named]);
          break;
        case r.types.GRAPH:
          s = c.createGraph(p(s.input), s.name);
          break;
        case r.types.GROUP:
          s = c.createGroup(p(s.input), [].concat(s.variables), s.aggregates.map(p));
          break;
        case r.types.INV:
          s = c.createInv(p(s.path));
          break;
        case r.types.JOIN:
          s = c.createJoin(s.input.map(p));
          break;
        case r.types.LEFT_JOIN:
          s = c.createLeftJoin(p(s.input[0]), p(s.input[1]), s.expression ? p(s.expression) : void 0);
          break;
        case r.types.LINK:
          s = c.createLink(s.iri);
          break;
        case r.types.MINUS:
          s = c.createMinus(p(s.input[0]), p(s.input[1]));
          break;
        case r.types.NOP:
          s = c.createNop();
          break;
        case r.types.NPS:
          s = c.createNps([].concat(s.iris));
          break;
        case r.types.ONE_OR_MORE_PATH:
          s = c.createOneOrMorePath(p(s.path));
          break;
        case r.types.ORDER_BY:
          s = c.createOrderBy(p(s.input), s.expressions.map(p));
          break;
        case r.types.PATH:
          s = c.createPath(s.subject, p(s.predicate), s.object, s.graph);
          break;
        case r.types.PATTERN:
          s = c.createPattern(s.subject, s.predicate, s.object, s.graph);
          break;
        case r.types.PROJECT:
          s = c.createProject(p(s.input), [...s.variables]);
          break;
        case r.types.REDUCED:
          s = c.createReduced(p(s.input));
          break;
        case r.types.SEQ:
          s = c.createSeq(s.input.map(p));
          break;
        case r.types.SERVICE:
          s = c.createService(p(s.input), s.name, s.silent);
          break;
        case r.types.SLICE:
          s = c.createSlice(p(s.input), s.start, s.length);
          break;
        case r.types.UNION:
          s = c.createUnion(s.input.map(p));
          break;
        case r.types.VALUES:
          s = c.createValues([].concat(s.variables), s.bindings.map((b) => Object.assign({}, b)));
          break;
        case r.types.ZERO_OR_MORE_PATH:
          s = c.createZeroOrMorePath(p(s.path));
          break;
        case r.types.ZERO_OR_ONE_PATH:
          s = c.createZeroOrOnePath(p(s.path));
          break;
        // UPDATE operations
        case r.types.COMPOSITE_UPDATE:
          s = c.createCompositeUpdate(s.updates.map(p));
          break;
        case r.types.DELETE_INSERT:
          s = c.createDeleteInsert(s.delete ? s.delete.map(p) : void 0, s.insert ? s.insert.map(p) : void 0, s.where ? p(s.where) : void 0);
          break;
        case r.types.LOAD:
          s = c.createLoad(s.source, s.destination, s.silent);
          break;
        case r.types.CLEAR:
          s = c.createClear(s.source, s.silent);
          break;
        case r.types.CREATE:
          s = c.createCreate(s.source, s.silent);
          break;
        case r.types.DROP:
          s = c.createDrop(s.source, s.silent);
          break;
        case r.types.ADD:
          s = c.createAdd(s.source, s.destination);
          break;
        case r.types.MOVE:
          s = c.createMove(s.source, s.destination);
          break;
        case r.types.COPY:
          s = c.createCopy(s.source, s.destination);
          break;
        default:
          throw new Error(`Unknown Operation type ${s.type}`);
      }
      return h && (s.metadata = h), s;
    }
    /**
     * Similar to the {@link mapOperation} function but specifically for expressions.
     * Both functions call each other while copying.
     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.
     * @param {Expression} expr - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapExpression(n, i, c) {
      let s = n, d = !0;
      c = c || new o.default();
      const l = i[n.expressionType];
      if (l && ({ result: s, recurse: d } = l(n, c)), !d)
        return s;
      let f = (h) => t.mapOperation(h, i, c);
      switch (n.expressionType) {
        case r.expressionTypes.AGGREGATE:
          return n.variable ? c.createBoundAggregate(n.variable, n.aggregator, f(n.expression), n.distinct, n.separator) : c.createAggregateExpression(n.aggregator, f(n.expression), n.distinct, n.separator);
        case r.expressionTypes.EXISTENCE:
          return c.createExistenceExpression(n.not, f(n.input));
        case r.expressionTypes.NAMED:
          return c.createNamedExpression(n.name, n.args.map(f));
        case r.expressionTypes.OPERATOR:
          return c.createOperatorExpression(n.operator, n.args.map(f));
        case r.expressionTypes.TERM:
          return c.createTermExpression(n.term);
        case r.expressionTypes.WILDCARD:
          return c.createWildcardExpression();
        default:
          throw new Error(`Unknown Expression type ${n.expressionType}`);
      }
    }
    /**
     * Creates a deep clone of the operation.
     * This is syntactic sugar for calling {@link mapOperation} without callbacks.
     * @param {Operation} op - The operation to copy.
     * @returns {Operation} - The deep copy.
     */
    static cloneOperation(n) {
      return t.mapOperation(n, {});
    }
    /**
     * Creates a deep clone of the expression.
     * This is syntactic sugar for calling {@link mapExpression} without callbacks.
     * @param {Expression} expr - The operation to copy.
     * @returns {Expression} - The deep copy.
     */
    static cloneExpression(n) {
      return t.mapExpression(n, {});
    }
    static createUniqueVariable(n, i, c) {
      let s = 0, d = n;
      for (; i[d]; )
        d = `${n}${s++}`;
      return c.variable(d);
    }
    // separate terms from wildcard since we handle them differently
    static isSimpleTerm(n) {
      return n.termType !== void 0 && n.termType !== "Quad" && n.termType !== "Wildcard";
    }
    static isQuad(n) {
      return n.termType === "Quad";
    }
    static hasQuadVariables(n) {
      return (0, a.someTermsNested)(n, (i) => i.termType === "Variable");
    }
    static isWildcard(n) {
      return n.termType === "Wildcard";
    }
  }
  return g0.default = t, g0;
}
var jR;
function Nne() {
  if (jR) return Nn;
  jR = 1;
  var u = Nn && Nn.__createBinding || (Object.create ? function(N, M, I, P) {
    P === void 0 && (P = I);
    var B = Object.getOwnPropertyDescriptor(M, I);
    (!B || ("get" in B ? !M.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return M[I];
    } }), Object.defineProperty(N, P, B);
  } : function(N, M, I, P) {
    P === void 0 && (P = I), N[P] = M[I];
  }), r = Nn && Nn.__setModuleDefault || (Object.create ? function(N, M) {
    Object.defineProperty(N, "default", { enumerable: !0, value: M });
  } : function(N, M) {
    N.default = M;
  }), o = Nn && Nn.__importStar || function(N) {
    if (N && N.__esModule) return N;
    var M = {};
    if (N != null) for (var I in N) I !== "default" && Object.prototype.hasOwnProperty.call(N, I) && u(M, N, I);
    return r(M, N), M;
  }, a = Nn && Nn.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(Nn, "__esModule", { value: !0 });
  const t = xne(), e = lr(), n = o(yw()), i = a(zS()), c = a(_8()), s = _w().Parser, d = n.types;
  let l = /* @__PURE__ */ new Set(), f = 0, h = !1, p;
  function b(N, M) {
    M = M || {}, p = new i.default(M.dataFactory);
    let I;
    if (y(N)) {
      let P = new s(M);
      P._resetBlanks(), I = P.parse(N);
    } else
      I = N;
    return _(I, M.quads, M.blankToVariable);
  }
  Nn.default = b;
  function _(N, M, I) {
    if (l = /* @__PURE__ */ new Set(), f = 0, h = !!M, !N.type)
      return p.createNop();
    if (N.type !== "query" && N.type !== "update")
      throw new Error("Translate only works on complete query or update objects.");
    let P;
    if (v(N), N.type === "query") {
      const B = { type: "group", patterns: N.where || [] };
      P = R(B), P = U(N, P);
    } else N.type === "update" && (P = pe(N));
    return I && (P = V(P)), P;
  }
  function y(N) {
    return typeof N == "string";
  }
  function m(N) {
    return !!(N != null && N.termType);
  }
  function g(N) {
    return N.subject && N.predicate && N.object;
  }
  function T(N) {
    return (N == null ? void 0 : N.termType) === "Variable";
  }
  function v(N) {
    if (m(N))
      T(N) && l.add(`?${N.value}`);
    else if (Array.isArray(N))
      for (const M of N)
        v(M);
    else if (N && typeof N == "object")
      for (let M of Object.keys(N))
        M.startsWith("?") ? l.add(M) : M.startsWith("$") && l.add(`?${M.slice(1)}`), v(N[M]);
  }
  function E(N) {
    let M = {};
    if (g(N)) {
      const I = [
        E(N.subject),
        E(N.predicate),
        E(N.object),
        N.graph ? E(N.graph) : {}
      ];
      Object.assign(M, ...I);
    } else if (m(N))
      T(N) && (M[N.value] = N);
    else if (N.type === "bgp") {
      const I = N.triples;
      Object.assign(M, ...I.map(E));
    } else if (N.type === "path")
      Object.assign(M, ...N.items.map(E));
    else if (N.type === "group" || N.type === "union" || N.type === "optional")
      Object.assign(M, ...N.patterns.map(E));
    else if (N.type === "service" || N.type === "graph")
      Object.assign(M, E(N.name)), Object.assign(M, ...N.patterns.map(E));
    else if (N.type === "bind")
      Object.assign(M, E(N.variable));
    else if (N.type === "values") {
      if (N.values.length > 0) {
        const I = Object.keys(N.values[0]).map((P) => p.createTerm(P));
        Object.assign(M, ...I.map(E));
      }
    } else if (N.type === "query" && (N.queryType === "SELECT" || N.queryType === "DESCRIBE")) {
      N.where && N.variables.some(c.default.isWildcard) && Object.assign(M, ...N.where.map(E));
      for (const I of N.variables)
        T(I) ? Object.assign(M, E(I)) : I.variable && Object.assign(M, E(I.variable));
      if (N.queryType === "SELECT") {
        if (N.group)
          for (const I of N.group)
            I.variable && Object.assign(M, E(I.variable));
        if (N.values) {
          const I = { type: "values", values: N.values };
          Object.assign(M, E(I));
        }
      }
    }
    return M;
  }
  function R(N) {
    if (N.type === "bgp")
      return A(N);
    if (N.type === "union")
      return p.createUnion(N.patterns.map((M) => (M.type !== "group" && (M = { type: "group", patterns: [M] }), R(M))));
    if (N.type === "graph") {
      const M = { type: "group", patterns: N.patterns };
      let I = R(M);
      return h ? I = q(I, N.name) : I = p.createGraph(I, N.name), I;
    }
    if (N.type === "values")
      return K(N);
    if (N.type === "query")
      return _(N, h, !1);
    if (N.type === "group") {
      let M = [], I = [];
      for (let z of N.patterns)
        (z.type === "filter" ? M : I).push(z);
      let P = I.reduce(Q, p.createBgp([])), B = M.map((z) => L(z.expression));
      return B.length > 0 && (P = p.createFilter(P, B.reduce((z, H) => p.createOperatorExpression("&&", [z, H])))), P;
    }
    throw new Error(`Unexpected type: ${N.type}`);
  }
  function L(N) {
    if (c.default.isSimpleTerm(N))
      return p.createTermExpression(N);
    if (c.default.isQuad(N))
      return c.default.hasQuadVariables(N) ? p.createOperatorExpression("triple", [
        L(N.subject),
        L(N.predicate),
        L(N.object)
      ]) : p.createTermExpression(N);
    if (c.default.isWildcard(N))
      return p.createWildcardExpression();
    if ("aggregation" in N)
      return p.createAggregateExpression(N.aggregation, L(N.expression), !!N.distinct, N.separator);
    if ("function" in N)
      return p.createNamedExpression(N.function, N.args.map(L));
    if ("operator" in N)
      return N.operator === "exists" || N.operator === "notexists" ? p.createExistenceExpression(N.operator === "notexists", R(N.args[0])) : ((N.operator === "in" || N.operator === "notin") && (N.args = [N.args[0]].concat(N.args[1])), p.createOperatorExpression(N.operator, N.args.map(L)));
    throw new Error(`Unknown expression: ${JSON.stringify(N)}`);
  }
  function A(N) {
    let M = [], I = [];
    for (let P of N.triples)
      if ("pathType" in P.predicate) {
        let B = w(P);
        for (let z of B)
          z.type === d.PATH ? (M.length > 0 && I.push(p.createBgp(M)), M = [], I.push(z)) : M.push(z);
      } else
        M.push(F(P));
    return M.length > 0 && I.push(p.createBgp(M)), I.length === 1 ? I[0] : p.createJoin(I);
  }
  function w(N) {
    let M = N.subject, I = S(N.predicate), P = N.object;
    return O(M, I, P);
  }
  function S(N) {
    if (c.default.isSimpleTerm(N)) {
      if (N.termType === "NamedNode")
        return p.createLink(N);
      throw new Error(`Path predicate should be a NamedNode, got ${JSON.stringify(N)}`);
    }
    if (N.pathType === "^")
      return p.createInv(S(N.items[0]));
    if (N.pathType === "!") {
      let M = [], I = [], P;
      "pathType" in N.items[0] && N.items[0].pathType === "|" ? P = N.items[0].items : P = N.items;
      for (let H of P)
        if (c.default.isSimpleTerm(H))
          M.push(H);
        else if (H.pathType === "^")
          I.push(H.items[0]);
        else
          throw new Error(`Unexpected item: ${JSON.stringify(H)}`);
      let B = p.createNps(M), z = p.createInv(p.createNps(I));
      return I.length === 0 ? B : M.length === 0 ? z : p.createAlt([B, z]);
    }
    if (N.pathType === "/")
      return p.createSeq(N.items.map(S));
    if (N.pathType === "|")
      return p.createAlt(N.items.map(S));
    if (N.pathType === "*")
      return p.createZeroOrMorePath(S(N.items[0]));
    if (N.pathType === "+")
      return p.createOneOrMorePath(S(N.items[0]));
    if (N.pathType === "?")
      return p.createZeroOrOnePath(S(N.items[0]));
    throw new Error(`Unable to translate path expression ${JSON.stringify(N)}`);
  }
  function O(N, M, I) {
    if (M.type === d.LINK)
      return [p.createPattern(N, M.iri, I)];
    if (M.type === d.INV)
      return O(I, M.path, N);
    if (M.type === d.SEQ) {
      let P = N;
      return c.default.flatten(M.input.map((B, z) => {
        const H = z === M.input.length - 1 ? I : x(), J = O(P, B, H);
        return H.termType === "Variable" && (P = H), J;
      }));
    }
    return [p.createPath(N, M, I)];
  }
  function x() {
    let N = `?var${f++}`;
    return l.has(N) ? x() : (l.add(N), p.createTerm(N));
  }
  function F(N) {
    if ("pathType" in N.predicate)
      throw new Error("Trying to translate property path to quad.");
    return p.createPattern(N.subject, N.predicate, N.object, N.graph);
  }
  let j = Object.values(d);
  function q(N, M, I) {
    if (N.type === d.GRAPH) {
      if (I)
        throw new Error("Recursing through nested GRAPH statements with a replacement is impossible.");
      N = q(N.input, N.name);
    } else if (N.type !== d.SERVICE) if (N.type === d.BGP)
      N.patterns = N.patterns.map((P) => (I && (P.subject.equals(M) && (P.subject = I), P.predicate.equals(M) && (P.predicate = I), P.object.equals(M) && (P.object = I)), P.graph.termType === "DefaultGraph" && (P.graph = M), P));
    else if (N.type === d.PATH)
      I && (N.subject.equals(M) && (N.subject = I), N.object.equals(M) && (N.object = I)), N.graph.termType === "DefaultGraph" && (N.graph = M);
    else if (N.type === d.PROJECT && !I)
      N.variables.some((P) => P.equals(M)) || (I = x()), N.input = q(N.input, M, I);
    else if (N.type === d.EXTEND && !I)
      N.variable.equals(M) && (I = x()), N.input = q(N.input, M, I);
    else
      for (let P of Object.keys(N))
        Array.isArray(N[P]) ? N[P] = N[P].map((B) => q(B, M, I)) : j.indexOf(N[P].type) >= 0 ? N[P] = q(N[P], M, I) : I && T(N[P]) && N[P].equals(M) && (N[P] = I);
    return N;
  }
  function Q(N, M) {
    if (M.type === "optional") {
      const I = R({ type: "group", patterns: M.patterns });
      I.type === d.FILTER ? N = p.createLeftJoin(N, I.input, I.expression) : N = p.createLeftJoin(N, I);
    } else if (M.type === "minus") {
      const I = R({ type: "group", patterns: M.patterns });
      N = p.createMinus(N, I);
    } else if (M.type === "bind")
      N = p.createExtend(N, M.variable, L(M.expression));
    else if (M.type === "service") {
      const I = { type: "group", patterns: M.patterns }, P = p.createService(R(I), M.name, M.silent);
      N = G(N, P);
    } else {
      const I = R(M);
      N = G(N, I);
    }
    return N;
  }
  function G(N, M) {
    return N.type === d.BGP && M.type === d.BGP ? N = p.createBgp([...N.patterns, ...M.patterns]) : N.type === d.BGP && N.patterns.length === 0 ? N = M : M.type === d.BGP && M.patterns.length === 0 || (N = p.createJoin([N, M])), N;
  }
  function K(N) {
    let M = (N.values.length === 0 ? [] : Object.keys(N.values[0])).map(p.createTerm.bind(p)), I = N.values.map((P) => {
      let B = Object.keys(P);
      B = B.filter((H) => P[H] !== void 0);
      let z = {};
      for (let H of B)
        z[H] = P[H];
      return z;
    });
    return p.createValues(M, I);
  }
  function U(N, M) {
    const I = N, P = [], B = {};
    if (I.variables = I.variables && I.variables.map((H) => ae(H, B)), I.having = I.having && I.having.map((H) => ae(H, B)), I.order = I.order && I.order.map((H) => ae(H, B)), I.group || Object.keys(B).length > 0) {
      const H = Object.keys(B).map((k) => ye(B[k], p.createTerm(k))), J = [];
      if (I.group)
        for (const k of I.group)
          if (c.default.isSimpleTerm(k.expression))
            J.push(k.expression);
          else {
            const W = "variable" in k ? k.variable : x();
            M = p.createExtend(M, W, L(k.expression)), J.push(W);
          }
      M = p.createGroup(M, J, H);
    }
    if (I.having)
      for (let H of I.having)
        M = p.createFilter(M, L(H));
    N.values && (M = p.createJoin([M, K(N)]));
    let z = [];
    if (N.queryType === "SELECT" || N.queryType === "DESCRIBE")
      if (N.variables.some((H) => H && c.default.isWildcard(H)))
        z = Object.values(E(N)).sort((H, J) => H.value.localeCompare(J.value));
      else
        for (let H of N.variables)
          T(H) || !("variable" in H) ? z.push(H) : H.variable && (z.push(H.variable), P.push(H));
    for (let H of P)
      M = p.createExtend(M, H.variable, L(H.expression));
    return I.order && (M = p.createOrderBy(M, I.order.map((H) => {
      let J = L(H.expression);
      return H.descending && (J = p.createOperatorExpression("desc", [J])), J;
    }))), N.queryType === "SELECT" && (M = p.createProject(M, z)), I.distinct && (M = p.createDistinct(M)), I.reduced && (M = p.createReduced(M)), N.queryType === "CONSTRUCT" ? M = p.createConstruct(M, (N.template || []).map(F)) : N.queryType === "ASK" ? M = p.createAsk(M) : N.queryType === "DESCRIBE" && (M = p.createDescribe(M, z)), (I.offset || I.limit) && (M = p.createSlice(M, I.offset || 0, I.limit)), I.from && (M = p.createFrom(M, I.from.default, I.from.named)), M;
  }
  function ae(N, M) {
    if ("type" in N && N.type === "aggregate") {
      let I = !1, P;
      for (let B of Object.keys(M))
        if (t(M[B], N)) {
          P = p.createTerm(B), I = !0;
          break;
        }
      return I || (P = x(), M[(0, e.termToString)(P)] = N), P;
    }
    return "expression" in N && N.expression ? { ...N, expression: ae(N.expression, M) } : "args" in N && N.args ? { ...N, args: N.args.map((I) => ae(I, M)) } : N;
  }
  function ye(N, M) {
    if (N.type !== "aggregate" || !N.aggregation)
      throw new Error(`Unexpected input: ${JSON.stringify(N)}`);
    const I = L(N);
    return I.variable = M, I;
  }
  function pe(N) {
    return N.updates.length === 1 ? ee(N.updates[0]) : p.createCompositeUpdate(N.updates.map(ee));
  }
  function ee(N) {
    if ("type" in N) {
      if (N.type === "load")
        return be(N);
      if (N.type === "clear" || N.type === "create" || N.type === "drop")
        return Oe(N);
      if (N.type === "add" || N.type === "copy" || N.type === "move")
        return he(N);
    } else if (N.updateType === "insertdelete" || N.updateType === "deletewhere" || N.updateType === "delete" || N.updateType === "insert")
      return Te(N);
    throw new Error(`Unknown update type ${JSON.stringify(N)}`);
  }
  function Te(N) {
    if (!h)
      throw new Error("INSERT/DELETE operations are only supported with quads option enabled");
    let M = [], I = [], P;
    if (N.delete && (M = c.default.flatten(N.delete.map((B) => we(B, N.graph)))), N.insert && (I = c.default.flatten(N.insert.map((B) => we(B, N.graph)))), N.where && N.where.length > 0) {
      P = R({ type: "group", patterns: N.where });
      const B = N.using;
      B ? P = p.createFrom(P, B.default, B.named) : N.graph && (P = q(P, N.graph));
    } else N.updateType === "deletewhere" && M.length > 0 && (P = p.createBgp(M));
    return p.createDeleteInsert(M.length > 0 ? M : void 0, I.length > 0 ? I : void 0, P);
  }
  function we(N, M) {
    let I = M;
    N.type === "graph" && (I = N.name);
    let P = N.triples;
    return I && (P = P.map((B) => Object.assign(B, { graph: I }))), P.map(F);
  }
  function Oe(N) {
    let M;
    switch (c.default.isSimpleTerm(N.graph) ? M = N.graph : N.graph.all ? M = "ALL" : N.graph.default ? M = "DEFAULT" : N.graph.named ? M = "NAMED" : M = N.graph.name, N.type) {
      case "clear":
        return p.createClear(M, N.silent);
      case "create":
        return p.createCreate(M, N.silent);
      case "drop":
        return p.createDrop(M, N.silent);
    }
  }
  function be(N) {
    return p.createLoad(N.source, N.destination, N.silent);
  }
  function he(N) {
    const M = N.source.default ? "DEFAULT" : N.source.name, I = N.destination.default ? "DEFAULT" : N.destination.name;
    switch (N.type) {
      case "copy":
        return p.createCopy(M, I, N.silent);
      case "move":
        return p.createMove(M, I, N.silent);
      case "add":
        return p.createAdd(M, I, N.silent);
    }
  }
  function V(N) {
    const M = {}, I = Array.from(l).reduce((B, z) => (B[z] = !0, B), {});
    return c.default.mapOperation(N, {
      [n.types.DELETE_INSERT]: (B) => ({
        result: p.createDeleteInsert(B.delete, B.insert, B.where && V(B.where)),
        recurse: !1
      }),
      [n.types.PATH]: (B, z) => ({
        result: z.createPath(P(B.subject), B.predicate, P(B.object), P(B.graph)),
        recurse: !1
      }),
      [n.types.PATTERN]: (B, z) => ({
        result: z.createPattern(P(B.subject), P(B.predicate), P(B.object), P(B.graph)),
        recurse: !1
      }),
      [n.types.CONSTRUCT]: (B) => ({
        result: p.createConstruct(V(B.input), B.template),
        recurse: !1
      })
    });
    function P(B) {
      if (B.termType === "BlankNode") {
        let z = M[B.value];
        return z || (z = c.default.createUniqueVariable(B.value, I, p.dataFactory), I[z.value] = !0, M[B.value] = z), z;
      }
      return B;
    }
  }
  return Nn;
}
var Zr = {}, Pu = {}, xt = {}, vA = {}, Qt = {}, TA, MR;
function gw() {
  if (MR) return TA;
  MR = 1, TA = u;
  function u(r, o) {
    if (!r)
      throw new Error(o || "Assertion failed");
  }
  return u.equal = function(o, a, t) {
    if (o != a)
      throw new Error(t || "Assertion failed: " + o + " != " + a);
  }, TA;
}
var a6 = { exports: {} }, CR;
function Pne() {
  return CR || (CR = 1, typeof Object.create == "function" ? a6.exports = function(r, o) {
    o && (r.super_ = o, r.prototype = Object.create(o.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : a6.exports = function(r, o) {
    if (o) {
      r.super_ = o;
      var a = function() {
      };
      a.prototype = o.prototype, r.prototype = new a(), r.prototype.constructor = r;
    }
  }), a6.exports;
}
var qR;
function ji() {
  if (qR) return Qt;
  qR = 1;
  var u = gw(), r = Pne();
  Qt.inherits = r;
  function o(O, x) {
    return (O.charCodeAt(x) & 64512) !== 55296 || x < 0 || x + 1 >= O.length ? !1 : (O.charCodeAt(x + 1) & 64512) === 56320;
  }
  function a(O, x) {
    if (Array.isArray(O))
      return O.slice();
    if (!O)
      return [];
    var F = [];
    if (typeof O == "string")
      if (x) {
        if (x === "hex")
          for (O = O.replace(/[^a-z0-9]+/ig, ""), O.length % 2 !== 0 && (O = "0" + O), q = 0; q < O.length; q += 2)
            F.push(parseInt(O[q] + O[q + 1], 16));
      } else for (var j = 0, q = 0; q < O.length; q++) {
        var Q = O.charCodeAt(q);
        Q < 128 ? F[j++] = Q : Q < 2048 ? (F[j++] = Q >> 6 | 192, F[j++] = Q & 63 | 128) : o(O, q) ? (Q = 65536 + ((Q & 1023) << 10) + (O.charCodeAt(++q) & 1023), F[j++] = Q >> 18 | 240, F[j++] = Q >> 12 & 63 | 128, F[j++] = Q >> 6 & 63 | 128, F[j++] = Q & 63 | 128) : (F[j++] = Q >> 12 | 224, F[j++] = Q >> 6 & 63 | 128, F[j++] = Q & 63 | 128);
      }
    else
      for (q = 0; q < O.length; q++)
        F[q] = O[q] | 0;
    return F;
  }
  Qt.toArray = a;
  function t(O) {
    for (var x = "", F = 0; F < O.length; F++)
      x += i(O[F].toString(16));
    return x;
  }
  Qt.toHex = t;
  function e(O) {
    var x = O >>> 24 | O >>> 8 & 65280 | O << 8 & 16711680 | (O & 255) << 24;
    return x >>> 0;
  }
  Qt.htonl = e;
  function n(O, x) {
    for (var F = "", j = 0; j < O.length; j++) {
      var q = O[j];
      x === "little" && (q = e(q)), F += c(q.toString(16));
    }
    return F;
  }
  Qt.toHex32 = n;
  function i(O) {
    return O.length === 1 ? "0" + O : O;
  }
  Qt.zero2 = i;
  function c(O) {
    return O.length === 7 ? "0" + O : O.length === 6 ? "00" + O : O.length === 5 ? "000" + O : O.length === 4 ? "0000" + O : O.length === 3 ? "00000" + O : O.length === 2 ? "000000" + O : O.length === 1 ? "0000000" + O : O;
  }
  Qt.zero8 = c;
  function s(O, x, F, j) {
    var q = F - x;
    u(q % 4 === 0);
    for (var Q = new Array(q / 4), G = 0, K = x; G < Q.length; G++, K += 4) {
      var U;
      j === "big" ? U = O[K] << 24 | O[K + 1] << 16 | O[K + 2] << 8 | O[K + 3] : U = O[K + 3] << 24 | O[K + 2] << 16 | O[K + 1] << 8 | O[K], Q[G] = U >>> 0;
    }
    return Q;
  }
  Qt.join32 = s;
  function d(O, x) {
    for (var F = new Array(O.length * 4), j = 0, q = 0; j < O.length; j++, q += 4) {
      var Q = O[j];
      x === "big" ? (F[q] = Q >>> 24, F[q + 1] = Q >>> 16 & 255, F[q + 2] = Q >>> 8 & 255, F[q + 3] = Q & 255) : (F[q + 3] = Q >>> 24, F[q + 2] = Q >>> 16 & 255, F[q + 1] = Q >>> 8 & 255, F[q] = Q & 255);
    }
    return F;
  }
  Qt.split32 = d;
  function l(O, x) {
    return O >>> x | O << 32 - x;
  }
  Qt.rotr32 = l;
  function f(O, x) {
    return O << x | O >>> 32 - x;
  }
  Qt.rotl32 = f;
  function h(O, x) {
    return O + x >>> 0;
  }
  Qt.sum32 = h;
  function p(O, x, F) {
    return O + x + F >>> 0;
  }
  Qt.sum32_3 = p;
  function b(O, x, F, j) {
    return O + x + F + j >>> 0;
  }
  Qt.sum32_4 = b;
  function _(O, x, F, j, q) {
    return O + x + F + j + q >>> 0;
  }
  Qt.sum32_5 = _;
  function y(O, x, F, j) {
    var q = O[x], Q = O[x + 1], G = j + Q >>> 0, K = (G < j ? 1 : 0) + F + q;
    O[x] = K >>> 0, O[x + 1] = G;
  }
  Qt.sum64 = y;
  function m(O, x, F, j) {
    var q = x + j >>> 0, Q = (q < x ? 1 : 0) + O + F;
    return Q >>> 0;
  }
  Qt.sum64_hi = m;
  function g(O, x, F, j) {
    var q = x + j;
    return q >>> 0;
  }
  Qt.sum64_lo = g;
  function T(O, x, F, j, q, Q, G, K) {
    var U = 0, ae = x;
    ae = ae + j >>> 0, U += ae < x ? 1 : 0, ae = ae + Q >>> 0, U += ae < Q ? 1 : 0, ae = ae + K >>> 0, U += ae < K ? 1 : 0;
    var ye = O + F + q + G + U;
    return ye >>> 0;
  }
  Qt.sum64_4_hi = T;
  function v(O, x, F, j, q, Q, G, K) {
    var U = x + j + Q + K;
    return U >>> 0;
  }
  Qt.sum64_4_lo = v;
  function E(O, x, F, j, q, Q, G, K, U, ae) {
    var ye = 0, pe = x;
    pe = pe + j >>> 0, ye += pe < x ? 1 : 0, pe = pe + Q >>> 0, ye += pe < Q ? 1 : 0, pe = pe + K >>> 0, ye += pe < K ? 1 : 0, pe = pe + ae >>> 0, ye += pe < ae ? 1 : 0;
    var ee = O + F + q + G + U + ye;
    return ee >>> 0;
  }
  Qt.sum64_5_hi = E;
  function R(O, x, F, j, q, Q, G, K, U, ae) {
    var ye = x + j + Q + K + ae;
    return ye >>> 0;
  }
  Qt.sum64_5_lo = R;
  function L(O, x, F) {
    var j = x << 32 - F | O >>> F;
    return j >>> 0;
  }
  Qt.rotr64_hi = L;
  function A(O, x, F) {
    var j = O << 32 - F | x >>> F;
    return j >>> 0;
  }
  Qt.rotr64_lo = A;
  function w(O, x, F) {
    return O >>> F;
  }
  Qt.shr64_hi = w;
  function S(O, x, F) {
    var j = O << 32 - F | x >>> F;
    return j >>> 0;
  }
  return Qt.shr64_lo = S, Qt;
}
var wA = {}, BR;
function mw() {
  if (BR) return wA;
  BR = 1;
  var u = ji(), r = gw();
  function o() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return wA.BlockHash = o, o.prototype.update = function(t, e) {
    if (t = u.toArray(t, e), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
      t = this.pending;
      var n = t.length % this._delta8;
      this.pending = t.slice(t.length - n, t.length), this.pending.length === 0 && (this.pending = null), t = u.join32(t, 0, t.length - n, this.endian);
      for (var i = 0; i < t.length; i += this._delta32)
        this._update(t, i, i + this._delta32);
    }
    return this;
  }, o.prototype.digest = function(t) {
    return this.update(this._pad()), r(this.pending === null), this._digest(t);
  }, o.prototype._pad = function() {
    var t = this.pendingTotal, e = this._delta8, n = e - (t + this.padLength) % e, i = new Array(n + this.padLength);
    i[0] = 128;
    for (var c = 1; c < n; c++)
      i[c] = 0;
    if (t <<= 3, this.endian === "big") {
      for (var s = 8; s < this.padLength; s++)
        i[c++] = 0;
      i[c++] = 0, i[c++] = 0, i[c++] = 0, i[c++] = 0, i[c++] = t >>> 24 & 255, i[c++] = t >>> 16 & 255, i[c++] = t >>> 8 & 255, i[c++] = t & 255;
    } else
      for (i[c++] = t & 255, i[c++] = t >>> 8 & 255, i[c++] = t >>> 16 & 255, i[c++] = t >>> 24 & 255, i[c++] = 0, i[c++] = 0, i[c++] = 0, i[c++] = 0, s = 8; s < this.padLength; s++)
        i[c++] = 0;
    return i;
  }, wA;
}
var Du = {}, Ei = {}, $R;
function QK() {
  if ($R) return Ei;
  $R = 1;
  var u = ji(), r = u.rotr32;
  function o(d, l, f, h) {
    if (d === 0)
      return a(l, f, h);
    if (d === 1 || d === 3)
      return e(l, f, h);
    if (d === 2)
      return t(l, f, h);
  }
  Ei.ft_1 = o;
  function a(d, l, f) {
    return d & l ^ ~d & f;
  }
  Ei.ch32 = a;
  function t(d, l, f) {
    return d & l ^ d & f ^ l & f;
  }
  Ei.maj32 = t;
  function e(d, l, f) {
    return d ^ l ^ f;
  }
  Ei.p32 = e;
  function n(d) {
    return r(d, 2) ^ r(d, 13) ^ r(d, 22);
  }
  Ei.s0_256 = n;
  function i(d) {
    return r(d, 6) ^ r(d, 11) ^ r(d, 25);
  }
  Ei.s1_256 = i;
  function c(d) {
    return r(d, 7) ^ r(d, 18) ^ d >>> 3;
  }
  Ei.g0_256 = c;
  function s(d) {
    return r(d, 17) ^ r(d, 19) ^ d >>> 10;
  }
  return Ei.g1_256 = s, Ei;
}
var SA, UR;
function Dne() {
  if (UR) return SA;
  UR = 1;
  var u = ji(), r = mw(), o = QK(), a = u.rotl32, t = u.sum32, e = u.sum32_5, n = o.ft_1, i = r.BlockHash, c = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function s() {
    if (!(this instanceof s))
      return new s();
    i.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return u.inherits(s, i), SA = s, s.blockSize = 512, s.outSize = 160, s.hmacStrength = 80, s.padLength = 64, s.prototype._update = function(l, f) {
    for (var h = this.W, p = 0; p < 16; p++)
      h[p] = l[f + p];
    for (; p < h.length; p++)
      h[p] = a(h[p - 3] ^ h[p - 8] ^ h[p - 14] ^ h[p - 16], 1);
    var b = this.h[0], _ = this.h[1], y = this.h[2], m = this.h[3], g = this.h[4];
    for (p = 0; p < h.length; p++) {
      var T = ~~(p / 20), v = e(a(b, 5), n(T, _, y, m), g, h[p], c[T]);
      g = m, m = y, y = a(_, 30), _ = b, b = v;
    }
    this.h[0] = t(this.h[0], b), this.h[1] = t(this.h[1], _), this.h[2] = t(this.h[2], y), this.h[3] = t(this.h[3], m), this.h[4] = t(this.h[4], g);
  }, s.prototype._digest = function(l) {
    return l === "hex" ? u.toHex32(this.h, "big") : u.split32(this.h, "big");
  }, SA;
}
var AA, VR;
function HK() {
  if (VR) return AA;
  VR = 1;
  var u = ji(), r = mw(), o = QK(), a = gw(), t = u.sum32, e = u.sum32_4, n = u.sum32_5, i = o.ch32, c = o.maj32, s = o.s0_256, d = o.s1_256, l = o.g0_256, f = o.g1_256, h = r.BlockHash, p = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function b() {
    if (!(this instanceof b))
      return new b();
    h.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = p, this.W = new Array(64);
  }
  return u.inherits(b, h), AA = b, b.blockSize = 512, b.outSize = 256, b.hmacStrength = 192, b.padLength = 64, b.prototype._update = function(y, m) {
    for (var g = this.W, T = 0; T < 16; T++)
      g[T] = y[m + T];
    for (; T < g.length; T++)
      g[T] = e(f(g[T - 2]), g[T - 7], l(g[T - 15]), g[T - 16]);
    var v = this.h[0], E = this.h[1], R = this.h[2], L = this.h[3], A = this.h[4], w = this.h[5], S = this.h[6], O = this.h[7];
    for (a(this.k.length === g.length), T = 0; T < g.length; T++) {
      var x = n(O, d(A), i(A, w, S), this.k[T], g[T]), F = t(s(v), c(v, E, R));
      O = S, S = w, w = A, A = t(L, x), L = R, R = E, E = v, v = t(x, F);
    }
    this.h[0] = t(this.h[0], v), this.h[1] = t(this.h[1], E), this.h[2] = t(this.h[2], R), this.h[3] = t(this.h[3], L), this.h[4] = t(this.h[4], A), this.h[5] = t(this.h[5], w), this.h[6] = t(this.h[6], S), this.h[7] = t(this.h[7], O);
  }, b.prototype._digest = function(y) {
    return y === "hex" ? u.toHex32(this.h, "big") : u.split32(this.h, "big");
  }, AA;
}
var EA, QR;
function Lne() {
  if (QR) return EA;
  QR = 1;
  var u = ji(), r = HK();
  function o() {
    if (!(this instanceof o))
      return new o();
    r.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return u.inherits(o, r), EA = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(t) {
    return t === "hex" ? u.toHex32(this.h.slice(0, 7), "big") : u.split32(this.h.slice(0, 7), "big");
  }, EA;
}
var OA, HR;
function GK() {
  if (HR) return OA;
  HR = 1;
  var u = ji(), r = mw(), o = gw(), a = u.rotr64_hi, t = u.rotr64_lo, e = u.shr64_hi, n = u.shr64_lo, i = u.sum64, c = u.sum64_hi, s = u.sum64_lo, d = u.sum64_4_hi, l = u.sum64_4_lo, f = u.sum64_5_hi, h = u.sum64_5_lo, p = r.BlockHash, b = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function _() {
    if (!(this instanceof _))
      return new _();
    p.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = b, this.W = new Array(160);
  }
  u.inherits(_, p), OA = _, _.blockSize = 1024, _.outSize = 512, _.hmacStrength = 192, _.padLength = 128, _.prototype._prepareBlock = function(F, j) {
    for (var q = this.W, Q = 0; Q < 32; Q++)
      q[Q] = F[j + Q];
    for (; Q < q.length; Q += 2) {
      var G = S(q[Q - 4], q[Q - 3]), K = O(q[Q - 4], q[Q - 3]), U = q[Q - 14], ae = q[Q - 13], ye = A(q[Q - 30], q[Q - 29]), pe = w(q[Q - 30], q[Q - 29]), ee = q[Q - 32], Te = q[Q - 31];
      q[Q] = d(
        G,
        K,
        U,
        ae,
        ye,
        pe,
        ee,
        Te
      ), q[Q + 1] = l(
        G,
        K,
        U,
        ae,
        ye,
        pe,
        ee,
        Te
      );
    }
  }, _.prototype._update = function(F, j) {
    this._prepareBlock(F, j);
    var q = this.W, Q = this.h[0], G = this.h[1], K = this.h[2], U = this.h[3], ae = this.h[4], ye = this.h[5], pe = this.h[6], ee = this.h[7], Te = this.h[8], we = this.h[9], Oe = this.h[10], be = this.h[11], he = this.h[12], V = this.h[13], N = this.h[14], M = this.h[15];
    o(this.k.length === q.length);
    for (var I = 0; I < q.length; I += 2) {
      var P = N, B = M, z = R(Te, we), H = L(Te, we), J = y(Te, we, Oe, be, he), k = m(Te, we, Oe, be, he, V), W = this.k[I], le = this.k[I + 1], fe = q[I], me = q[I + 1], Ne = f(
        P,
        B,
        z,
        H,
        J,
        k,
        W,
        le,
        fe,
        me
      ), xe = h(
        P,
        B,
        z,
        H,
        J,
        k,
        W,
        le,
        fe,
        me
      );
      P = v(Q, G), B = E(Q, G), z = g(Q, G, K, U, ae), H = T(Q, G, K, U, ae, ye);
      var ue = c(P, B, z, H), $ = s(P, B, z, H);
      N = he, M = V, he = Oe, V = be, Oe = Te, be = we, Te = c(pe, ee, Ne, xe), we = s(ee, ee, Ne, xe), pe = ae, ee = ye, ae = K, ye = U, K = Q, U = G, Q = c(Ne, xe, ue, $), G = s(Ne, xe, ue, $);
    }
    i(this.h, 0, Q, G), i(this.h, 2, K, U), i(this.h, 4, ae, ye), i(this.h, 6, pe, ee), i(this.h, 8, Te, we), i(this.h, 10, Oe, be), i(this.h, 12, he, V), i(this.h, 14, N, M);
  }, _.prototype._digest = function(F) {
    return F === "hex" ? u.toHex32(this.h, "big") : u.split32(this.h, "big");
  };
  function y(x, F, j, q, Q) {
    var G = x & j ^ ~x & Q;
    return G < 0 && (G += 4294967296), G;
  }
  function m(x, F, j, q, Q, G) {
    var K = F & q ^ ~F & G;
    return K < 0 && (K += 4294967296), K;
  }
  function g(x, F, j, q, Q) {
    var G = x & j ^ x & Q ^ j & Q;
    return G < 0 && (G += 4294967296), G;
  }
  function T(x, F, j, q, Q, G) {
    var K = F & q ^ F & G ^ q & G;
    return K < 0 && (K += 4294967296), K;
  }
  function v(x, F) {
    var j = a(x, F, 28), q = a(F, x, 2), Q = a(F, x, 7), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function E(x, F) {
    var j = t(x, F, 28), q = t(F, x, 2), Q = t(F, x, 7), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function R(x, F) {
    var j = a(x, F, 14), q = a(x, F, 18), Q = a(F, x, 9), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function L(x, F) {
    var j = t(x, F, 14), q = t(x, F, 18), Q = t(F, x, 9), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function A(x, F) {
    var j = a(x, F, 1), q = a(x, F, 8), Q = e(x, F, 7), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function w(x, F) {
    var j = t(x, F, 1), q = t(x, F, 8), Q = n(x, F, 7), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function S(x, F) {
    var j = a(x, F, 19), q = a(F, x, 29), Q = e(x, F, 6), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  function O(x, F) {
    var j = t(x, F, 19), q = t(F, x, 29), Q = n(x, F, 6), G = j ^ q ^ Q;
    return G < 0 && (G += 4294967296), G;
  }
  return OA;
}
var xA, GR;
function jne() {
  if (GR) return xA;
  GR = 1;
  var u = ji(), r = GK();
  function o() {
    if (!(this instanceof o))
      return new o();
    r.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return u.inherits(o, r), xA = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(t) {
    return t === "hex" ? u.toHex32(this.h.slice(0, 12), "big") : u.split32(this.h.slice(0, 12), "big");
  }, xA;
}
var zR;
function Mne() {
  return zR || (zR = 1, Du.sha1 = Dne(), Du.sha224 = Lne(), Du.sha256 = HK(), Du.sha384 = jne(), Du.sha512 = GK()), Du;
}
var IA = {}, kR;
function Cne() {
  if (kR) return IA;
  kR = 1;
  var u = ji(), r = mw(), o = u.rotl32, a = u.sum32, t = u.sum32_3, e = u.sum32_4, n = r.BlockHash;
  function i() {
    if (!(this instanceof i))
      return new i();
    n.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  u.inherits(i, n), IA.ripemd160 = i, i.blockSize = 512, i.outSize = 160, i.hmacStrength = 192, i.padLength = 64, i.prototype._update = function(_, y) {
    for (var m = this.h[0], g = this.h[1], T = this.h[2], v = this.h[3], E = this.h[4], R = m, L = g, A = T, w = v, S = E, O = 0; O < 80; O++) {
      var x = a(
        o(
          e(m, c(O, g, T, v), _[l[O] + y], s(O)),
          h[O]
        ),
        E
      );
      m = E, E = v, v = o(T, 10), T = g, g = x, x = a(
        o(
          e(R, c(79 - O, L, A, w), _[f[O] + y], d(O)),
          p[O]
        ),
        S
      ), R = S, S = w, w = o(A, 10), A = L, L = x;
    }
    x = t(this.h[1], T, w), this.h[1] = t(this.h[2], v, S), this.h[2] = t(this.h[3], E, R), this.h[3] = t(this.h[4], m, L), this.h[4] = t(this.h[0], g, A), this.h[0] = x;
  }, i.prototype._digest = function(_) {
    return _ === "hex" ? u.toHex32(this.h, "little") : u.split32(this.h, "little");
  };
  function c(b, _, y, m) {
    return b <= 15 ? _ ^ y ^ m : b <= 31 ? _ & y | ~_ & m : b <= 47 ? (_ | ~y) ^ m : b <= 63 ? _ & m | y & ~m : _ ^ (y | ~m);
  }
  function s(b) {
    return b <= 15 ? 0 : b <= 31 ? 1518500249 : b <= 47 ? 1859775393 : b <= 63 ? 2400959708 : 2840853838;
  }
  function d(b) {
    return b <= 15 ? 1352829926 : b <= 31 ? 1548603684 : b <= 47 ? 1836072691 : b <= 63 ? 2053994217 : 0;
  }
  var l = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], f = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], h = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], p = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return IA;
}
var RA, XR;
function qne() {
  if (XR) return RA;
  XR = 1;
  var u = ji(), r = gw();
  function o(a, t, e) {
    if (!(this instanceof o))
      return new o(a, t, e);
    this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(u.toArray(t, e));
  }
  return RA = o, o.prototype._init = function(t) {
    t.length > this.blockSize && (t = new this.Hash().update(t).digest()), r(t.length <= this.blockSize);
    for (var e = t.length; e < this.blockSize; e++)
      t.push(0);
    for (e = 0; e < t.length; e++)
      t[e] ^= 54;
    for (this.inner = new this.Hash().update(t), e = 0; e < t.length; e++)
      t[e] ^= 106;
    this.outer = new this.Hash().update(t);
  }, o.prototype.update = function(t, e) {
    return this.inner.update(t, e), this;
  }, o.prototype.digest = function(t) {
    return this.outer.update(this.inner.digest()), this.outer.digest(t);
  }, RA;
}
var JR;
function vw() {
  return JR || (JR = 1, function(u) {
    var r = u;
    r.utils = ji(), r.common = mw(), r.sha = Mne(), r.ripemd = Cne(), r.hmac = qne(), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160;
  }(vA)), vA;
}
var KR;
function Bne() {
  if (KR) return xt;
  KR = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.isTermGrounded = xt.termToSignature = xt.quadToSignature = xt.sha1hex = xt.hashTerm = xt.hashTerms = xt.getGraphBlankNodes = xt.uniqGraph = xt.deindexGraph = xt.indexGraph = xt.getQuadsWithoutBlankNodes = xt.getQuadsWithBlankNodes = xt.hasValue = xt.hashValues = xt.getBijectionInner = xt.getBijection = xt.isomorphic = void 0;
  const u = vw(), r = lr(), o = zn();
  function a(v, E) {
    return !!t(v, E);
  }
  xt.isomorphic = a;
  function t(v, E) {
    const R = l(d(v)), L = l(d(E));
    if (Object.keys(R).length !== Object.keys(L).length)
      return null;
    for (const x in R)
      if (R[x] !== L[x])
        return null;
    const A = h(s(v)), w = h(s(E)), S = p(v), O = p(E);
    return e(A, w, S, O);
  }
  xt.getBijection = t;
  function e(v, E, R, L, A, w) {
    A || (A = {}), w || (w = {});
    const [S, O] = b(v, R, A), [x, F] = b(E, L, w);
    if (Object.keys(S).length !== Object.keys(x).length)
      return null;
    for (const q in S)
      if (!c(x, S[q]))
        return null;
    let j = {};
    for (const q of R) {
      const Q = r.termToString(q), G = O[Q];
      for (const K in F)
        if (F[K] === G) {
          j[Q] = K, delete F[K];
          break;
        }
    }
    if (!n(Object.keys(j).sort(), R.map(r.termToString).sort()) || !n(i(j).sort(), L.map(r.termToString).sort())) {
      j = null;
      for (const q of R) {
        const Q = r.termToString(q);
        if (!S[Q])
          for (const G of L) {
            const K = r.termToString(G);
            if (!x[K] && O[Q] === F[K]) {
              const U = y(Q);
              j = e(v, E, R, L, Object.assign(Object.assign({}, S), { [Q]: U }), Object.assign(Object.assign({}, x), { [K]: U }));
            }
          }
      }
    }
    return j;
  }
  xt.getBijectionInner = e;
  function n(v, E) {
    if (v.length !== E.length)
      return !1;
    for (let R = v.length; R--; )
      if (v[R] !== E[R])
        return !1;
    return !0;
  }
  function i(v) {
    const E = [];
    for (const R in v)
      E.push(v[R]);
    return E;
  }
  xt.hashValues = i;
  function c(v, E) {
    for (const R in v)
      if (v[R] === E)
        return !0;
    return !1;
  }
  xt.hasValue = c;
  function s(v) {
    return v.filter((E) => o.someTerms(E, (R) => R.termType === "BlankNode" || R.termType === "Quad" && o.getTermsNested(R).some((L) => L.termType === "BlankNode")));
  }
  xt.getQuadsWithBlankNodes = s;
  function d(v) {
    return v.filter((E) => o.everyTerms(E, (R) => R.termType !== "BlankNode" && !(R.termType === "Quad" && o.getTermsNested(R).some((L) => L.termType === "BlankNode"))));
  }
  xt.getQuadsWithoutBlankNodes = d;
  function l(v) {
    const E = {};
    for (const R of v)
      E[JSON.stringify(r.quadToStringQuad(R))] = !0;
    return E;
  }
  xt.indexGraph = l;
  function f(v) {
    return Object.keys(v).map((E) => r.stringQuadToQuad(JSON.parse(E)));
  }
  xt.deindexGraph = f;
  function h(v) {
    return f(l(v));
  }
  xt.uniqGraph = h;
  function p(v) {
    return o.uniqTerms(v.map((E) => o.getBlankNodes(o.getTermsNested(E))).reduce((E, R) => E.concat(R), []));
  }
  xt.getGraphBlankNodes = p;
  function b(v, E, R) {
    const L = Object.assign({}, R), A = {};
    let w = !0;
    for (; w; ) {
      const S = Object.keys(L).length;
      for (const x of E) {
        const F = r.termToString(x);
        if (!L[F]) {
          const [j, q] = _(x, v, L);
          j && (L[F] = q), A[F] = q;
        }
      }
      const O = {};
      for (const x in A) {
        const F = A[x];
        O[F] === void 0 ? O[F] = x : O[F] = !1;
      }
      for (const x in O) {
        const F = O[x];
        F && (L[F] = x);
      }
      w = S !== Object.keys(L).length;
    }
    return [L, A];
  }
  xt.hashTerms = b;
  function _(v, E, R) {
    const L = [];
    let A = !0;
    for (const S of E) {
      const O = o.getTermsNested(S);
      if (O.some((x) => x.equals(v))) {
        L.push(m(S, R, v));
        for (const x of O)
          !T(x, R) && !x.equals(v) && (A = !1);
      }
    }
    const w = y(L.sort().join(""));
    return [A, w];
  }
  xt.hashTerm = _;
  function y(v) {
    return u.sha1().update(v).digest("hex");
  }
  xt.sha1hex = y;
  function m(v, E, R) {
    return o.getTerms(v).map((L) => g(L, E, R)).join("|");
  }
  xt.quadToSignature = m;
  function g(v, E, R) {
    return v.equals(R) ? "@self" : v.termType === "BlankNode" ? E[r.termToString(v)] || "@blank" : v.termType === "Quad" ? `<${m(v, E, R)}>` : r.termToString(v);
  }
  xt.termToSignature = g;
  function T(v, E) {
    return v.termType !== "BlankNode" && !(v.termType === "Quad" && o.getTermsNested(v).some((R) => !T(R, E))) || !!E[r.termToString(v)];
  }
  return xt.isTermGrounded = T, xt;
}
var WR;
function $ne() {
  return WR || (WR = 1, function(u) {
    var r = Pu && Pu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e), Object.defineProperty(a, n, { enumerable: !0, get: function() {
        return t[e];
      } });
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Pu && Pu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(Bne(), u);
  }(Pu)), Pu;
}
var YR;
function Une() {
  if (YR) return Zr;
  YR = 1;
  var u = Zr && Zr.__createBinding || (Object.create ? function(Y, Ee, Ie, Ue) {
    Ue === void 0 && (Ue = Ie);
    var Le = Object.getOwnPropertyDescriptor(Ee, Ie);
    (!Le || ("get" in Le ? !Ee.__esModule : Le.writable || Le.configurable)) && (Le = { enumerable: !0, get: function() {
      return Ee[Ie];
    } }), Object.defineProperty(Y, Ue, Le);
  } : function(Y, Ee, Ie, Ue) {
    Ue === void 0 && (Ue = Ie), Y[Ue] = Ee[Ie];
  }), r = Zr && Zr.__setModuleDefault || (Object.create ? function(Y, Ee) {
    Object.defineProperty(Y, "default", { enumerable: !0, value: Ee });
  } : function(Y, Ee) {
    Y.default = Ee;
  }), o = Zr && Zr.__importStar || function(Y) {
    if (Y && Y.__esModule) return Y;
    var Ee = {};
    if (Y != null) for (var Ie in Y) Ie !== "default" && Object.prototype.hasOwnProperty.call(Y, Ie) && u(Ee, Y, Ie);
    return r(Ee, Y), Ee;
  }, a = Zr && Zr.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.toSparqlJs = Zr.toSparql = void 0;
  const t = $ne(), e = lr(), n = _w(), i = o(yw()), c = a(zS()), s = a(_8()), d = i.types, l = i.expressionTypes;
  let f;
  const h = new c.default();
  function p(Y, Ee = {}) {
    return new n.Generator(Ee).stringify(b(Y));
  }
  Zr.toSparql = p;
  function b(Y) {
    _(), Y = Ve(Y);
    let Ee = y(Y);
    return Ee.type === "group" ? Ee.patterns[0] : Ee;
  }
  Zr.toSparqlJs = b;
  function _() {
    f = { project: !1, extend: [], group: [], aggregates: [], order: [] };
  }
  function y(Y) {
    switch (Y.type !== d.EXTEND && Y.type !== d.ORDER_BY && Y.type !== d.GRAPH && (f.project = !1), Y.type) {
      case d.EXPRESSION:
        return m(Y);
      case d.ASK:
        return be(Y, d.ASK);
      case d.BGP:
        return x(Y);
      case d.CONSTRUCT:
        return F(Y);
      case d.DESCRIBE:
        return be(Y, d.DESCRIBE);
      case d.DISTINCT:
        return j(Y);
      case d.EXTEND:
        return q(Y);
      case d.FROM:
        return Q(Y);
      case d.FILTER:
        return G(Y);
      case d.GRAPH:
        return K(Y);
      case d.GROUP:
        return U(Y);
      case d.JOIN:
        return ae(Y);
      case d.LEFT_JOIN:
        return ye(Y);
      case d.MINUS:
        return pe(Y);
      case d.NOP:
        return {};
      case d.ORDER_BY:
        return ee(Y);
      case d.PATH:
        return Te(Y);
      case d.PATTERN:
        return we(Y);
      case d.PROJECT:
        return be(Y, d.PROJECT);
      case d.REDUCED:
        return V(Y);
      case d.SERVICE:
        return N(Y);
      case d.SLICE:
        return M(Y);
      case d.UNION:
        return I(Y);
      case d.VALUES:
        return P(Y);
      // UPDATE operations
      case d.COMPOSITE_UPDATE:
        return me(Y);
      case d.DELETE_INSERT:
        return Ne(Y);
      case d.LOAD:
        return xe(Y);
      case d.CLEAR:
        return ue(Y);
      case d.CREATE:
        return $(Y);
      case d.DROP:
        return D(Y);
      case d.ADD:
        return X(Y);
      case d.MOVE:
        return te(Y);
      case d.COPY:
        return de(Y);
    }
    throw new Error(`Unknown Operation type ${Y.type}`);
  }
  function m(Y) {
    switch (Y.expressionType) {
      case l.AGGREGATE:
        return v(Y);
      case l.EXISTENCE:
        return E(Y);
      case l.NAMED:
        return R(Y);
      case l.OPERATOR:
        return L(Y);
      case l.TERM:
        return A(Y);
      case l.WILDCARD:
        return w(Y);
    }
    throw new Error(`Unknown Expression Operation type ${Y.expressionType}`);
  }
  function g(Y) {
    switch (Y.type) {
      case d.ALT:
        return B(Y);
      case d.INV:
        return z(Y);
      case d.LINK:
        return H(Y);
      case d.NPS:
        return J(Y);
      case d.ONE_OR_MORE_PATH:
        return k(Y);
      case d.SEQ:
        return W(Y);
      case d.ZERO_OR_MORE_PATH:
        return le(Y);
      case d.ZERO_OR_ONE_PATH:
        return fe(Y);
    }
    throw new Error(`Unknown Path type ${Y.type}`);
  }
  function T(Y) {
    return (0, e.termToString)(Y);
  }
  function v(Y) {
    const Ee = {
      expression: m(Y.expression),
      type: "aggregate",
      aggregation: Y.aggregator,
      distinct: Y.distinct
    };
    return Y.separator && (Ee.separator = Y.separator), Ee;
  }
  function E(Y) {
    return {
      type: "operation",
      operator: Y.not ? "notexists" : "exists",
      args: [{
        type: "group",
        patterns: s.default.flatten([y(Y.input)])
      }]
    };
  }
  function R(Y) {
    return {
      type: "functionCall",
      // Wrong typings
      function: Y.name,
      args: Y.args.map(m)
    };
  }
  function L(Y) {
    if (Y.operator === "desc") {
      const Ie = { expression: m(Y.args[0]) };
      return Ie.descending = !0, Ie;
    }
    const Ee = {
      type: "operation",
      operator: Y.operator,
      args: Y.args.map(m)
    };
    return (Ee.operator === "in" || Ee.operator === "notin") && (Ee.args = [Ee.args[0]].concat([Ee.args.slice(1)])), Ee;
  }
  function A(Y) {
    return Y.term;
  }
  function w(Y) {
    return Y.wildcard;
  }
  function S(Y) {
    return Array.isArray(Y) ? Y.length === 1 ? Y[0] : {
      type: "group",
      patterns: Y
    } : Y;
  }
  function O(Y) {
    return Y;
  }
  function x(Y) {
    let Ee = Y.patterns.map(we);
    return Ee.length === 0 ? null : {
      type: "bgp",
      triples: Ee
    };
  }
  function F(Y) {
    return {
      type: "query",
      prefixes: {},
      queryType: "CONSTRUCT",
      template: Y.template.map(we),
      where: s.default.flatten([
        y(Y.input)
      ])
    };
  }
  function j(Y) {
    let Ee = y(Y.input);
    return Ee.patterns[0].distinct = !0, Ee;
  }
  function q(Y) {
    return f.project ? (f.extend.push(Y), y(Y.input)) : s.default.flatten([
      y(Y.input),
      {
        type: "bind",
        variable: Y.variable,
        expression: m(Y.expression)
      }
    ]);
  }
  function Q(Y) {
    const Ee = y(Y.input);
    let Ie = Ee;
    return Ee.type === "group" && (Ie = Ee.patterns[0]), Ie.from = {
      default: Y.default,
      named: Y.named
    }, Ee;
  }
  function G(Y) {
    return {
      type: "group",
      patterns: s.default.flatten([
        y(Y.input),
        { type: "filter", expression: m(Y.expression) }
      ])
    };
  }
  function K(Y) {
    return {
      type: "graph",
      patterns: s.default.flatten([y(Y.input)]),
      name: Y.name
    };
  }
  function U(Y) {
    const Ee = y(Y.input), Ie = Y.aggregates.map(O);
    return f.aggregates.push(...Ie), f.group.push(...Y.variables), Ee;
  }
  function ae(Y) {
    return s.default.flatten(Y.input.map(y)).reduce((Ie, Ue) => (Ue.type !== "bgp" || Ie.length == 0 || Ie[Ie.length - 1].type !== "bgp" ? Ie.push(Ue) : Ie[Ie.length - 1].triples.push(...Ue.triples), Ie), []);
  }
  function ye(Y) {
    const Ee = {
      type: "optional",
      patterns: [
        y(Y.input[1])
      ]
    };
    return Y.expression && Ee.patterns.push({
      type: "filter",
      expression: m(Y.expression)
    }), Ee.patterns = s.default.flatten(Ee.patterns), s.default.flatten([
      y(Y.input[0]),
      Ee
    ]);
  }
  function pe(Y) {
    let Ee = y(Y.input[1]);
    return Ee.type === "group" && (Ee = Ee.patterns), Array.isArray(Ee) || (Ee = [Ee]), s.default.flatten([
      y(Y.input[0]),
      {
        type: "minus",
        patterns: Ee
      }
    ]);
  }
  function ee(Y) {
    return f.order.push(...Y.expressions), y(Y.input);
  }
  function Te(Y) {
    return {
      type: "bgp",
      triples: [{
        subject: Y.subject,
        predicate: g(Y.predicate),
        object: Y.object
      }]
    };
  }
  function we(Y) {
    return {
      subject: Y.subject,
      predicate: Y.predicate,
      object: Y.object
    };
  }
  function Oe(Y, Ee) {
    let Ie = s.default.isSimpleTerm(Y) ? T(Y) : Y;
    if (typeof Ie == "string") {
      if (Ee[Ie])
        return Ee[Ie];
    } else if (Array.isArray(Y))
      Y = Y.map((Ue) => Oe(Ue, Ee));
    else
      for (let Ue of Object.keys(Y))
        Y[Ue] = Oe(Y[Ue], Ee);
    return Y;
  }
  function be(Y, Ee) {
    const Ie = {
      type: "query",
      prefixes: {}
    }, Ue = Ie;
    let Le;
    Ee === d.PROJECT ? (Ie.queryType = "SELECT", Le = Y.variables) : Ee === d.ASK ? Ie.queryType = "ASK" : Ee === d.DESCRIBE && (Ie.queryType = "DESCRIBE", Le = Y.terms);
    const tt = f.extend, it = f.group, Ye = f.aggregates, ht = f.order;
    _(), f.project = !0;
    let ne = s.default.flatten([y(Y.input)]);
    ne.length === 1 && ne[0].type === "group" && (ne = ne[0].patterns), Ie.where = ne;
    let ie = {};
    for (let He of f.aggregates)
      ie[T(He.variable)] = m(He);
    let je = {};
    for (let He = f.extend.length - 1; He >= 0; --He) {
      let At = f.extend[He];
      je[T(At.variable)] = Oe(m(At.expression), ie);
    }
    f.group.length > 0 && (Ue.group = f.group.map((He) => {
      let At = T(He);
      if (je[At]) {
        let Qe = je[At];
        return delete je[At], {
          variable: He,
          expression: Qe
        };
      }
      return { expression: He };
    })), f.order.length > 0 && (Ue.order = f.order.map(y).map((He) => He.descending ? He : { expression: He })), Le && (Ue.variables = Le.map((He) => {
      let At = T(He);
      if (je[At]) {
        let Qe = je[At];
        return delete je[At], {
          variable: He,
          expression: Qe
        };
      }
      return He;
    }), Ue.variables.length === 0 && (Ue.variables = [new n.Wildcard()]));
    const $e = Object.entries(je);
    if ($e.length > 0) {
      Ue.where = Ue.where || [];
      for (const [He, At] of $e)
        Ue.where.push({
          type: "bind",
          variable: (0, e.stringToTerm)(He),
          expression: At
        });
    }
    if (Ie.where.length > 0 && Ie.where[Ie.where.length - 1].type === "filter") {
      const He = Ie.where[Ie.where.length - 1];
      he(He, Object.keys(ie)) && (Ue.having = s.default.flatten([Oe(He.expression, ie)]), Ie.where.splice(-1));
    }
    return f.extend = tt, f.group = it, f.aggregates = Ye, f.order = ht, { type: "group", patterns: [Ue] };
  }
  function he(Y, Ee) {
    return s.default.isSimpleTerm(Y) ? Ee.indexOf(T(Y)) >= 0 : Array.isArray(Y) ? Y.some((Ie) => he(Ie, Ee)) : Y === Object(Y) ? Object.keys(Y).some((Ie) => he(Y[Ie], Ee)) : Ee.indexOf(Y) >= 0;
  }
  function V(Y) {
    let Ee = y(Y.input);
    return Ee.patterns[0].reduced = !0, Ee;
  }
  function N(Y) {
    let Ee = y(Y.input);
    return Ee.type === "group" && (Ee = Ee.patterns), Array.isArray(Ee) || (Ee = [Ee]), {
      type: "service",
      // Typings are wrong, name can also be a variable
      name: Y.name,
      silent: Y.silent,
      patterns: Ee
    };
  }
  function M(Y) {
    let Ee = y(Y.input), Ie = Ee;
    return Ee.type && Ee.type === "group" && (Ie = Ee.patterns[0]), Y.start !== 0 && (Ie.offset = Y.start), Y.length !== void 0 && (Ie.limit = Y.length), Ee;
  }
  function I(Y) {
    return {
      type: "union",
      patterns: Y.input.map(y).map(S)
    };
  }
  function P(Y) {
    return {
      type: "values",
      values: Y.bindings.map((Ee) => {
        let Ie = {};
        for (let Ue of Y.variables) {
          let Le = `?${Ue.value}`;
          Ee[Le] ? Ie[Le] = Ee[Le] : Ie[Le] = void 0;
        }
        return Ie;
      })
    };
  }
  function B(Y) {
    const Ee = Y.input.map(g);
    return Ee.every((Ie) => "pathType" in Ie && Ie.pathType === "!") ? {
      type: "path",
      pathType: "!",
      items: [{
        type: "path",
        pathType: "|",
        items: s.default.flatten(Ee.map((Ie) => Ie.items))
      }]
    } : {
      type: "path",
      pathType: "|",
      items: Ee
    };
  }
  function z(Y) {
    if (Y.path.type === d.NPS) {
      const Ee = Y.path.iris.map((Ie) => ({
        type: "path",
        pathType: "^",
        items: [Ie]
      }));
      return Ee.length <= 1 ? {
        type: "path",
        pathType: "!",
        items: Ee
      } : {
        type: "path",
        pathType: "!",
        items: [{
          type: "path",
          pathType: "|",
          items: Ee
        }]
      };
    }
    return {
      type: "path",
      pathType: "^",
      items: [g(Y.path)]
    };
  }
  function H(Y) {
    return Y.iri;
  }
  function J(Y) {
    return Y.iris.length <= 1 ? {
      type: "path",
      pathType: "!",
      items: Y.iris
    } : {
      type: "path",
      pathType: "!",
      items: [{
        type: "path",
        pathType: "|",
        items: Y.iris
      }]
    };
  }
  function k(Y) {
    return {
      type: "path",
      pathType: "+",
      items: [g(Y.path)]
    };
  }
  function W(Y) {
    return {
      type: "path",
      pathType: "/",
      items: Y.input.map(g)
    };
  }
  function le(Y) {
    return {
      type: "path",
      pathType: "*",
      items: [g(Y.path)]
    };
  }
  function fe(Y) {
    return {
      type: "path",
      // Typings are missing this path
      pathType: "?",
      items: [g(Y.path)]
    };
  }
  function me(Y) {
    const Ee = Y.updates.map((Ie) => y(Ie).updates[0]);
    return { prefixes: {}, type: "update", updates: Ee };
  }
  function Ne(Y) {
    var Ee;
    let Ie = Y.where, Ue;
    if (Ie && Ie.type === d.FROM) {
      let tt = Ie;
      Ie = tt.input, Ue = { default: tt.default, named: tt.named };
    }
    const Le = [{
      updateType: "insertdelete",
      delete: De(Y.delete || []),
      insert: De(Y.insert || [])
    }];
    if (Ue && (Le[0].using = Ue), !Ie || Ie.type === d.BGP && Ie.patterns.length === 0)
      Le[0].where = [];
    else {
      const tt = [];
      let it = y(qe(Ie, tt));
      if (it.type === "group" ? Le[0].where = it.patterns : Le[0].where = [it], tt.length > 0) {
        if (tt.length !== 1)
          throw new Error("This is unexpected and might indicate an error in graph handling for updates.");
        ((Ee = tt[0]) === null || Ee === void 0 ? void 0 : Ee.value) !== "" && (Le[0].where = [{ type: "graph", patterns: Le[0].where, name: tt[0] }]);
      }
    }
    return !Y.delete && !Y.where ? (Le[0].updateType = "insert", delete Le[0].delete, delete Le[0].where) : !Y.insert && !Y.where ? (delete Le[0].insert, delete Le[0].where, Y.delete.some((tt) => tt.subject.termType === "Variable" || tt.predicate.termType === "Variable" || tt.object.termType === "Variable") ? Le[0].updateType = "deletewhere" : Le[0].updateType = "delete") : !Y.insert && Y.where && Y.where.type === "bgp" && (0, t.isomorphic)(Y.delete, Y.where.patterns) && (delete Le[0].where, Le[0].updateType = "deletewhere"), { prefixes: {}, type: "update", updates: Le };
  }
  function xe(Y) {
    const Ee = [{ type: "load", silent: !!Y.silent, source: Y.source }];
    return Y.destination && (Ee[0].destination = Y.destination), { prefixes: {}, type: "update", updates: Ee };
  }
  function ue(Y) {
    return C(Y, "clear");
  }
  function $(Y) {
    return C(Y, "create");
  }
  function D(Y) {
    return C(Y, "drop");
  }
  function C(Y, Ee) {
    const Ie = [{ type: Ee, silent: !!Y.silent }];
    return Y.source === "DEFAULT" ? Ie[0].graph = { default: !0 } : Y.source === "NAMED" ? Ie[0].graph = { named: !0 } : Y.source === "ALL" ? Ie[0].graph = { all: !0 } : Ie[0].graph = { type: "graph", name: Y.source }, { prefixes: {}, type: "update", updates: Ie };
  }
  function X(Y) {
    return oe(Y, "add");
  }
  function te(Y) {
    return oe(Y, "move");
  }
  function de(Y) {
    return oe(Y, "copy");
  }
  function oe(Y, Ee) {
    const Ie = [{ type: Ee, silent: !!Y.silent }];
    return Ie[0].source = Y.source === "DEFAULT" ? { type: "graph", default: !0 } : { type: "graph", name: Y.source }, Ie[0].destination = Y.destination === "DEFAULT" ? { type: "graph", default: !0 } : { type: "graph", name: Y.destination }, { prefixes: {}, type: "update", updates: Ie };
  }
  function De(Y) {
    if (!Y)
      return [];
    const Ee = {};
    return Y.forEach((Ie) => {
      const Ue = Ie.graph.value;
      Ee[Ue] || (Ee[Ue] = []), Ee[Ue].push(Ie);
    }), Object.keys(Ee).map((Ie) => Ie === "" ? { type: "bgp", triples: Ee[Ie].map(we) } : { type: "graph", triples: Ee[Ie].map(we), name: Ee[Ie][0].graph });
  }
  function Ve(Y) {
    return qe(Y, []);
  }
  function qe(Y, Ee) {
    if (Array.isArray(Y))
      return Y.map((it) => qe(it, Ee));
    if (!Y.type || Y.type === d.DELETE_INSERT)
      return Y;
    if ((Y.type === d.PATTERN || Y.type === d.PATH) && Y.graph)
      return Ee.push(Y.graph), Y.graph.name !== "" ? Y.type === d.PATTERN ? h.createPattern(Y.subject, Y.predicate, Y.object) : h.createPath(Y.subject, Y.predicate, Y.object) : Y;
    const Ie = {}, Ue = {}, Le = {};
    for (let it of Object.keys(Y)) {
      const Ye = [];
      if (Ie[it] = qe(Y[it], Ye), Ye.length > 0) {
        Ue[it] = Ye;
        for (const ht of Ye)
          Le[ht.value] = ht;
      }
    }
    const tt = Object.keys(Le);
    if (tt.length > 0)
      if (tt.length === 1 && ![d.PROJECT, d.SERVICE].includes(Y.type))
        Ee.push(Le[tt[0]]);
      else {
        if (Y.type === d.BGP)
          return Ke(Y, Ue.patterns);
        for (let it of Object.keys(Ue)) {
          const Ye = Ie[it];
          Array.isArray(Ye) ? Ie[it] = Ye.map((ht, ne) => Ue[it][0].value === "" ? ht : h.createGraph(ht, Ue[it][ne])) : Ue[it][0].value !== "" && (Ie[it] = h.createGraph(Ye, Ue[it][0]));
        }
      }
    return Ie;
  }
  function Ke(Y, Ee) {
    var Ie;
    const Ue = {};
    for (let it = 0; it < Y.patterns.length; ++it) {
      const Ye = Y.patterns[it], ht = Ee[it].value;
      Ue[ht] = (Ie = Ue[ht]) !== null && Ie !== void 0 ? Ie : { patterns: [], graph: Ee[it] }, Ue[ht].patterns.push(Ye);
    }
    let Le = [];
    for (const [it, { patterns: Ye, graph: ht }] of Object.entries(Ue)) {
      const ne = h.createBgp(Ye);
      Le.push(it === "" ? ne : h.createGraph(ne, ht));
    }
    let tt = Le[0];
    for (let it = 1; it < Le.length; ++it)
      tt = h.createJoin([tt, Le[it]]);
    return tt;
  }
  return Zr;
}
var ZR;
function ft() {
  return ZR || (ZR = 1, function(u) {
    var r = Jn && Jn.__createBinding || (Object.create ? function(d, l, f, h) {
      h === void 0 && (h = f);
      var p = Object.getOwnPropertyDescriptor(l, f);
      (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(d, h, p);
    } : function(d, l, f, h) {
      h === void 0 && (h = f), d[h] = l[f];
    }), o = Jn && Jn.__setModuleDefault || (Object.create ? function(d, l) {
      Object.defineProperty(d, "default", { enumerable: !0, value: l });
    } : function(d, l) {
      d.default = l;
    }), a = Jn && Jn.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var l = {};
      if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && r(l, d, f);
      return o(l, d), l;
    }, t = Jn && Jn.__importDefault || function(d) {
      return d && d.__esModule ? d : { default: d };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.Util = u.toSparqlJs = u.toSparql = u.Factory = u.Algebra = u.translate = void 0;
    const e = t(Nne());
    u.translate = e.default;
    const n = a(yw());
    u.Algebra = n;
    const i = t(zS());
    u.Factory = i.default;
    const c = Une();
    Object.defineProperty(u, "toSparql", { enumerable: !0, get: function() {
      return c.toSparql;
    } }), Object.defineProperty(u, "toSparqlJs", { enumerable: !0, get: function() {
      return c.toSparqlJs;
    } });
    const s = t(_8());
    u.Util = s.default;
  }(Jn)), Jn;
}
var Lu = {}, Wh = {}, eF;
function Vne() {
  if (eF) return Wh;
  eF = 1, Object.defineProperty(Wh, "__esModule", { value: !0 }), Wh.asTermType = void 0;
  function u(r) {
    if (r === "namedNode" || r === "literal" || r === "blankNode" || r === "quad")
      return r;
  }
  return Wh.asTermType = u, Wh;
}
var Yh = {}, tF;
function Qne() {
  if (tF) return Yh;
  tF = 1, Object.defineProperty(Yh, "__esModule", { value: !0 }), Yh.Variable = void 0;
  const u = /* @__PURE__ */ ru();
  class r {
    constructor(a) {
      this.expressionType = u.ExpressionType.Variable, this.name = a;
    }
  }
  return Yh.Variable = r, Yh;
}
var pt = {}, Kn = {}, rF;
function Wf() {
  if (rF) return Kn;
  rF = 1, Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.SparqlOperator = Kn.TypeURL = Kn.typedLiteral = Kn.TypeAlias = void 0;
  const u = Or();
  var r;
  (function(n) {
    n.SPARQL_NUMERIC = "SPARQL_NUMERIC", n.SPARQL_STRINGLY = "SPARQL_STRINGLY";
  })(r || (Kn.TypeAlias = r = {}));
  const o = new u.DataFactory();
  function a(n, i) {
    return o.literal(n, o.namedNode(i));
  }
  Kn.typedLiteral = a;
  var t;
  (function(n) {
    n.XSD_ANY_URI = "http://www.w3.org/2001/XMLSchema#anyURI", n.XSD_STRING = "http://www.w3.org/2001/XMLSchema#string", n.RDF_LANG_STRING = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString", n.XSD_BOOLEAN = "http://www.w3.org/2001/XMLSchema#boolean", n.XSD_DATE_TIME = "http://www.w3.org/2001/XMLSchema#dateTime", n.XSD_DATE_TIME_STAMP = "http://www.w3.org/2001/XMLSchema#dateTimeStamp", n.XSD_DATE = "http://www.w3.org/2001/XMLSchema#date", n.XSD_G_MONTH = "http://www.w3.org/2001/XMLSchema#gMonth", n.XSD_G_MONTHDAY = "http://www.w3.org/2001/XMLSchema#gMonthDay", n.XSD_G_YEAR = "http://www.w3.org/2001/XMLSchema#gYear", n.XSD_G_YEAR_MONTH = "http://www.w3.org/2001/XMLSchema#gYearMonth", n.XSD_TIME = "http://www.w3.org/2001/XMLSchema#time", n.XSD_G_DAY = "http://www.w3.org/2001/XMLSchema#gDay", n.XSD_DECIMAL = "http://www.w3.org/2001/XMLSchema#decimal", n.XSD_FLOAT = "http://www.w3.org/2001/XMLSchema#float", n.XSD_DOUBLE = "http://www.w3.org/2001/XMLSchema#double", n.XSD_INTEGER = "http://www.w3.org/2001/XMLSchema#integer", n.XSD_NON_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", n.XSD_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#negativeInteger", n.XSD_LONG = "http://www.w3.org/2001/XMLSchema#long", n.XSD_INT = "http://www.w3.org/2001/XMLSchema#int", n.XSD_SHORT = "http://www.w3.org/2001/XMLSchema#short", n.XSD_BYTE = "http://www.w3.org/2001/XMLSchema#byte", n.XSD_NON_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", n.XSD_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#positiveInteger", n.XSD_UNSIGNED_LONG = "http://www.w3.org/2001/XMLSchema#unsignedLong", n.XSD_UNSIGNED_INT = "http://www.w3.org/2001/XMLSchema#unsignedInt", n.XSD_UNSIGNED_SHORT = "http://www.w3.org/2001/XMLSchema#unsignedShort", n.XSD_UNSIGNED_BYTE = "http://www.w3.org/2001/XMLSchema#unsignedByte", n.XSD_NORMALIZED_STRING = "http://www.w3.org/2001/XMLSchema#normalizedString", n.XSD_TOKEN = "http://www.w3.org/2001/XMLSchema#token", n.XSD_LANGUAGE = "http://www.w3.org/2001/XMLSchema#language", n.XSD_NM_TOKEN = "http://www.w3.org/2001/XMLSchema#NMTOKEN", n.XSD_NAME = "http://www.w3.org/2001/XMLSchema#name", n.XSD_NC_NAME = "http://www.w3.org/2001/XMLSchema#NCName", n.XSD_ENTITY = "http://www.w3.org/2001/XMLSchema#ENTITY", n.XSD_ID = "http://www.w3.org/2001/XMLSchema#ID", n.XSD_ID_REF = "http://www.w3.org/2001/XMLSchema#IDREF", n.XSD_DURATION = "http://www.w3.org/2001/XMLSchema#duration", n.XSD_YEAR_MONTH_DURATION = "http://www.w3.org/2001/XMLSchema#yearMonthDuration", n.XSD_DAY_TIME_DURATION = "http://www.w3.org/2001/XMLSchema#dayTimeDuration";
  })(t || (Kn.TypeURL = t = {}));
  var e;
  return function(n) {
    n.NOT = "!", n.UMINUS = "uminus", n.UPLUS = "uplus", n.LOGICAL_OR = "||", n.LOGICAL_AND = "&&", n.EQUAL = "=", n.NOT_EQUAL = "!=", n.LT = "<", n.GT = ">", n.LTE = "<=", n.GTE = ">=", n.SAME_TERM = "sameterm", n.IN = "in", n.NOT_IN = "notin", n.MULTIPLICATION = "*", n.DIVISION = "/", n.ADDITION = "+", n.SUBTRACTION = "-", n.IS_IRI = "isiri", n.IS_URI = "isuri", n.IS_BLANK = "isblank", n.IS_LITERAL = "isliteral", n.IS_NUMERIC = "isnumeric", n.STR = "str", n.LANG = "lang", n.DATATYPE = "datatype", n.IRI = "iri", n.URI = "uri", n.BNODE = "bnode", n.STRDT = "strdt", n.STRLANG = "strlang", n.UUID = "uuid", n.STRUUID = "struuid", n.STRLEN = "strlen", n.SUBSTR = "substr", n.UCASE = "ucase", n.LCASE = "lcase", n.STRSTARTS = "strstarts", n.STRENDS = "strends", n.CONTAINS = "contains", n.STRBEFORE = "strbefore", n.STRAFTER = "strafter", n.ENCODE_FOR_URI = "encode_for_uri", n.CONCAT = "concat", n.LANG_MATCHES = "langmatches", n.REGEX = "regex", n.REPLACE = "replace", n.ABS = "abs", n.ROUND = "round", n.CEIL = "ceil", n.FLOOR = "floor", n.RAND = "rand", n.NOW = "now", n.YEAR = "year", n.MONTH = "month", n.DAY = "day", n.HOURS = "hours", n.MINUTES = "minutes", n.SECONDS = "seconds", n.TIMEZONE = "timezone", n.TZ = "tz", n.MD5 = "md5", n.SHA1 = "sha1", n.SHA256 = "sha256", n.SHA384 = "sha384", n.SHA512 = "sha512", n.TRIPLE = "triple", n.SUBJECT = "subject", n.PREDICATE = "predicate", n.OBJECT = "object", n.IS_TRIPLE = "istriple", n.BOUND = "bound", n.IF = "if", n.COALESCE = "coalesce";
  }(e || (Kn.SparqlOperator = e = {})), Kn;
}
var gt = {}, nF;
function K0() {
  if (nF) return gt;
  nF = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.NoAggregator = gt.ExtensionFunctionError = gt.InvalidExpression = gt.InvalidArity = gt.UnexpectedError = gt.ParseError = gt.EmptyAggregateError = gt.IncompatibleLanguageOperation = gt.InvalidTimezoneCall = gt.CastError = gt.InvalidArgumentTypes = gt.InError = gt.CoalesceError = gt.RDFEqualTypeError = gt.EBVCoercionError = gt.UnboundVariableError = gt.InvalidLexicalForm = gt.isExpressionError = gt.ExpressionError = void 0;
  class u extends Error {
  }
  gt.ExpressionError = u;
  function r(T) {
    return T instanceof u;
  }
  gt.isExpressionError = r;
  class o extends u {
    constructor(v) {
      super(`Invalid lexical form '${g(v)}'`), this.arg = v;
    }
  }
  gt.InvalidLexicalForm = o;
  class a extends u {
    constructor(v, E) {
      super(`Unbound variable '${g(v)}'`), this.variable = v, this.bindings = E;
    }
  }
  gt.UnboundVariableError = a;
  class t extends u {
    constructor(v) {
      super(`Cannot coerce term to EBV '${g(v)}'`), this.arg = v;
    }
  }
  gt.EBVCoercionError = t;
  class e extends u {
    constructor(v) {
      super("Equality test for literals with unsupported datatypes"), this.args = v;
    }
  }
  gt.RDFEqualTypeError = e;
  class n extends u {
    constructor(v) {
      super("All COALESCE arguments threw errors"), this.errors = v;
    }
  }
  gt.CoalesceError = n;
  class i extends u {
    constructor(v) {
      super(`Some argument to IN errorred and none where equal. ${v.map((E) => `(${E.toString()}) `).join("and ")}`), this.errors = v;
    }
  }
  gt.InError = i;
  class c extends u {
    constructor(v, E) {
      super(`Argument types not valid for operator: '${g(E)}' with '${g(v)}`), this.args = v, this.op = E;
    }
  }
  gt.InvalidArgumentTypes = c;
  class s extends u {
    constructor(v, E) {
      super(`Invalid cast: '${g(v)}' to '${g(E)}'`), this.arg = v;
    }
  }
  gt.CastError = s;
  class d extends u {
    constructor(v) {
      super(`TIMEZONE call on ${v} which has no timezone`), this.dateString = v;
    }
  }
  gt.InvalidTimezoneCall = d;
  class l extends u {
    constructor(v, E) {
      super(`Operation on incompatible language literals '${g(v)}' and '${g(E)}'`), this.arg1 = v, this.arg2 = E;
    }
  }
  gt.IncompatibleLanguageOperation = l;
  class f extends u {
    constructor() {
      super("Empty aggregate expression");
    }
  }
  gt.EmptyAggregateError = f;
  class h extends u {
    constructor(v, E) {
      super(`Failed to parse "${v}" as ${E}.`);
    }
  }
  gt.ParseError = h;
  class p extends Error {
    constructor(v, E) {
      super(`Programmer Error '${v}'`), this.payload = E;
    }
  }
  gt.UnexpectedError = p;
  class b extends Error {
    constructor(v, E) {
      super(`The number of args does not match the arity of the operator '${g(E)}'.`), this.args = v, this.op = E;
    }
  }
  gt.InvalidArity = b;
  class _ extends Error {
    constructor(v) {
      super(`Invalid SPARQL Expression '${g(v)}'`);
    }
  }
  gt.InvalidExpression = _;
  class y extends Error {
    constructor(v, E) {
      E instanceof Error ? super(`Error thrown in ${v}: ${E.message}${E.stack ? `
${E.stack}` : ""}`) : super(`Error thrown in ${v}`);
    }
  }
  gt.ExtensionFunctionError = y;
  class m extends Error {
    constructor(v) {
      super(`Aggregate expression ${g(v)} found, but no aggregate hook provided.`);
    }
  }
  gt.NoAggregator = m;
  function g(T) {
    return JSON.stringify(T);
  }
  return gt;
}
var Wn = {}, iF;
function Hne() {
  if (iF) return Wn;
  iF = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.serializeDuration = Wn.serializeTime = Wn.serializeDate = Wn.serializeDateTime = void 0;
  function u(n, i = 2) {
    return n.toLocaleString(void 0, { minimumIntegerDigits: i, useGrouping: !1 });
  }
  function r(n) {
    return `${a({ year: n.year, month: n.month, day: n.day })}T${t(n)}`;
  }
  Wn.serializeDateTime = r;
  function o(n) {
    return n.zoneHours === void 0 || n.zoneMinutes === void 0 ? "" : n.zoneHours === 0 && n.zoneMinutes === 0 ? "Z" : `${n.zoneHours >= 0 ? `+${u(n.zoneHours)}` : u(n.zoneHours)}:${u(Math.abs(n.zoneMinutes))}`;
  }
  function a(n) {
    return `${u(n.year, 4)}-${u(n.month)}-${u(n.day)}${o(n)}`;
  }
  Wn.serializeDate = a;
  function t(n) {
    return `${u(n.hours)}:${u(n.minutes)}:${u(n.seconds)}${o(n)}`;
  }
  Wn.serializeTime = t;
  function e(n, i = "PT0S") {
    if (!Object.values(n).some((_) => (_ || 0) !== 0))
      return i;
    const c = Object.values(n).some((_) => (_ || 0) < 0) ? "-" : "", s = n.year ? `${Math.abs(n.year)}Y` : "", d = n.month ? `${Math.abs(n.month)}M` : "", l = n.day ? `${Math.abs(n.day)}D` : "", f = `${c}P${s}${d}${l}`;
    if (!(n.hours || n.minutes || n.seconds))
      return f;
    const h = n.hours ? `${Math.abs(n.hours)}H` : "", p = n.minutes ? `${Math.abs(n.minutes)}M` : "", b = n.seconds ? `${Math.abs(n.seconds)}S` : "";
    return `${f}T${h}${p}${b}`;
  }
  return Wn.serializeDuration = e, Wn;
}
var FA = {}, Wt = {}, Zh = {}, aF;
function zK() {
  if (aF) return Zh;
  aF = 1, Object.defineProperty(Zh, "__esModule", { value: !0 }), Zh.OverloadTree = void 0;
  const u = /* @__PURE__ */ W0(), r = /* @__PURE__ */ kS();
  let o = class ex {
    constructor(t, e) {
      this.identifier = t, this.implementation = void 0, this.generalOverloads = /* @__PURE__ */ Object.create(null), this.literalOverLoads = [], this.depth = e ?? 0, this.promotionCount = void 0;
    }
    getSubtree(t) {
      const e = (0, r.asGeneralType)(t);
      if (e)
        return this.generalOverloads[e];
      for (const [n, i] of this.literalOverLoads)
        if (t === n)
          return i;
    }
    /**
     * Get the implementation for the types that exactly match @param args .
     */
    getImplementationExact(t) {
      let e = this;
      for (const n of t)
        if (e = e.getSubtree(n), !e)
          return;
      return e.implementation;
    }
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args the arguments to the function.
     * @param superTypeProvider
     * @param functionArgumentsCache
     */
    search(t, e, n) {
      let i = n[this.identifier], c = 0;
      for (; c < t.length && (i != null && i.cache); ) {
        const l = t[c], f = (0, u.isLiteralTermExpression)(l);
        i = i.cache[f ? f.dataType : l.termType], c++;
      }
      if (c === t.length && (i != null && i.func))
        return i.func;
      const s = [], d = 0;
      if (t.length === 0)
        return this.implementation;
      for (s.push(...this.getSubTreeWithArg(t[d], e).map((l) => ({ node: l, index: d + 1 }))); s.length > 0; ) {
        const { index: l, node: f } = s.pop();
        if (l === t.length && f.implementation)
          return this.addToCache(n, t, f.implementation), f.implementation;
        s.push(...f.getSubTreeWithArg(t[l], e).map((h) => ({ node: h, index: l + 1 })));
      }
    }
    addToCache(t, e, n) {
      function i(s, d) {
        return d in s || (s[d] = {}), s[d];
      }
      let c = i(t, this.identifier);
      for (const s of e) {
        const d = (0, u.isLiteralTermExpression)(s), l = d ? d.dataType : s.termType;
        c.cache = c.cache ?? {}, c = i(c.cache, l);
      }
      c.func = n;
    }
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param argumentTypes a list of argumentTypes that would need to be provided in
     * the same order to get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(t, e) {
      this._addOverload([...t], e, 0);
    }
    _addOverload(t, e, n) {
      const [i, ...c] = t;
      if (!i) {
        (this.promotionCount === void 0 || n <= this.promotionCount) && (this.promotionCount = n, this.implementation = e);
        return;
      }
      let s = this.getSubtree(i);
      if (!s) {
        const d = new ex(this.identifier, this.depth + 1), l = (0, r.asGeneralType)(i);
        l && (this.generalOverloads[l] = d);
        const f = (0, r.asOverrideType)(i);
        f && this.literalOverLoads.push([f, d]), s = d;
      }
      if (s._addOverload(c, e, n), r.typePromotion[i])
        for (const d of r.typePromotion[i])
          this.addPromotedOverload(d.typeToPromote, e, d.conversionFunction, c, n);
    }
    addPromotedOverload(t, e, n, i, c) {
      let s = this.getSubtree(t);
      if (!s) {
        const d = new ex(this.identifier, this.depth + 1);
        this.literalOverLoads.push([t, d]), s = d;
      }
      s._addOverload(i, (d) => (l) => e(d)([
        ...l.slice(0, this.depth),
        n(l[this.depth]),
        ...l.slice(this.depth + 1, l.length)
      ]), c + 1);
    }
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @param openWorldType interface allowing to discover relations between types.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    getSubTreeWithArg(t, e) {
      const n = [], i = (0, u.isLiteralTermExpression)(t);
      if (this.generalOverloads.term && n.push(this.generalOverloads.term), this.generalOverloads[t.termType] && n.push(this.generalOverloads[t.termType]), i) {
        const c = (0, r.asKnownLiteralType)(i.dataType);
        let s;
        c ? s = r.superTypeDictTable[c] : s = (0, r.getSuperTypes)(i.dataType, e);
        const d = this.literalOverLoads.filter(([l, f]) => l in s).map(([l, f]) => [s[l], f]);
        d.sort(([l, f], [h, p]) => l - h), n.push(...d.map(([l, f]) => f));
      }
      return n;
    }
  };
  return Zh.OverloadTree = o, Zh;
}
var uF;
function kK() {
  if (uF) return Wt;
  uF = 1, Object.defineProperty(Wt, "__esModule", { value: !0 }), Wt.expressionToVar = Wt.dateTime = Wt.langString = Wt.string = Wt.double = Wt.float = Wt.decimal = Wt.integer = Wt.bool = Wt.Builder = Wt.declare = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ W0(), o = /* @__PURE__ */ W0(), a = /* @__PURE__ */ Wf(), t = /* @__PURE__ */ Wf(), e = /* @__PURE__ */ K0(), n = /* @__PURE__ */ zK();
  function i(m) {
    return new c(m);
  }
  Wt.declare = i;
  class c {
    constructor(g) {
      this.overloadTree = new n.OverloadTree(g), this.collected = !1;
    }
    collect() {
      if (this.collected)
        throw new Error("Builders can only be collected once!");
      return this.collected = !0, this.overloadTree;
    }
    static wrapInvalidLexicalProtected(g) {
      return (T) => (v) => {
        for (const [E, R] of v.entries())
          if (R instanceof o.NonLexicalLiteral)
            throw new e.InvalidLexicalForm(v[E].toRDF(T.context.getSafe(u.KeysInitQuery.dataFactory)));
        return g(T)(v);
      };
    }
    set(g, T, v = !0) {
      return this.overloadTree.addOverload(g, v ? c.wrapInvalidLexicalProtected(T) : T), this;
    }
    copy({ from: g, to: T }) {
      const v = this.overloadTree.getImplementationExact(g);
      if (!v)
        throw new e.UnexpectedError("Tried to copy implementation, but types not found", { from: g, to: T });
      return this.set(T, v);
    }
    onUnary(g, T, v = !0) {
      return this.set([g], (E) => ([R]) => T(E)(R), v);
    }
    onUnaryTyped(g, T, v = !0) {
      return this.set([g], (E) => ([R]) => T(E)(R.typedValue), v);
    }
    onBinary(g, T, v = !0) {
      return this.set(g, (E) => ([R, L]) => T(E)(R, L), v);
    }
    onBinaryTyped(g, T, v = !0) {
      return this.set(g, (E) => ([R, L]) => T(E)(R.typedValue, L.typedValue), v);
    }
    onTernaryTyped(g, T, v = !0) {
      return this.set(g, (E) => ([R, L, A]) => T(E)(R.typedValue, L.typedValue, A.typedValue), v);
    }
    onTernary(g, T, v = !0) {
      return this.set(g, (E) => ([R, L, A]) => T(E)(R, L, A), v);
    }
    onQuaternaryTyped(g, T, v = !0) {
      return this.set(g, (E) => ([R, L, A, w]) => T(E)(R.typedValue, L.typedValue, A.typedValue, w.typedValue), v);
    }
    onTerm1(g, T = !1) {
      return this.set(["term"], (v) => ([E]) => g(v)(E), T);
    }
    onTerm3(g) {
      return this.set(["term", "term", "term"], (T) => ([v, E, R]) => g(T)(v, E, R));
    }
    onQuad1(g) {
      return this.set(["quad"], (T) => ([v]) => g(T)(v));
    }
    onLiteral1(g, T = !0) {
      return this.set(["literal"], (v) => ([E]) => g(v)(E), T);
    }
    onBoolean1(g, T = !0) {
      return this.set([a.TypeURL.XSD_BOOLEAN], (v) => ([E]) => g(v)(E), T);
    }
    onBoolean1Typed(g, T = !0) {
      return this.set([a.TypeURL.XSD_BOOLEAN], (v) => ([E]) => g(v)(E.typedValue), T);
    }
    onString1(g, T = !0) {
      return this.set([a.TypeURL.XSD_STRING], (v) => ([E]) => g(v)(E), T);
    }
    onString1Typed(g, T = !0) {
      return this.set([a.TypeURL.XSD_STRING], (v) => ([E]) => g(v)(E.typedValue), T);
    }
    onLangString1(g, T = !0) {
      return this.set([a.TypeURL.RDF_LANG_STRING], (v) => ([E]) => g(v)(E), T);
    }
    onStringly1(g, T = !0) {
      return this.set([a.TypeAlias.SPARQL_STRINGLY], (v) => ([E]) => g(v)(E), T);
    }
    onStringly1Typed(g, T = !0) {
      return this.set([a.TypeAlias.SPARQL_STRINGLY], (v) => ([E]) => g(v)(E.typedValue), T);
    }
    onNumeric1(g, T = !0) {
      return this.set([a.TypeAlias.SPARQL_NUMERIC], (v) => ([E]) => g(v)(E), T);
    }
    onDateTime1(g, T = !0) {
      return this.set([a.TypeURL.XSD_DATE_TIME], (v) => ([E]) => g(v)(E), T);
    }
    /**
     * We return the base types and not the provided types because we don't want to create invalid terms.
     * Providing negative number to a function unary - for example should not
     * return a term of type negative number having a positive value.
     * @param op the numeric operator performed
     * @param addInvalidHandling whether to add invalid handling,
     *   whether to add @param op in @see wrapInvalidLexicalProtected
     */
    numericConverter(g, T = !0) {
      const v = (E) => (R) => g(E)(R.typedValue);
      return this.onUnary(t.TypeURL.XSD_INTEGER, (E) => (R) => d(v(E)(R)), T).onUnary(t.TypeURL.XSD_DECIMAL, (E) => (R) => l(v(E)(R)), T).onUnary(t.TypeURL.XSD_FLOAT, (E) => (R) => f(v(E)(R)), T).onUnary(t.TypeURL.XSD_DOUBLE, (E) => (R) => h(v(E)(R)), T);
    }
    /**
     * !!! Be aware when using this function, it will create different overloads with different return types !!!
     * Arithmetic operators take 2 numeric arguments, and return a single numerical
     * value. The type of the return value is heavily dependent on the types of the
     * input arguments. In JS everything is a double, but in SPARQL it is not.
     *
     * The different arguments are handled by type promotion and subtype substitution.
     * The way numeric function arguments work is described here:
     * https://www.w3.org/TR/xpath20/#mapping
     * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping
     */
    arithmetic(g, T = !0) {
      const v = (E) => (R, L) => g(E)(R.typedValue, L.typedValue);
      return this.onBinary([t.TypeURL.XSD_INTEGER, t.TypeURL.XSD_INTEGER], (E) => (R, L) => d(v(E)(R, L)), T).onBinary([t.TypeURL.XSD_DECIMAL, t.TypeURL.XSD_DECIMAL], (E) => (R, L) => l(v(E)(R, L)), T).onBinary([t.TypeURL.XSD_FLOAT, t.TypeURL.XSD_FLOAT], (E) => (R, L) => f(v(E)(R, L)), T).onBinary([t.TypeURL.XSD_DOUBLE, t.TypeURL.XSD_DOUBLE], (E) => (R, L) => h(v(E)(R, L)), T);
    }
    numberTest(g) {
      return this.numeric((T) => ([v, E]) => {
        const R = g(T)(v.typedValue, E.typedValue);
        return s(R);
      });
    }
    stringTest(g, T = !0) {
      return this.set([a.TypeURL.XSD_STRING, a.TypeURL.XSD_STRING], (v) => ([E, R]) => {
        const L = g(v)(E.typedValue, R.typedValue);
        return s(L);
      }, T);
    }
    booleanTest(g, T = !0) {
      return this.set([a.TypeURL.XSD_BOOLEAN, a.TypeURL.XSD_BOOLEAN], (v) => ([E, R]) => {
        const L = g(v)(E.typedValue, R.typedValue);
        return s(L);
      }, T);
    }
    dateTimeTest(g, T = !0) {
      return this.set([a.TypeURL.XSD_DATE_TIME, a.TypeURL.XSD_DATE_TIME], (v) => ([E, R]) => {
        const L = g(v)(E.typedValue, R.typedValue);
        return s(L);
      }, T);
    }
    numeric(g) {
      return this.set([a.TypeAlias.SPARQL_NUMERIC, a.TypeAlias.SPARQL_NUMERIC], g);
    }
  }
  Wt.Builder = c;
  function s(m) {
    return new r.BooleanLiteral(m);
  }
  Wt.bool = s;
  function d(m) {
    return new r.IntegerLiteral(m);
  }
  Wt.integer = d;
  function l(m) {
    return new r.DecimalLiteral(m);
  }
  Wt.decimal = l;
  function f(m) {
    return new r.FloatLiteral(m);
  }
  Wt.float = f;
  function h(m) {
    return new r.DoubleLiteral(m);
  }
  Wt.double = h;
  function p(m) {
    return new r.StringLiteral(m);
  }
  Wt.string = p;
  function b(m, g) {
    return new r.LangStringLiteral(m, g);
  }
  Wt.langString = b;
  function _(m, g) {
    return new r.DateTimeLiteral(m, g);
  }
  Wt.dateTime = _;
  function y(m, g) {
    return m.variable(g.name.slice(1));
  }
  return Wt.expressionToVar = y, Wt;
}
var oF;
function kS() {
  return oF || (oF = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.typePromotion = u.isSubTypeOf = u.getSuperTypeDict = u.isInternalSubType = u.asGeneralType = u.asOverrideType = u.asKnownLiteralType = u.asTypeAlias = u.typeAliasCheck = u.extensionTableInit = u.getSuperTypes = u.superTypeDictTable = u.extensionTableInput = void 0;
    const r = /* @__PURE__ */ W0(), o = /* @__PURE__ */ kK(), a = /* @__PURE__ */ Wf();
    u.extensionTableInput = {
      // Datetime types
      [a.TypeURL.XSD_DATE_TIME_STAMP]: a.TypeURL.XSD_DATE_TIME,
      // Duration types
      [a.TypeURL.XSD_DAY_TIME_DURATION]: a.TypeURL.XSD_DURATION,
      [a.TypeURL.XSD_YEAR_MONTH_DURATION]: a.TypeURL.XSD_DURATION,
      // Stringly types
      [a.TypeURL.RDF_LANG_STRING]: a.TypeAlias.SPARQL_STRINGLY,
      [a.TypeURL.XSD_STRING]: a.TypeAlias.SPARQL_STRINGLY,
      // String types
      [a.TypeURL.XSD_NORMALIZED_STRING]: a.TypeURL.XSD_STRING,
      [a.TypeURL.XSD_TOKEN]: a.TypeURL.XSD_NORMALIZED_STRING,
      [a.TypeURL.XSD_LANGUAGE]: a.TypeURL.XSD_TOKEN,
      [a.TypeURL.XSD_NM_TOKEN]: a.TypeURL.XSD_TOKEN,
      [a.TypeURL.XSD_NAME]: a.TypeURL.XSD_TOKEN,
      [a.TypeURL.XSD_NC_NAME]: a.TypeURL.XSD_NAME,
      [a.TypeURL.XSD_ENTITY]: a.TypeURL.XSD_NC_NAME,
      [a.TypeURL.XSD_ID]: a.TypeURL.XSD_NC_NAME,
      [a.TypeURL.XSD_ID_REF]: a.TypeURL.XSD_NC_NAME,
      // Numeric types
      // https://www.w3.org/TR/sparql11-query/#operandDataTypes
      // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double
      [a.TypeURL.XSD_DOUBLE]: a.TypeAlias.SPARQL_NUMERIC,
      [a.TypeURL.XSD_FLOAT]: a.TypeAlias.SPARQL_NUMERIC,
      [a.TypeURL.XSD_DECIMAL]: a.TypeAlias.SPARQL_NUMERIC,
      // Decimal types
      [a.TypeURL.XSD_INTEGER]: a.TypeURL.XSD_DECIMAL,
      [a.TypeURL.XSD_NON_POSITIVE_INTEGER]: a.TypeURL.XSD_INTEGER,
      [a.TypeURL.XSD_NEGATIVE_INTEGER]: a.TypeURL.XSD_NON_POSITIVE_INTEGER,
      [a.TypeURL.XSD_LONG]: a.TypeURL.XSD_INTEGER,
      [a.TypeURL.XSD_INT]: a.TypeURL.XSD_LONG,
      [a.TypeURL.XSD_SHORT]: a.TypeURL.XSD_INT,
      [a.TypeURL.XSD_BYTE]: a.TypeURL.XSD_SHORT,
      [a.TypeURL.XSD_NON_NEGATIVE_INTEGER]: a.TypeURL.XSD_INTEGER,
      [a.TypeURL.XSD_POSITIVE_INTEGER]: a.TypeURL.XSD_NON_NEGATIVE_INTEGER,
      [a.TypeURL.XSD_UNSIGNED_LONG]: a.TypeURL.XSD_NON_NEGATIVE_INTEGER,
      [a.TypeURL.XSD_UNSIGNED_INT]: a.TypeURL.XSD_UNSIGNED_LONG,
      [a.TypeURL.XSD_UNSIGNED_SHORT]: a.TypeURL.XSD_UNSIGNED_INT,
      [a.TypeURL.XSD_UNSIGNED_BYTE]: a.TypeURL.XSD_UNSIGNED_SHORT,
      [a.TypeURL.XSD_DATE_TIME]: "term",
      [a.TypeURL.XSD_BOOLEAN]: "term",
      [a.TypeURL.XSD_DATE]: "term",
      [a.TypeURL.XSD_G_MONTH]: "term",
      [a.TypeURL.XSD_G_MONTHDAY]: "term",
      [a.TypeURL.XSD_G_YEAR]: "term",
      [a.TypeURL.XSD_G_YEAR_MONTH]: "term",
      [a.TypeURL.XSD_TIME]: "term",
      [a.TypeURL.XSD_G_DAY]: "term",
      [a.TypeURL.XSD_DURATION]: "term",
      [a.TypeAlias.SPARQL_NUMERIC]: "term",
      [a.TypeAlias.SPARQL_STRINGLY]: "term",
      [a.TypeURL.XSD_ANY_URI]: "term"
    }, u.superTypeDictTable = /* @__PURE__ */ Object.create(null);
    function t(b, _) {
      const y = _.cache.get(b);
      if (y)
        return y;
      const m = _.discoverer(b);
      if (m === "term") {
        const v = /* @__PURE__ */ Object.create(null);
        return v.__depth = 0, v[b] = 0, _.cache.set(b, v), v;
      }
      let g;
      const T = s(m);
      return T ? g = { ...u.superTypeDictTable[T] } : g = { ...t(m, _) }, g.__depth++, g[b] = g.__depth, _.cache.set(b, g), g;
    }
    u.getSuperTypes = t;
    function e() {
      for (const [b, _] of Object.entries(u.extensionTableInput)) {
        const y = b;
        u.superTypeDictTable[y] || n(y, _, u.superTypeDictTable);
      }
    }
    u.extensionTableInit = e, e();
    function n(b, _, y) {
      if (_ === "term" || _ === void 0) {
        const m = /* @__PURE__ */ Object.create(null);
        m.__depth = 0, m[b] = 0, y[b] = m;
        return;
      }
      y[_] || n(_, u.extensionTableInput[_], y), y[b] = { ...y[_], [b]: y[_].__depth + 1, __depth: y[_].__depth + 1 };
    }
    u.typeAliasCheck = /* @__PURE__ */ Object.create(null);
    function i() {
      for (const b of Object.values(a.TypeAlias))
        u.typeAliasCheck[b] = !0;
    }
    i();
    function c(b) {
      if (b in u.typeAliasCheck)
        return b;
    }
    u.asTypeAlias = c;
    function s(b) {
      if (b in u.superTypeDictTable)
        return b;
    }
    u.asKnownLiteralType = s;
    function d(b) {
      if (s(b) ?? b === "term")
        return b;
    }
    u.asOverrideType = d;
    function l(b) {
      if (b === "term" || (0, r.asTermType)(b))
        return b;
    }
    u.asGeneralType = l;
    function f(b, _) {
      return b !== "term" && u.superTypeDictTable[b] && u.superTypeDictTable[b][_] !== void 0;
    }
    u.isInternalSubType = f;
    function h(b, _) {
      const y = s(b);
      return y ? u.superTypeDictTable[y] : t(b, _);
    }
    u.getSuperTypeDict = h;
    function p(b, _, y) {
      return b === "term" ? !1 : h(b, y)[_] !== void 0;
    }
    u.isSubTypeOf = p, u.typePromotion = {
      [a.TypeURL.XSD_STRING]: [
        { typeToPromote: a.TypeURL.XSD_ANY_URI, conversionFunction: (b) => (0, o.string)(b.str()) }
      ],
      [a.TypeURL.XSD_DOUBLE]: [
        { typeToPromote: a.TypeURL.XSD_FLOAT, conversionFunction: (b) => (0, o.double)(b.typedValue) },
        // TODO: in case of decimal a round needs to happen.
        { typeToPromote: a.TypeURL.XSD_DECIMAL, conversionFunction: (b) => (0, o.double)(b.typedValue) }
      ],
      [a.TypeURL.XSD_FLOAT]: [
        // TODO: in case of decimal a round needs to happen.
        { typeToPromote: a.TypeURL.XSD_DECIMAL, conversionFunction: (b) => (0, o.float)(b.typedValue) }
      ]
    };
  }(FA)), FA;
}
var sF;
function Gne() {
  if (sF) return pt;
  sF = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.isNonLexicalLiteral = pt.NonLexicalLiteral = pt.YearMonthDurationLiteral = pt.DayTimeDurationLiteral = pt.DurationLiteral = pt.DateLiteral = pt.TimeLiteral = pt.DateTimeLiteral = pt.StringLiteral = pt.LangStringLiteral = pt.BooleanLiteral = pt.DoubleLiteral = pt.FloatLiteral = pt.DecimalLiteral = pt.IntegerLiteral = pt.NumericLiteral = pt.Literal = pt.isLiteralTermExpression = pt.DefaultGraph = pt.Quad = pt.BlankNode = pt.NamedNode = pt.Term = void 0;
  const u = /* @__PURE__ */ ru(), r = /* @__PURE__ */ Wf(), o = /* @__PURE__ */ Wf(), a = /* @__PURE__ */ K0(), t = /* @__PURE__ */ Hne(), e = /* @__PURE__ */ kS();
  class n {
    constructor() {
      this.expressionType = u.ExpressionType.Term;
    }
    str() {
      throw new a.InvalidArgumentTypes([this], r.SparqlOperator.STR);
    }
    coerceEBV() {
      throw new a.EBVCoercionError(this);
    }
  }
  pt.Term = n;
  class i extends n {
    constructor(F) {
      super(), this.value = F, this.termType = "namedNode";
    }
    toRDF(F) {
      return F.namedNode(this.value);
    }
    str() {
      return this.value;
    }
  }
  pt.NamedNode = i;
  class c extends n {
    constructor(F) {
      super(), this.termType = "blankNode", this.value = F;
    }
    toRDF(F) {
      return typeof this.value == "string" ? F.blankNode(this.value) : this.value;
    }
  }
  pt.BlankNode = c;
  class s extends n {
    constructor(F, j, q, Q) {
      super(), this.subject = F, this.predicate = j, this.object = q, this.graph = Q, this.termType = "quad";
    }
    toRDF(F) {
      return F.quad(this.subject.toRDF(F), this.predicate.toRDF(F), this.object.toRDF(F), this.graph.toRDF(F));
    }
    str() {
      return `Quad: [${this.subject.str()}, ${this.predicate.str()}, ${this.object.str()}, ${this.graph.str()}]`;
    }
  }
  pt.Quad = s;
  class d extends n {
    constructor() {
      super(), this.termType = "defaultGraph";
    }
    toRDF(F) {
      return F.defaultGraph();
    }
    str() {
      return "DefaultGraph";
    }
  }
  pt.DefaultGraph = d;
  function l(x) {
    if (x.termType === "literal")
      return x;
  }
  pt.isLiteralTermExpression = l;
  class f extends n {
    /**
     * @param typedValue internal representation of this literal's value
     * @param dataType a string representing the datatype. Can be of type @see LiteralTypes or any URI
     * @param strValue the string value of this literal. In other words, the string representing the RDF.literal value.
     * @param language the language, mainly for language enabled strings like RDF_LANG_STRING
     */
    constructor(F, j, q, Q) {
      super(), this.typedValue = F, this.dataType = j, this.strValue = q, this.language = Q, this.termType = "literal";
    }
    toRDF(F) {
      return F.literal(this.strValue ?? this.str(), this.language ?? F.namedNode(this.dataType));
    }
    str() {
      return this.strValue ?? this.typedValue.toString();
    }
  }
  pt.Literal = f;
  class h extends f {
    constructor(F, j, q, Q) {
      super(F, j, q, Q), this.typedValue = F, this.strValue = q, this.language = Q;
    }
    coerceEBV() {
      return !!this.typedValue;
    }
    toRDF(F) {
      const j = super.toRDF(F);
      return Number.isFinite(this.typedValue) || (j.value = j.value.replace("Infinity", "INF")), j;
    }
    str() {
      return this.strValue ?? this.specificFormatter(this.typedValue);
    }
  }
  pt.NumericLiteral = h;
  class p extends h {
    constructor(F, j, q, Q) {
      super(F, j ?? o.TypeURL.XSD_INTEGER, q, Q), this.typedValue = F, this.strValue = q, this.language = Q;
    }
    specificFormatter(F) {
      return F.toFixed(0);
    }
  }
  pt.IntegerLiteral = p;
  class b extends h {
    constructor(F, j, q, Q) {
      super(F, j ?? o.TypeURL.XSD_DECIMAL, q, Q), this.typedValue = F, this.strValue = q, this.language = Q;
    }
    specificFormatter(F) {
      return F.toString();
    }
  }
  pt.DecimalLiteral = b;
  class _ extends h {
    constructor(F, j, q, Q) {
      super(F, j ?? o.TypeURL.XSD_FLOAT, q, Q), this.typedValue = F, this.strValue = q, this.language = Q;
    }
    specificFormatter(F) {
      return F.toString();
    }
  }
  pt.FloatLiteral = _;
  class y extends h {
    constructor(F, j, q, Q) {
      super(F, j ?? o.TypeURL.XSD_DOUBLE, q, Q), this.typedValue = F, this.strValue = q, this.language = Q;
    }
    specificFormatter(F) {
      if (!Number.isFinite(F))
        return F > 0 ? "INF" : F < 0 ? "-INF" : "NaN";
      const j = F.toExponential(), [q, Q] = j.split("e"), G = Q.replace(/\+/u, "");
      return `${q.includes(".") ? q : `${q}.0`}E${G}`;
    }
  }
  pt.DoubleLiteral = y;
  class m extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_BOOLEAN, j), this.typedValue = F, this.strValue = j;
    }
    coerceEBV() {
      return this.typedValue;
    }
  }
  pt.BooleanLiteral = m;
  class g extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.RDF_LANG_STRING, F, j), this.typedValue = F, this.language = j;
    }
    coerceEBV() {
      return this.str().length > 0;
    }
  }
  pt.LangStringLiteral = g;
  class T extends f {
    /**
     * @param typedValue
     * @param dataType Should be type that implements XSD_STRING
     */
    constructor(F, j) {
      super(F, j ?? o.TypeURL.XSD_STRING, F), this.typedValue = F;
    }
    coerceEBV() {
      return this.str().length > 0;
    }
  }
  pt.StringLiteral = T;
  class v extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_DATE_TIME, j), this.typedValue = F, this.strValue = j;
    }
    str() {
      return (0, t.serializeDateTime)(this.typedValue);
    }
  }
  pt.DateTimeLiteral = v;
  class E extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_TIME, j), this.typedValue = F, this.strValue = j;
    }
    str() {
      return (0, t.serializeTime)(this.typedValue);
    }
  }
  pt.TimeLiteral = E;
  class R extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_DATE, j), this.typedValue = F, this.strValue = j;
    }
    str() {
      return (0, t.serializeDate)(this.typedValue);
    }
  }
  pt.DateLiteral = R;
  class L extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_DURATION, j), this.typedValue = F, this.strValue = j;
    }
    str() {
      return (0, t.serializeDuration)(this.typedValue);
    }
  }
  pt.DurationLiteral = L;
  class A extends L {
    constructor(F, j, q) {
      super(F, j, q ?? o.TypeURL.XSD_DAY_TIME_DURATION), this.typedValue = F, this.strValue = j;
    }
  }
  pt.DayTimeDurationLiteral = A;
  class w extends f {
    constructor(F, j, q) {
      super(F, q ?? o.TypeURL.XSD_YEAR_MONTH_DURATION, j), this.typedValue = F, this.strValue = j;
    }
    str() {
      return (0, t.serializeDuration)(this.typedValue, "P0M");
    }
  }
  pt.YearMonthDurationLiteral = w;
  class S extends f {
    constructor(F, j, q, Q, G) {
      super({ toString: () => "undefined" }, j, Q, G), this.openWorldType = q;
    }
    coerceEBV() {
      if ((0, e.isSubTypeOf)(this.dataType, o.TypeURL.XSD_BOOLEAN, this.openWorldType) || (0, e.isSubTypeOf)(this.dataType, o.TypeAlias.SPARQL_NUMERIC, this.openWorldType))
        return !1;
      throw new a.EBVCoercionError(this);
    }
    toRDF(F) {
      return F.literal(this.str(), this.language ?? F.namedNode(this.dataType));
    }
    str() {
      return this.strValue ?? "";
    }
  }
  pt.NonLexicalLiteral = S;
  function O(x) {
    if (x instanceof S)
      return x;
  }
  return pt.isNonLexicalLiteral = O, pt;
}
var ep = {}, cF;
function zne() {
  if (cF) return ep;
  cF = 1, Object.defineProperty(ep, "__esModule", { value: !0 }), ep.Operator = void 0;
  const u = /* @__PURE__ */ ru();
  let r = class {
    constructor(a, t, e) {
      this.name = a, this.args = t, this.apply = e, this.expressionType = u.ExpressionType.Operator;
    }
  };
  return ep.Operator = r, ep;
}
var tp = {}, dF;
function kne() {
  if (dF) return tp;
  dF = 1, Object.defineProperty(tp, "__esModule", { value: !0 }), tp.Aggregate = void 0;
  const u = /* @__PURE__ */ ru();
  let r = class {
    constructor(a, t) {
      this.name = a, this.expression = t, this.expressionType = u.ExpressionType.Aggregate;
    }
  };
  return tp.Aggregate = r, tp;
}
var rp = {}, lF;
function Xne() {
  if (lF) return rp;
  lF = 1, Object.defineProperty(rp, "__esModule", { value: !0 }), rp.Existence = void 0;
  const u = /* @__PURE__ */ ru();
  let r = class {
    constructor(a) {
      this.expression = a, this.expressionType = u.ExpressionType.Existence;
    }
  };
  return rp.Existence = r, rp;
}
var fF;
function W0() {
  return fF || (fF = 1, function(u) {
    var r = Lu && Lu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Lu && Lu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Vne(), u), o(/* @__PURE__ */ Qne(), u), o(/* @__PURE__ */ Gne(), u), o(/* @__PURE__ */ zne(), u), o(/* @__PURE__ */ kne(), u), o(/* @__PURE__ */ Xne(), u);
  }(Lu)), Lu;
}
var wr = {}, Pt = {}, hF;
function kT() {
  if (hF) return Pt;
  hF = 1, Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.extractTimeZone = Pt.extractRawTimeZone = Pt.dayTimeDurationsToSeconds = Pt.yearMonthDurationsToMonths = Pt.trimToDayTimeDuration = Pt.trimToYearMonthDuration = Pt.toUTCDate = Pt.toJSDate = Pt.negateDuration = Pt.toDateTimeRepresentation = Pt.defaultedDateTimeRepresentation = Pt.simplifyDurationRepresentation = Pt.defaultedDurationRepresentation = Pt.defaultedYearMonthDurationRepresentation = Pt.defaultedDayTimeDurationRepresentation = void 0;
  function u(b) {
    return {
      day: b.day ?? 0,
      hours: b.hours ?? 0,
      minutes: b.minutes ?? 0,
      seconds: b.seconds ?? 0
    };
  }
  Pt.defaultedDayTimeDurationRepresentation = u;
  function r(b) {
    return {
      year: b.year ?? 0,
      month: b.month ?? 0
    };
  }
  Pt.defaultedYearMonthDurationRepresentation = r;
  function o(b) {
    return {
      ...u(b),
      ...r(b)
    };
  }
  Pt.defaultedDurationRepresentation = o;
  function a(b) {
    const _ = o(b), y = {}, m = _.year + Math.trunc(_.month / 12);
    m && (y.year = m, _.month %= 12), _.month && (y.month = _.month);
    const g = _.day + Math.trunc(_.hours / 24) + Math.trunc(_.minutes / (24 * 60)) + Math.trunc(_.seconds / (24 * 60 * 60));
    g && (y.day = g, _.hours %= 24, _.minutes %= 24 * 60, _.seconds %= 24 * 60 * 60);
    const T = _.hours + Math.trunc(_.minutes / 60) + Math.trunc(_.seconds / (60 * 60));
    T && (y.hours = T, _.minutes %= 60, _.seconds %= 60 * 60);
    const v = _.minutes + Math.trunc(_.seconds / 60);
    return v && (y.minutes = v, _.seconds %= 60), _.seconds && (y.seconds = _.seconds), y;
  }
  Pt.simplifyDurationRepresentation = a;
  function t(b) {
    return {
      ...b,
      day: b.day ?? 1,
      hours: b.hours ?? 0,
      month: b.month ?? 1,
      year: b.year ?? 0,
      seconds: b.seconds ?? 0,
      minutes: b.minutes ?? 0
    };
  }
  Pt.defaultedDateTimeRepresentation = t;
  function e({ date: b, timeZone: _ }) {
    return {
      year: b.getFullYear(),
      month: b.getMonth() + 1,
      day: b.getDate(),
      hours: b.getHours(),
      minutes: b.getMinutes(),
      seconds: b.getSeconds(),
      zoneHours: _.zoneHours,
      zoneMinutes: _.zoneMinutes
    };
  }
  Pt.toDateTimeRepresentation = e;
  function n(b) {
    return {
      year: b.year === void 0 ? void 0 : -1 * b.year,
      month: b.month === void 0 ? void 0 : -1 * b.month,
      day: b.day === void 0 ? void 0 : -1 * b.day,
      hours: b.hours === void 0 ? void 0 : -1 * b.hours,
      minutes: b.minutes === void 0 ? void 0 : -1 * b.minutes,
      seconds: b.seconds === void 0 ? void 0 : -1 * b.seconds
    };
  }
  Pt.negateDuration = n;
  function i(b) {
    const _ = new Date(b.year, b.month - 1, b.day, b.hours, b.minutes, Math.trunc(b.seconds), b.seconds % 1 * 1e3);
    return b.year >= 0 && b.year < 100 && _.setFullYear(_.getFullYear() - 1900), _;
  }
  Pt.toJSDate = i;
  function c(b, _) {
    const y = i(t(b)), m = y.getTimezoneOffset(), g = b.zoneHours ?? _.zoneHours, T = b.zoneMinutes ?? _.zoneMinutes;
    return new Date(y.getTime() - (m + g * 60 + T) * 60 * 1e3);
  }
  Pt.toUTCDate = c;
  function s(b) {
    return {
      year: b.year,
      month: b.month
    };
  }
  Pt.trimToYearMonthDuration = s;
  function d(b) {
    return {
      day: b.day,
      hours: b.hours,
      minutes: b.minutes,
      seconds: b.seconds
    };
  }
  Pt.trimToDayTimeDuration = d;
  function l(b) {
    return b.year * 12 + b.month;
  }
  Pt.yearMonthDurationsToMonths = l;
  function f(b) {
    return ((b.day * 24 + b.hours) * 60 + b.minutes) * 60 + b.seconds;
  }
  Pt.dayTimeDurationsToSeconds = f;
  function h(b) {
    return /(Z|([+-]\d\d:\d\d))?$/u.exec(b)[0];
  }
  Pt.extractRawTimeZone = h;
  function p(b) {
    return {
      zoneHours: b.getTimezoneOffset() / 60,
      zoneMinutes: b.getTimezoneOffset() % 60
    };
  }
  return Pt.extractTimeZone = p, Pt;
}
var Xi = {}, pF;
function XK() {
  if (pF) return Xi;
  pF = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.elapsedDuration = Xi.addDurationToDateTime = Xi.maximumDayInMonthFor = void 0;
  const u = /* @__PURE__ */ kT();
  function r(e, n, i = 0) {
    const c = e - i, s = n - i, d = Math.floor(c / s);
    return { intDiv: d, remainder: e - d * s };
  }
  function o(e, n) {
    const { intDiv: i, remainder: c } = r(n, 13, 1), s = e + i;
    return [1, 3, 5, 7, 8, 10, 12].includes(c) ? 31 : [4, 6, 9, 11].includes(c) ? 30 : c === 2 && (r(s, 400).remainder === 0 || r(s, 100).remainder !== 0 && r(s, 4).remainder === 0) ? 29 : 28;
  }
  Xi.maximumDayInMonthFor = o;
  function a(e, n) {
    const i = { ...e };
    let c = r(e.month + n.month, 13, 1);
    for (i.month = c.remainder, i.year = e.year + n.year + c.intDiv, c = r(e.seconds + n.seconds, 60), i.seconds = c.remainder, c = r(e.minutes + n.minutes + c.intDiv, 60), i.minutes = c.remainder, c = r(e.hours + n.hours + c.intDiv, 24), i.hours = c.remainder, i.day = e.day + n.day + c.intDiv; ; ) {
      let s;
      if (i.day < 1)
        i.day += o(i.year, i.month - 1), s = -1;
      else if (i.day > o(i.year, i.month))
        i.day -= o(i.year, i.month), s = 1;
      else
        break;
      c = r(i.month + s, 13, 1), i.month = c.remainder, i.year += c.intDiv;
    }
    return i;
  }
  Xi.addDurationToDateTime = a;
  function t(e, n, i) {
    const c = (0, u.toUTCDate)(e, i), s = (0, u.toUTCDate)(n, i), d = c.getTime() - s.getTime();
    return {
      day: Math.floor(d / (1e3 * 60 * 60 * 24)),
      hours: Math.floor(d % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)),
      minutes: Math.floor(d % (1e3 * 60 * 60) / (1e3 * 60)),
      seconds: d % (1e3 * 60)
    };
  }
  return Xi.elapsedDuration = t, Xi;
}
var bF;
function tx() {
  if (bF) return wr;
  bF = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.parseDayTimeDuration = wr.parseYearMonthDuration = wr.parseDuration = wr.parseTime = wr.parseDate = wr.parseDateTime = wr.parseXSDDecimal = wr.parseXSDFloat = void 0;
  const u = /* @__PURE__ */ kT(), r = /* @__PURE__ */ K0(), o = /* @__PURE__ */ XK();
  function a(h) {
    const p = Number(h);
    return Number.isNaN(p) ? h === "NaN" ? Number.NaN : h === "INF" || h === "+INF" ? Number.POSITIVE_INFINITY : h === "-INF" ? Number.NEGATIVE_INFINITY : void 0 : p;
  }
  wr.parseXSDFloat = a;
  function t(h) {
    const p = Number(h);
    return Number.isNaN(p) ? void 0 : p;
  }
  wr.parseXSDDecimal = t;
  function e(h) {
    const [p, b] = h.split("T");
    if (b === void 0)
      throw new r.ParseError(h, "dateTime");
    return { ...i(p), ...c(b) };
  }
  wr.parseDateTime = e;
  function n(h) {
    if (h === "")
      return { zoneHours: void 0, zoneMinutes: void 0 };
    if (h === "Z")
      return { zoneHours: 0, zoneMinutes: 0 };
    const b = h.replaceAll(/^([+|-])(\d\d):(\d\d)$/gu, "$11!$2!$3").split("!").map(Number);
    return {
      zoneHours: b[0] * b[1],
      zoneMinutes: b[0] * b[2]
    };
  }
  function i(h) {
    const p = h.replaceAll(/^(-)?([123456789]*\d{4})-(\d\d)-(\d\d)(Z|([+-]\d\d:\d\d))?$/gu, "$11!$2!$3!$4!$5");
    if (p === h)
      throw new r.ParseError(h, "date");
    const b = p.split("!"), _ = b.slice(0, -1).map(Number), y = {
      year: _[0] * _[1],
      month: _[2],
      day: _[3],
      ...n(b[4])
    };
    if (!(y.month >= 1 && y.month <= 12) || !(y.day >= 1 && y.day <= (0, o.maximumDayInMonthFor)(y.year, y.month)))
      throw new r.ParseError(h, "date");
    return y;
  }
  wr.parseDate = i;
  function c(h) {
    const p = h.replaceAll(/^(\d\d):(\d\d):(\d\d(\.\d+)?)(Z|([+-]\d\d:\d\d))?$/gu, "$1!$2!$3!$5");
    if (p === h)
      throw new r.ParseError(h, "time");
    const b = p.split("!"), _ = b.slice(0, -1).map(Number), y = {
      hours: _[0],
      minutes: _[1],
      seconds: _[2],
      ...n(b[3])
    };
    if (y.seconds >= 60 || y.minutes >= 60 || y.hours > 24 || y.hours === 24 && (y.minutes !== 0 || y.seconds !== 0))
      throw new r.ParseError(h, "time");
    return y;
  }
  function s(h) {
    const p = c(h);
    return p.hours %= 24, p;
  }
  wr.parseTime = s;
  function d(h) {
    const [p, b] = h.split("T"), _ = p.replaceAll(/^(-)?P(\d+Y)?(\d+M)?(\d+D)?$/gu, "$11S!$2!$3!$4");
    if (_ === p)
      throw new r.ParseError(h, "duration");
    const y = _.split("!");
    if (b !== void 0) {
      const T = b.replaceAll(/^(\d+H)?(\d+M)?(\d+(\.\d+)?S)?$/gu, "$1!$2!$3");
      if (b === "" || b === T)
        throw new r.ParseError(h, "duration");
      y.push(...T.split("!"));
    }
    const m = y.map((T) => T.slice(0, -1));
    if (!m.slice(1).some(Boolean))
      throw new r.ParseError(h, "duration");
    const g = Number(m[0]);
    return (0, u.simplifyDurationRepresentation)({
      year: m[1] ? g * Number(m[1]) : void 0,
      month: m[2] ? g * Number(m[2]) : void 0,
      day: m[3] ? g * Number(m[3]) : void 0,
      hours: m[4] ? g * Number(m[4]) : void 0,
      minutes: m[5] ? g * Number(m[5]) : void 0,
      seconds: m[6] ? g * Number(m[6]) : void 0
    });
  }
  wr.parseDuration = d;
  function l(h) {
    const p = d(h);
    if (["hours", "minutes", "seconds", "day"].some((b) => !!p[b]))
      throw new r.ParseError(h, "yearMonthDuration");
    return p;
  }
  wr.parseYearMonthDuration = l;
  function f(h) {
    const p = d(h);
    if (["year", "month"].some((b) => !!p[b]))
      throw new r.ParseError(h, "dayTimeDuration");
    return p;
  }
  return wr.parseDayTimeDuration = f, wr;
}
var yF;
function Jne() {
  if (yF) return Qh;
  yF = 1, Object.defineProperty(Qh, "__esModule", { value: !0 }), Qh.TermTransformer = void 0;
  const u = lr(), r = ft(), o = /* @__PURE__ */ W0(), a = /* @__PURE__ */ Wf(), t = /* @__PURE__ */ K0(), e = /* @__PURE__ */ K0(), n = /* @__PURE__ */ tx(), i = /* @__PURE__ */ tx(), c = /* @__PURE__ */ kS();
  let s = class {
    constructor(l) {
      this.superTypeProvider = l;
    }
    /**
     * Transforms an RDF term to the internal representation of a term,
     * assuming it is not a variable, which would be an expression (internally).
     *
     * @param term RDF term to transform into internal representation of a term
     */
    transformRDFTermUnsafe(l) {
      return this.transformTerm({
        term: l,
        type: r.Algebra.types.EXPRESSION,
        expressionType: r.Algebra.expressionTypes.TERM
      });
    }
    transformTerm(l) {
      if (!l.term)
        throw new t.InvalidExpression(l);
      switch (l.term.termType) {
        case "Variable":
          return new o.Variable(u.termToString(l.term));
        case "Literal":
          return this.transformLiteral(l.term);
        case "NamedNode":
          return new o.NamedNode(l.term.value);
        case "BlankNode":
          return new o.BlankNode(l.term.value);
        case "Quad":
          return new o.Quad(this.transformRDFTermUnsafe(l.term.subject), this.transformRDFTermUnsafe(l.term.predicate), this.transformRDFTermUnsafe(l.term.object), this.transformRDFTermUnsafe(l.term.graph));
        case "DefaultGraph":
          return new o.DefaultGraph();
      }
    }
    /**
     * @param lit the rdf literal we want to transform to an internal Literal expression.
     */
    transformLiteral(l) {
      if (!l.datatype || [null, void 0, ""].includes(l.datatype.value))
        return l.language ? new o.LangStringLiteral(l.value, l.language) : new o.StringLiteral(l.value);
      const f = l.datatype.value, h = (0, c.getSuperTypeDict)(f, this.superTypeProvider);
      try {
        if (a.TypeURL.XSD_STRING in h)
          return new o.StringLiteral(l.value, f);
        if (a.TypeURL.RDF_LANG_STRING in h)
          return new o.LangStringLiteral(l.value, l.language);
        if (a.TypeURL.XSD_YEAR_MONTH_DURATION in h)
          return new o.YearMonthDurationLiteral((0, n.parseYearMonthDuration)(l.value), l.value, f);
        if (a.TypeURL.XSD_DAY_TIME_DURATION in h)
          return new o.DayTimeDurationLiteral((0, n.parseDayTimeDuration)(l.value), l.value, f);
        if (a.TypeURL.XSD_DURATION in h)
          return new o.DurationLiteral((0, n.parseDuration)(l.value), l.value, f);
        if (a.TypeURL.XSD_DATE_TIME in h) {
          const _ = new Date(l.value);
          return Number.isNaN(_.getTime()) ? new o.NonLexicalLiteral(void 0, f, this.superTypeProvider, l.value) : new o.DateTimeLiteral((0, n.parseDateTime)(l.value), l.value, f);
        }
        if (a.TypeURL.XSD_DATE in h)
          return new o.DateLiteral((0, n.parseDate)(l.value), l.value, f);
        if (a.TypeURL.XSD_TIME in h)
          return new o.TimeLiteral((0, n.parseTime)(l.value), l.value, f);
        if (a.TypeURL.XSD_BOOLEAN in h)
          return l.value !== "true" && l.value !== "false" && l.value !== "1" && l.value !== "0" ? new o.NonLexicalLiteral(void 0, f, this.superTypeProvider, l.value) : new o.BooleanLiteral(l.value === "true" || l.value === "1", l.value);
        if (a.TypeURL.XSD_DECIMAL in h) {
          const _ = i.parseXSDDecimal(l.value);
          return _ === void 0 ? new o.NonLexicalLiteral(void 0, f, this.superTypeProvider, l.value) : a.TypeURL.XSD_INTEGER in h ? new o.IntegerLiteral(_, f, l.value) : new o.DecimalLiteral(_, f, l.value);
        }
        const p = a.TypeURL.XSD_FLOAT in h, b = a.TypeURL.XSD_DOUBLE in h;
        if (p || b) {
          const _ = i.parseXSDFloat(l.value);
          return _ === void 0 ? new o.NonLexicalLiteral(void 0, f, this.superTypeProvider, l.value) : p ? new o.FloatLiteral(_, f, l.value) : new o.DoubleLiteral(_, f, l.value);
        }
        return new o.Literal(l.value, f, l.value);
      } catch (p) {
        if ((0, e.isExpressionError)(p))
          return new o.NonLexicalLiteral(void 0, f, this.superTypeProvider, l.value);
        throw p;
      }
    }
  };
  return Qh.TermTransformer = s, Qh;
}
var np = {}, ip = {}, _F;
function fh() {
  var f, h, b, _, y, m, g, T, v, E, R, L, A, w, S, O, x, F, j, q, Q, G, K, U, ae, ye, pe, ee, rx, we, Oe, be, he, JK, N, M, I, Da, La, nx, Y6, Z6, Yt, ix, yT, ja, ax;
  if (_F) return ip;
  _F = 1, Object.defineProperty(ip, "__esModule", { value: !0 }), ip.LRUCache = void 0;
  const u = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, r = /* @__PURE__ */ new Set(), o = typeof process == "object" && process ? process : {}, a = (xe, ue, $, D) => {
    typeof o.emitWarning == "function" ? o.emitWarning(xe, ue, $, D) : console.error(`[${$}] ${ue}: ${xe}`);
  };
  let t = globalThis.AbortController, e = globalThis.AbortSignal;
  if (typeof t > "u") {
    e = class {
      constructor() {
        Ft(this, "onabort");
        Ft(this, "_onabort", []);
        Ft(this, "reason");
        Ft(this, "aborted", !1);
      }
      addEventListener(D, C) {
        this._onabort.push(C);
      }
    }, t = class {
      constructor() {
        Ft(this, "signal", new e());
        ue();
      }
      abort(D) {
        var C, X;
        if (!this.signal.aborted) {
          this.signal.reason = D, this.signal.aborted = !0;
          for (const te of this.signal._onabort)
            te(D);
          (X = (C = this.signal).onabort) == null || X.call(C, D);
        }
      }
    };
    let xe = ((f = o.env) == null ? void 0 : f.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
    const ue = () => {
      xe && (xe = !1, a("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", ue));
    };
  }
  const n = (xe) => !r.has(xe), i = (xe) => xe && xe === Math.floor(xe) && xe > 0 && isFinite(xe), c = (xe) => i(xe) ? xe <= Math.pow(2, 8) ? Uint8Array : xe <= Math.pow(2, 16) ? Uint16Array : xe <= Math.pow(2, 32) ? Uint32Array : xe <= Number.MAX_SAFE_INTEGER ? s : null : null;
  class s extends Array {
    constructor(ue) {
      super(ue), this.fill(0);
    }
  }
  const p = class p {
    constructor(ue, $) {
      Ft(this, "heap");
      Ft(this, "length");
      if (!ce(p, h))
        throw new TypeError("instantiate Stack using Stack.create(n)");
      this.heap = new $(ue), this.length = 0;
    }
    static create(ue) {
      const $ = c(ue);
      if (!$)
        return [];
      ct(p, h, !0);
      const D = new p(ue, $);
      return ct(p, h, !1), D;
    }
    push(ue) {
      this.heap[this.length++] = ue;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  h = new WeakMap(), // private constructor
  It(p, h, !1);
  let d = p;
  const Ne = class Ne {
    constructor(ue) {
      It(this, ee);
      // options that cannot be changed without disaster
      It(this, y);
      It(this, m);
      It(this, g);
      It(this, T);
      It(this, v);
      It(this, E);
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      Ft(this, "ttl");
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      Ft(this, "ttlResolution");
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      Ft(this, "ttlAutopurge");
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      Ft(this, "updateAgeOnGet");
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      Ft(this, "updateAgeOnHas");
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      Ft(this, "allowStale");
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      Ft(this, "noDisposeOnSet");
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      Ft(this, "noUpdateTTL");
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      Ft(this, "maxEntrySize");
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      Ft(this, "sizeCalculation");
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      Ft(this, "noDeleteOnFetchRejection");
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      Ft(this, "noDeleteOnStaleGet");
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      Ft(this, "allowStaleOnFetchAbort");
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      Ft(this, "allowStaleOnFetchRejection");
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      Ft(this, "ignoreFetchAbort");
      // computed properties
      It(this, R);
      It(this, L);
      It(this, A);
      It(this, w);
      It(this, S);
      It(this, O);
      It(this, x);
      It(this, F);
      It(this, j);
      It(this, q);
      It(this, Q);
      It(this, G);
      It(this, K);
      It(this, U);
      It(this, ae);
      It(this, ye);
      It(this, pe);
      // conditionally set private methods related to TTL
      It(this, we, () => {
      });
      It(this, Oe, () => {
      });
      It(this, be, () => {
      });
      /* c8 ignore stop */
      It(this, he, () => !1);
      It(this, N, (ue) => {
      });
      It(this, M, (ue, $, D) => {
      });
      It(this, I, (ue, $, D, C) => {
        if (D || C)
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        return 0;
      });
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      Ft(this, b, "LRUCache");
      const { max: $ = 0, ttl: D, ttlResolution: C = 1, ttlAutopurge: X, updateAgeOnGet: te, updateAgeOnHas: de, allowStale: oe, dispose: De, disposeAfter: Ve, noDisposeOnSet: qe, noUpdateTTL: Ke, maxSize: Y = 0, maxEntrySize: Ee = 0, sizeCalculation: Ie, fetchMethod: Ue, memoMethod: Le, noDeleteOnFetchRejection: tt, noDeleteOnStaleGet: it, allowStaleOnFetchRejection: Ye, allowStaleOnFetchAbort: ht, ignoreFetchAbort: ne } = ue;
      if ($ !== 0 && !i($))
        throw new TypeError("max option must be a nonnegative integer");
      const ie = $ ? c($) : Array;
      if (!ie)
        throw new Error("invalid max value: " + $);
      if (ct(this, y, $), ct(this, m, Y), this.maxEntrySize = Ee || ce(this, m), this.sizeCalculation = Ie, this.sizeCalculation) {
        if (!ce(this, m) && !this.maxEntrySize)
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if (typeof this.sizeCalculation != "function")
          throw new TypeError("sizeCalculation set to non-function");
      }
      if (Le !== void 0 && typeof Le != "function")
        throw new TypeError("memoMethod must be a function if defined");
      if (ct(this, E, Le), Ue !== void 0 && typeof Ue != "function")
        throw new TypeError("fetchMethod must be a function if specified");
      if (ct(this, v, Ue), ct(this, ye, !!Ue), ct(this, A, /* @__PURE__ */ new Map()), ct(this, w, new Array($).fill(void 0)), ct(this, S, new Array($).fill(void 0)), ct(this, O, new ie($)), ct(this, x, new ie($)), ct(this, F, 0), ct(this, j, 0), ct(this, q, d.create($)), ct(this, R, 0), ct(this, L, 0), typeof De == "function" && ct(this, g, De), typeof Ve == "function" ? (ct(this, T, Ve), ct(this, Q, [])) : (ct(this, T, void 0), ct(this, Q, void 0)), ct(this, ae, !!ce(this, g)), ct(this, pe, !!ce(this, T)), this.noDisposeOnSet = !!qe, this.noUpdateTTL = !!Ke, this.noDeleteOnFetchRejection = !!tt, this.allowStaleOnFetchRejection = !!Ye, this.allowStaleOnFetchAbort = !!ht, this.ignoreFetchAbort = !!ne, this.maxEntrySize !== 0) {
        if (ce(this, m) !== 0 && !i(ce(this, m)))
          throw new TypeError("maxSize must be a positive integer if specified");
        if (!i(this.maxEntrySize))
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        at(this, ee, JK).call(this);
      }
      if (this.allowStale = !!oe, this.noDeleteOnStaleGet = !!it, this.updateAgeOnGet = !!te, this.updateAgeOnHas = !!de, this.ttlResolution = i(C) || C === 0 ? C : 1, this.ttlAutopurge = !!X, this.ttl = D || 0, this.ttl) {
        if (!i(this.ttl))
          throw new TypeError("ttl must be a positive integer if specified");
        at(this, ee, rx).call(this);
      }
      if (ce(this, y) === 0 && this.ttl === 0 && ce(this, m) === 0)
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !ce(this, y) && !ce(this, m)) {
        const je = "LRU_CACHE_UNBOUNDED";
        n(je) && (r.add(je), a("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", je, Ne));
      }
    }
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(ue) {
      return {
        // properties
        starts: ce(ue, K),
        ttls: ce(ue, U),
        sizes: ce(ue, G),
        keyMap: ce(ue, A),
        keyList: ce(ue, w),
        valList: ce(ue, S),
        next: ce(ue, O),
        prev: ce(ue, x),
        get head() {
          return ce(ue, F);
        },
        get tail() {
          return ce(ue, j);
        },
        free: ce(ue, q),
        // methods
        isBackgroundFetch: ($) => {
          var D;
          return at(D = ue, ee, Yt).call(D, $);
        },
        backgroundFetch: ($, D, C, X) => {
          var te;
          return at(te = ue, ee, Z6).call(te, $, D, C, X);
        },
        moveToTail: ($) => {
          var D;
          return at(D = ue, ee, yT).call(D, $);
        },
        indexes: ($) => {
          var D;
          return at(D = ue, ee, Da).call(D, $);
        },
        rindexes: ($) => {
          var D;
          return at(D = ue, ee, La).call(D, $);
        },
        isStale: ($) => {
          var D;
          return ce(D = ue, he).call(D, $);
        }
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return ce(this, y);
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return ce(this, m);
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return ce(this, L);
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return ce(this, R);
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return ce(this, v);
    }
    get memoMethod() {
      return ce(this, E);
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return ce(this, g);
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return ce(this, T);
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(ue) {
      return ce(this, A).has(ue) ? 1 / 0 : 0;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const ue of at(this, ee, Da).call(this))
        ce(this, S)[ue] !== void 0 && ce(this, w)[ue] !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield [ce(this, w)[ue], ce(this, S)[ue]]);
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const ue of at(this, ee, La).call(this))
        ce(this, S)[ue] !== void 0 && ce(this, w)[ue] !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield [ce(this, w)[ue], ce(this, S)[ue]]);
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const ue of at(this, ee, Da).call(this)) {
        const $ = ce(this, w)[ue];
        $ !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield $);
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const ue of at(this, ee, La).call(this)) {
        const $ = ce(this, w)[ue];
        $ !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield $);
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const ue of at(this, ee, Da).call(this))
        ce(this, S)[ue] !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield ce(this, S)[ue]);
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const ue of at(this, ee, La).call(this))
        ce(this, S)[ue] !== void 0 && !at(this, ee, Yt).call(this, ce(this, S)[ue]) && (yield ce(this, S)[ue]);
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [(_ = Symbol.iterator, b = Symbol.toStringTag, _)]() {
      return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(ue, $ = {}) {
      for (const D of at(this, ee, Da).call(this)) {
        const C = ce(this, S)[D], X = at(this, ee, Yt).call(this, C) ? C.__staleWhileFetching : C;
        if (X !== void 0 && ue(X, ce(this, w)[D], this))
          return this.get(ce(this, w)[D], $);
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(ue, $ = this) {
      for (const D of at(this, ee, Da).call(this)) {
        const C = ce(this, S)[D], X = at(this, ee, Yt).call(this, C) ? C.__staleWhileFetching : C;
        X !== void 0 && ue.call($, X, ce(this, w)[D], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(ue, $ = this) {
      for (const D of at(this, ee, La).call(this)) {
        const C = ce(this, S)[D], X = at(this, ee, Yt).call(this, C) ? C.__staleWhileFetching : C;
        X !== void 0 && ue.call($, X, ce(this, w)[D], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let ue = !1;
      for (const $ of at(this, ee, La).call(this, { allowStale: !0 }))
        ce(this, he).call(this, $) && (at(this, ee, ja).call(this, ce(this, w)[$], "expire"), ue = !0);
      return ue;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(ue) {
      const $ = ce(this, A).get(ue);
      if ($ === void 0)
        return;
      const D = ce(this, S)[$], C = at(this, ee, Yt).call(this, D) ? D.__staleWhileFetching : D;
      if (C === void 0)
        return;
      const X = { value: C };
      if (ce(this, U) && ce(this, K)) {
        const te = ce(this, U)[$], de = ce(this, K)[$];
        if (te && de) {
          const oe = te - (u.now() - de);
          X.ttl = oe, X.start = Date.now();
        }
      }
      return ce(this, G) && (X.size = ce(this, G)[$]), X;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const ue = [];
      for (const $ of at(this, ee, Da).call(this, { allowStale: !0 })) {
        const D = ce(this, w)[$], C = ce(this, S)[$], X = at(this, ee, Yt).call(this, C) ? C.__staleWhileFetching : C;
        if (X === void 0 || D === void 0)
          continue;
        const te = { value: X };
        if (ce(this, U) && ce(this, K)) {
          te.ttl = ce(this, U)[$];
          const de = u.now() - ce(this, K)[$];
          te.start = Math.floor(Date.now() - de);
        }
        ce(this, G) && (te.size = ce(this, G)[$]), ue.unshift([D, te]);
      }
      return ue;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(ue) {
      this.clear();
      for (const [$, D] of ue) {
        if (D.start) {
          const C = Date.now() - D.start;
          D.start = u.now() - C;
        }
        this.set($, D.value, D);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(ue, $, D = {}) {
      var Ke, Y, Ee, Ie, Ue;
      if ($ === void 0)
        return this.delete(ue), this;
      const { ttl: C = this.ttl, start: X, noDisposeOnSet: te = this.noDisposeOnSet, sizeCalculation: de = this.sizeCalculation, status: oe } = D;
      let { noUpdateTTL: De = this.noUpdateTTL } = D;
      const Ve = ce(this, I).call(this, ue, $, D.size || 0, de);
      if (this.maxEntrySize && Ve > this.maxEntrySize)
        return oe && (oe.set = "miss", oe.maxEntrySizeExceeded = !0), at(this, ee, ja).call(this, ue, "set"), this;
      let qe = ce(this, R) === 0 ? void 0 : ce(this, A).get(ue);
      if (qe === void 0)
        qe = ce(this, R) === 0 ? ce(this, j) : ce(this, q).length !== 0 ? ce(this, q).pop() : ce(this, R) === ce(this, y) ? at(this, ee, Y6).call(this, !1) : ce(this, R), ce(this, w)[qe] = ue, ce(this, S)[qe] = $, ce(this, A).set(ue, qe), ce(this, O)[ce(this, j)] = qe, ce(this, x)[qe] = ce(this, j), ct(this, j, qe), Ww(this, R)._++, ce(this, M).call(this, qe, Ve, oe), oe && (oe.set = "add"), De = !1;
      else {
        at(this, ee, yT).call(this, qe);
        const Le = ce(this, S)[qe];
        if ($ !== Le) {
          if (ce(this, ye) && at(this, ee, Yt).call(this, Le)) {
            Le.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: tt } = Le;
            tt !== void 0 && !te && (ce(this, ae) && ((Ke = ce(this, g)) == null || Ke.call(this, tt, ue, "set")), ce(this, pe) && ((Y = ce(this, Q)) == null || Y.push([tt, ue, "set"])));
          } else te || (ce(this, ae) && ((Ee = ce(this, g)) == null || Ee.call(this, Le, ue, "set")), ce(this, pe) && ((Ie = ce(this, Q)) == null || Ie.push([Le, ue, "set"])));
          if (ce(this, N).call(this, qe), ce(this, M).call(this, qe, Ve, oe), ce(this, S)[qe] = $, oe) {
            oe.set = "replace";
            const tt = Le && at(this, ee, Yt).call(this, Le) ? Le.__staleWhileFetching : Le;
            tt !== void 0 && (oe.oldValue = tt);
          }
        } else oe && (oe.set = "update");
      }
      if (C !== 0 && !ce(this, U) && at(this, ee, rx).call(this), ce(this, U) && (De || ce(this, be).call(this, qe, C, X), oe && ce(this, Oe).call(this, oe, qe)), !te && ce(this, pe) && ce(this, Q)) {
        const Le = ce(this, Q);
        let tt;
        for (; tt = Le == null ? void 0 : Le.shift(); )
          (Ue = ce(this, T)) == null || Ue.call(this, ...tt);
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      var ue;
      try {
        for (; ce(this, R); ) {
          const $ = ce(this, S)[ce(this, F)];
          if (at(this, ee, Y6).call(this, !0), at(this, ee, Yt).call(this, $)) {
            if ($.__staleWhileFetching)
              return $.__staleWhileFetching;
          } else if ($ !== void 0)
            return $;
        }
      } finally {
        if (ce(this, pe) && ce(this, Q)) {
          const $ = ce(this, Q);
          let D;
          for (; D = $ == null ? void 0 : $.shift(); )
            (ue = ce(this, T)) == null || ue.call(this, ...D);
        }
      }
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(ue, $ = {}) {
      const { updateAgeOnHas: D = this.updateAgeOnHas, status: C } = $, X = ce(this, A).get(ue);
      if (X !== void 0) {
        const te = ce(this, S)[X];
        if (at(this, ee, Yt).call(this, te) && te.__staleWhileFetching === void 0)
          return !1;
        if (ce(this, he).call(this, X))
          C && (C.has = "stale", ce(this, Oe).call(this, C, X));
        else return D && ce(this, we).call(this, X), C && (C.has = "hit", ce(this, Oe).call(this, C, X)), !0;
      } else C && (C.has = "miss");
      return !1;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(ue, $ = {}) {
      const { allowStale: D = this.allowStale } = $, C = ce(this, A).get(ue);
      if (C === void 0 || !D && ce(this, he).call(this, C))
        return;
      const X = ce(this, S)[C];
      return at(this, ee, Yt).call(this, X) ? X.__staleWhileFetching : X;
    }
    async fetch(ue, $ = {}) {
      const {
        // get options
        allowStale: D = this.allowStale,
        updateAgeOnGet: C = this.updateAgeOnGet,
        noDeleteOnStaleGet: X = this.noDeleteOnStaleGet,
        // set options
        ttl: te = this.ttl,
        noDisposeOnSet: de = this.noDisposeOnSet,
        size: oe = 0,
        sizeCalculation: De = this.sizeCalculation,
        noUpdateTTL: Ve = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection: qe = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection: Ke = this.allowStaleOnFetchRejection,
        ignoreFetchAbort: Y = this.ignoreFetchAbort,
        allowStaleOnFetchAbort: Ee = this.allowStaleOnFetchAbort,
        context: Ie,
        forceRefresh: Ue = !1,
        status: Le,
        signal: tt
      } = $;
      if (!ce(this, ye))
        return Le && (Le.fetch = "get"), this.get(ue, {
          allowStale: D,
          updateAgeOnGet: C,
          noDeleteOnStaleGet: X,
          status: Le
        });
      const it = {
        allowStale: D,
        updateAgeOnGet: C,
        noDeleteOnStaleGet: X,
        ttl: te,
        noDisposeOnSet: de,
        size: oe,
        sizeCalculation: De,
        noUpdateTTL: Ve,
        noDeleteOnFetchRejection: qe,
        allowStaleOnFetchRejection: Ke,
        allowStaleOnFetchAbort: Ee,
        ignoreFetchAbort: Y,
        status: Le,
        signal: tt
      };
      let Ye = ce(this, A).get(ue);
      if (Ye === void 0) {
        Le && (Le.fetch = "miss");
        const ht = at(this, ee, Z6).call(this, ue, Ye, it, Ie);
        return ht.__returned = ht;
      } else {
        const ht = ce(this, S)[Ye];
        if (at(this, ee, Yt).call(this, ht)) {
          const He = D && ht.__staleWhileFetching !== void 0;
          return Le && (Le.fetch = "inflight", He && (Le.returnedStale = !0)), He ? ht.__staleWhileFetching : ht.__returned = ht;
        }
        const ne = ce(this, he).call(this, Ye);
        if (!Ue && !ne)
          return Le && (Le.fetch = "hit"), at(this, ee, yT).call(this, Ye), C && ce(this, we).call(this, Ye), Le && ce(this, Oe).call(this, Le, Ye), ht;
        const ie = at(this, ee, Z6).call(this, ue, Ye, it, Ie), $e = ie.__staleWhileFetching !== void 0 && D;
        return Le && (Le.fetch = ne ? "stale" : "refresh", $e && ne && (Le.returnedStale = !0)), $e ? ie.__staleWhileFetching : ie.__returned = ie;
      }
    }
    async forceFetch(ue, $ = {}) {
      const D = await this.fetch(ue, $);
      if (D === void 0)
        throw new Error("fetch() returned undefined");
      return D;
    }
    memo(ue, $ = {}) {
      const D = ce(this, E);
      if (!D)
        throw new Error("no memoMethod provided to constructor");
      const { context: C, forceRefresh: X, ...te } = $, de = this.get(ue, te);
      if (!X && de !== void 0)
        return de;
      const oe = D(ue, de, {
        options: te,
        context: C
      });
      return this.set(ue, oe, te), oe;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(ue, $ = {}) {
      const { allowStale: D = this.allowStale, updateAgeOnGet: C = this.updateAgeOnGet, noDeleteOnStaleGet: X = this.noDeleteOnStaleGet, status: te } = $, de = ce(this, A).get(ue);
      if (de !== void 0) {
        const oe = ce(this, S)[de], De = at(this, ee, Yt).call(this, oe);
        return te && ce(this, Oe).call(this, te, de), ce(this, he).call(this, de) ? (te && (te.get = "stale"), De ? (te && D && oe.__staleWhileFetching !== void 0 && (te.returnedStale = !0), D ? oe.__staleWhileFetching : void 0) : (X || at(this, ee, ja).call(this, ue, "expire"), te && D && (te.returnedStale = !0), D ? oe : void 0)) : (te && (te.get = "hit"), De ? oe.__staleWhileFetching : (at(this, ee, yT).call(this, de), C && ce(this, we).call(this, de), oe));
      } else te && (te.get = "miss");
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(ue) {
      return at(this, ee, ja).call(this, ue, "delete");
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return at(this, ee, ax).call(this, "delete");
    }
  };
  y = new WeakMap(), m = new WeakMap(), g = new WeakMap(), T = new WeakMap(), v = new WeakMap(), E = new WeakMap(), R = new WeakMap(), L = new WeakMap(), A = new WeakMap(), w = new WeakMap(), S = new WeakMap(), O = new WeakMap(), x = new WeakMap(), F = new WeakMap(), j = new WeakMap(), q = new WeakMap(), Q = new WeakMap(), G = new WeakMap(), K = new WeakMap(), U = new WeakMap(), ae = new WeakMap(), ye = new WeakMap(), pe = new WeakMap(), ee = new WeakSet(), rx = function() {
    const ue = new s(ce(this, y)), $ = new s(ce(this, y));
    ct(this, U, ue), ct(this, K, $), ct(this, be, (X, te, de = u.now()) => {
      if ($[X] = te !== 0 ? de : 0, ue[X] = te, te !== 0 && this.ttlAutopurge) {
        const oe = setTimeout(() => {
          ce(this, he).call(this, X) && at(this, ee, ja).call(this, ce(this, w)[X], "expire");
        }, te + 1);
        oe.unref && oe.unref();
      }
    }), ct(this, we, (X) => {
      $[X] = ue[X] !== 0 ? u.now() : 0;
    }), ct(this, Oe, (X, te) => {
      if (ue[te]) {
        const de = ue[te], oe = $[te];
        if (!de || !oe)
          return;
        X.ttl = de, X.start = oe, X.now = D || C();
        const De = X.now - oe;
        X.remainingTTL = de - De;
      }
    });
    let D = 0;
    const C = () => {
      const X = u.now();
      if (this.ttlResolution > 0) {
        D = X;
        const te = setTimeout(() => D = 0, this.ttlResolution);
        te.unref && te.unref();
      }
      return X;
    };
    this.getRemainingTTL = (X) => {
      const te = ce(this, A).get(X);
      if (te === void 0)
        return 0;
      const de = ue[te], oe = $[te];
      if (!de || !oe)
        return 1 / 0;
      const De = (D || C()) - oe;
      return de - De;
    }, ct(this, he, (X) => {
      const te = $[X], de = ue[X];
      return !!de && !!te && (D || C()) - te > de;
    });
  }, we = new WeakMap(), Oe = new WeakMap(), be = new WeakMap(), he = new WeakMap(), JK = function() {
    const ue = new s(ce(this, y));
    ct(this, L, 0), ct(this, G, ue), ct(this, N, ($) => {
      ct(this, L, ce(this, L) - ue[$]), ue[$] = 0;
    }), ct(this, I, ($, D, C, X) => {
      if (at(this, ee, Yt).call(this, D))
        return 0;
      if (!i(C))
        if (X) {
          if (typeof X != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (C = X(D, $), !i(C))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return C;
    }), ct(this, M, ($, D, C) => {
      if (ue[$] = D, ce(this, m)) {
        const X = ce(this, m) - ue[$];
        for (; ce(this, L) > X; )
          at(this, ee, Y6).call(this, !0);
      }
      ct(this, L, ce(this, L) + ue[$]), C && (C.entrySize = D, C.totalCalculatedSize = ce(this, L));
    });
  }, N = new WeakMap(), M = new WeakMap(), I = new WeakMap(), Da = function* ({ allowStale: ue = this.allowStale } = {}) {
    if (ce(this, R))
      for (let $ = ce(this, j); !(!at(this, ee, nx).call(this, $) || ((ue || !ce(this, he).call(this, $)) && (yield $), $ === ce(this, F))); )
        $ = ce(this, x)[$];
  }, La = function* ({ allowStale: ue = this.allowStale } = {}) {
    if (ce(this, R))
      for (let $ = ce(this, F); !(!at(this, ee, nx).call(this, $) || ((ue || !ce(this, he).call(this, $)) && (yield $), $ === ce(this, j))); )
        $ = ce(this, O)[$];
  }, nx = function(ue) {
    return ue !== void 0 && ce(this, A).get(ce(this, w)[ue]) === ue;
  }, Y6 = function(ue) {
    var X, te;
    const $ = ce(this, F), D = ce(this, w)[$], C = ce(this, S)[$];
    return ce(this, ye) && at(this, ee, Yt).call(this, C) ? C.__abortController.abort(new Error("evicted")) : (ce(this, ae) || ce(this, pe)) && (ce(this, ae) && ((X = ce(this, g)) == null || X.call(this, C, D, "evict")), ce(this, pe) && ((te = ce(this, Q)) == null || te.push([C, D, "evict"]))), ce(this, N).call(this, $), ue && (ce(this, w)[$] = void 0, ce(this, S)[$] = void 0, ce(this, q).push($)), ce(this, R) === 1 ? (ct(this, F, ct(this, j, 0)), ce(this, q).length = 0) : ct(this, F, ce(this, O)[$]), ce(this, A).delete(D), Ww(this, R)._--, $;
  }, Z6 = function(ue, $, D, C) {
    const X = $ === void 0 ? void 0 : ce(this, S)[$];
    if (at(this, ee, Yt).call(this, X))
      return X;
    const te = new t(), { signal: de } = D;
    de == null || de.addEventListener("abort", () => te.abort(de.reason), {
      signal: te.signal
    });
    const oe = {
      signal: te.signal,
      options: D,
      context: C
    }, De = (Ie, Ue = !1) => {
      const { aborted: Le } = te.signal, tt = D.ignoreFetchAbort && Ie !== void 0;
      if (D.status && (Le && !Ue ? (D.status.fetchAborted = !0, D.status.fetchError = te.signal.reason, tt && (D.status.fetchAbortIgnored = !0)) : D.status.fetchResolved = !0), Le && !tt && !Ue)
        return qe(te.signal.reason);
      const it = Y;
      return ce(this, S)[$] === Y && (Ie === void 0 ? it.__staleWhileFetching ? ce(this, S)[$] = it.__staleWhileFetching : at(this, ee, ja).call(this, ue, "fetch") : (D.status && (D.status.fetchUpdated = !0), this.set(ue, Ie, oe.options))), Ie;
    }, Ve = (Ie) => (D.status && (D.status.fetchRejected = !0, D.status.fetchError = Ie), qe(Ie)), qe = (Ie) => {
      const { aborted: Ue } = te.signal, Le = Ue && D.allowStaleOnFetchAbort, tt = Le || D.allowStaleOnFetchRejection, it = tt || D.noDeleteOnFetchRejection, Ye = Y;
      if (ce(this, S)[$] === Y && (!it || Ye.__staleWhileFetching === void 0 ? at(this, ee, ja).call(this, ue, "fetch") : Le || (ce(this, S)[$] = Ye.__staleWhileFetching)), tt)
        return D.status && Ye.__staleWhileFetching !== void 0 && (D.status.returnedStale = !0), Ye.__staleWhileFetching;
      if (Ye.__returned === Ye)
        throw Ie;
    }, Ke = (Ie, Ue) => {
      var tt;
      const Le = (tt = ce(this, v)) == null ? void 0 : tt.call(this, ue, X, oe);
      Le && Le instanceof Promise && Le.then((it) => Ie(it === void 0 ? void 0 : it), Ue), te.signal.addEventListener("abort", () => {
        (!D.ignoreFetchAbort || D.allowStaleOnFetchAbort) && (Ie(void 0), D.allowStaleOnFetchAbort && (Ie = (it) => De(it, !0)));
      });
    };
    D.status && (D.status.fetchDispatched = !0);
    const Y = new Promise(Ke).then(De, Ve), Ee = Object.assign(Y, {
      __abortController: te,
      __staleWhileFetching: X,
      __returned: void 0
    });
    return $ === void 0 ? (this.set(ue, Ee, { ...oe.options, status: void 0 }), $ = ce(this, A).get(ue)) : ce(this, S)[$] = Ee, Ee;
  }, Yt = function(ue) {
    if (!ce(this, ye))
      return !1;
    const $ = ue;
    return !!$ && $ instanceof Promise && $.hasOwnProperty("__staleWhileFetching") && $.__abortController instanceof t;
  }, ix = function(ue, $) {
    ce(this, x)[$] = ue, ce(this, O)[ue] = $;
  }, yT = function(ue) {
    ue !== ce(this, j) && (ue === ce(this, F) ? ct(this, F, ce(this, O)[ue]) : at(this, ee, ix).call(this, ce(this, x)[ue], ce(this, O)[ue]), at(this, ee, ix).call(this, ce(this, j), ue), ct(this, j, ue));
  }, ja = function(ue, $) {
    var C, X, te, de;
    let D = !1;
    if (ce(this, R) !== 0) {
      const oe = ce(this, A).get(ue);
      if (oe !== void 0)
        if (D = !0, ce(this, R) === 1)
          at(this, ee, ax).call(this, $);
        else {
          ce(this, N).call(this, oe);
          const De = ce(this, S)[oe];
          if (at(this, ee, Yt).call(this, De) ? De.__abortController.abort(new Error("deleted")) : (ce(this, ae) || ce(this, pe)) && (ce(this, ae) && ((C = ce(this, g)) == null || C.call(this, De, ue, $)), ce(this, pe) && ((X = ce(this, Q)) == null || X.push([De, ue, $]))), ce(this, A).delete(ue), ce(this, w)[oe] = void 0, ce(this, S)[oe] = void 0, oe === ce(this, j))
            ct(this, j, ce(this, x)[oe]);
          else if (oe === ce(this, F))
            ct(this, F, ce(this, O)[oe]);
          else {
            const Ve = ce(this, x)[oe];
            ce(this, O)[Ve] = ce(this, O)[oe];
            const qe = ce(this, O)[oe];
            ce(this, x)[qe] = ce(this, x)[oe];
          }
          Ww(this, R)._--, ce(this, q).push(oe);
        }
    }
    if (ce(this, pe) && ((te = ce(this, Q)) != null && te.length)) {
      const oe = ce(this, Q);
      let De;
      for (; De = oe == null ? void 0 : oe.shift(); )
        (de = ce(this, T)) == null || de.call(this, ...De);
    }
    return D;
  }, ax = function(ue) {
    var $, D, C;
    for (const X of at(this, ee, La).call(this, { allowStale: !0 })) {
      const te = ce(this, S)[X];
      if (at(this, ee, Yt).call(this, te))
        te.__abortController.abort(new Error("deleted"));
      else {
        const de = ce(this, w)[X];
        ce(this, ae) && (($ = ce(this, g)) == null || $.call(this, te, de, ue)), ce(this, pe) && ((D = ce(this, Q)) == null || D.push([te, de, ue]));
      }
    }
    if (ce(this, A).clear(), ce(this, S).fill(void 0), ce(this, w).fill(void 0), ce(this, U) && ce(this, K) && (ce(this, U).fill(0), ce(this, K).fill(0)), ce(this, G) && ce(this, G).fill(0), ct(this, F, 0), ct(this, j, 0), ce(this, q).length = 0, ct(this, L, 0), ct(this, R, 0), ce(this, pe) && ce(this, Q)) {
      const X = ce(this, Q);
      let te;
      for (; te = X == null ? void 0 : X.shift(); )
        (C = ce(this, T)) == null || C.call(this, ...te);
    }
  };
  let l = Ne;
  return ip.LRUCache = l, ip;
}
var gF;
function Kne() {
  if (gF) return np;
  gF = 1, Object.defineProperty(np, "__esModule", { value: !0 }), np.prepareEvaluatorActionContext = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ fh(), o = /* @__PURE__ */ kT();
  function a(t) {
    let e = t;
    if (e.has(u.KeysInitQuery.extensionFunctionCreator) && e.has(u.KeysInitQuery.extensionFunctions))
      throw new Error("Illegal simultaneous usage of extensionFunctionCreator and extensionFunctions in context");
    if (e.has(u.KeysInitQuery.extensionFunctionCreator))
      e = e.set(u.KeysExpressionEvaluator.extensionFunctionCreator, e.get(u.KeysInitQuery.extensionFunctionCreator));
    else if (e.has(u.KeysInitQuery.extensionFunctions)) {
      const n = e.getSafe(u.KeysInitQuery.extensionFunctions);
      e = e.set(u.KeysExpressionEvaluator.extensionFunctionCreator, async (i) => n[i.value]);
    } else
      e = e.setDefault(u.KeysExpressionEvaluator.extensionFunctionCreator, async () => {
      });
    return e = e.setDefault(u.KeysExpressionEvaluator.defaultTimeZone, (0, o.extractTimeZone)(e.getSafe(u.KeysInitQuery.queryTimestamp))), e = e.setDefault(u.KeysExpressionEvaluator.superTypeProvider, {
      cache: new r.LRUCache({ max: 1e3 }),
      discoverer: () => "term"
    }), e;
  }
  return np.prepareEvaluatorActionContext = a, np;
}
var mF;
function ve() {
  return mF || (mF = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.LangStringLiteral = u.TimeLiteral = u.DurationLiteral = u.DateLiteral = u.DayTimeDurationLiteral = u.DateTimeLiteral = u.yearMonthDurationsToMonths = u.toUTCDate = u.toDateTimeRepresentation = u.negateDuration = u.extractRawTimeZone = u.defaultedYearMonthDurationRepresentation = u.defaultedDurationRepresentation = u.defaultedDayTimeDurationRepresentation = u.defaultedDateTimeRepresentation = u.dayTimeDurationsToSeconds = u.isSubTypeOf = u.SparqlOperator = u.TypeAlias = u.TypeURL = u.typedLiteral = u.InvalidArity = u.InvalidLexicalForm = u.ExtensionFunctionError = u.CastError = u.UnboundVariableError = u.NoAggregator = u.InError = u.CoalesceError = u.InvalidArgumentTypes = u.InvalidTimezoneCall = u.IncompatibleLanguageOperation = u.RDFEqualTypeError = u.EmptyAggregateError = u.isExpressionError = u.ExpressionError = u.Builder = u.expressionToVar = u.float = u.decimal = u.langString = u.dateTime = u.integer = u.double = u.string = u.bool = u.declare = u.prepareEvaluatorActionContext = u.OverloadTree = u.TermTransformer = void 0, u.trimToDayTimeDuration = u.trimToYearMonthDuration = u.parseDate = u.parseXSDFloat = u.parseXSDDecimal = u.parseYearMonthDuration = u.parseTime = u.parseDuration = u.parseDayTimeDuration = u.parseDateTime = u.elapsedDuration = u.addDurationToDateTime = u.isNonLexicalLiteral = u.StringLiteral = u.NonLexicalLiteral = u.FloatLiteral = u.IntegerLiteral = u.Literal = u.Existence = u.Aggregate = u.DoubleLiteral = u.DefaultGraph = u.DecimalLiteral = u.BlankNode = u.BooleanLiteral = u.NumericLiteral = u.Variable = u.NamedNode = u.Operator = u.Quad = u.YearMonthDurationLiteral = u.Term = void 0;
    var r = /* @__PURE__ */ Jne();
    Object.defineProperty(u, "TermTransformer", { enumerable: !0, get: function() {
      return r.TermTransformer;
    } });
    var o = /* @__PURE__ */ zK();
    Object.defineProperty(u, "OverloadTree", { enumerable: !0, get: function() {
      return o.OverloadTree;
    } });
    var a = /* @__PURE__ */ Kne();
    Object.defineProperty(u, "prepareEvaluatorActionContext", { enumerable: !0, get: function() {
      return a.prepareEvaluatorActionContext;
    } });
    var t = /* @__PURE__ */ kK();
    Object.defineProperty(u, "declare", { enumerable: !0, get: function() {
      return t.declare;
    } }), Object.defineProperty(u, "bool", { enumerable: !0, get: function() {
      return t.bool;
    } }), Object.defineProperty(u, "string", { enumerable: !0, get: function() {
      return t.string;
    } }), Object.defineProperty(u, "double", { enumerable: !0, get: function() {
      return t.double;
    } }), Object.defineProperty(u, "integer", { enumerable: !0, get: function() {
      return t.integer;
    } }), Object.defineProperty(u, "dateTime", { enumerable: !0, get: function() {
      return t.dateTime;
    } }), Object.defineProperty(u, "langString", { enumerable: !0, get: function() {
      return t.langString;
    } }), Object.defineProperty(u, "decimal", { enumerable: !0, get: function() {
      return t.decimal;
    } }), Object.defineProperty(u, "float", { enumerable: !0, get: function() {
      return t.float;
    } }), Object.defineProperty(u, "expressionToVar", { enumerable: !0, get: function() {
      return t.expressionToVar;
    } }), Object.defineProperty(u, "Builder", { enumerable: !0, get: function() {
      return t.Builder;
    } });
    var e = /* @__PURE__ */ K0();
    Object.defineProperty(u, "ExpressionError", { enumerable: !0, get: function() {
      return e.ExpressionError;
    } }), Object.defineProperty(u, "isExpressionError", { enumerable: !0, get: function() {
      return e.isExpressionError;
    } }), Object.defineProperty(u, "EmptyAggregateError", { enumerable: !0, get: function() {
      return e.EmptyAggregateError;
    } }), Object.defineProperty(u, "RDFEqualTypeError", { enumerable: !0, get: function() {
      return e.RDFEqualTypeError;
    } }), Object.defineProperty(u, "IncompatibleLanguageOperation", { enumerable: !0, get: function() {
      return e.IncompatibleLanguageOperation;
    } }), Object.defineProperty(u, "InvalidTimezoneCall", { enumerable: !0, get: function() {
      return e.InvalidTimezoneCall;
    } }), Object.defineProperty(u, "InvalidArgumentTypes", { enumerable: !0, get: function() {
      return e.InvalidArgumentTypes;
    } }), Object.defineProperty(u, "CoalesceError", { enumerable: !0, get: function() {
      return e.CoalesceError;
    } }), Object.defineProperty(u, "InError", { enumerable: !0, get: function() {
      return e.InError;
    } }), Object.defineProperty(u, "NoAggregator", { enumerable: !0, get: function() {
      return e.NoAggregator;
    } }), Object.defineProperty(u, "UnboundVariableError", { enumerable: !0, get: function() {
      return e.UnboundVariableError;
    } }), Object.defineProperty(u, "CastError", { enumerable: !0, get: function() {
      return e.CastError;
    } }), Object.defineProperty(u, "ExtensionFunctionError", { enumerable: !0, get: function() {
      return e.ExtensionFunctionError;
    } }), Object.defineProperty(u, "InvalidLexicalForm", { enumerable: !0, get: function() {
      return e.InvalidLexicalForm;
    } }), Object.defineProperty(u, "InvalidArity", { enumerable: !0, get: function() {
      return e.InvalidArity;
    } });
    var n = /* @__PURE__ */ Wf();
    Object.defineProperty(u, "typedLiteral", { enumerable: !0, get: function() {
      return n.typedLiteral;
    } }), Object.defineProperty(u, "TypeURL", { enumerable: !0, get: function() {
      return n.TypeURL;
    } }), Object.defineProperty(u, "TypeAlias", { enumerable: !0, get: function() {
      return n.TypeAlias;
    } }), Object.defineProperty(u, "SparqlOperator", { enumerable: !0, get: function() {
      return n.SparqlOperator;
    } });
    var i = /* @__PURE__ */ kS();
    Object.defineProperty(u, "isSubTypeOf", { enumerable: !0, get: function() {
      return i.isSubTypeOf;
    } });
    var c = /* @__PURE__ */ kT();
    Object.defineProperty(u, "dayTimeDurationsToSeconds", { enumerable: !0, get: function() {
      return c.dayTimeDurationsToSeconds;
    } }), Object.defineProperty(u, "defaultedDateTimeRepresentation", { enumerable: !0, get: function() {
      return c.defaultedDateTimeRepresentation;
    } }), Object.defineProperty(u, "defaultedDayTimeDurationRepresentation", { enumerable: !0, get: function() {
      return c.defaultedDayTimeDurationRepresentation;
    } }), Object.defineProperty(u, "defaultedDurationRepresentation", { enumerable: !0, get: function() {
      return c.defaultedDurationRepresentation;
    } }), Object.defineProperty(u, "defaultedYearMonthDurationRepresentation", { enumerable: !0, get: function() {
      return c.defaultedYearMonthDurationRepresentation;
    } }), Object.defineProperty(u, "extractRawTimeZone", { enumerable: !0, get: function() {
      return c.extractRawTimeZone;
    } }), Object.defineProperty(u, "negateDuration", { enumerable: !0, get: function() {
      return c.negateDuration;
    } }), Object.defineProperty(u, "toDateTimeRepresentation", { enumerable: !0, get: function() {
      return c.toDateTimeRepresentation;
    } }), Object.defineProperty(u, "toUTCDate", { enumerable: !0, get: function() {
      return c.toUTCDate;
    } }), Object.defineProperty(u, "yearMonthDurationsToMonths", { enumerable: !0, get: function() {
      return c.yearMonthDurationsToMonths;
    } });
    var s = /* @__PURE__ */ W0();
    Object.defineProperty(u, "DateTimeLiteral", { enumerable: !0, get: function() {
      return s.DateTimeLiteral;
    } }), Object.defineProperty(u, "DayTimeDurationLiteral", { enumerable: !0, get: function() {
      return s.DayTimeDurationLiteral;
    } }), Object.defineProperty(u, "DateLiteral", { enumerable: !0, get: function() {
      return s.DateLiteral;
    } }), Object.defineProperty(u, "DurationLiteral", { enumerable: !0, get: function() {
      return s.DurationLiteral;
    } }), Object.defineProperty(u, "TimeLiteral", { enumerable: !0, get: function() {
      return s.TimeLiteral;
    } }), Object.defineProperty(u, "LangStringLiteral", { enumerable: !0, get: function() {
      return s.LangStringLiteral;
    } }), Object.defineProperty(u, "Term", { enumerable: !0, get: function() {
      return s.Term;
    } }), Object.defineProperty(u, "YearMonthDurationLiteral", { enumerable: !0, get: function() {
      return s.YearMonthDurationLiteral;
    } }), Object.defineProperty(u, "Quad", { enumerable: !0, get: function() {
      return s.Quad;
    } }), Object.defineProperty(u, "Operator", { enumerable: !0, get: function() {
      return s.Operator;
    } }), Object.defineProperty(u, "NamedNode", { enumerable: !0, get: function() {
      return s.NamedNode;
    } }), Object.defineProperty(u, "Variable", { enumerable: !0, get: function() {
      return s.Variable;
    } }), Object.defineProperty(u, "NumericLiteral", { enumerable: !0, get: function() {
      return s.NumericLiteral;
    } }), Object.defineProperty(u, "BooleanLiteral", { enumerable: !0, get: function() {
      return s.BooleanLiteral;
    } }), Object.defineProperty(u, "BlankNode", { enumerable: !0, get: function() {
      return s.BlankNode;
    } }), Object.defineProperty(u, "DecimalLiteral", { enumerable: !0, get: function() {
      return s.DecimalLiteral;
    } }), Object.defineProperty(u, "DefaultGraph", { enumerable: !0, get: function() {
      return s.DefaultGraph;
    } }), Object.defineProperty(u, "DoubleLiteral", { enumerable: !0, get: function() {
      return s.DoubleLiteral;
    } }), Object.defineProperty(u, "Aggregate", { enumerable: !0, get: function() {
      return s.Aggregate;
    } }), Object.defineProperty(u, "Existence", { enumerable: !0, get: function() {
      return s.Existence;
    } }), Object.defineProperty(u, "Literal", { enumerable: !0, get: function() {
      return s.Literal;
    } }), Object.defineProperty(u, "IntegerLiteral", { enumerable: !0, get: function() {
      return s.IntegerLiteral;
    } }), Object.defineProperty(u, "FloatLiteral", { enumerable: !0, get: function() {
      return s.FloatLiteral;
    } }), Object.defineProperty(u, "NonLexicalLiteral", { enumerable: !0, get: function() {
      return s.NonLexicalLiteral;
    } }), Object.defineProperty(u, "StringLiteral", { enumerable: !0, get: function() {
      return s.StringLiteral;
    } }), Object.defineProperty(u, "isNonLexicalLiteral", { enumerable: !0, get: function() {
      return s.isNonLexicalLiteral;
    } });
    var d = /* @__PURE__ */ XK();
    Object.defineProperty(u, "addDurationToDateTime", { enumerable: !0, get: function() {
      return d.addDurationToDateTime;
    } }), Object.defineProperty(u, "elapsedDuration", { enumerable: !0, get: function() {
      return d.elapsedDuration;
    } });
    var l = /* @__PURE__ */ tx();
    Object.defineProperty(u, "parseDateTime", { enumerable: !0, get: function() {
      return l.parseDateTime;
    } }), Object.defineProperty(u, "parseDayTimeDuration", { enumerable: !0, get: function() {
      return l.parseDayTimeDuration;
    } }), Object.defineProperty(u, "parseDuration", { enumerable: !0, get: function() {
      return l.parseDuration;
    } }), Object.defineProperty(u, "parseTime", { enumerable: !0, get: function() {
      return l.parseTime;
    } }), Object.defineProperty(u, "parseYearMonthDuration", { enumerable: !0, get: function() {
      return l.parseYearMonthDuration;
    } }), Object.defineProperty(u, "parseXSDDecimal", { enumerable: !0, get: function() {
      return l.parseXSDDecimal;
    } }), Object.defineProperty(u, "parseXSDFloat", { enumerable: !0, get: function() {
      return l.parseXSDFloat;
    } }), Object.defineProperty(u, "parseDate", { enumerable: !0, get: function() {
      return l.parseDate;
    } });
    var f = /* @__PURE__ */ kT();
    Object.defineProperty(u, "trimToYearMonthDuration", { enumerable: !0, get: function() {
      return f.trimToYearMonthDuration;
    } }), Object.defineProperty(u, "trimToDayTimeDuration", { enumerable: !0, get: function() {
      return f.trimToDayTimeDuration;
    } });
  }(fA)), fA;
}
var vF;
function KK() {
  if (vF) return Ru;
  vF = 1, Object.defineProperty(Ru, "__esModule", { value: !0 }), Ru.TermFunctionBase = Ru.ExpressionFunctionBase = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ ve();
  class o {
    constructor({ arity: e, operator: n, apply: i }) {
      this.arity = e, this.operator = n, this.apply = i;
    }
    checkArity(e) {
      return Array.isArray(this.arity) ? this.arity.includes(e.length) : this.arity === Number.POSITIVE_INFINITY ? !0 : e.length === this.arity;
    }
  }
  Ru.ExpressionFunctionBase = o;
  class a extends o {
    constructor({ arity: e, operator: n, overloads: i }) {
      super({
        arity: e,
        operator: n,
        apply: async ({ args: c, exprEval: s, mapping: d }) => this.applyOnTerms(await Promise.all(c.map((l) => s.evaluatorExpressionEvaluation(l, d))), s)
      }), this.supportsTermExpressions = !0, this.overloads = i;
    }
    applyOnTerms(e, n) {
      return (this.overloads.search(e, n.context.getSafe(u.KeysExpressionEvaluator.superTypeProvider), n.context.getSafe(u.KeysInitQuery.functionArgumentsCache)) ?? this.handleInvalidTypes(e))(n)(e);
    }
    handleInvalidTypes(e) {
      throw new r.InvalidArgumentTypes(e, this.operator);
    }
  }
  return Ru.TermFunctionBase = a, Ru;
}
var TF;
function Ae() {
  return TF || (TF = 1, function(u) {
    var r = xu && xu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xu && xu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ jK(), u), o(/* @__PURE__ */ Sne(), u), o(/* @__PURE__ */ Ane(), u), o(/* @__PURE__ */ KK(), u);
  }(xu)), xu;
}
var ju = {}, ap = {}, wF;
function WK() {
  if (wF) return ap;
  wF = 1, Object.defineProperty(ap, "__esModule", { value: !0 }), ap.ActorQueryOperation = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cbqo:components/BusQueryOperation.jsonld#BusQueryOperation>} bus
     *   \ @defaultNested {Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return ap.ActorQueryOperation = r, ap;
}
var up = {}, Mu = {}, op = {}, SF;
function Wne() {
  if (SF) return op;
  SF = 1, Object.defineProperty(op, "__esModule", { value: !0 }), op.MetadataValidationState = void 0;
  let u = class {
    constructor() {
      this.invalidateListeners = [], this.valid = !0;
    }
    addInvalidateListener(o) {
      this.invalidateListeners.push(o);
    }
    invalidate() {
      if (this.valid) {
        this.valid = !1;
        for (const o of this.invalidateListeners)
          o();
      }
    }
  };
  return op.MetadataValidationState = u, op;
}
var mn = {}, AF;
function Yne() {
  if (AF) return mn;
  AF = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.cachifyMetadata = mn.validateMetadataBindings = mn.validateMetadataQuads = mn.getMetadataBindings = mn.getMetadataQuads = void 0;
  function u(e) {
    return t(() => new Promise((n, i) => {
      e.getProperty("metadata", (c) => n(c)), e.on("error", i);
    }).then((n) => o(n)));
  }
  mn.getMetadataQuads = u;
  function r(e) {
    return t(() => new Promise((n, i) => {
      e.getProperty("metadata", (c) => n(c)), e.on("error", i);
    }).then((n) => a(n)));
  }
  mn.getMetadataBindings = r;
  function o(e) {
    for (const n of ["cardinality"])
      if (!(n in e))
        throw new Error(`Invalid metadata: missing ${n} in ${JSON.stringify(e)}`);
    return e;
  }
  mn.validateMetadataQuads = o;
  function a(e) {
    for (const n of ["cardinality", "variables"])
      if (!(n in e))
        throw new Error(`Invalid metadata: missing ${n} in ${JSON.stringify(e)}`);
    return e;
  }
  mn.validateMetadataBindings = a;
  function t(e) {
    let n;
    return () => (n || (n = e(), n.then((i) => i.state.addInvalidateListener(() => {
      n = void 0;
    })).catch(() => {
    })), n);
  }
  return mn.cachifyMetadata = t, mn;
}
var EF;
function Rr() {
  return EF || (EF = 1, function(u) {
    var r = Mu && Mu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Mu && Mu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Wne(), u), o(/* @__PURE__ */ Yne(), u);
  }(Mu)), Mu;
}
var OF;
function YK() {
  if (OF) return up;
  OF = 1, Object.defineProperty(up, "__esModule", { value: !0 }), up.ActorQueryOperationTyped = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Rr(), a = /* @__PURE__ */ WK();
  let t = class extends a.ActorQueryOperation {
    constructor(n, i) {
      if (super({ ...n, operationName: i }), !this.operationName)
        throw new Error('A valid "operationName" argument must be provided.');
    }
    async test(n) {
      if (!n.operation)
        return (0, r.failTest)("Missing field 'operation' in a query operation action.");
      if (n.operation.type !== this.operationName)
        return (0, r.failTest)(`Actor ${this.name} only supports ${this.operationName} operations, but got ${n.operation.type}`);
      const i = n.operation;
      return this.testOperation(i, n.context);
    }
    async run(n, i) {
      const c = n.context.get(u.KeysInitQuery.physicalQueryPlanLogger);
      c && (c.logOperation(n.operation.type, void 0, n.operation, n.context.get(u.KeysInitQuery.physicalQueryPlanNode), this.name, {}), n.context = n.context.set(u.KeysInitQuery.physicalQueryPlanNode, n.operation));
      const s = n.operation, d = n.context.set(u.KeysQueryOperation.operation, s), l = await this.runOperation(s, d, i);
      return "metadata" in l && (l.metadata = (0, o.cachifyMetadata)(l.metadata)), l;
    }
  };
  return up.ActorQueryOperationTyped = t, up;
}
var sp = {}, xF;
function Zne() {
  if (xF) return sp;
  xF = 1, Object.defineProperty(sp, "__esModule", { value: !0 }), sp.ActorQueryOperationTypedMediated = void 0;
  const u = /* @__PURE__ */ YK();
  let r = class extends u.ActorQueryOperationTyped {
    constructor(a, t) {
      super(a, t);
    }
  };
  return sp.ActorQueryOperationTypedMediated = r, sp;
}
var cp = {}, IF;
function eie() {
  if (IF) return cp;
  IF = 1, Object.defineProperty(cp, "__esModule", { value: !0 }), cp.BusQueryOperation = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.BusIndexed {
    constructor(a) {
      super({
        ...a,
        actorIdentifierFields: ["operationName"],
        actionIdentifierFields: ["operation", "type"]
      });
    }
  };
  return cp.BusQueryOperation = r, cp;
}
var RF;
function Ht() {
  return RF || (RF = 1, function(u) {
    var r = ju && ju.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ju && ju.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ WK(), u), o(/* @__PURE__ */ YK(), u), o(/* @__PURE__ */ Zne(), u), o(/* @__PURE__ */ eie(), u);
  }(ju)), ju;
}
var Cu = {}, dp = {}, qu = {}, lp = {}, FF;
function tie() {
  if (FF) return lp;
  FF = 1, Object.defineProperty(lp, "__esModule", { value: !0 }), lp.ActorContextPreprocess = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Context preprocessing failed} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return lp.ActorContextPreprocess = r, lp;
}
var NF;
function Tw() {
  return NF || (NF = 1, function(u) {
    var r = qu && qu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = qu && qu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ tie(), u);
  }(qu)), qu;
}
var PF;
function rie() {
  if (PF) return dp;
  PF = 1, Object.defineProperty(dp, "__esModule", { value: !0 }), dp.ActorContextPreprocessConvertShortcuts = void 0;
  const u = /* @__PURE__ */ Tw(), r = /* @__PURE__ */ _e();
  let o = class ZK extends u.ActorContextPreprocess {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return {
        context: ZK.expandShortcuts(t.context, this.contextKeyShortcuts)
      };
    }
    static expandShortcuts(t, e) {
      for (const n of t.keys())
        e[n.name] && (t = t.set(new r.ActionContextKey(e[n.name]), t.get(n)).delete(n));
      return t;
    }
  };
  return dp.ActorContextPreprocessConvertShortcuts = o, dp;
}
var DF;
function nie() {
  return DF || (DF = 1, function(u) {
    var r = Cu && Cu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Cu && Cu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rie(), u);
  }(Cu)), Cu;
}
var Bu = {}, fp = {}, LF;
function iie() {
  if (LF) return fp;
  LF = 1, Object.defineProperty(fp, "__esModule", { value: !0 }), fp.ActorContextPreprocessSetDefaults = void 0;
  const u = /* @__PURE__ */ Tw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = Or();
  let t = class extends u.ActorContextPreprocess {
    constructor(n) {
      super(n), this.defaultFunctionArgumentsCache = {};
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      let i = n.context;
      if (n.initialize) {
        i = i.setDefault(r.KeysInitQuery.queryTimestamp, /* @__PURE__ */ new Date()).setDefault(r.KeysInitQuery.queryTimestampHighResolution, performance.now()).setDefault(r.KeysQuerySourceIdentify.sourceIds, /* @__PURE__ */ new Map()).setDefault(r.KeysCore.log, this.logger).setDefault(r.KeysInitQuery.functionArgumentsCache, this.defaultFunctionArgumentsCache).setDefault(r.KeysQuerySourceIdentify.hypermediaSourcesAggregatedStores, /* @__PURE__ */ new Map()).setDefault(r.KeysInitQuery.dataFactory, new a.DataFactory());
        let c = { language: "sparql", version: "1.1" };
        i.has(r.KeysInitQuery.queryFormat) ? (c = i.get(r.KeysInitQuery.queryFormat), c.language === "graphql" && (i = i.setDefault(r.KeysInitQuery.graphqlSingularizeVariables, {}))) : i = i.set(r.KeysInitQuery.queryFormat, c);
      }
      return { context: i };
    }
  };
  return fp.ActorContextPreprocessSetDefaults = t, fp;
}
var jF;
function aie() {
  return jF || (jF = 1, function(u) {
    var r = Bu && Bu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bu && Bu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ iie(), u);
  }(Bu)), Bu;
}
var $u = {}, hp = {}, MF;
function uie() {
  if (MF) return hp;
  MF = 1, Object.defineProperty(hp, "__esModule", { value: !0 }), hp.ActorContextPreprocessSourceToDestination = void 0;
  const u = /* @__PURE__ */ Tw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class extends u.ActorContextPreprocess {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (0, o.passTestVoid)();
    }
    async run(e) {
      if (e.context.get(r.KeysInitQuery.querySourcesUnidentified) && !e.context.get(r.KeysRdfUpdateQuads.destination)) {
        const n = e.context.get(r.KeysInitQuery.querySourcesUnidentified);
        if (n.length === 1)
          return { context: e.context.set(r.KeysRdfUpdateQuads.destination, n[0]) };
      }
      return e;
    }
  };
  return hp.ActorContextPreprocessSourceToDestination = a, hp;
}
var CF;
function oie() {
  return CF || (CF = 1, function(u) {
    var r = $u && $u.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $u && $u.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ uie(), u);
  }($u)), $u;
}
var Uu = {}, pp = {}, bp = {}, NA = {}, u6 = { exports: {} }, qF;
function ww() {
  if (qF) return u6.exports;
  qF = 1;
  var u = typeof Reflect == "object" ? Reflect : null, r = u && typeof u.apply == "function" ? u.apply : function(v, E, R) {
    return Function.prototype.apply.call(v, E, R);
  }, o;
  u && typeof u.ownKeys == "function" ? o = u.ownKeys : Object.getOwnPropertySymbols ? o = function(v) {
    return Object.getOwnPropertyNames(v).concat(Object.getOwnPropertySymbols(v));
  } : o = function(v) {
    return Object.getOwnPropertyNames(v);
  };
  function a(T) {
    console && console.warn && console.warn(T);
  }
  var t = Number.isNaN || function(v) {
    return v !== v;
  };
  function e() {
    e.init.call(this);
  }
  u6.exports = e, u6.exports.once = y, e.EventEmitter = e, e.prototype._events = void 0, e.prototype._eventsCount = 0, e.prototype._maxListeners = void 0;
  var n = 10;
  function i(T) {
    if (typeof T != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof T);
  }
  Object.defineProperty(e, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return n;
    },
    set: function(T) {
      if (typeof T != "number" || T < 0 || t(T))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + T + ".");
      n = T;
    }
  }), e.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, e.prototype.setMaxListeners = function(v) {
    if (typeof v != "number" || v < 0 || t(v))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + v + ".");
    return this._maxListeners = v, this;
  };
  function c(T) {
    return T._maxListeners === void 0 ? e.defaultMaxListeners : T._maxListeners;
  }
  e.prototype.getMaxListeners = function() {
    return c(this);
  }, e.prototype.emit = function(v) {
    for (var E = [], R = 1; R < arguments.length; R++) E.push(arguments[R]);
    var L = v === "error", A = this._events;
    if (A !== void 0)
      L = L && A.error === void 0;
    else if (!L)
      return !1;
    if (L) {
      var w;
      if (E.length > 0 && (w = E[0]), w instanceof Error)
        throw w;
      var S = new Error("Unhandled error." + (w ? " (" + w.message + ")" : ""));
      throw S.context = w, S;
    }
    var O = A[v];
    if (O === void 0)
      return !1;
    if (typeof O == "function")
      r(O, this, E);
    else
      for (var x = O.length, F = p(O, x), R = 0; R < x; ++R)
        r(F[R], this, E);
    return !0;
  };
  function s(T, v, E, R) {
    var L, A, w;
    if (i(E), A = T._events, A === void 0 ? (A = T._events = /* @__PURE__ */ Object.create(null), T._eventsCount = 0) : (A.newListener !== void 0 && (T.emit(
      "newListener",
      v,
      E.listener ? E.listener : E
    ), A = T._events), w = A[v]), w === void 0)
      w = A[v] = E, ++T._eventsCount;
    else if (typeof w == "function" ? w = A[v] = R ? [E, w] : [w, E] : R ? w.unshift(E) : w.push(E), L = c(T), L > 0 && w.length > L && !w.warned) {
      w.warned = !0;
      var S = new Error("Possible EventEmitter memory leak detected. " + w.length + " " + String(v) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      S.name = "MaxListenersExceededWarning", S.emitter = T, S.type = v, S.count = w.length, a(S);
    }
    return T;
  }
  e.prototype.addListener = function(v, E) {
    return s(this, v, E, !1);
  }, e.prototype.on = e.prototype.addListener, e.prototype.prependListener = function(v, E) {
    return s(this, v, E, !0);
  };
  function d() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(T, v, E) {
    var R = { fired: !1, wrapFn: void 0, target: T, type: v, listener: E }, L = d.bind(R);
    return L.listener = E, R.wrapFn = L, L;
  }
  e.prototype.once = function(v, E) {
    return i(E), this.on(v, l(this, v, E)), this;
  }, e.prototype.prependOnceListener = function(v, E) {
    return i(E), this.prependListener(v, l(this, v, E)), this;
  }, e.prototype.removeListener = function(v, E) {
    var R, L, A, w, S;
    if (i(E), L = this._events, L === void 0)
      return this;
    if (R = L[v], R === void 0)
      return this;
    if (R === E || R.listener === E)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete L[v], L.removeListener && this.emit("removeListener", v, R.listener || E));
    else if (typeof R != "function") {
      for (A = -1, w = R.length - 1; w >= 0; w--)
        if (R[w] === E || R[w].listener === E) {
          S = R[w].listener, A = w;
          break;
        }
      if (A < 0)
        return this;
      A === 0 ? R.shift() : b(R, A), R.length === 1 && (L[v] = R[0]), L.removeListener !== void 0 && this.emit("removeListener", v, S || E);
    }
    return this;
  }, e.prototype.off = e.prototype.removeListener, e.prototype.removeAllListeners = function(v) {
    var E, R, L;
    if (R = this._events, R === void 0)
      return this;
    if (R.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : R[v] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete R[v]), this;
    if (arguments.length === 0) {
      var A = Object.keys(R), w;
      for (L = 0; L < A.length; ++L)
        w = A[L], w !== "removeListener" && this.removeAllListeners(w);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (E = R[v], typeof E == "function")
      this.removeListener(v, E);
    else if (E !== void 0)
      for (L = E.length - 1; L >= 0; L--)
        this.removeListener(v, E[L]);
    return this;
  };
  function f(T, v, E) {
    var R = T._events;
    if (R === void 0)
      return [];
    var L = R[v];
    return L === void 0 ? [] : typeof L == "function" ? E ? [L.listener || L] : [L] : E ? _(L) : p(L, L.length);
  }
  e.prototype.listeners = function(v) {
    return f(this, v, !0);
  }, e.prototype.rawListeners = function(v) {
    return f(this, v, !1);
  }, e.listenerCount = function(T, v) {
    return typeof T.listenerCount == "function" ? T.listenerCount(v) : h.call(T, v);
  }, e.prototype.listenerCount = h;
  function h(T) {
    var v = this._events;
    if (v !== void 0) {
      var E = v[T];
      if (typeof E == "function")
        return 1;
      if (E !== void 0)
        return E.length;
    }
    return 0;
  }
  e.prototype.eventNames = function() {
    return this._eventsCount > 0 ? o(this._events) : [];
  };
  function p(T, v) {
    for (var E = new Array(v), R = 0; R < v; ++R)
      E[R] = T[R];
    return E;
  }
  function b(T, v) {
    for (; v + 1 < T.length; v++)
      T[v] = T[v + 1];
    T.pop();
  }
  function _(T) {
    for (var v = new Array(T.length), E = 0; E < v.length; ++E)
      v[E] = T[E].listener || T[E];
    return v;
  }
  function y(T, v) {
    return new Promise(function(E, R) {
      function L(w) {
        T.removeListener(v, A), R(w);
      }
      function A() {
        typeof T.removeListener == "function" && T.removeListener("error", L), E([].slice.call(arguments));
      }
      g(T, v, A, { once: !0 }), v !== "error" && m(T, L, { once: !0 });
    });
  }
  function m(T, v, E) {
    typeof T.on == "function" && g(T, "error", v, E);
  }
  function g(T, v, E, R) {
    if (typeof T.on == "function")
      R.once ? T.once(v, E) : T.on(v, E);
    else if (typeof T.addEventListener == "function")
      T.addEventListener(v, function L(A) {
        R.once && T.removeEventListener(v, L), E(A);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof T);
  }
  return u6.exports;
}
var yp = {}, BF;
function sie() {
  if (BF) return yp;
  BF = 1, Object.defineProperty(yp, "__esModule", { value: !0 }), yp.LinkedList = void 0;
  class u {
    constructor() {
      this._length = 0, this._head = null, this._tail = null;
    }
    get length() {
      return this._length;
    }
    get first() {
      var o;
      return (o = this._head) === null || o === void 0 ? void 0 : o.value;
    }
    get last() {
      var o;
      return (o = this._tail) === null || o === void 0 ? void 0 : o.value;
    }
    get empty() {
      return this._head === null;
    }
    push(o) {
      const a = { value: o, next: null };
      this._tail === null ? this._head = this._tail = a : this._tail.next = this._tail = a, this._length++;
    }
    shift() {
      if (this._head === null)
        return;
      const { value: o, next: a } = this._head;
      return this._head = a, a === null && (this._tail = null), this._length--, o;
    }
    clear() {
      this._length = 0, this._head = this._tail = null;
    }
  }
  return yp.LinkedList = u, yp;
}
var _p = {}, $F;
function cie() {
  if ($F) return _p;
  $F = 1, Object.defineProperty(_p, "__esModule", { value: !0 }), _p.createTaskScheduler = void 0;
  const u = Promise.resolve(void 0);
  function r() {
    const o = typeof queueMicrotask == "function" ? queueMicrotask : (n) => u.then(n), a = typeof setImmediate == "function" ? setImmediate : (n) => setTimeout(n, 0);
    let t = 0, e = null;
    return (n) => {
      e !== null ? e.push(n) : ++t < 100 ? o(n) : (e = [n], a(() => {
        for (const i of e)
          o(i);
        e = null, t = 0;
      }));
    };
  }
  return _p.createTaskScheduler = r, _p;
}
var UF;
function yt() {
  return UF || (UF = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.isIterator = u.isIterable = u.isSourceExpression = u.isPromise = u.isEventEmitter = u.isFunction = u.range = u.union = u.fromIterable = u.fromIterator = u.fromArray = u.single = u.empty = u.wrap = u.WrappingIterator = u.ClonedIterator = u.UnionIterator = u.MultiTransformIterator = u.SimpleTransformIterator = u.TransformIterator = u.BufferedIterator = u.MappingIterator = u.DESTINATION = u.identity = u.IntegerIterator = u.ArrayIterator = u.SingletonIterator = u.EmptyIterator = u.AsyncIterator = u.DESTROYED = u.ENDED = u.CLOSED = u.CLOSING = u.OPEN = u.INIT = u.setTaskScheduler = u.getTaskScheduler = u.scheduleTask = u.LinkedList = void 0;
    const r = ww(), o = /* @__PURE__ */ sie();
    Object.defineProperty(u, "LinkedList", { enumerable: !0, get: function() {
      return o.LinkedList;
    } });
    let t = (/* @__PURE__ */ cie()).createTaskScheduler();
    function e(M) {
      t(M);
    }
    u.scheduleTask = e;
    function n() {
      return t;
    }
    u.getTaskScheduler = n;
    function i(M) {
      t = M;
    }
    u.setTaskScheduler = i, u.INIT = 1, u.OPEN = 2, u.CLOSING = 4, u.CLOSED = 8, u.ENDED = 16, u.DESTROYED = 32;
    class c extends r.EventEmitter {
      /** Creates a new `AsyncIterator`. */
      constructor(I = u.OPEN) {
        super(), this._readable = !1, this._state = I, this.on("newListener", s);
      }
      /**
        Changes the iterator to the given state if possible and necessary,
        possibly emitting events to signal that change.
        @protected
        @param {integer} newState The ID of the new state
        @param {boolean} [eventAsync=false] Whether resulting events should be emitted asynchronously
        @returns {boolean} Whether the state was changed
        @emits module:asynciterator.AsyncIterator.end
      */
      _changeState(I, P = !1) {
        const B = I > this._state && this._state < u.ENDED;
        return B && (this._state = I, I === u.ENDED && (P ? t(() => this.emit("end")) : this.emit("end"))), B;
      }
      /**
        Tries to read the next item from the iterator.
        This is the main method for reading the iterator in _on-demand mode_,
        where new items are only created when needed by consumers.
        If no items are currently available, this methods returns `null`.
        The {@link module:asynciterator.event:readable} event
        will then signal when new items might be ready.
        To read all items from the iterator,
        switch to _flow mode_ by subscribing
        to the {@link module:asynciterator.event:data} event.
        When in flow mode, do not use the `read` method.
        @returns {object?} The next item, or `null` if none is available
      */
      read() {
        return null;
      }
      /**
        The iterator emits a `readable` event when it might have new items available
        after having had no items available right before this event.
        If the iterator is not in flow mode, items can be retrieved
        by calling {@link module:asynciterator.AsyncIterator#read}.
        @event module:asynciterator.readable
      */
      /**
        The iterator emits a `data` event with a new item as soon as it becomes available.
        When one or more listeners are attached to the `data` event,
        the iterator switches to _flow mode_,
        generating and emitting new items as fast as possible.
        This drains the source and might create backpressure on the consumers,
        so only subscribe to this event if this behavior is intended.
        In flow mode, don't use {@link module:asynciterator.AsyncIterator#read}.
        To switch back to _on-demand mode_, remove all listeners from the `data` event.
        You can then obtain items through `read` again.
        @event module:asynciterator.data
        @param {object} item The new item
      */
      /**
        Invokes the callback for each remaining item in the iterator.
        Switches the iterator to flow mode.
        @param {Function} callback A function that will be called with each item
        @param {object?} self The `this` pointer for the callback
      */
      forEach(I, P) {
        this.on("data", Te(I, P));
      }
      /**
        Stops the iterator from generating new items.
        Already generated items or terminating items can still be emitted.
        After this, the iterator will end asynchronously.
        @emits module:asynciterator.AsyncIterator.end
      */
      close() {
        this._changeState(u.CLOSED) && this._endAsync();
      }
      /**
        Destroy the iterator and stop it from generating new items.
        This will not do anything if the iterator was already ended or destroyed.
        All internal resources will be released an no new items will be emitted,
        even not already generated items.
        Implementors should not override this method,
        but instead implement {@link module:asynciterator.AsyncIterator#_destroy}.
        @param {Error} [cause] An optional error to emit.
        @emits module:asynciterator.AsyncIterator.end
        @emits module:asynciterator.AsyncIterator.error Only if an error is passed.
      */
      destroy(I) {
        this.done || this._destroy(I, (P) => {
          I = I || P, I && this.emit("error", I), this._end(!0);
        });
      }
      /**
        Called by {@link module:asynciterator.AsyncIterator#destroy}.
        Implementers can override this, but this should not be called directly.
        @param {?Error} cause The reason why the iterator is destroyed.
        @param {Function} callback A callback function with an optional error argument.
      */
      _destroy(I, P) {
        P();
      }
      /**
        Ends the iterator and cleans up.
        Should never be called before {@link module:asynciterator.AsyncIterator#close};
        typically, `close` is responsible for calling `_end`.
        @param {boolean} [destroy] If the iterator should be forcefully destroyed.
        @protected
        @emits module:asynciterator.AsyncIterator.end
      */
      _end(I = !1) {
        this._changeState(I ? u.DESTROYED : u.ENDED) && (this._readable = !1, this.removeAllListeners("readable"), this.removeAllListeners("data"), this.removeAllListeners("end"));
      }
      /**
        Asynchronously calls `_end`.
        @protected
      */
      _endAsync() {
        t(() => this._end());
      }
      /**
        The `end` event is emitted after the last item of the iterator has been read.
        @event module:asynciterator.end
      */
      /**
        Gets or sets whether this iterator might have items available for read.
        A value of `false` means there are _definitely_ no items available;
        a value of `true` means items _might_ be available.
        @type boolean
        @emits module:asynciterator.AsyncIterator.readable
      */
      get readable() {
        return this._readable;
      }
      set readable(I) {
        I = !!I && !this.done, this._readable !== I && (this._readable = I, I && t(() => this.emit("readable")));
      }
      /**
        Gets whether the iterator has stopped generating new items.
        @type boolean
        @readonly
      */
      get closed() {
        return this._state >= u.CLOSING;
      }
      /**
        Gets whether the iterator has finished emitting items.
        @type boolean
        @readonly
      */
      get ended() {
        return this._state === u.ENDED;
      }
      /**
        Gets whether the iterator has been destroyed.
        @type boolean
        @readonly
      */
      get destroyed() {
        return this._state === u.DESTROYED;
      }
      /**
        Gets whether the iterator will not emit anymore items,
        either due to being closed or due to being destroyed.
        @type boolean
        @readonly
      */
      get done() {
        return this._state >= u.ENDED;
      }
      /* Generates a textual representation of the iterator. */
      toString() {
        const I = this._toStringDetails();
        return `[${this.constructor.name}${I ? ` ${I}` : ""}]`;
      }
      /**
        Generates details for a textual representation of the iterator.
        @protected
      */
      _toStringDetails() {
        return "";
      }
      /**
        Consume all remaining items of the iterator into an array that will be returned asynchronously.
        @param {object} [options] Settings for array creation
        @param {integer} [options.limit] The maximum number of items to place in the array.
       */
      toArray(I) {
        const P = [], B = typeof (I == null ? void 0 : I.limit) == "number" ? I.limit : 1 / 0;
        return this.ended || B <= 0 ? Promise.resolve(P) : new Promise((z, H) => {
          const J = () => z(P), k = (W) => {
            P.push(W), P.length >= B && (this.removeListener("error", H), this.removeListener("data", k), this.removeListener("end", J), z(P));
          };
          this.on("error", H), this.on("data", k), this.on("end", J);
        });
      }
      /**
        Retrieves the property with the given name from the iterator.
        If no callback is passed, it returns the value of the property
        or `undefined` if the property is not set.
        If a callback is passed, it returns `undefined`
        and calls the callback with the property the moment it is set.
        @param {string} propertyName The name of the property to retrieve
        @param {Function?} [callback] A one-argument callback to receive the property value
        @returns {object?} The value of the property (if set and no callback is given)
      */
      getProperty(I, P) {
        const B = this._properties;
        if (!P)
          return B && B[I];
        if (B && I in B)
          t(() => P(B[I]));
        else {
          let z;
          (z = this._propertyCallbacks) || (this._propertyCallbacks = z = /* @__PURE__ */ Object.create(null)), I in z ? z[I].push(P) : z[I] = [P];
        }
      }
      /**
        Sets the property with the given name to the value.
        @param {string} propertyName The name of the property to set
        @param {object?} value The new value of the property
      */
      setProperty(I, P) {
        const B = this._properties || (this._properties = /* @__PURE__ */ Object.create(null));
        B[I] = P;
        const z = this._propertyCallbacks || {}, H = z[I];
        if (H) {
          delete z[I], t(() => {
            for (const J of H)
              J(P);
          });
          for (I in z)
            return;
          delete this._propertyCallbacks;
        }
      }
      /**
        Retrieves all properties of the iterator.
        @returns {object} An object with property names as keys.
      */
      getProperties() {
        const I = this._properties, P = {};
        for (const B in I)
          P[B] = I[B];
        return P;
      }
      /**
        Sets all of the given properties.
        @param {object} properties Key/value pairs of properties to set
      */
      setProperties(I) {
        for (const P in I)
          this.setProperty(P, I[P]);
      }
      /**
        Copies the given properties from the source iterator.
        @param {module:asynciterator.AsyncIterator} source The iterator to copy from
        @param {Array} propertyNames List of property names to copy
      */
      copyProperties(I, P) {
        for (const B of P)
          I.getProperty(B, (z) => this.setProperty(B, z));
      }
      /**
        Transforms items from this iterator.
        After this operation, only read the returned iterator instead of the current one.
        @param {object|Function} [options] Settings of the iterator, or the transformation function
        @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer
        @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
        @param {integer} [options.offset] The number of items to skip
        @param {integer} [options.limit] The maximum number of items
        @param {Function} [options.filter] A function to synchronously filter items from the source
        @param {Function} [options.map] A function to synchronously transform items from the source
        @param {Function} [options.transform] A function to asynchronously transform items from the source
        @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items
        @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items
        @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items
        @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator
      */
      transform(I) {
        return new w(this, I);
      }
      /**
        Maps items from this iterator using the given function.
        After this operation, only read the returned iterator instead of the current one.
        @param {Function} map A mapping function to call on this iterator's (remaining) items
        @param {object?} self The `this` pointer for the mapping function
        @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator
      */
      map(I, P) {
        return new y(this, Te(I, P));
      }
      filter(I, P) {
        return this.map(function(B) {
          return I.call(P || this, B) ? B : null;
        });
      }
      /**
       * Returns a new iterator containing all of the unique items in the original iterator.
       * @param by - The derived value by which to determine uniqueness (e.g., stringification).
                     Defaults to the identity function.
       * @returns An iterator with duplicates filtered out.
       */
      uniq(I = _) {
        const P = /* @__PURE__ */ new Set();
        return this.filter(function(B) {
          const z = I.call(this, B);
          return P.has(z) ? !1 : (P.add(z), !0);
        });
      }
      /**
        Prepends the items after those of the current iterator.
        After this operation, only read the returned iterator instead of the current one.
        @param {Array|module:asynciterator.AsyncIterator} items Items to insert before this iterator's (remaining) items
        @returns {module:asynciterator.AsyncIterator} A new iterator that prepends items to this iterator
      */
      prepend(I) {
        return this.transform({ prepend: I });
      }
      /**
        Appends the items after those of the current iterator.
        After this operation, only read the returned iterator instead of the current one.
        @param {Array|module:asynciterator.AsyncIterator} items Items to insert after this iterator's (remaining) items
        @returns {module:asynciterator.AsyncIterator} A new iterator that appends items to this iterator
      */
      append(I) {
        return this.transform({ append: I });
      }
      /**
        Surrounds items of the current iterator with the given items.
        After this operation, only read the returned iterator instead of the current one.
        @param {Array|module:asynciterator.AsyncIterator} prepend Items to insert before this iterator's (remaining) items
        @param {Array|module:asynciterator.AsyncIterator} append Items to insert after this iterator's (remaining) items
        @returns {module:asynciterator.AsyncIterator} A new iterator that appends and prepends items to this iterator
      */
      surround(I, P) {
        return this.transform({ prepend: I, append: P });
      }
      /**
        Skips the given number of items from the current iterator.
        The current iterator may not be read anymore until the returned iterator ends.
        @param {integer} offset The number of items to skip
        @returns {module:asynciterator.AsyncIterator} A new iterator that skips the given number of items
      */
      skip(I) {
        return this.map((P) => I-- > 0 ? null : P);
      }
      /**
        Limits the current iterator to the given number of items.
        The current iterator may not be read anymore until the returned iterator ends.
        @param {integer} limit The maximum number of items
        @returns {module:asynciterator.AsyncIterator} A new iterator with at most the given number of items
      */
      take(I) {
        return this.transform({ limit: I });
      }
      /**
        Limits the current iterator to the given range.
        The current iterator may not be read anymore until the returned iterator ends.
        @param {integer} start Index of the first item to return
        @param {integer} end Index of the last item to return
        @returns {module:asynciterator.AsyncIterator} A new iterator with items in the given range
      */
      range(I, P) {
        return this.transform({ offset: I, limit: Math.max(P - I + 1, 0) });
      }
      /**
        Creates a copy of the current iterator,
        containing all items emitted from this point onward.
        Further copies can be created; they will all start from this same point.
        After this operation, only read the returned copies instead of the original iterator.
        @returns {module:asynciterator.AsyncIterator} A new iterator that contains all future items of this iterator
      */
      clone() {
        return new F(this);
      }
      /**
       * An AsyncIterator is async iterable.
       * This allows iterators to be used via the for-await syntax.
       *
       * In cases where the returned EcmaScript AsyncIterator will not be fully consumed,
       * it is recommended to manually listen for error events on the main AsyncIterator
       * to avoid uncaught error messages.
       *
       * @returns {ESAsyncIterator<T>} An EcmaScript AsyncIterator
       */
      [Symbol.asyncIterator]() {
        const I = this;
        let P = null, B = null, z = null;
        I.addListener("readable", H), I.addListener("end", H), I.addListener("error", J);
        function H() {
          if (P !== null)
            if (z !== null)
              J(z);
            else if (I.done)
              P({ done: !0, value: void 0 }), P = B = null, k();
            else {
              const W = I.read();
              W !== null && (P({ done: !1, value: W }), P = B = null);
            }
        }
        function J(W) {
          B !== null ? (B(W), P = B = z = null, k()) : z === null && (z = W);
        }
        function k() {
          I.removeListener("readable", H), I.removeListener("end", H), I.removeListener("error", J);
        }
        return {
          next() {
            return new Promise((W, le) => {
              P = W, B = le, H();
            });
          }
        };
      }
    }
    u.AsyncIterator = c;
    function s(M) {
      M === "data" && (this.removeListener("newListener", s), l(this, "readable", d), this.readable && t(() => d.call(this)));
    }
    function d() {
      let M;
      for (; this.listenerCount("data") !== 0 && (M = this.read()) !== null; )
        this.emit("data", M);
      this.listenerCount("data") === 0 && !this.done && (this.removeListener("readable", d), l(this, "newListener", s));
    }
    function l(M, I, P) {
      M.listeners(I).includes(P) || M.on(I, P);
    }
    class f extends c {
      /** Creates a new `EmptyIterator`. */
      constructor() {
        super(), this._changeState(u.ENDED, !0);
      }
    }
    u.EmptyIterator = f;
    class h extends c {
      /**
        Creates a new `SingletonIterator`.
        @param {object} item The item that will be emitted.
      */
      constructor(I) {
        super(), this._item = I, I === null ? this.close() : this.readable = !0;
      }
      /* Reads the item from the iterator. */
      read() {
        const I = this._item;
        return this._item = null, this.close(), I;
      }
      /* Generates details for a textual representation of the iterator. */
      _toStringDetails() {
        return this._item === null ? "" : `(${this._item})`;
      }
    }
    u.SingletonIterator = h;
    class p extends c {
      /**
        Creates a new `ArrayIterator`.
        @param {Array} items The items that will be emitted.
        @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
        @param {boolean} [options.preserve=true] If false, the passed array can be safely modified
      */
      constructor(I = [], { autoStart: P = !0, preserve: B = !0 } = {}) {
        super();
        const z = B || !Array.isArray(I) ? [...I] : I;
        this._index = 0, this._sourceStarted = P !== !1, this._truncateThreshold = B ? -1 : 64, this._sourceStarted && z.length === 0 ? this.close() : this._buffer = z, this.readable = !0;
      }
      /* Reads an item from the iterator. */
      read() {
        this._sourceStarted || (this._sourceStarted = !0);
        let I = null;
        return this._buffer && (this._index < this._buffer.length && (I = this._buffer[this._index++]), this._index === this._buffer.length ? (delete this._buffer, this.close()) : this._index === this._truncateThreshold && (this._buffer.splice(0, this._truncateThreshold), this._index = 0)), I;
      }
      /* Generates details for a textual representation of the iterator. */
      _toStringDetails() {
        return `(${this._buffer ? this._buffer.length - this._index : 0})`;
      }
      /* Called by {@link module:asynciterator.AsyncIterator#destroy} */
      _destroy(I, P) {
        delete this._buffer, P();
      }
      /**
       Consume all remaining items of the iterator into an array that will be returned asynchronously.
       @param {object} [options] Settings for array creation
       @param {integer} [options.limit] The maximum number of items to place in the array.
       */
      toArray(I = {}) {
        if (!this._buffer)
          return Promise.resolve([]);
        const { length: P } = this._buffer, B = this._index, z = typeof I.limit != "number" ? P : B + I.limit, H = this._buffer.slice(B, z);
        return this._index = z, z >= P && this.close(), Promise.resolve(H);
      }
    }
    u.ArrayIterator = p;
    class b extends c {
      /**
        Creates a new `IntegerIterator`.
        @param {object} [options] Settings of the iterator
        @param {integer} [options.start=0] The first number to emit
        @param {integer} [options.end=Infinity] The last number to emit
        @param {integer} [options.step=1] The increment between two numbers
      */
      constructor({ start: I = 0, step: P = 1, end: B } = {}) {
        super(), Number.isFinite(I) && (I = Math.trunc(I)), this._next = I, Number.isFinite(P) && (P = Math.trunc(P)), this._step = P;
        const z = P >= 0, H = z ? 1 / 0 : -1 / 0;
        Number.isFinite(B) ? B = Math.trunc(B) : B !== -H && (B = H), this._last = B, !Number.isFinite(I) || (z ? I > B : I < B) ? this.close() : this.readable = !0;
      }
      /* Reads an item from the iterator. */
      read() {
        if (this.closed)
          return null;
        const I = this._next, P = this._step, B = this._last, z = this._next += P;
        return (P >= 0 ? z > B : z < B) && this.close(), I;
      }
      /* Generates details for a textual representation of the iterator. */
      _toStringDetails() {
        return `(${this._next}...${this._last})`;
      }
    }
    u.IntegerIterator = b;
    function _(M) {
      return M;
    }
    u.identity = _, u.DESTINATION = Symbol("destination");
    class y extends c {
      /**
       * Applies the given mapping to the source iterator.
       */
      constructor(I, P = _, B = {}) {
        super(), this._map = P, this._source = m(I), this._destroySource = B.destroySource !== !1, I.done ? this.close() : (this._source[u.DESTINATION] = this, this._source.on("end", R), this._source.on("error", E), this._source.on("readable", v), this.readable = this._source.readable);
      }
      /* Tries to read the next item from the iterator. */
      read() {
        if (!this.done) {
          if (this._source.readable) {
            let I, P;
            for (; (I = this._source.read()) !== null; )
              if ((P = this._map(I)) !== null)
                return P;
          }
          this.readable = !1, this._source.done && this.close();
        }
        return null;
      }
      /* Cleans up the source iterator and ends. */
      _end(I) {
        this._source.removeListener("end", R), this._source.removeListener("error", E), this._source.removeListener("readable", v), delete this._source[u.DESTINATION], this._destroySource && this._source.destroy(), super._end(I);
      }
    }
    u.MappingIterator = y;
    function m(M, I = !1) {
      if (!M || !we(M.read) || !we(M.on))
        throw new TypeError(`Invalid source: ${M}`);
      if (!I && M[u.DESTINATION])
        throw new Error("The source already has a destination");
      return M;
    }
    class g extends c {
      /**
        Creates a new `BufferedIterator`.
        @param {object} [options] Settings of the iterator
        @param {integer} [options.maxBufferSize=4] The number of items to preload in the internal buffer
        @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
      */
      constructor({ maxBufferSize: I = 4, autoStart: P = !0 } = {}) {
        super(u.INIT), this._buffer = new o.LinkedList(), this._maxBufferSize = 4, this._reading = !0, this._pushedCount = 0, this.maxBufferSize = I, t(() => this._init(P)), this._sourceStarted = P !== !1;
      }
      /**
        The maximum number of items to preload in the internal buffer.
        A `BufferedIterator` tries to fill its buffer as far as possible.
        Set to `Infinity` to fully drain the source.
        @type number
      */
      get maxBufferSize() {
        return this._maxBufferSize;
      }
      set maxBufferSize(I) {
        I !== 1 / 0 && (I = Number.isFinite(I) ? Math.max(Math.trunc(I), 1) : 4), this._maxBufferSize !== I && (this._maxBufferSize = I, this._state === u.OPEN && this._fillBuffer());
      }
      /**
        Initializing the iterator by calling {@link BufferedIterator#_begin}
        and changing state from INIT to OPEN.
        @protected
        @param {boolean} autoStart Whether reading of items should immediately start after OPEN.
      */
      _init(I) {
        let P = !1;
        this._reading = !0, this._begin(() => {
          if (P)
            throw new Error("done callback called multiple times");
          P = !0, this._reading = !1, this._changeState(u.OPEN), I ? this._fillBufferAsync() : this.readable = !0;
        });
      }
      /**
        Writes beginning items and opens iterator resources.
        Should never be called before {@link BufferedIterator#_init};
        typically, `_init` is responsible for calling `_begin`.
        @protected
        @param {function} done To be called when initialization is complete
      */
      _begin(I) {
        I();
      }
      /**
        Tries to read the next item from the iterator.
        If the buffer is empty,
        this method calls {@link BufferedIterator#_read} to fetch items.
        @returns {object?} The next item, or `null` if none is available
      */
      read() {
        if (this.done)
          return null;
        this._sourceStarted || (this._sourceStarted = !0);
        const I = this._buffer;
        let P;
        return I.empty ? (P = null, this.readable = !1) : P = I.shift(), !this._reading && I.length < this._maxBufferSize && (this.closed ? I.empty && this._endAsync() : this._fillBufferAsync()), P;
      }
      /**
        Tries to generate the given number of items.
        Implementers should add `count` items through {@link BufferedIterator#_push}.
        @protected
        @param {integer} count The number of items to generate
        @param {function} done To be called when reading is complete
      */
      _read(I, P) {
        P();
      }
      /**
        Adds an item to the internal buffer.
        @protected
        @param {object} item The item to add
        @emits module:asynciterator.AsyncIterator.readable
      */
      _push(I) {
        this.done || (this._pushedCount++, this._buffer.push(I), this.readable = !0);
      }
      /**
        Fills the internal buffer until `this._maxBufferSize` items are present.
        This method calls {@link BufferedIterator#_read} to fetch items.
        @protected
        @emits module:asynciterator.AsyncIterator.readable
      */
      _fillBuffer() {
        let I;
        this._reading || (this.closed ? this._completeClose() : (I = Math.min(this._maxBufferSize - this._buffer.length, 128)) > 0 && (this._pushedCount = 0, this._reading = !0, this._read(I, () => {
          if (!I)
            throw new Error("done callback called multiple times");
          I = 0, this._reading = !1, this.closed ? this._completeClose() : this._pushedCount && (this.readable = !0, this._buffer.length < this._maxBufferSize / 2 && this._fillBufferAsync());
        })));
      }
      /**
        Schedules `_fillBuffer` asynchronously.
      */
      _fillBufferAsync() {
        this._reading || (this._reading = !0, t(() => {
          this._reading = !1, this._fillBuffer();
        }));
      }
      /**
        Stops the iterator from generating new items
        after a possible pending read operation has finished.
        Already generated, pending, or terminating items can still be emitted.
        After this, the iterator will end asynchronously.
        @emits module:asynciterator.AsyncIterator.end
      */
      close() {
        this._reading ? this._changeState(u.CLOSING) : this._completeClose();
      }
      /**
        Stops the iterator from generating new items,
        switching from `CLOSING` state into `CLOSED` state.
        @protected
        @emits module:asynciterator.AsyncIterator.end
      */
      _completeClose() {
        this._changeState(u.CLOSED) && (this._reading = !0, this._flush(() => {
          if (!this._reading)
            throw new Error("done callback called multiple times");
          this._reading = !1, this._buffer.empty && this._endAsync();
        }));
      }
      /* Called by {@link module:asynciterator.AsyncIterator#destroy} */
      _destroy(I, P) {
        this._buffer.clear(), P();
      }
      /**
        Writes terminating items and closes iterator resources.
        Should never be called before {@link BufferedIterator#close};
        typically, `close` is responsible for calling `_flush`.
        @protected
        @param {function} done To be called when termination is complete
      */
      _flush(I) {
        I();
      }
      /**
        Generates details for a textual representation of the iterator.
        @protected
       */
      _toStringDetails() {
        const I = this._buffer;
        return `{${I.empty ? "" : `next: ${I.first}, `}buffer: ${I.length}}`;
      }
    }
    u.BufferedIterator = g;
    class T extends g {
      /**
        Creates a new `TransformIterator`.
        @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from
        @param {object} [options] Settings of the iterator
        @param {integer} [options.maxBufferSize=4] The maximum number of items to keep in the buffer
        @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
        @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its transformation yields no items
        @param {boolean} [options.destroySource=true] Whether the source should be destroyed when this transformed iterator is closed or destroyed
        @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from
      */
      constructor(I, P = I || {}) {
        super(P), this._boundPush = (B) => this._push(B), he(I) || (I = P.source), Oe(I) ? this.source = I : I && (this._createSource = be(I) ? () => I : I, this._sourceStarted && this._loadSourceAsync()), this._optional = !!P.optional, this._destroySource = P.destroySource !== !1;
      }
      /**
        The source this iterator generates items from.
        @type module:asynciterator.AsyncIterator
      */
      get source() {
        return we(this._createSource) && this._loadSourceAsync(), this._source;
      }
      set source(I) {
        const P = this._source = this._validateSource(I);
        P[u.DESTINATION] = this, this.done ? this._destroySource && P.destroy() : P.done ? this.close() : (P.on("end", L), P.on("readable", A), P.on("error", E));
      }
      /**
        Initializes a source that was set through a promise
        @protected
      */
      _loadSourceAsync() {
        we(this._createSource) && (Promise.resolve(this._createSource()).then((I) => {
          delete this._createSource, this.source = I, this._fillBuffer();
        }, (I) => this.emit("error", I)), this._createSource = null);
      }
      /**
        Validates whether the given iterator can be used as a source.
        @protected
        @param {object} source The source to validate
        @param {boolean} allowDestination Whether the source can already have a destination
      */
      _validateSource(I, P = !1) {
        if (this._source || typeof this._createSource < "u")
          throw new Error("The source cannot be changed after it has been set");
        return m(I, P);
      }
      /**
        Tries to read transformed items.
      */
      _read(I, P) {
        const B = () => {
          this._pushedCount < I && !this.closed ? t(() => this._readAndTransform(B, P)) : P();
        };
        this._readAndTransform(B, P);
      }
      /**
        Reads a transforms an item
      */
      _readAndTransform(I, P) {
        let B;
        const z = this.source;
        !z || z.done || (B = z.read()) === null ? P() : this._optional ? this._optionalTransform(B, I) : this._transform(B, I, this._boundPush);
      }
      /**
        Tries to transform the item;
        if the transformation yields no items, pushes the original item.
      */
      _optionalTransform(I, P) {
        const B = this._pushedCount;
        this._transform(I, () => {
          B === this._pushedCount && this._push(I), P();
        }, this._boundPush);
      }
      /**
        Generates items based on the item from the source.
        Implementers should add items through {@link BufferedIterator#_push}.
        The default implementation pushes the source item as-is.
        @protected
        @param {object} item The last read item from the source
        @param {function} done To be called when reading is complete
        @param {function} push A callback to push zero or more transformation results.
      */
      _transform(I, P, B) {
        B(I), P();
      }
      /**
        Closes the iterator when pending items are transformed.
        @protected
      */
      _closeWhenDone() {
        this.close();
      }
      /* Cleans up the source iterator and ends. */
      _end(I) {
        const P = this._source;
        P && (P.removeListener("end", L), P.removeListener("error", E), P.removeListener("readable", A), delete P[u.DESTINATION], this._destroySource && P.destroy()), super._end(I);
      }
    }
    u.TransformIterator = T;
    function v() {
      this[u.DESTINATION].readable = !0;
    }
    function E(M) {
      this[u.DESTINATION].emit("error", M);
    }
    function R() {
      this[u.DESTINATION].close();
    }
    function L() {
      this[u.DESTINATION]._closeWhenDone();
    }
    function A() {
      this[u.DESTINATION]._sourceStarted !== !1 && this[u.DESTINATION]._fillBuffer();
    }
    class w extends T {
      /**
        Creates a new `SimpleTransformIterator`.
        @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from
        @param {object|Function} [options] Settings of the iterator, or the transformation function
        @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer
        @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
        @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from
        @param {integer} [options.offset] The number of items to skip
        @param {integer} [options.limit] The maximum number of items
        @param {Function} [options.filter] A function to synchronously filter items from the source
        @param {Function} [options.map] A function to synchronously transform items from the source
        @param {Function} [options.transform] A function to asynchronously transform items from the source
        @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items
        @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items
        @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items
      */
      constructor(I, P) {
        if (super(I, P), this._offset = 0, this._limit = 1 / 0, this._filter = (B) => !0, P = P || (he(I) ? null : I), P) {
          const B = we(P) ? P : P.transform, { limit: z, offset: H, filter: J, map: k, prepend: W, append: le } = P;
          H === 1 / 0 || z === -1 / 0 ? this._limit = 0 : (Number.isFinite(H) && (this._offset = Math.max(Math.trunc(H), 0)), Number.isFinite(z) && (this._limit = Math.max(Math.trunc(z), 0)), we(J) && (this._filter = J), we(k) && (this._map = k), this._transform = we(B) ? B : null), W && (this._prepender = Oe(W) ? W : U(W)), le && (this._appender = Oe(le) ? le : U(le));
        }
      }
      /* Tries to read and transform items */
      _read(I, P) {
        const B = () => this._readAndTransformSimple(I, z, P);
        this._readAndTransformSimple(I, z, P);
        function z() {
          t(B);
        }
      }
      /* Reads and transform items */
      _readAndTransformSimple(I, P, B) {
        let z;
        const { source: H } = this;
        if (!H || H.done) {
          B();
          return;
        }
        for (this._limit === 0 && this.close(); !this.closed && this._pushedCount < I && (z = H.read()) !== null; ) {
          if (!this._filter(z) || this._offset !== 0 && this._offset--)
            continue;
          const J = typeof this._map > "u" ? z : this._map(z);
          if (J === null)
            this._optional && this._push(z);
          else if (!we(this._transform))
            this._push(J);
          else {
            this._optional ? this._optionalTransform(J, P) : this._transform(J, P, this._boundPush);
            return;
          }
          --this._limit === 0 && this.close();
        }
        B();
      }
      // Prepends items to the iterator
      _begin(I) {
        this._insert(this._prepender, I), delete this._prepender;
      }
      // Appends items to the iterator
      _flush(I) {
        this._insert(this._appender, I), delete this._appender;
      }
      // Inserts items in the iterator
      _insert(I, P) {
        const B = (H) => this._push(H);
        !I || I.done ? P() : (I.on("data", B), I.on("end", z));
        function z() {
          I.removeListener("data", B), I.removeListener("end", z), P();
        }
      }
    }
    u.SimpleTransformIterator = w;
    class S extends T {
      /**
       Creates a new `MultiTransformIterator`.
       @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from
       @param {object|Function} [options] Settings of the iterator, or the transformation function
       @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer
       @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction
       @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from
       @param {integer} [options.offset] The number of items to skip
       @param {integer} [options.limit] The maximum number of items
       @param {Function} [options.filter] A function to synchronously filter items from the source
       @param {Function} [options.map] A function to synchronously transform items from the source
       @param {Function} [options.transform] A function to asynchronously transform items from the source
       @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items
       @param {Function} [options.multiTransform] A function to asynchronously transform items to iterators from the source
       @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items
       @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items
       */
      constructor(I, P) {
        if (super(I, P), this._transformerQueue = [], P) {
          const B = we(P) ? P : P.multiTransform;
          B && (this._createTransformer = B);
        }
      }
      /* Tries to read and transform items */
      _read(I, P) {
        const B = this._transformerQueue, z = this._optional;
        let H, J;
        for (; (H = B[0]) && H.transformer.done; ) {
          z && H.item !== null && (I--, this._push(H.item)), B.shift();
          const { transformer: W } = H;
          W.removeListener("end", A), W.removeListener("readable", A), W.removeListener("error", E);
        }
        const { source: k } = this;
        for (; k && !k.done && B.length < this.maxBufferSize && (J = k.read(), J !== null); ) {
          const W = this._createTransformer(J) || new f();
          W[u.DESTINATION] = this, W.on("end", A), W.on("readable", A), W.on("error", E), B.push({ transformer: W, item: J });
        }
        if (H = B[0], H) {
          const { transformer: W } = H;
          for (; I-- > 0 && (J = W.read()) !== null; )
            this._push(J), z && (H.item = null);
        } else k && k.done && this.close();
        P();
      }
      /**
        Creates a transformer for the given item.
        @param {object} item The last read item from the source
        @returns {module:asynciterator.AsyncIterator} An iterator that transforms the given item
      */
      _createTransformer(I) {
        return new h(I);
      }
      /* Closes the iterator when pending items are transformed. */
      _closeWhenDone() {
        this._transformerQueue.length || this.close();
      }
      _end(I) {
        if (super._end(I), this._destroySource)
          for (const P of this._transformerQueue)
            P.transformer.destroy();
      }
    }
    u.MultiTransformIterator = S;
    class O extends g {
      /**
        Creates a new `UnionIterator`.
        @param {module:asynciterator.AsyncIterator|Array} [sources] The sources to read from
        @param {object} [options] Settings of the iterator
        @param {boolean} [options.destroySource=true] Whether the sources should be destroyed when transformed iterator is closed or destroyed
      */
      constructor(I, P = {}) {
        super(P), this._sources = [], this._currentSource = -1;
        const B = P.autoStart !== !1;
        if (Oe(I))
          I.on("error", (z) => this.emit("error", z)), this._pending = { loading: !1, sources: I }, B && this._loadSources();
        else if (Array.isArray(I) && I.length > 0)
          for (const z of I)
            this._addSource(z);
        else B && this.close();
        this._destroySources = P.destroySources !== !1;
      }
      // Loads pending sources into the sources list
      _loadSources() {
        const I = this._pending.sources;
        this._pending.loading = !0, I.done ? (delete this._pending, this.close()) : (I.on("data", (P) => {
          this._addSource(P), this._fillBufferAsync();
        }), I.on("end", () => {
          delete this._pending, this._fillBuffer();
        }));
      }
      // Adds the given source to the internal sources array
      _addSource(I) {
        be(I) && (I = Q(I)), I.done || (this._sources.push(I), I[u.DESTINATION] = this, I.on("error", E), I.on("readable", A), I.on("end", x));
      }
      // Removes sources that will no longer emit items
      _removeEmptySources() {
        this._sources = this._sources.filter((I, P) => (I.done && P <= this._currentSource && this._currentSource--, !I.done)), this._fillBuffer();
      }
      // Reads items from the next sources
      _read(I, P) {
        var B;
        ((B = this._pending) === null || B === void 0 ? void 0 : B.loading) === !1 && this._loadSources();
        let z = 0, H;
        for (; z !== (z = I); )
          for (let J = 0; J < this._sources.length && I > 0; J++)
            this._currentSource = (this._currentSource + 1) % this._sources.length, (H = this._sources[this._currentSource].read()) !== null && (I--, this._push(H));
        !this._pending && this._sources.length === 0 && this.close(), P();
      }
      _end(I = !1) {
        if (super._end(I), this._destroySources) {
          for (const P of this._sources)
            P.destroy();
          this._pending && (this._pending.sources.destroy(), delete this._pending);
        }
      }
    }
    u.UnionIterator = O;
    function x() {
      this[u.DESTINATION]._removeEmptySources();
    }
    class F extends T {
      /**
        Creates a new `ClonedIterator`.
        @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator copies items from
      */
      constructor(I) {
        super(I, { autoStart: !1 }), this._readPosition = 0, this._reading = !1, I && (this.readable = !0);
      }
      _init() {
      }
      close() {
        c.prototype.close.call(this);
      }
      // The source this iterator copies items from
      get source() {
        return super.source;
      }
      set source(I) {
        const P = this._source = this._validateSource(I), B = P && P[u.DESTINATION] || (P[u.DESTINATION] = new j(P));
        this.done ? this._destroySource && P.destroy() : B.endsAt(0) ? this.close() : (B.register(this), (P._sourceStarted === !1 || B.readAt(0) !== null) && (this.readable = !0));
        const z = this._propertyCallbacks;
        for (const H in z) {
          const J = z[H];
          for (const k of J)
            this._getSourceProperty(H, k);
        }
      }
      /**
        Validates whether the given iterator can be used as a source.
        @protected
        @param {object} source The source to validate
        @param {boolean} allowDestination Whether the source can already have a destination
      */
      _validateSource(I, P = !1) {
        const B = I && I[u.DESTINATION];
        return super._validateSource(I, !B || B instanceof j);
      }
      // Retrieves the property with the given name from the clone or its source.
      getProperty(I, P) {
        const { source: B } = this, z = this._properties, H = z && I in z;
        if (!P)
          return H ? z && z[I] : B && B.getProperty(I);
        super.getProperty(I, P), B && !H && this._getSourceProperty(I, P);
      }
      // Retrieves the property with the given name from the source
      _getSourceProperty(I, P) {
        this.source.getProperty(I, (B) => {
          (!this._properties || !(I in this._properties)) && P(B);
        });
      }
      // Retrieves all properties of the iterator and its source.
      getProperties() {
        const I = this.source ? this.source.getProperties() : {}, P = this._properties;
        for (const B in P)
          I[B] = P[B];
        return I;
      }
      /* Generates details for a textual representation of the iterator. */
      _toStringDetails() {
        return `{source: ${this.source ? this.source.toString() : "none"}}`;
      }
      /* Tries to read an item */
      read() {
        this._sourceStarted || (this._sourceStarted = !0);
        const I = this.source;
        let P = null;
        if (!this.done && I) {
          const B = I[u.DESTINATION];
          (P = B.readAt(this._readPosition)) !== null ? this._readPosition++ : this.readable = !1, B.endsAt(this._readPosition) && this.close();
        }
        return P;
      }
      /* End the iterator and cleans up. */
      _end(I) {
        const P = this.source, B = P == null ? void 0 : P[u.DESTINATION];
        B && B.unregister(this), g.prototype._end.call(this, I);
      }
    }
    u.ClonedIterator = F;
    class j {
      constructor(I) {
        if (this._history = [], this._trackers = /* @__PURE__ */ new Set(), this._source = I, !I.done) {
          const P = () => {
            for (const H of this._trackers)
              H.readable = !0;
          }, B = (H) => {
            for (const J of this._trackers)
              J.emit("error", H);
          }, z = () => {
            for (const H of this._trackers)
              H._sourceStarted !== !1 && H._readPosition === this._history.length && H.close();
            this._trackers.clear(), I.removeListener("end", z), I.removeListener("error", B), I.removeListener("readable", P);
          };
          I.on("end", z), I.on("error", B), I.on("readable", P);
        }
      }
      // Registers a clone for history updates
      register(I) {
        this._source.done || this._trackers.add(I);
      }
      // Unregisters a clone for history updates
      unregister(I) {
        this._trackers.delete(I);
      }
      // Tries to read the item at the given history position
      readAt(I) {
        let P = null;
        return I < this._history.length ? P = this._history[I] : !this._source.done && (P = this._source.read()) !== null && (this._history[I] = P), P;
      }
      // Determines whether the given position is the end of the source
      endsAt(I) {
        return this._source.done && this._history.length === I;
      }
    }
    class q extends c {
      constructor(I, P) {
        super(), this._source = null, this._destroySource = (P == null ? void 0 : P.destroySource) !== !1, be(I) ? (this._source = new c(), I.then((B) => {
          this._source = null, this.source = B;
        }).catch((B) => this.emit("error", B))) : I && (this.source = I);
      }
      set source(I) {
        let P = I;
        if (this._source !== null)
          throw new Error("The source cannot be changed after it has been set");
        if (V(P) && (P = P[Symbol.iterator]()), N(P)) {
          let B = P;
          P = new r.EventEmitter(), P.read = () => {
            if (B !== null) {
              let z;
              for (; !(z = B.next()).done; )
                if (z.value !== null)
                  return z.value;
              B = null, this.close();
            }
            return null;
          };
        } else
          P = m(P);
        if (this.done) {
          this._destroySource && we(P.destroy) && P.destroy();
          return;
        }
        P[u.DESTINATION] = this, P.on("end", R), P.on("error", E), P.on("readable", v), this._source = P, this.readable = P.readable !== !1;
      }
      read() {
        if (this._source !== null && this._source.readable !== !1) {
          const I = this._source.read();
          if (I !== null)
            return I;
          this.readable = !1;
        }
        return null;
      }
      _end(I = !1) {
        this._source !== null && (this._source.removeListener("end", R), this._source.removeListener("error", E), this._source.removeListener("readable", v), delete this._source[u.DESTINATION], this._destroySource && we(this._source.destroy) && this._source.destroy(), this._source = null), super._end(I);
      }
    }
    u.WrappingIterator = q;
    function Q(M, I) {
      if (I && ("autoStart" in I || "optional" in I || "source" in I || "maxBufferSize" in I))
        return M && !Oe(M) && (M = new q(M)), new T(M, I);
      if (!M)
        return G();
      if (be(M))
        return new q(M, I);
      if (M instanceof c)
        return M;
      if (Array.isArray(M))
        return U(M);
      if (V(M) || N(M) || Oe(M))
        return new q(M, I);
      throw new TypeError(`Invalid source: ${M}`);
    }
    u.wrap = Q;
    function G() {
      return new f();
    }
    u.empty = G;
    function K(M) {
      return new h(M);
    }
    u.single = K;
    function U(M) {
      return new p(M);
    }
    u.fromArray = U;
    function ae(M) {
      return new q(M);
    }
    u.fromIterator = ae;
    function ye(M) {
      return new q(M);
    }
    u.fromIterable = ye;
    function pe(M) {
      return new O(M);
    }
    u.union = pe;
    function ee(M, I, P) {
      return new b({ start: M, end: I, step: P });
    }
    u.range = ee;
    function Te(M, I) {
      return I ? M.bind(I) : M;
    }
    function we(M) {
      return typeof M == "function";
    }
    u.isFunction = we;
    function Oe(M) {
      return we(M == null ? void 0 : M.on);
    }
    u.isEventEmitter = Oe;
    function be(M) {
      return we(M == null ? void 0 : M.then);
    }
    u.isPromise = be;
    function he(M) {
      return M && (Oe(M) || be(M) || we(M));
    }
    u.isSourceExpression = he;
    function V(M) {
      return M && Symbol.iterator in M;
    }
    u.isIterable = V;
    function N(M) {
      return we(M == null ? void 0 : M.next);
    }
    u.isIterator = N;
  }(NA)), NA;
}
var PA = {}, Vu = {}, gp = {}, VF;
function die() {
  if (VF) return gp;
  VF = 1, Object.defineProperty(gp, "__esModule", { value: !0 }), gp.BlankNodeScoped = void 0;
  let u = class {
    constructor(o, a) {
      this.termType = "BlankNode", this.value = o, this.skolemized = a;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  };
  return gp.BlankNodeScoped = u, gp;
}
var mp = {}, QF;
function lie() {
  if (QF) return mp;
  QF = 1, Object.defineProperty(mp, "__esModule", { value: !0 }), mp.BlankNodeBindingsScoped = void 0;
  let u = class {
    constructor(o) {
      this.termType = "BlankNode", this.singleBindingsScope = !0, this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  };
  return mp.BlankNodeBindingsScoped = u, mp;
}
var HF;
function g8() {
  return HF || (HF = 1, function(u) {
    var r = Vu && Vu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vu && Vu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ die(), u), o(/* @__PURE__ */ lie(), u);
  }(Vu)), Vu;
}
var GF;
function m8() {
  return GF || (GF = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.deskolemizeOperation = u.deskolemizeQuad = u.deskolemizeTermNestedThrowing = u.deskolemizeTerm = u.skolemizeBindingsStream = u.skolemizeQuadStream = u.skolemizeBindings = u.skolemizeQuad = u.skolemizeTerm = u.getSourceId = u.SKOLEM_PREFIX = void 0;
    const r = /* @__PURE__ */ g8(), o = zn(), a = ft();
    u.SKOLEM_PREFIX = "urn:comunica_skolem:source_";
    function t(p, b) {
      let _ = p.get(b.referenceValue);
      return _ === void 0 && (_ = `${p.size}`, p.set(b.referenceValue, _)), _;
    }
    u.getSourceId = t;
    function e(p, b, _) {
      return b.termType === "BlankNode" ? new r.BlankNodeScoped(`bc_${_}_${b.value}`, p.namedNode(`${u.SKOLEM_PREFIX}${_}:${b.value}`)) : b;
    }
    u.skolemizeTerm = e;
    function n(p, b, _) {
      return (0, o.mapTermsNested)(b, (y) => e(p, y, _));
    }
    u.skolemizeQuad = n;
    function i(p, b, _) {
      return b.map((y) => y.termType === "Quad" ? n(p, y, _) : e(p, y, _));
    }
    u.skolemizeBindings = i;
    function c(p, b, _) {
      const y = b.map((g) => n(p, g, _));
      function m() {
        b.getProperty("metadata", (g) => {
          y.setProperty("metadata", g), g.state.addInvalidateListener(m);
        });
      }
      return m(), y;
    }
    u.skolemizeQuadStream = c;
    function s(p, b, _) {
      const y = b.map((g) => i(p, g, _));
      function m() {
        b.getProperty("metadata", (g) => {
          y.setProperty("metadata", g), g.state.addInvalidateListener(m);
        });
      }
      return m(), y;
    }
    u.skolemizeBindingsStream = s;
    function d(p, b, _) {
      if (b.termType === "BlankNode" && "skolemized" in b && (b = b.skolemized), b.termType === "NamedNode" && b.value.startsWith(u.SKOLEM_PREFIX)) {
        const y = b.value.indexOf(":", u.SKOLEM_PREFIX.length);
        if (b.value.slice(u.SKOLEM_PREFIX.length, y) === _) {
          const g = b.value.slice(y + 1, b.value.length);
          return p.blankNode(g);
        }
        return null;
      }
      return b;
    }
    u.deskolemizeTerm = d;
    function l(p, b, _) {
      if (b.termType === "Quad")
        return (0, o.mapTermsNested)(b, (m) => {
          const g = d(p, m, _);
          if (!g)
            throw new Error("Skolemized term is not in scope for this source");
          return g;
        });
      const y = d(p, b, _);
      if (y === null)
        throw new Error("Skolemized term is not in scope for this source");
      return y;
    }
    u.deskolemizeTermNestedThrowing = l;
    function f(p, b, _) {
      return (0, o.mapTermsNested)(b, (y) => d(p, y, _) ?? y);
    }
    u.deskolemizeQuad = f;
    function h(p, b, _) {
      const y = new a.Factory();
      try {
        return a.Util.mapOperation(b, {
          [a.Algebra.types.PATTERN](m, g) {
            return {
              result: Object.assign(g.createPattern(l(p, m.subject, _), l(p, m.predicate, _), l(p, m.object, _), l(p, m.graph, _)), { metadata: m.metadata }),
              recurse: !1
            };
          },
          [a.Algebra.types.PATH](m, g) {
            return {
              result: Object.assign(g.createPath(l(p, m.subject, _), m.predicate, l(p, m.object, _), l(p, m.graph, _)), { metadata: m.metadata }),
              recurse: !1
            };
          }
        }, y);
      } catch {
      }
    }
    u.deskolemizeOperation = h;
  }(PA)), PA;
}
var zF;
function eW() {
  if (zF) return bp;
  zF = 1, Object.defineProperty(bp, "__esModule", { value: !0 }), bp.QuerySourceSkolemized = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ Rr(), o = /* @__PURE__ */ yt(), a = /* @__PURE__ */ m8();
  let t = class {
    constructor(n, i) {
      this.innerSource = n, this.sourceId = i;
    }
    async getSelectorShape(n) {
      return this.innerSource.getSelectorShape(n);
    }
    queryBindings(n, i, c) {
      const s = i.getSafe(u.KeysInitQuery.dataFactory), d = (0, a.deskolemizeOperation)(s, n, this.sourceId);
      if (!d) {
        const l = new o.ArrayIterator([], { autoStart: !1 });
        return l.setProperty("metadata", {
          state: new r.MetadataValidationState(),
          cardinality: { type: "exact", value: 0 },
          variables: []
        }), l;
      }
      return (0, a.skolemizeBindingsStream)(s, this.innerSource.queryBindings(d, i, c), this.sourceId);
    }
    queryBoolean(n, i) {
      return this.innerSource.queryBoolean(n, i);
    }
    queryQuads(n, i) {
      const c = i.getSafe(u.KeysInitQuery.dataFactory), s = (0, a.deskolemizeOperation)(c, n, this.sourceId);
      if (!s) {
        const d = new o.ArrayIterator([], { autoStart: !1 });
        return d.setProperty("metadata", {
          state: new r.MetadataValidationState(),
          cardinality: { type: "exact", value: 0 }
        }), d;
      }
      return (0, a.skolemizeQuadStream)(c, this.innerSource.queryQuads(s, i), this.sourceId);
    }
    queryVoid(n, i) {
      return this.innerSource.queryVoid(n, i);
    }
    get referenceValue() {
      return this.innerSource.referenceValue;
    }
    toString() {
      return `${this.innerSource.toString()}(SkolemID:${this.sourceId})`;
    }
  };
  return bp.QuerySourceSkolemized = t, bp;
}
var kF;
function fie() {
  if (kF) return pp;
  kF = 1, Object.defineProperty(pp, "__esModule", { value: !0 }), pp.ActorContextPreprocessQuerySourceSkolemize = void 0;
  const u = /* @__PURE__ */ Tw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ eW(), t = /* @__PURE__ */ m8();
  let e = class extends u.ActorContextPreprocess {
    constructor(i) {
      super(i);
    }
    async test(i) {
      return (0, o.passTestVoid)();
    }
    async run(i) {
      let c = i.context;
      if (c.has(r.KeysQueryOperation.querySources)) {
        c.has(r.KeysQuerySourceIdentify.sourceIds) || (c = c.set(r.KeysQuerySourceIdentify.sourceIds, /* @__PURE__ */ new Map()));
        const s = c.getSafe(r.KeysQuerySourceIdentify.sourceIds);
        let d = c.getSafe(r.KeysQueryOperation.querySources);
        d = d.map((l) => ({
          source: new a.QuerySourceSkolemized(l.source, (0, t.getSourceId)(s, l.source)),
          context: l.context
        })), c = c.set(r.KeysQueryOperation.querySources, d);
      }
      return { context: c };
    }
  };
  return pp.ActorContextPreprocessQuerySourceSkolemize = e, pp;
}
var XF;
function tW() {
  return XF || (XF = 1, function(u) {
    var r = Uu && Uu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Uu && Uu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ fie(), u), o(/* @__PURE__ */ eW(), u), o(/* @__PURE__ */ m8(), u);
  }(Uu)), Uu;
}
var Qu = {}, vp = {}, JF;
function hie() {
  if (JF) return vp;
  JF = 1, Object.defineProperty(vp, "__esModule", { value: !0 }), vp.MediatorCombinePipeline = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Mediator {
    constructor(a) {
      super(a);
    }
    async mediate(a) {
      let t;
      try {
        t = this.publish(a);
      } catch {
        return a;
      }
      if (this.filterFailures) {
        const c = [];
        for (const s of t)
          (await s.reply).isPassed() && c.push(s);
        t = c;
      }
      const e = [];
      if (t = await Promise.all(t.map(async ({ actor: c, reply: s }, d) => {
        try {
          const l = await s, f = l.getOrThrow();
          return e[d] = l.getSideData(), { actor: c, reply: f };
        } catch (l) {
          throw new Error(this.constructFailureMessage(a, [l.message]));
        }
      })), this.order) {
        const c = (s) => {
          const d = this.field ? s[this.field] : s;
          if (typeof d != "number")
            throw new TypeError("Cannot order elements that are not numbers.");
          return d;
        };
        t = t.sort((s, d) => (this.order === "increasing" ? 1 : -1) * (c(s.reply) - c(d.reply)));
      }
      let n = a, i = 0;
      for (const { actor: c } of t)
        n = { ...n, ...await c.runObservable(n, e[i++]) };
      return n;
    }
    mediateWith() {
      throw new Error("Method not supported.");
    }
  };
  return vp.MediatorCombinePipeline = r, vp;
}
var KF;
function WF() {
  return KF || (KF = 1, function(u) {
    var r = Qu && Qu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Qu && Qu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hie(), u);
  }(Qu)), Qu;
}
var Hu = {}, Tp = {}, Gu = {}, wp = {}, YF;
function pie() {
  if (YF) return wp;
  YF = 1, Object.defineProperty(wp, "__esModule", { value: !0 }), wp.ActorHashBindings = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Failed to obtaining hash functions for bindings} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return wp.ActorHashBindings = r, wp;
}
var ZF;
function bie() {
  return ZF || (ZF = 1, function(u) {
    var r = Gu && Gu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Gu && Gu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ pie(), u);
  }(Gu)), Gu;
}
var DA = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
var eN;
function rW() {
  return eN || (eN = 1, function(u) {
    (function() {
      var r;
      function o(a, t) {
        var e = this instanceof o ? this : r;
        if (e.reset(t), typeof a == "string" && a.length > 0 && e.hash(a), e !== this)
          return e;
      }
      o.prototype.hash = function(a) {
        var t, e, n, i, c;
        switch (c = a.length, this.len += c, e = this.k1, n = 0, this.rem) {
          case 0:
            e ^= c > n ? a.charCodeAt(n++) & 65535 : 0;
          case 1:
            e ^= c > n ? (a.charCodeAt(n++) & 65535) << 8 : 0;
          case 2:
            e ^= c > n ? (a.charCodeAt(n++) & 65535) << 16 : 0;
          case 3:
            e ^= c > n ? (a.charCodeAt(n) & 255) << 24 : 0, e ^= c > n ? (a.charCodeAt(n++) & 65280) >> 8 : 0;
        }
        if (this.rem = c + this.rem & 3, c -= this.rem, c > 0) {
          for (t = this.h1; e = e * 11601 + (e & 65535) * 3432906752 & 4294967295, e = e << 15 | e >>> 17, e = e * 13715 + (e & 65535) * 461832192 & 4294967295, t ^= e, t = t << 13 | t >>> 19, t = t * 5 + 3864292196 & 4294967295, !(n >= c); )
            e = a.charCodeAt(n++) & 65535 ^ (a.charCodeAt(n++) & 65535) << 8 ^ (a.charCodeAt(n++) & 65535) << 16, i = a.charCodeAt(n++), e ^= (i & 255) << 24 ^ (i & 65280) >> 8;
          switch (e = 0, this.rem) {
            case 3:
              e ^= (a.charCodeAt(n + 2) & 65535) << 16;
            case 2:
              e ^= (a.charCodeAt(n + 1) & 65535) << 8;
            case 1:
              e ^= a.charCodeAt(n) & 65535;
          }
          this.h1 = t;
        }
        return this.k1 = e, this;
      }, o.prototype.result = function() {
        var a, t;
        return a = this.k1, t = this.h1, a > 0 && (a = a * 11601 + (a & 65535) * 3432906752 & 4294967295, a = a << 15 | a >>> 17, a = a * 13715 + (a & 65535) * 461832192 & 4294967295, t ^= a), t ^= this.len, t ^= t >>> 16, t = t * 51819 + (t & 65535) * 2246770688 & 4294967295, t ^= t >>> 13, t = t * 44597 + (t & 65535) * 3266445312 & 4294967295, t ^= t >>> 16, t >>> 0;
      }, o.prototype.reset = function(a) {
        return this.h1 = typeof a == "number" ? a : 0, this.rem = this.k1 = this.len = 0, this;
      }, r = new o(), u.exports = o;
    })();
  }(DA)), DA.exports;
}
var tN;
function yie() {
  if (tN) return Tp;
  tN = 1, Object.defineProperty(Tp, "__esModule", { value: !0 }), Tp.ActorHashBindingsMurmur = void 0;
  const u = /* @__PURE__ */ bie(), r = /* @__PURE__ */ _e(), o = rW();
  let a = class extends u.ActorHashBindings {
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      return {
        hashFunction: (n, i) => {
          var s;
          let c = o();
          for (const d of i)
            c = c.hash(((s = n.get(d)) == null ? void 0 : s.value) ?? "UNDEF");
          return c.result();
        }
      };
    }
  };
  return Tp.ActorHashBindingsMurmur = a, Tp;
}
var rN;
function _ie() {
  return rN || (rN = 1, function(u) {
    var r = Hu && Hu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Hu && Hu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ yie(), u);
  }(Hu)), Hu;
}
var zu = {}, Sp = {}, nN;
function gie() {
  if (nN) return Sp;
  nN = 1, Object.defineProperty(Sp, "__esModule", { value: !0 }), Sp.MediatorRace = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Mediator {
    constructor(a) {
      super(a);
    }
    mediateWith(a, t) {
      return new Promise((e, n) => {
        const i = [];
        for (const c of t)
          c.reply.then((s) => {
            s.isPassed() ? e((0, u.passTestWithSideData)(c.actor, s.getSideData())) : (i.push(s.getFailMessage()), i.length === t.length && e((0, u.failTest)(this.constructFailureMessage(a, i))));
          }).catch((s) => {
            n(s);
          });
      });
    }
  };
  return Sp.MediatorRace = r, Sp;
}
var iN;
function xr() {
  return iN || (iN = 1, function(u) {
    var r = zu && zu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zu && zu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ gie(), u);
  }(zu)), zu;
}
var ku = {}, Ap = {}, Xu = {}, Ep = {}, aN;
function mie() {
  if (aN) return Ep;
  aN = 1, Object.defineProperty(Ep, "__esModule", { value: !0 }), Ep.ActorHashQuads = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Failed to obtaining hash functions for quads} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return Ep.ActorHashQuads = r, Ep;
}
var uN;
function vie() {
  return uN || (uN = 1, function(u) {
    var r = Xu && Xu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xu && Xu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ mie(), u);
  }(Xu)), Xu;
}
var oN;
function Tie() {
  if (oN) return Ap;
  oN = 1, Object.defineProperty(Ap, "__esModule", { value: !0 }), Ap.ActorHashQuadsMurmur = void 0;
  const u = /* @__PURE__ */ vie(), r = /* @__PURE__ */ _e(), o = rW();
  let a = class extends u.ActorHashQuads {
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      return {
        hashFunction: (n) => {
          const i = o(n.subject.value);
          return i.hash(n.predicate.value), i.hash(n.object.value), i.hash(n.graph.value), i.result();
        }
      };
    }
  };
  return Ap.ActorHashQuadsMurmur = a, Ap;
}
var sN;
function wie() {
  return sN || (sN = 1, function(u) {
    var r = ku && ku.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ku && ku.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Tie(), u);
  }(ku)), ku;
}
var Ju = {}, Op = {}, Ku = {}, xp = {}, cN;
function Sie() {
  if (cN) return xp;
  cN = 1, Object.defineProperty(xp, "__esModule", { value: !0 }), xp.ActorOptimizeQueryOperation = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query optimization failed: none of the configured actors were able to optimize} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return xp.ActorOptimizeQueryOperation = r, xp;
}
var dN;
function kn() {
  return dN || (dN = 1, function(u) {
    var r = Ku && Ku.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ku && Ku.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Sie(), u);
  }(Ku)), Ku;
}
var lN;
function Aie() {
  if (lN) return Op;
  lN = 1, Object.defineProperty(Op, "__esModule", { value: !0 }), Op.ActorOptimizeQueryOperationRewriteCopy = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i);
      return { operation: a.Util.mapOperation(n.operation, {
        [a.Algebra.types.COPY](d, l) {
          let f;
          return typeof d.destination == "string" && typeof d.source == "string" && d.destination === d.source || typeof d.destination != "string" && typeof d.source != "string" && d.destination.equals(d.source) ? f = l.createCompositeUpdate([]) : f = l.createCompositeUpdate([
            l.createDrop(d.destination, !0),
            l.createAdd(d.source, d.destination, d.silent)
          ]), {
            result: f,
            recurse: !1
          };
        }
      }, c), context: n.context };
    }
  };
  return Op.ActorOptimizeQueryOperationRewriteCopy = t, Op;
}
var fN;
function Eie() {
  return fN || (fN = 1, function(u) {
    var r = Ju && Ju.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ju && Ju.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Aie(), u);
  }(Ju)), Ju;
}
var Wu = {}, Ip = {}, hN;
function Oie() {
  if (hN) return Ip;
  hN = 1, Object.defineProperty(Ip, "__esModule", { value: !0 }), Ip.ActorOptimizeQueryOperationRewriteMove = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i);
      return { operation: a.Util.mapOperation(n.operation, {
        [a.Algebra.types.MOVE](d, l) {
          let f;
          if (typeof d.destination == "string" && typeof d.source == "string" && d.destination === d.source || typeof d.destination != "string" && typeof d.source != "string" && d.destination.equals(d.source))
            f = l.createCompositeUpdate([]);
          else {
            const h = [
              l.createDrop(d.destination, !0),
              l.createAdd(d.source, d.destination, d.silent),
              l.createDrop(d.source)
            ];
            f = l.createCompositeUpdate(h);
          }
          return {
            result: f,
            recurse: !1
          };
        }
      }, c), context: n.context };
    }
  };
  return Ip.ActorOptimizeQueryOperationRewriteMove = t, Ip;
}
var pN;
function xie() {
  return pN || (pN = 1, function(u) {
    var r = Wu && Wu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Wu && Wu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Oie(), u);
  }(Wu)), Wu;
}
var Yu = {}, Rp = {}, bN;
function Iie() {
  if (bN) return Rp;
  bN = 1, Object.defineProperty(Rp, "__esModule", { value: !0 }), Rp.ActorOptimizeQueryOperationRewriteAdd = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = Or(), t = ft(), e = new a.DataFactory();
  let n = class extends u.ActorOptimizeQueryOperation {
    constructor(c) {
      super(c);
    }
    async test(c) {
      return (0, o.passTestVoid)();
    }
    async run(c) {
      const s = c.context.getSafe(r.KeysInitQuery.dataFactory), d = new t.Factory(s);
      return { operation: t.Util.mapOperation(c.operation, {
        [t.Algebra.types.ADD](f, h) {
          const p = f.destination === "DEFAULT" ? e.defaultGraph() : f.destination, b = f.source === "DEFAULT" ? e.defaultGraph() : f.source;
          return {
            result: h.createDeleteInsert(void 0, [
              h.createPattern(e.variable("s"), e.variable("p"), e.variable("o"), p)
            ], h.createPattern(e.variable("s"), e.variable("p"), e.variable("o"), b)),
            recurse: !1
          };
        }
      }, d), context: c.context };
    }
  };
  return Rp.ActorOptimizeQueryOperationRewriteAdd = n, Rp;
}
var yN;
function Rie() {
  return yN || (yN = 1, function(u) {
    var r = Yu && Yu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Yu && Yu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Iie(), u);
  }(Yu)), Yu;
}
var Zu = {}, Fp = {}, eo = {}, en = {}, _N;
function Fie() {
  if (_N) return en;
  _N = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.estimateNpsCardinality = en.estimateJoinCardinality = en.estimateUnionCardinality = en.estimateSliceCardinality = en.estimateMinusCardinality = en.estimateCardinality = void 0;
  const u = Or(), r = ft(), o = new u.DataFactory(), a = new r.Factory(o);
  function t(d, l) {
    const f = l.getCardinality(d);
    if (f)
      return f;
    switch (d.type) {
      case r.Algebra.types.ASK:
        return { type: "exact", value: 1, dataset: l.uri };
      case r.Algebra.types.LOAD:
      case r.Algebra.types.DELETE_INSERT:
      case r.Algebra.types.ADD:
      case r.Algebra.types.COMPOSITE_UPDATE:
      case r.Algebra.types.CLEAR:
      case r.Algebra.types.NOP:
      case r.Algebra.types.DROP:
      case r.Algebra.types.CREATE:
      case r.Algebra.types.MOVE:
      case r.Algebra.types.COPY:
        return { type: "exact", value: 0, dataset: l.uri };
      case r.Algebra.types.PROJECT:
      case r.Algebra.types.FILTER:
      case r.Algebra.types.ORDER_BY:
      case r.Algebra.types.GROUP:
      case r.Algebra.types.CONSTRUCT:
      case r.Algebra.types.DISTINCT:
      case r.Algebra.types.REDUCED:
      case r.Algebra.types.EXTEND:
      case r.Algebra.types.FROM:
      case r.Algebra.types.GRAPH:
        return t(d.input, l);
      case r.Algebra.types.ZERO_OR_ONE_PATH:
      case r.Algebra.types.ZERO_OR_MORE_PATH:
      case r.Algebra.types.ONE_OR_MORE_PATH:
      case r.Algebra.types.INV:
        return t(d.path, l);
      case r.Algebra.types.PATH:
        return t(d.predicate, l);
      case r.Algebra.types.NPS:
        return s(d, l);
      case r.Algebra.types.LINK:
        return t(a.createPattern(o.variable("s"), d.iri, o.variable("o")), l);
      case r.Algebra.types.UNION:
      case r.Algebra.types.SEQ:
      case r.Algebra.types.ALT:
        return i(d.input, l);
      case r.Algebra.types.BGP:
        return c(d.patterns, l);
      case r.Algebra.types.JOIN:
      case r.Algebra.types.LEFT_JOIN:
        return c(d.input, l);
      case r.Algebra.types.SLICE:
        return n(d, l);
      case r.Algebra.types.MINUS:
        return e(d, l);
      case r.Algebra.types.VALUES:
        return { type: "exact", value: d.bindings.length, dataset: l.uri };
      case r.Algebra.types.SERVICE:
      case r.Algebra.types.DESCRIBE:
      case r.Algebra.types.EXPRESSION:
      case r.Algebra.types.PATTERN:
        return { type: "estimate", value: Number.POSITIVE_INFINITY, dataset: l.uri };
    }
  }
  en.estimateCardinality = t;
  function e(d, l) {
    const f = t(d.input[0], l), h = t(d.input[1], l);
    return {
      type: "estimate",
      value: Math.max(f.value - h.value, 0),
      dataset: l.uri
    };
  }
  en.estimateMinusCardinality = e;
  function n(d, l) {
    const f = t(d.input, l);
    return f.value > 0 && (f.value = Math.max(f.value - d.start, 0), d.length !== void 0 && (f.value = Math.min(f.value, d.length))), f;
  }
  en.estimateSliceCardinality = n;
  function i(d, l) {
    const f = { type: "exact", value: 0, dataset: l.uri };
    for (const h of d) {
      const p = t(h, l);
      p.type === "estimate" && f.type === "exact" && (f.type = p.type), p.value > 0 && (f.value += p.value);
    }
    return f;
  }
  en.estimateUnionCardinality = i;
  function c(d, l) {
    const f = [];
    for (const p of d) {
      const b = r.Util.inScopeVariables(p).map((y) => y.value), _ = f.find((y) => b.some((m) => y.vars.has(m)));
      if (_) {
        _.ops.push(p);
        for (const y of b)
          _.vars.add(y);
      } else
        f.push({ ops: [p], vars: new Set(b) });
    }
    return {
      type: "estimate",
      value: f.map((p) => Math.min(...p.ops.map((b) => t(b, l).value))).reduce((p, b) => p * b, 1),
      dataset: l.uri
    };
  }
  en.estimateJoinCardinality = c;
  function s(d, l) {
    const f = a.createSeq([...d.iris].reverse().map((_) => a.createLink(_))), h = t(f, l), p = a.createPattern(o.variable("s"), o.variable("p"), o.variable("o")), b = t(p, l);
    return {
      type: "estimate",
      value: Math.max(0, b.value - h.value),
      dataset: l.uri
    };
  }
  return en.estimateNpsCardinality = s, en;
}
var Np = {}, gN;
function Nie() {
  if (gN) return Np;
  gN = 1, Object.defineProperty(Np, "__esModule", { value: !0 }), Np.doesShapeAcceptOperation = void 0;
  function u(a, t, e) {
    return r(a, a, t, e);
  }
  Np.doesShapeAcceptOperation = u;
  function r(a, t, e, n) {
    if (t.type === "conjunction")
      return t.children.every((c) => r(a, c, e, n));
    if (t.type === "disjunction")
      return t.children.some((c) => r(a, c, e, n));
    if (t.type === "arity")
      return r(a, t.child, e, n);
    if (((n == null ? void 0 : n.joinBindings) && !t.joinBindings) ?? ((n == null ? void 0 : n.filterBindings) && !t.filterBindings))
      return !1;
    const i = t.operation;
    switch (i.operationType) {
      case "type":
        return o(a, t, e, n) ? i.type === e.type : !1;
      case "pattern":
        return o(a, t, e, n) ? i.pattern.type === e.type : !1;
      case "wildcard":
        return !0;
    }
  }
  function o(a, t, e, n) {
    return !(e.input && !(Array.isArray(e.input) ? e.input : [e.input]).every((c) => r(a, a, c, n)) || e.patterns && !e.patterns.every((i) => r(a, a, i, n)));
  }
  return Np;
}
var yr = {}, mN;
function Pie() {
  if (mN) return yr;
  mN = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.removeOperationSource = yr.assignOperationSource = yr.getOperationSource = yr.testReadOnly = yr.validateQueryOutput = yr.getSafeVoid = yr.getSafeBoolean = yr.getSafeQuads = yr.getSafeBindings = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e();
  function o(l) {
    return n(l, "bindings"), l;
  }
  yr.getSafeBindings = o;
  function a(l) {
    return n(l, "quads"), l;
  }
  yr.getSafeQuads = a;
  function t(l) {
    return n(l, "boolean"), l;
  }
  yr.getSafeBoolean = t;
  function e(l) {
    return n(l, "void"), l;
  }
  yr.getSafeVoid = e;
  function n(l, f) {
    if (l.type !== f)
      throw new Error(`Invalid query output type: Expected '${f}' but got '${l.type}'`);
  }
  yr.validateQueryOutput = n;
  function i(l) {
    return l.get(u.KeysQueryOperation.readOnly) ? (0, r.failTest)("Attempted a write operation in read-only mode") : (0, r.passTestVoid)();
  }
  yr.testReadOnly = i;
  function c(l) {
    var f;
    return (f = l.metadata) == null ? void 0 : f.scopedSource;
  }
  yr.getOperationSource = c;
  function s(l, f) {
    return l = { ...l }, l.metadata = l.metadata ? { ...l.metadata } : {}, l.metadata.scopedSource = f, l;
  }
  yr.assignOperationSource = s;
  function d(l) {
    var f;
    (f = l.metadata) == null || delete f.scopedSource, l.metadata && Object.keys(l.metadata).length === 0 && delete l.metadata;
  }
  return yr.removeOperationSource = d, yr;
}
var to = {}, vN;
function Die() {
  if (vN) return to;
  vN = 1, Object.defineProperty(to, "__esModule", { value: !0 }), to.materializeOperation = to.materializeTerm = void 0;
  const u = lr(), r = zn(), o = ft();
  function a(n, i) {
    if (n.termType === "Variable") {
      const c = i.get(n);
      if (c)
        return c;
    }
    return n.termType === "Quad" && (0, r.someTermsNested)(n, (c) => c.termType === "Variable") ? (0, r.mapTermsNested)(n, (c) => a(c, i)) : n;
  }
  to.materializeTerm = a;
  function t(n, i, c, s, d = {}) {
    return d = {
      strictTargetVariables: "strictTargetVariables" in d ? d.strictTargetVariables : !1,
      bindFilter: "bindFilter" in d ? d.bindFilter : !0,
      originalBindings: "originalBindings" in d ? d.originalBindings : i
    }, o.Util.mapOperation(n, {
      path(l, f) {
        return {
          recurse: !1,
          result: Object.assign(f.createPath(a(l.subject, i), l.predicate, a(l.object, i), a(l.graph, i)), { metadata: l.metadata })
        };
      },
      pattern(l, f) {
        return {
          recurse: !1,
          result: Object.assign(f.createPattern(a(l.subject, i), a(l.predicate, i), a(l.object, i), a(l.graph, i)), { metadata: l.metadata })
        };
      },
      join(l, f) {
        return {
          recurse: !1,
          result: f.createJoin(l.input.map((h) => t(h, i, c, s, d)), l.input.every((h) => !h.metadata))
        };
      },
      extend(l) {
        if (i.has(l.variable)) {
          if (d.strictTargetVariables)
            throw new Error(`Tried to bind variable ${(0, u.termToString)(l.variable)} in a BIND operator.`);
          return {
            recurse: !0,
            result: t(l.input, i, c, s, d)
          };
        }
        return {
          recurse: !0,
          result: l
        };
      },
      group(l, f) {
        if (d.strictTargetVariables) {
          for (const p of l.variables)
            if (i.has(p))
              throw new Error(`Tried to bind variable ${(0, u.termToString)(p)} in a GROUP BY operator.`);
          return {
            recurse: !0,
            result: l
          };
        }
        const h = l.variables.filter((p) => !i.has(p));
        return {
          recurse: !0,
          result: f.createGroup(l.input, h, l.aggregates)
        };
      },
      filter(l, f) {
        const h = d.originalBindings;
        if (l.expression.expressionType !== "operator" || h.size === 0)
          return {
            recurse: !1,
            result: l
          };
        const p = e(f, h), b = t(l.expression, i, c, s, d);
        let _ = t(l.input, i, c, s, d);
        return p.length > 0 && (_ = f.createJoin([...p, _])), {
          // Recursion already taken care of above.
          recurse: !1,
          result: f.createFilter(_, b)
        };
      },
      project(l, f) {
        const h = e(f, d.originalBindings, l.variables);
        let p = t(l.input, i, c, s, d);
        return h.length > 0 && (p = f.createJoin([...h, p])), {
          recurse: !1,
          result: f.createProject(p, l.variables)
        };
      },
      values(l, f) {
        if (d.strictTargetVariables) {
          for (const h of l.variables)
            if (i.has(h))
              throw new Error(`Tried to bind variable ${(0, u.termToString)(h)} in a VALUES operator.`);
        } else {
          const h = l.variables.filter((b) => !i.has(b)), p = l.bindings.map((b) => {
            const _ = { ...b };
            let y = !0;
            return i.forEach((m, g) => {
              const T = (0, u.termToString)(g);
              T in _ && (m.equals(_[T]) || (y = !1), delete _[T]);
            }), y ? _ : void 0;
          }).filter(Boolean);
          return {
            recurse: !0,
            result: f.createValues(h, p)
          };
        }
        return {
          recurse: !1,
          result: l
        };
      },
      expression(l, f) {
        if (!d.bindFilter)
          return {
            recurse: !1,
            result: l
          };
        if (l.expressionType === "term")
          return {
            recurse: !1,
            result: f.createTermExpression(a(l.term, i))
          };
        if (l.expressionType === "operator")
          return l.operator === "bound" && l.args.length === 1 && l.args[0].expressionType === "term" && [...i.keys()].some((h) => l.args[0].term.equals(h)) ? {
            recurse: !1,
            result: f.createTermExpression(f.dataFactory.literal("true", f.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean")))
          } : {
            recurse: !0,
            result: l
          };
        if (l.expressionType === "aggregate" && "variable" in l && i.has(l.variable)) {
          if (d.strictTargetVariables)
            throw new Error(`Tried to bind ${(0, u.termToString)(l.variable)} in a ${l.aggregator} aggregate.`);
          return {
            recurse: !0,
            result: l
          };
        }
        return {
          recurse: !0,
          result: l
        };
      }
    }, c);
  }
  to.materializeOperation = t;
  function e(n, i, c) {
    const s = [];
    for (const [d, l] of i)
      if (!c || c.some((f) => f.equals(d))) {
        const f = { [(0, u.termToString)(d)]: l };
        s.push(n.createValues([d], [f]));
      }
    return s;
  }
  return to;
}
var TN;
function vt() {
  return TN || (TN = 1, function(u) {
    var r = eo && eo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = eo && eo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Fie(), u), o(/* @__PURE__ */ Nie(), u), o(/* @__PURE__ */ Pie(), u), o(/* @__PURE__ */ Die(), u);
  }(eo)), eo;
}
var wN;
function Lie() {
  if (wN) return Fp;
  wN = 1, Object.defineProperty(Fp, "__esModule", { value: !0 }), Fp.ActorOptimizeQueryOperationGroupSources = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = ft();
  let e = class extends u.ActorOptimizeQueryOperation {
    constructor(i) {
      super(i);
    }
    async test(i) {
      return (0, a.getOperationSource)(i.operation) ? (0, o.failTest)(`Actor ${this.name} does not work with top-level operation sources.`) : (0, o.passTestVoid)();
    }
    async run(i) {
      return { operation: await this.groupOperation(i.operation, i.context), context: i.context };
    }
    /**
     * Group operations belonging to the same source together, only if that source accepts the grouped operations.
     * This grouping will be done recursively for the whole operation tree.
     * Operations annotated with sources are considered leaves in the tree.
     * @param operation An operation to group.
     * @param context The action context.
     */
    async groupOperation(i, c) {
      var p;
      const s = c.getSafe(r.KeysInitQuery.dataFactory), d = new t.Factory(s);
      if ((0, a.getOperationSource)(i) ?? !("input" in i))
        return i;
      if (!Array.isArray(i.input)) {
        const b = await this.groupOperation(i.input, c);
        if ((p = b.metadata) != null && p.scopedSource) {
          const _ = (0, a.getOperationSource)(b);
          (0, a.doesShapeAcceptOperation)(await _.source.getSelectorShape(c), i) && (this.logDebug(c, `Hoist 1 source-specific operation into a single ${i.type} operation for ${_.source.toString()}`), (0, a.removeOperationSource)(b), i = (0, a.assignOperationSource)(i, _));
        }
        return { ...i, input: b };
      }
      const l = await Promise.all(i.input.map((b) => this.groupOperation(b, c))), f = this.clusterOperationsWithEqualSources(l);
      if (f.length === 1) {
        const b = f[0], _ = (0, a.getOperationSource)(f[0][0]);
        return {
          ...await this.moveSourceAnnotationUpwardsIfPossible(i, b, _, c),
          input: b
        };
      }
      if (f.length === l.length)
        return { ...i, input: l };
      let h;
      switch (i.type) {
        case t.Algebra.types.JOIN:
          h = d.createJoin.bind(d);
          break;
        case t.Algebra.types.UNION:
          h = d.createUnion.bind(d);
          break;
        case t.Algebra.types.ALT:
          h = d.createAlt.bind(d);
          break;
        case t.Algebra.types.SEQ:
          h = d.createSeq.bind(d);
          break;
        default:
          throw new Error(`Unsupported operation '${i.type}' detected while grouping sources`);
      }
      return await this.groupOperationMulti(f, h, c);
    }
    async groupOperationMulti(i, c, s) {
      let d = !0;
      const l = await Promise.all(i.map(async (f) => {
        const h = (0, a.getOperationSource)(f[0]), p = await this.moveSourceAnnotationUpwardsIfPossible(c(f, !0), f, h, s);
        return (0, a.getOperationSource)(p) && (d = !1), p;
      }));
      return c(l, d);
    }
    /**
     * Cluster the given operations by equal source annotations.
     * @param operationsIn An array of operations to cluster.
     */
    clusterOperationsWithEqualSources(i) {
      const c = /* @__PURE__ */ new Map(), s = [];
      for (const l of i) {
        const f = (0, a.getOperationSource)(l);
        f ? (c.has(f) || c.set(f, []), c.get(f).push(l)) : s.push(l);
      }
      const d = [];
      s.length > 0 && d.push(s);
      for (const [l, f] of c.entries())
        d.push(f.map((h) => (0, a.assignOperationSource)(h, l)));
      return d;
    }
    /**
     * If the given source accepts the grouped operation, annotate the grouped operation with the source,
     * and remove the source annotation from the seperate input operations.
     * Otherwise, return the grouped operation unchanged.
     * @param operation A grouped operation consisting of all given input operations.
     * @param inputs An array of operations that share the same source annotation.
     * @param source The common source.
     * @param context The action context.
     */
    async moveSourceAnnotationUpwardsIfPossible(i, c, s, d) {
      if (s && (0, a.doesShapeAcceptOperation)(await s.source.getSelectorShape(d), i)) {
        this.logDebug(d, `Hoist ${c.length} source-specific operations into a single ${i.type} operation for ${s.source.toString()}`), i = (0, a.assignOperationSource)(i, s);
        for (const l of c)
          (0, a.removeOperationSource)(l);
      }
      return i;
    }
  };
  return Fp.ActorOptimizeQueryOperationGroupSources = e, Fp;
}
var SN;
function jie() {
  return SN || (SN = 1, function(u) {
    var r = Zu && Zu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zu && Zu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Lie(), u);
  }(Zu)), Zu;
}
var ro = {}, Pp = {}, AN;
function Mie() {
  if (AN) return Pp;
  AN = 1, Object.defineProperty(Pp, "__esModule", { value: !0 }), Pp.ActorOptimizeQueryOperationConstructDistinct = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ PK(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return n.context.has(r.KeysInitQuery.distinctConstruct) ? (0, o.passTestVoid)() : (0, o.failTest)(`${this.name} was not enabled by the query.`);
    }
    async run(n) {
      return { operation: a.Util.mapOperation(n.operation, {
        construct(c, s) {
          return {
            recurse: !1,
            result: s.createDistinct(s.createConstruct(c.input, c.template))
          };
        }
      }), context: n.context.delete(r.KeysInitQuery.distinctConstruct) };
    }
  };
  return Pp.ActorOptimizeQueryOperationConstructDistinct = t, Pp;
}
var EN;
function Cie() {
  return EN || (EN = 1, function(u) {
    var r = ro && ro.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ro && ro.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Mie(), u);
  }(ro)), ro;
}
var no = {}, Dp = {}, io = {}, Lp = {}, ON;
function qie() {
  if (ON) return Lp;
  ON = 1, Object.defineProperty(Lp, "__esModule", { value: !0 }), Lp.ActorQueryParse = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query parsing failed: none of the configured parsers were able to the query "${action.query}"} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Lp.ActorQueryParse = r, Lp;
}
var xN;
function nW() {
  return xN || (xN = 1, function(u) {
    var r = io && io.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = io && io.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qie(), u);
  }(io)), io;
}
var IN;
function Bie() {
  if (IN) return Dp;
  IN = 1, Object.defineProperty(Dp, "__esModule", { value: !0 }), Dp.ActorQueryParseSparql = void 0;
  const u = /* @__PURE__ */ nW(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft(), t = _w();
  let e = class extends u.ActorQueryParse {
    constructor(i) {
      super(i), this.prefixes = Object.freeze(this.prefixes);
    }
    async test(i) {
      return i.queryFormat && i.queryFormat.language !== "sparql" ? (0, o.failTest)("This actor can only parse SPARQL queries") : (0, o.passTestVoid)();
    }
    async run(i) {
      const c = i.context.getSafe(r.KeysInitQuery.dataFactory), d = new t.Parser({
        prefixes: this.prefixes,
        baseIRI: i.baseIRI,
        sparqlStar: !0,
        factory: c
      }).parse(i.query);
      return {
        baseIRI: d.type === "query" ? d.base : void 0,
        operation: (0, a.translate)(d, {
          quads: !0,
          prefixes: this.prefixes,
          blankToVariable: !0,
          baseIRI: i.baseIRI,
          dataFactory: c
        })
      };
    }
  };
  return Dp.ActorQueryParseSparql = e, Dp;
}
var RN;
function $ie() {
  return RN || (RN = 1, function(u) {
    var r = no && no.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = no && no.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Bie(), u);
  }(no)), no;
}
var ao = {}, jp = {}, uo = {}, oo = {}, so = {}, Mp = {}, FN;
function hh() {
  if (FN) return Mp;
  FN = 1, Object.defineProperty(Mp, "__esModule", { value: !0 }), Mp.DirectiveNodeHandlerAdapter = void 0;
  let u = class {
    constructor(o, a, t) {
      this.targetKind = o, this.util = a, this.settings = t;
    }
    /**
     * Get the value of the 'if' argument in a directive.
     * @param {DirectiveNode} directive A directive.
     * @param {IConvertContext} convertContext A convert context.
     * @return {Term} The term.
     */
    getDirectiveConditionalValue(o, a) {
      const t = this.util.getArgument(o.arguments, "if");
      if (!t)
        throw new Error(`The directive ${o.name.value} is missing an if-argument.`);
      const e = this.util.handleNodeValue(t.value, t.name.value, a);
      if (e.terms.length !== 1)
        throw new Error(`Can not apply the directive ${o.name.value} with a list.`);
      return e.terms[0];
    }
    /**
     * If a `scope: all` directive param is present.
     * @param {DirectiveNode} directive A directive.
     * @return {boolean} If `scope: all` is present.
     */
    isDirectiveScopeAll(o) {
      const a = this.util.getArgument(o.arguments, "scope");
      return a && a.value.kind === "EnumValue" && a.value.value === "all";
    }
  };
  return Mp.DirectiveNodeHandlerAdapter = u, Mp;
}
var Cp = {}, NN;
function Uie() {
  if (NN) return Cp;
  NN = 1, Object.defineProperty(Cp, "__esModule", { value: !0 }), Cp.DirectiveNodeHandlerInclude = void 0;
  const u = hh();
  let r = class extends u.DirectiveNodeHandlerAdapter {
    constructor(a, t) {
      super("include", a, t);
    }
    handle(a, t) {
      const e = this.getDirectiveConditionalValue(a.directive, t);
      return e.termType === "Literal" && e.value === "false" ? { ignore: !0 } : {};
    }
  };
  return Cp.DirectiveNodeHandlerInclude = r, Cp;
}
var qp = {}, PN;
function Vie() {
  if (PN) return qp;
  PN = 1, Object.defineProperty(qp, "__esModule", { value: !0 }), qp.DirectiveNodeHandlerOptional = void 0;
  const u = hh();
  let r = class extends u.DirectiveNodeHandlerAdapter {
    constructor(a, t) {
      super("optional", a, t);
    }
    handle(a, t) {
      return {
        operationOverrider: (e) => this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), e)
      };
    }
  };
  return qp.DirectiveNodeHandlerOptional = r, qp;
}
var Bp = {}, LA = {}, DN;
function Sw() {
  return DN || (DN = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.SingularizeState = void 0, function(r) {
      r[r.SINGLE = 0] = "SINGLE", r[r.PLURAL = 1] = "PLURAL";
    }(u.SingularizeState || (u.SingularizeState = {}));
  }(LA)), LA;
}
var LN;
function Qie() {
  if (LN) return Bp;
  LN = 1, Object.defineProperty(Bp, "__esModule", { value: !0 }), Bp.DirectiveNodeHandlerPlural = void 0;
  const u = Sw(), r = hh();
  let o = class extends r.DirectiveNodeHandlerAdapter {
    constructor(t, e) {
      super("plural", t, e);
    }
    handle(t, e) {
      return this.isDirectiveScopeAll(t.directive) && (e.singularizeState = u.SingularizeState.PLURAL), delete e.singularizeVariables[this.util.nameToVariable(t.fieldLabel, e).value], {};
    }
  };
  return Bp.DirectiveNodeHandlerPlural = o, Bp;
}
var $p = {}, jN;
function Hie() {
  if (jN) return $p;
  jN = 1, Object.defineProperty($p, "__esModule", { value: !0 }), $p.DirectiveNodeHandlerSingle = void 0;
  const u = Sw(), r = hh();
  let o = class extends r.DirectiveNodeHandlerAdapter {
    constructor(t, e) {
      super("single", t, e);
    }
    handle(t, e) {
      return this.isDirectiveScopeAll(t.directive) && (e.singularizeState = u.SingularizeState.SINGLE), e.singularizeVariables[this.util.nameToVariable(t.fieldLabel, e).value] = !0, {};
    }
  };
  return $p.DirectiveNodeHandlerSingle = o, $p;
}
var Up = {}, MN;
function Gie() {
  if (MN) return Up;
  MN = 1, Object.defineProperty(Up, "__esModule", { value: !0 }), Up.DirectiveNodeHandlerSkip = void 0;
  const u = hh();
  let r = class extends u.DirectiveNodeHandlerAdapter {
    constructor(a, t) {
      super("skip", a, t);
    }
    handle(a, t) {
      const e = this.getDirectiveConditionalValue(a.directive, t);
      return e.termType === "Literal" && e.value === "true" ? { ignore: !0 } : {};
    }
  };
  return Up.DirectiveNodeHandlerSkip = r, Up;
}
var CN;
function iW() {
  return CN || (CN = 1, function(u) {
    var r = so && so.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = so && so.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(hh(), u), o(Uie(), u), o(Vie(), u), o(Qie(), u), o(Hie(), u), o(Gie(), u);
  }(so)), so;
}
var co = {}, Vp = {}, qN;
function Mi() {
  if (qN) return Vp;
  qN = 1, Object.defineProperty(Vp, "__esModule", { value: !0 }), Vp.NodeValueHandlerAdapter = void 0;
  let u = class {
    constructor(o, a, t) {
      this.targetKind = o, this.util = a, this.settings = t;
    }
  };
  return Vp.NodeValueHandlerAdapter = u, Vp;
}
var Qp = {}, BN;
function zie() {
  if (BN) return Qp;
  BN = 1, Object.defineProperty(Qp, "__esModule", { value: !0 }), Qp.NodeValueHandlerBoolean = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("BooleanValue", a, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean");
    }
    handle(a, t, e) {
      return { terms: [this.util.dataFactory.literal(a.value ? "true" : "false", this.datatype)] };
    }
  };
  return Qp.NodeValueHandlerBoolean = r, Qp;
}
var Hp = {}, $N;
function kie() {
  if ($N) return Hp;
  $N = 1, Object.defineProperty(Hp, "__esModule", { value: !0 }), Hp.NodeValueHandlerEnum = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("EnumValue", a, t);
    }
    handle(a, t, e) {
      return { terms: [this.util.valueToNamedNode(a.value, e.context)] };
    }
  };
  return Hp.NodeValueHandlerEnum = r, Hp;
}
var Gp = {}, UN;
function Xie() {
  if (UN) return Gp;
  UN = 1, Object.defineProperty(Gp, "__esModule", { value: !0 }), Gp.NodeValueHandlerFloat = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("FloatValue", a, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#float");
    }
    handle(a, t, e) {
      return { terms: [this.util.dataFactory.literal(a.value, this.datatype)] };
    }
  };
  return Gp.NodeValueHandlerFloat = r, Gp;
}
var zp = {}, VN;
function Jie() {
  if (VN) return zp;
  VN = 1, Object.defineProperty(zp, "__esModule", { value: !0 }), zp.NodeValueHandlerInt = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("IntValue", a, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#integer");
    }
    handle(a, t, e) {
      return { terms: [this.util.dataFactory.literal(a.value, this.datatype)] };
    }
  };
  return zp.NodeValueHandlerInt = r, zp;
}
var kp = {}, QN;
function Kie() {
  if (QN) return kp;
  QN = 1, Object.defineProperty(kp, "__esModule", { value: !0 }), kp.NodeValueHandlerList = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("ListValue", a, t), this.nodeFirst = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), this.nodeRest = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), this.nodeNil = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil");
    }
    handle(a, t, e) {
      const n = [];
      let i = [];
      for (const c of a.values) {
        const s = this.util.handleNodeValue(c, t, e);
        for (const d of s.terms)
          n.push(d);
        s.auxiliaryPatterns && (i = i.concat(s.auxiliaryPatterns));
      }
      if (this.settings.arraysToRdfLists) {
        const c = this.util.dataFactory.blankNode();
        let s = c, d = n.length;
        for (const l of n) {
          i.push(this.util.operationFactory.createPattern(s, this.nodeFirst, l, e.graph));
          const f = --d === 0 ? this.nodeNil : this.util.dataFactory.blankNode();
          i.push(this.util.operationFactory.createPattern(s, this.nodeRest, f, e.graph)), s = f;
        }
        return { terms: [c], auxiliaryPatterns: i };
      } else
        return { terms: n, auxiliaryPatterns: i };
    }
  };
  return kp.NodeValueHandlerList = r, kp;
}
var Xp = {}, HN;
function Wie() {
  if (HN) return Xp;
  HN = 1, Object.defineProperty(Xp, "__esModule", { value: !0 }), Xp.NodeValueHandlerNull = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("NullValue", a, t), this.nil = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil");
    }
    handle(a, t, e) {
      return { terms: [this.nil] };
    }
  };
  return Xp.NodeValueHandlerNull = r, Xp;
}
var Jp = {}, GN;
function Yie() {
  if (GN) return Jp;
  GN = 1, Object.defineProperty(Jp, "__esModule", { value: !0 }), Jp.NodeValueHandlerObject = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("ObjectValue", a, t);
    }
    handle(a, t, e) {
      const n = this.util.dataFactory.blankNode();
      let i = [];
      for (const c of a.fields) {
        const s = this.util.handleNodeValue(c.value, t, e);
        for (const d of s.terms)
          i.push(this.util.createQuadPattern(n, c.name, d, e.graph, e.context));
        s.auxiliaryPatterns && (i = i.concat(s.auxiliaryPatterns));
      }
      return { terms: [n], auxiliaryPatterns: i };
    }
  };
  return Jp.NodeValueHandlerObject = r, Jp;
}
var Kp = {}, zN;
function Zie() {
  if (zN) return Kp;
  zN = 1, Object.defineProperty(Kp, "__esModule", { value: !0 }), Kp.NodeValueHandlerString = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("StringValue", a, t);
    }
    handle(a, t, e) {
      const n = e.context.getContextRaw()[t];
      let i, c;
      return n && typeof n != "string" && (n["@language"] ? i = n["@language"] : n["@type"] && (c = this.util.dataFactory.namedNode(n["@type"]))), { terms: [this.util.dataFactory.literal(a.value, i || c)] };
    }
  };
  return Kp.NodeValueHandlerString = r, Kp;
}
var Wp = {}, kN;
function eae() {
  if (kN) return Wp;
  kN = 1, Object.defineProperty(Wp, "__esModule", { value: !0 }), Wp.NodeValueHandlerVariable = void 0;
  const u = Mi();
  let r = class extends u.NodeValueHandlerAdapter {
    constructor(a, t) {
      super("Variable", a, t);
    }
    handle(a, t, e) {
      const n = a.name.value, i = e.variablesDict[n], c = e.variablesMetaDict[n];
      if (!i) {
        if (!e.ignoreUnknownVariables && (!c || c.mandatory))
          throw new Error(`Undefined variable: ${n}`);
        {
          const s = this.util.dataFactory.variable(n);
          return e.terminalVariables.map((d) => d.value).indexOf(n) < 0 && e.terminalVariables.push(s), { terms: [s] };
        }
      }
      if (i.kind === "Variable")
        throw new Error(`Variable refers to another variable: ${n}`);
      if (c)
        if (c.list) {
          if (i.kind !== "ListValue")
            throw new Error(`Expected a list, but got ${i.kind} for ${n}`);
          if (c.type) {
            const s = i;
            for (const d of s.values)
              if (d.kind !== c.type)
                throw new Error(`Expected ${c.type}, but got ${d.kind} for ${n}`);
          }
        } else c.type;
      return this.util.handleNodeValue(i, t, e);
    }
  };
  return Wp.NodeValueHandlerVariable = r, Wp;
}
var XN;
function tae() {
  return XN || (XN = 1, function(u) {
    var r = co && co.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = co && co.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(Mi(), u), o(zie(), u), o(kie(), u), o(Xie(), u), o(Jie(), u), o(Kie(), u), o(Wie(), u), o(Yie(), u), o(Zie(), u), o(eae(), u);
  }(co)), co;
}
var Yp = {}, JN;
function XS() {
  if (JN) return Yp;
  JN = 1, Object.defineProperty(Yp, "__esModule", { value: !0 }), Yp.NodeHandlerAdapter = void 0;
  let u = class {
    constructor(o, a, t) {
      this.targetKind = o, this.util = a, this.settings = t;
    }
    /* ----- Node quad context ----- */
    /**
     * Get the quad context of a selection set node that should be used for the whole definition node.
     *
     * This is a pre-processing step of selection sets.
     * Its only purpose is to determine the subject within a selection set,
     * because this subject is needed to link with its parent.
     * In a later phase, the selection set will be processed using the discovered subject,
     * and the field identifying the subject will be ignored.
     *
     * @param {SelectionSetNode} selectionSet A selection set node.
     * @param {string} fieldLabel A field label.
     * @param {IConvertContext} convertContext A convert context.
     * @return {INodeQuadContext} The subject, graph and auxiliary patterns.
     */
    getNodeQuadContextSelectionSet(o, a, t) {
      const e = {};
      if (o) {
        for (const n of o.selections)
          if (n.kind === "Field") {
            const i = n;
            this.handleNodeQuadContextField(i, t, e, "id", "subject"), this.handleNodeQuadContextField(i, t, e, "graph", "graph");
          }
      }
      return e;
    }
    /**
     * Handles a single field for determining the node quad context.
     * @param {FieldNode} fieldNode A field node.
     * @param {IConvertContext} convertContext A convert context.
     * @param {INodeQuadContext} nodeQuadContext The node quad context to populate.
     * @param {string} fieldName The field name to check for.
     * @param {'subject' | 'graph'} nodeQuadContextKey The key to fill into the node quad context.
     */
    handleNodeQuadContextField(o, a, t, e, n) {
      if (!t[n] && o.name.value === e) {
        if (!t[n]) {
          const i = this.util.getArgument(o.arguments, "_");
          if (i) {
            const c = this.util.handleNodeValue(i.value, o.name.value, a);
            if (c.terms.length !== 1)
              throw new Error(`Only single values can be set as ${e}, but got ${c.terms.length} at ${o.name.value}`);
            t[n] = c.terms[0], c.auxiliaryPatterns && (t.auxiliaryPatterns || (t.auxiliaryPatterns = []), t.auxiliaryPatterns.concat(c.auxiliaryPatterns));
          }
        }
        if (!t[n]) {
          const i = this.util.nameToVariable(this.util.getFieldLabel(o), a);
          a.terminalVariables.push(i), t[n] = i;
        }
      }
    }
    /* ----- Directives ----- */
    /**
     * Get an operation override defined by one of the directives.
     *
     * This should be called before a sub-operation is handled.
     *
     * @param {ReadonlyArray<DirectiveNode>} directives An option directives array.
     * @param {string} fieldLabel The current field label.
     * @param {IConvertContext} convertContext A convert context.
     * @return {IDirectiveNodeHandlerOutput[]} The directive node handler outputs, or null if it should be ignored.
     */
    getDirectiveOutputs(o, a, t) {
      const e = [];
      if (o)
        for (const n of o) {
          const i = this.util.handleDirectiveNode({ directive: n, fieldLabel: a }, t);
          if (i) {
            if (i.ignore)
              return null;
            e.push(i);
          }
        }
      return e;
    }
    /**
     * Handle the directive outputs with respect to an operation.
     *
     * This should be called after a sub-operation was handled.
     *
     * @param {IDirectiveNodeHandlerOutput[]} directiveOutputs
     * @param {Operation} operation
     * @return {Operation}
     */
    handleDirectiveOutputs(o, a) {
      for (const t of o) {
        if (t.ignore)
          return this.util.operationFactory.createBgp([]);
        t.operationOverrider && (a = t.operationOverrider(a));
      }
      return a;
    }
  };
  return Yp.NodeHandlerAdapter = u, Yp;
}
var Zp = {}, KN;
function v8() {
  if (KN) return Zp;
  KN = 1, Object.defineProperty(Zp, "__esModule", { value: !0 }), Zp.NodeHandlerDefinitionAdapter = void 0;
  const u = XS();
  let r = class extends u.NodeHandlerAdapter {
    constructor(a, t, e) {
      super(a, t, e);
    }
  };
  return Zp.NodeHandlerDefinitionAdapter = r, Zp;
}
var e1 = {}, WN;
function rae() {
  if (WN) return e1;
  WN = 1, Object.defineProperty(e1, "__esModule", { value: !0 }), e1.NodeHandlerDefinitionFragment = void 0;
  const u = v8();
  let r = class extends u.NodeHandlerDefinitionAdapter {
    constructor(a, t) {
      super("FragmentDefinition", a, t);
    }
    handle(a, t) {
      throw new Error("Illegal state: fragment definitions must be indexed and removed before processing");
    }
  };
  return e1.NodeHandlerDefinitionFragment = r, e1;
}
var t1 = {}, YN;
function nae() {
  if (YN) return t1;
  YN = 1, Object.defineProperty(t1, "__esModule", { value: !0 }), t1.NodeHandlerDefinitionOperation = void 0;
  const u = v8();
  let r = class extends u.NodeHandlerDefinitionAdapter {
    constructor(a, t) {
      super("OperationDefinition", a, t);
    }
    handle(a, t) {
      if (a.operation !== "query")
        throw new Error("Unsupported definition operation: " + a.operation);
      if (a.variableDefinitions)
        for (const i of a.variableDefinitions) {
          const c = i.variable.name.value;
          i.defaultValue && (t.variablesDict[c] || (t.variablesDict[c] = i.defaultValue));
          let s = i.type;
          const d = s.kind === "NonNullType";
          d && (s = s.type);
          const l = s.kind === "ListType";
          l && (s = s.type);
          const f = s.name.value;
          t.variablesMetaDict[c] = { mandatory: d, list: l, type: f };
        }
      const e = this.getDirectiveOutputs(a.directives, a.name ? a.name.value : "", t);
      if (!e)
        return this.util.operationFactory.createBgp([]);
      const n = this.util.joinOperations(a.selectionSet.selections.map((i) => this.util.handleNode(i, t)));
      return this.handleDirectiveOutputs(e, n);
    }
  };
  return t1.NodeHandlerDefinitionOperation = r, t1;
}
var r1 = {}, ZN;
function iae() {
  if (ZN) return r1;
  ZN = 1, Object.defineProperty(r1, "__esModule", { value: !0 }), r1.NodeHandlerDocument = void 0;
  const u = ft(), r = XS();
  let o = class extends r.NodeHandlerAdapter {
    constructor(t, e) {
      super("Document", t, e);
    }
    handle(t, e) {
      const n = t.definitions.map((c) => {
        const s = this.getNodeQuadContextDefinitionNode(c, Object.assign(Object.assign({}, e), { ignoreUnknownVariables: !0 })), d = Object.assign(Object.assign({}, e), { graph: s.graph || e.graph, subject: s.subject || this.util.dataFactory.blankNode() });
        let l = this.util.handleNode(c, d);
        return s && s.auxiliaryPatterns && (l = this.util.joinOperations([
          l,
          this.util.operationFactory.createBgp(s.auxiliaryPatterns)
        ])), l;
      }), i = this.util.operationFactory.createProject(n.length === 1 ? n[0] : this.util.operationFactory.createUnion(n), e.terminalVariables);
      return this.translateBlankNodesToVariables(i);
    }
    /**
     * Get the quad context of a definition node that should be used for the whole definition node.
     * @param {DefinitionNode} definition A definition node.
     * @param {IConvertContext} convertContext A convert context.
     * @return {INodeQuadContext} The subject and optional auxiliary patterns.
     */
    getNodeQuadContextDefinitionNode(t, e) {
      if (t.kind === "OperationDefinition")
        return this.getNodeQuadContextSelectionSet(t.selectionSet, t.name ? t.name.value : "", e);
      throw new Error(`Unsupported definition: ${t.kind}`);
    }
    /**
     * Translates blank nodes inside the query to variables.
     * @param {Project} operation The operation to translate.
     * @return {Operation} The transformed operation.
     */
    translateBlankNodesToVariables(t) {
      const e = this, n = {}, i = Array.from(t.variables).reduce((s, d) => (s[d.value] = !0, s), {});
      return u.Util.mapOperation(t, {
        path: (s, d) => ({
          recurse: !1,
          result: d.createPath(c(s.subject), s.predicate, c(s.object), c(s.graph))
        }),
        pattern: (s, d) => ({
          recurse: !1,
          result: d.createPattern(c(s.subject), c(s.predicate), c(s.object), c(s.graph))
        })
      });
      function c(s) {
        if (s.termType === "BlankNode") {
          let d = n[s.value];
          return d || (d = u.Util.createUniqueVariable(s.value, i, e.util.dataFactory), i[d.value] = !0, n[s.value] = d), d;
        }
        return s;
      }
    }
  };
  return r1.NodeHandlerDocument = o, r1;
}
var n1 = {}, eP;
function JS() {
  if (eP) return n1;
  eP = 1, Object.defineProperty(n1, "__esModule", { value: !0 }), n1.NodeHandlerSelectionAdapter = void 0;
  const u = ft(), r = Sw(), o = XS();
  let a = class extends o.NodeHandlerAdapter {
    constructor(e, n, i) {
      super(e, n, i);
    }
    /**
     * Get the quad context of a field node that should be used for the whole definition node.
     * @param {FieldNode} field A field node.
     * @param {string} fieldLabel A field label.
     * @param {IConvertContext} convertContext A convert context.
     * @return {INodeQuadContext} The subject and optional auxiliary patterns.
     */
    getNodeQuadContextFieldNode(e, n, i) {
      return this.getNodeQuadContextSelectionSet(e.selectionSet, n, Object.assign(Object.assign({}, i), { path: this.util.appendFieldToPath(i.path, n) }));
    }
    /**
     * Convert a field node to an operation.
     * @param {IConvertContext} convertContext A convert context.
     * @param {FieldNode} fieldNode The field node to convert.
     * @param {boolean} pushTerminalVariables If terminal variables should be created.
     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.
     * @return {Operation} The reslting operation.
     */
    fieldToOperation(e, n, i, c) {
      const s = i;
      let d = 0, l;
      if ((n.name.value === "id" || n.name.value === "graph") && (i = !1, n.arguments))
        for (const v of n.arguments)
          v.name.value === "_" && this.util.handleNodeValue(v.value, n.name.value, e);
      const f = this.util.getFieldLabel(n);
      if (e.singularizeState === r.SingularizeState.SINGLE && (e.singularizeVariables[this.util.nameToVariable(f, e).value] = !0), i) {
        const v = this.handleMetaField(e, f, c);
        if (v)
          return v;
      }
      const h = c ? [this.util.operationFactory.createBgp(c)] : [], p = this.getNodeQuadContextFieldNode(n, f, e);
      let b = p.subject || this.util.nameToVariable(f, e), _ = p.graph || e.graph;
      p.auxiliaryPatterns && h.push(this.util.operationFactory.createBgp(p.auxiliaryPatterns));
      let y = !0, m = null;
      if (i && n.arguments && n.arguments.length) {
        for (const v of n.arguments)
          if (v.name.value === "_") {
            const E = this.util.handleNodeValue(v.value, n.name.value, e);
            m = E.terms, h.push(this.util.operationFactory.createBgp(E.terms.map((R) => this.util.createQuadPattern(e.subject, n.name, R, e.graph, e.context)))), E.auxiliaryPatterns && h.push(this.util.operationFactory.createBgp(E.auxiliaryPatterns)), i = !1;
            break;
          } else if (v.name.value === "graph") {
            const E = this.util.handleNodeValue(v.value, n.name.value, e);
            if (E.terms.length !== 1)
              throw new Error(`Only single values can be set as graph, but got ${E.terms.length} at ${n.name.value}`);
            _ = E.terms[0], e = Object.assign(Object.assign({}, e), { graph: _ }), E.auxiliaryPatterns && h.push(this.util.operationFactory.createBgp(E.auxiliaryPatterns));
            break;
          } else if (v.name.value === "alt") {
            let E = v.value;
            E.kind !== "ListValue" && (E = { kind: "ListValue", values: [E] }), h.push(this.util.createQuadPath(e.subject, n.name, E, b, e.graph, e.context)), y = !1;
            break;
          }
      }
      if (i && y && h.push(this.util.operationFactory.createBgp([
        this.util.createQuadPattern(e.subject, n.name, b, e.graph, e.context)
      ])), n.arguments && n.arguments.length) {
        for (const v of n.arguments)
          if (!(v.name.value === "_" || v.name.value === "graph" || v.name.value === "alt")) if (v.name.value === "first") {
            if (v.value.kind !== "IntValue")
              throw new Error("Invalid value type for 'first' argument: " + v.value.kind);
            l = parseInt(v.value.value, 10);
          } else if (v.name.value === "offset") {
            if (v.value.kind !== "IntValue")
              throw new Error("Invalid value type for 'offset' argument: " + v.value.kind);
            d = parseInt(v.value.value, 10);
          } else {
            const E = this.util.handleNodeValue(v.value, v.name.value, e);
            h.push(this.util.operationFactory.createBgp(E.terms.map((R) => this.util.createQuadPattern(b, v.name, R, e.graph, e.context)))), E.auxiliaryPatterns && h.push(this.util.operationFactory.createBgp(E.auxiliaryPatterns));
          }
      }
      const g = this.getDirectiveOutputs(n.directives, f, e);
      if (!g)
        return this.util.operationFactory.createBgp([]);
      let T = this.util.joinOperations(h);
      if (n.selectionSet && n.selectionSet.selections.length) {
        if (m) {
          if (m.length !== 1)
            throw new Error(`Only single values can be set as id, but got ${m.length} at ${n.name.value}`);
          b = m[0];
        }
        const v = Object.assign(Object.assign(Object.assign({}, e), s ? { path: this.util.appendFieldToPath(e.path, f) } : {}), { graph: _, subject: s ? b : e.subject });
        let E = !1;
        const R = n.selectionSet.selections.filter((A) => A.kind === "Field" && A.name.value === "totalCount" ? (E = !0, !1) : !0);
        let L = this.util.joinOperations(h.concat(R.map((A) => this.util.handleNode(A, v))));
        if (E) {
          const A = this.util.dataFactory.variable("var" + this.settings.expressionVariableCounter++), w = this.util.dataFactory.variable(b.value + this.settings.variableDelimiter + "totalCount"), S = this.util.operationFactory.createBoundAggregate(A, "count", this.util.operationFactory.createTermExpression(b), !1), O = this.util.operationFactory.createProject(this.util.operationFactory.createExtend(this.util.operationFactory.createGroup(T, [], [S]), w, this.util.operationFactory.createTermExpression(A)), [w]);
          e.terminalVariables.push(w), R.length ? L = this.util.operationFactory.createJoin([
            this.util.operationFactory.createProject(L, []),
            O
          ]) : L = O;
        }
        T = L;
      } else i && b.termType === "Variable" && e.terminalVariables.push(b);
      return (d || l) && (T = this.util.operationFactory.createSlice(this.util.operationFactory.createProject(T, u.Util.inScopeVariables(T)), d, l)), this.handleDirectiveOutputs(g, T);
    }
    /**
     * Check if the given node is a meta field, for things like introspection.
     * If so, return a new operation for this, otherwise, null is returned.
     * @param {IConvertContext} convertContext A convert context.
     * @param {Term} subject The subject.
     * @param {string} fieldLabel The field label to convert.
     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.
     * @return {Operation} An operation or undefined.
     */
    handleMetaField(e, n, i) {
      if (n === "__typename") {
        const c = this.util.nameToVariable(n, e);
        return e.terminalVariables.push(c), this.util.operationFactory.createBgp([
          this.util.operationFactory.createPattern(e.subject, this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), this.util.nameToVariable(n, e), e.graph)
        ].concat(i || []));
      }
    }
  };
  return n1.NodeHandlerSelectionAdapter = a, n1;
}
var i1 = {}, tP;
function aae() {
  if (tP) return i1;
  tP = 1, Object.defineProperty(i1, "__esModule", { value: !0 }), i1.NodeHandlerSelectionField = void 0;
  const u = JS();
  let r = class extends u.NodeHandlerSelectionAdapter {
    constructor(a, t) {
      super("Field", a, t);
    }
    handle(a, t) {
      return this.fieldToOperation(t, a, !0);
    }
  };
  return i1.NodeHandlerSelectionField = r, i1;
}
var a1 = {}, rP;
function uae() {
  if (rP) return a1;
  rP = 1, Object.defineProperty(a1, "__esModule", { value: !0 }), a1.NodeHandlerSelectionFragmentSpread = void 0;
  const u = JS();
  let r = class extends u.NodeHandlerSelectionAdapter {
    constructor(a, t) {
      super("FragmentSpread", a, t);
    }
    handle(a, t) {
      const e = t.fragmentDefinitions[a.name.value];
      if (!e)
        throw new Error("Undefined fragment definition: " + a.name.value);
      const n = {
        alias: void 0,
        arguments: void 0,
        directives: e.directives,
        kind: "Field",
        name: a.name,
        selectionSet: e.selectionSet
      }, i = [
        this.util.newTypePattern(t.subject, e.typeCondition, t)
      ];
      return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(t, n, !1, i));
    }
  };
  return a1.NodeHandlerSelectionFragmentSpread = r, a1;
}
var u1 = {}, nP;
function oae() {
  if (nP) return u1;
  nP = 1, Object.defineProperty(u1, "__esModule", { value: !0 }), u1.NodeHandlerSelectionInlineFragment = void 0;
  const u = JS();
  let r = class extends u.NodeHandlerSelectionAdapter {
    constructor(a, t) {
      super("InlineFragment", a, t);
    }
    handle(a, t) {
      const e = {
        alias: void 0,
        arguments: void 0,
        directives: a.directives,
        kind: "Field",
        name: { kind: "Name", value: t.subject.value },
        selectionSet: a.selectionSet
      }, n = a.typeCondition ? [this.util.newTypePattern(t.subject, a.typeCondition, t)] : [];
      return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(t, e, !1, n));
    }
  };
  return u1.NodeHandlerSelectionInlineFragment = r, u1;
}
var iP;
function aW() {
  return iP || (iP = 1, function(u) {
    var r = oo && oo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = oo && oo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(iW(), u), o(tae(), u), o(XS(), u), o(v8(), u), o(rae(), u), o(nae(), u), o(iae(), u), o(JS(), u), o(aae(), u), o(uae(), u), o(oae(), u);
  }(oo)), oo;
}
var lo = {}, uW = typeof Symbol == "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag", ux = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
function eS(u) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? eS = function(o) {
    return typeof o;
  } : eS = function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, eS(u);
}
var sae = 10, oW = 2;
function sW(u) {
  return KS(u, []);
}
function KS(u, r) {
  switch (eS(u)) {
    case "string":
      return JSON.stringify(u);
    case "function":
      return u.name ? "[function ".concat(u.name, "]") : "[function]";
    case "object":
      return u === null ? "null" : cae(u, r);
    default:
      return String(u);
  }
}
function cae(u, r) {
  if (r.indexOf(u) !== -1)
    return "[Circular]";
  var o = [].concat(r, [u]), a = fae(u);
  if (a !== void 0) {
    var t = a.call(u);
    if (t !== u)
      return typeof t == "string" ? t : KS(t, o);
  } else if (Array.isArray(u))
    return lae(u, o);
  return dae(u, o);
}
function dae(u, r) {
  var o = Object.keys(u);
  if (o.length === 0)
    return "{}";
  if (r.length > oW)
    return "[" + hae(u) + "]";
  var a = o.map(function(t) {
    var e = KS(u[t], r);
    return t + ": " + e;
  });
  return "{ " + a.join(", ") + " }";
}
function lae(u, r) {
  if (u.length === 0)
    return "[]";
  if (r.length > oW)
    return "[Array]";
  for (var o = Math.min(sae, u.length), a = u.length - o, t = [], e = 0; e < o; ++e)
    t.push(KS(u[e], r));
  return a === 1 ? t.push("... 1 more item") : a > 1 && t.push("... ".concat(a, " more items")), "[" + t.join(", ") + "]";
}
function fae(u) {
  var r = u[String(ux)];
  if (typeof r == "function")
    return r;
  if (typeof u.inspect == "function")
    return u.inspect;
}
function hae(u) {
  var r = Object.prototype.toString.call(u).replace(/^\[object /, "").replace(/]$/, "");
  if (r === "Object" && typeof u.constructor == "function") {
    var o = u.constructor.name;
    if (typeof o == "string" && o !== "")
      return o;
  }
  return r;
}
function tS(u, r) {
  var o = !!u;
  if (!o)
    throw new Error(r);
}
const pae = (
  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
  // eslint-disable-next-line no-shadow
  function(r, o) {
    return r instanceof o;
  }
);
function bae(u, r) {
  for (var o = 0; o < r.length; o++) {
    var a = r[o];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(u, a.key, a);
  }
}
function yae(u, r, o) {
  return r && bae(u.prototype, r), u;
}
var T8 = /* @__PURE__ */ function() {
  function u(r) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request", a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof r == "string" || tS(0, "Body must be a string. Received: ".concat(sW(r), ".")), this.body = r, this.name = o, this.locationOffset = a, this.locationOffset.line > 0 || tS(0, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || tS(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  return yae(u, [{
    key: uW,
    get: function() {
      return "Source";
    }
  }]), u;
}();
function _ae(u) {
  return pae(u, T8);
}
function ES(u, r) {
  for (var o = /\r\n|[\n\r]/g, a = 1, t = r + 1, e; (e = o.exec(u.body)) && e.index < r; )
    a += 1, t = r + 1 - (e.index + e[0].length);
  return {
    line: a,
    column: t
  };
}
function cW(u) {
  return w8(u.source, ES(u.source, u.start));
}
function w8(u, r) {
  var o = u.locationOffset.column - 1, a = rS(o) + u.body, t = r.line - 1, e = u.locationOffset.line - 1, n = r.line + e, i = r.line === 1 ? o : 0, c = r.column + i, s = "".concat(u.name, ":").concat(n, ":").concat(c, `
`), d = a.split(/\r\n|[\n\r]/g), l = d[t];
  if (l.length > 120) {
    for (var f = Math.floor(c / 80), h = c % 80, p = [], b = 0; b < l.length; b += 80)
      p.push(l.slice(b, b + 80));
    return s + aP([["".concat(n), p[0]]].concat(p.slice(1, f + 1).map(function(_) {
      return ["", _];
    }), [[" ", rS(h - 1) + "^"], ["", p[f + 1]]]));
  }
  return s + aP([
    // Lines specified like this: ["prefix", "string"],
    ["".concat(n - 1), d[t - 1]],
    ["".concat(n), l],
    ["", rS(c - 1) + "^"],
    ["".concat(n + 1), d[t + 1]]
  ]);
}
function aP(u) {
  var r = u.filter(function(a) {
    a[0];
    var t = a[1];
    return t !== void 0;
  }), o = Math.max.apply(Math, r.map(function(a) {
    var t = a[0];
    return t.length;
  }));
  return r.map(function(a) {
    var t = a[0], e = a[1];
    return gae(o, t) + (e ? " | " + e : " |");
  }).join(`
`);
}
function rS(u) {
  return Array(u + 1).join(" ");
}
function gae(u, r) {
  return rS(u - r.length) + r;
}
var We = Object.freeze({
  // Name
  NAME: "Name",
  // Document
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  // Fragments
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  // Values
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  // Directives
  DIRECTIVE: "Directive",
  // Types
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  // Type System Definitions
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  // Type Definitions
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  // Directive Definitions
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  // Type System Extensions
  SCHEMA_EXTENSION: "SchemaExtension",
  // Type Extensions
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
}), Me = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});
function nS(u) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? nS = function(o) {
    return typeof o;
  } : nS = function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, nS(u);
}
function mae(u) {
  return nS(u) == "object" && u !== null;
}
function iS(u) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? iS = function(o) {
    return typeof o;
  } : iS = function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, iS(u);
}
function uP(u, r) {
  var o = Object.keys(u);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(u);
    r && (a = a.filter(function(t) {
      return Object.getOwnPropertyDescriptor(u, t).enumerable;
    })), o.push.apply(o, a);
  }
  return o;
}
function vae(u) {
  for (var r = 1; r < arguments.length; r++) {
    var o = arguments[r] != null ? arguments[r] : {};
    r % 2 ? uP(Object(o), !0).forEach(function(a) {
      Tae(u, a, o[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(u, Object.getOwnPropertyDescriptors(o)) : uP(Object(o)).forEach(function(a) {
      Object.defineProperty(u, a, Object.getOwnPropertyDescriptor(o, a));
    });
  }
  return u;
}
function Tae(u, r, o) {
  return r in u ? Object.defineProperty(u, r, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : u[r] = o, u;
}
function wae(u, r) {
  if (!(u instanceof r))
    throw new TypeError("Cannot call a class as a function");
}
function Sae(u, r) {
  for (var o = 0; o < r.length; o++) {
    var a = r[o];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(u, a.key, a);
  }
}
function Aae(u, r, o) {
  return r && Sae(u.prototype, r), u;
}
function Eae(u, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Super expression must either be null or a function");
  u.prototype = Object.create(r && r.prototype, { constructor: { value: u, writable: !0, configurable: !0 } }), r && XT(u, r);
}
function Oae(u) {
  var r = lW();
  return function() {
    var a = JT(u), t;
    if (r) {
      var e = JT(this).constructor;
      t = Reflect.construct(a, arguments, e);
    } else
      t = a.apply(this, arguments);
    return dW(this, t);
  };
}
function dW(u, r) {
  return r && (iS(r) === "object" || typeof r == "function") ? r : _T(u);
}
function _T(u) {
  if (u === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return u;
}
function ox(u) {
  var r = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ox = function(a) {
    if (a === null || !xae(a)) return a;
    if (typeof a != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof r < "u") {
      if (r.has(a)) return r.get(a);
      r.set(a, t);
    }
    function t() {
      return aS(a, arguments, JT(this).constructor);
    }
    return t.prototype = Object.create(a.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), XT(t, a);
  }, ox(u);
}
function aS(u, r, o) {
  return lW() ? aS = Reflect.construct : aS = function(t, e, n) {
    var i = [null];
    i.push.apply(i, e);
    var c = Function.bind.apply(t, i), s = new c();
    return n && XT(s, n.prototype), s;
  }, aS.apply(null, arguments);
}
function lW() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function xae(u) {
  return Function.toString.call(u).indexOf("[native code]") !== -1;
}
function XT(u, r) {
  return XT = Object.setPrototypeOf || function(a, t) {
    return a.__proto__ = t, a;
  }, XT(u, r);
}
function JT(u) {
  return JT = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, JT(u);
}
var Iae = /* @__PURE__ */ function(u) {
  Eae(o, u);
  var r = Oae(o);
  function o(a, t, e, n, i, c, s) {
    var d, l, f, h;
    wae(this, o), h = r.call(this, a), h.name = "GraphQLError", h.originalError = c ?? void 0, h.nodes = oP(Array.isArray(t) ? t : t ? [t] : void 0);
    for (var p = [], b = 0, _ = (y = h.nodes) !== null && y !== void 0 ? y : []; b < _.length; b++) {
      var y, m = _[b], g = m.loc;
      g != null && p.push(g);
    }
    p = oP(p), h.source = e ?? ((d = p) === null || d === void 0 ? void 0 : d[0].source), h.positions = n ?? ((l = p) === null || l === void 0 ? void 0 : l.map(function(v) {
      return v.start;
    })), h.locations = n && e ? n.map(function(v) {
      return ES(e, v);
    }) : (f = p) === null || f === void 0 ? void 0 : f.map(function(v) {
      return ES(v.source, v.start);
    }), h.path = i ?? void 0;
    var T = c == null ? void 0 : c.extensions;
    return s == null && mae(T) ? h.extensions = vae({}, T) : h.extensions = s ?? {}, Object.defineProperties(_T(h), {
      message: {
        enumerable: !0
      },
      locations: {
        enumerable: h.locations != null
      },
      path: {
        enumerable: h.path != null
      },
      extensions: {
        enumerable: h.extensions != null && Object.keys(h.extensions).length > 0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), c != null && c.stack ? (Object.defineProperty(_T(h), "stack", {
      value: c.stack,
      writable: !0,
      configurable: !0
    }), dW(h)) : (Error.captureStackTrace ? Error.captureStackTrace(_T(h), o) : Object.defineProperty(_T(h), "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    }), h);
  }
  return Aae(o, [{
    key: "toString",
    value: function() {
      return Rae(this);
    }
  }, {
    key: "toJSON",
    value: function() {
      return Fae(this);
    }
    // FIXME: workaround to not break chai comparisons, should be remove in v16
    // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet
  }, {
    key: uW,
    get: function() {
      return "Object";
    }
  }]), o;
}(/* @__PURE__ */ ox(Error));
function oP(u) {
  return u === void 0 || u.length === 0 ? void 0 : u;
}
function Rae(u) {
  var r = u.message;
  if (u.nodes)
    for (var o = 0, a = u.nodes; o < a.length; o++) {
      var t = a[o];
      t.loc && (r += `

` + cW(t.loc));
    }
  else if (u.source && u.locations)
    for (var e = 0, n = u.locations; e < n.length; e++) {
      var i = n[e];
      r += `

` + w8(u.source, i);
    }
  return r;
}
function Fae(u) {
  var r;
  u || tS(0, "Received null or undefined error.");
  var o = (r = u.message) !== null && r !== void 0 ? r : "An unknown error occurred.", a = u.locations, t = u.path, e = u.extensions;
  return e && Object.keys(e).length > 0 ? {
    message: o,
    locations: a,
    path: t,
    extensions: e
  } : {
    message: o,
    locations: a,
    path: t
  };
}
function An(u, r, o) {
  return new Iae("Syntax Error: ".concat(o), void 0, u, [r]);
}
function Nae(u, r) {
  var o = !!u;
  if (!o)
    throw new Error("Unexpected invariant triggered.");
}
function fW(u) {
  var r = u.prototype.toJSON;
  typeof r == "function" || Nae(0), u.prototype.inspect = r, ux && (u.prototype[ux] = r);
}
var S8 = /* @__PURE__ */ function() {
  function u(o, a, t) {
    this.start = o.start, this.end = a.end, this.startToken = o, this.endToken = a, this.source = t;
  }
  var r = u.prototype;
  return r.toJSON = function() {
    return {
      start: this.start,
      end: this.end
    };
  }, u;
}();
fW(S8);
var cr = /* @__PURE__ */ function() {
  function u(o, a, t, e, n, i, c) {
    this.kind = o, this.start = a, this.end = t, this.line = e, this.column = n, this.value = c, this.prev = i, this.next = null;
  }
  var r = u.prototype;
  return r.toJSON = function() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }, u;
}();
fW(cr);
function sP(u) {
  return u != null && typeof u.kind == "string";
}
function Pae(u) {
  var r = u.split(/\r\n|[\n\r]/g), o = Dae(u);
  if (o !== 0)
    for (var a = 1; a < r.length; a++)
      r[a] = r[a].slice(o);
  for (var t = 0; t < r.length && cP(r[t]); )
    ++t;
  for (var e = r.length; e > t && cP(r[e - 1]); )
    --e;
  return r.slice(t, e).join(`
`);
}
function cP(u) {
  for (var r = 0; r < u.length; ++r)
    if (u[r] !== " " && u[r] !== "	")
      return !1;
  return !0;
}
function Dae(u) {
  for (var r, o = !0, a = !0, t = 0, e = null, n = 0; n < u.length; ++n)
    switch (u.charCodeAt(n)) {
      case 13:
        u.charCodeAt(n + 1) === 10 && ++n;
      // falls through
      case 10:
        o = !1, a = !0, t = 0;
        break;
      case 9:
      //   \t
      case 32:
        ++t;
        break;
      default:
        a && !o && (e === null || t < e) && (e = t), a = !1;
    }
  return (r = e) !== null && r !== void 0 ? r : 0;
}
function Lae(u) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, a = u.indexOf(`
`) === -1, t = u[0] === " " || u[0] === "	", e = u[u.length - 1] === '"', n = u[u.length - 1] === "\\", i = !a || e || n || o, c = "";
  return i && !(a && t) && (c += `
` + r), c += r ? u.replace(/\n/g, `
` + r) : u, i && (c += `
`), '"""' + c.replace(/"""/g, '\\"""') + '"""';
}
var hW = /* @__PURE__ */ function() {
  function u(o) {
    var a = new cr(Me.SOF, 0, 0, 0, 0, null);
    this.source = o, this.lastToken = a, this.token = a, this.line = 1, this.lineStart = 0;
  }
  var r = u.prototype;
  return r.advance = function() {
    this.lastToken = this.token;
    var a = this.token = this.lookahead();
    return a;
  }, r.lookahead = function() {
    var a = this.token;
    if (a.kind !== Me.EOF)
      do {
        var t;
        a = (t = a.next) !== null && t !== void 0 ? t : a.next = Mae(this, a);
      } while (a.kind === Me.COMMENT);
    return a;
  }, u;
}();
function jae(u) {
  return u === Me.BANG || u === Me.DOLLAR || u === Me.AMP || u === Me.PAREN_L || u === Me.PAREN_R || u === Me.SPREAD || u === Me.COLON || u === Me.EQUALS || u === Me.AT || u === Me.BRACKET_L || u === Me.BRACKET_R || u === Me.BRACE_L || u === Me.PIPE || u === Me.BRACE_R;
}
function Yf(u) {
  return (
    // NaN/undefined represents access beyond the end of the file.
    isNaN(u) ? Me.EOF : (
      // Trust JSON for ASCII.
      u < 127 ? JSON.stringify(String.fromCharCode(u)) : (
        // Otherwise print the escaped form.
        '"\\u'.concat(("00" + u.toString(16).toUpperCase()).slice(-4), '"')
      )
    )
  );
}
function Mae(u, r) {
  for (var o = u.source, a = o.body, t = a.length, e = r.end; e < t; ) {
    var n = a.charCodeAt(e), i = u.line, c = 1 + e - u.lineStart;
    switch (n) {
      case 65279:
      // <BOM>
      case 9:
      //   \t
      case 32:
      //  <space>
      case 44:
        ++e;
        continue;
      case 10:
        ++e, ++u.line, u.lineStart = e;
        continue;
      case 13:
        a.charCodeAt(e + 1) === 10 ? e += 2 : ++e, ++u.line, u.lineStart = e;
        continue;
      case 33:
        return new cr(Me.BANG, e, e + 1, i, c, r);
      case 35:
        return qae(o, e, i, c, r);
      case 36:
        return new cr(Me.DOLLAR, e, e + 1, i, c, r);
      case 38:
        return new cr(Me.AMP, e, e + 1, i, c, r);
      case 40:
        return new cr(Me.PAREN_L, e, e + 1, i, c, r);
      case 41:
        return new cr(Me.PAREN_R, e, e + 1, i, c, r);
      case 46:
        if (a.charCodeAt(e + 1) === 46 && a.charCodeAt(e + 2) === 46)
          return new cr(Me.SPREAD, e, e + 3, i, c, r);
        break;
      case 58:
        return new cr(Me.COLON, e, e + 1, i, c, r);
      case 61:
        return new cr(Me.EQUALS, e, e + 1, i, c, r);
      case 64:
        return new cr(Me.AT, e, e + 1, i, c, r);
      case 91:
        return new cr(Me.BRACKET_L, e, e + 1, i, c, r);
      case 93:
        return new cr(Me.BRACKET_R, e, e + 1, i, c, r);
      case 123:
        return new cr(Me.BRACE_L, e, e + 1, i, c, r);
      case 124:
        return new cr(Me.PIPE, e, e + 1, i, c, r);
      case 125:
        return new cr(Me.BRACE_R, e, e + 1, i, c, r);
      case 34:
        return a.charCodeAt(e + 1) === 34 && a.charCodeAt(e + 2) === 34 ? Uae(o, e, i, c, r, u) : $ae(o, e, i, c, r);
      case 45:
      //  -
      case 48:
      //  0
      case 49:
      //  1
      case 50:
      //  2
      case 51:
      //  3
      case 52:
      //  4
      case 53:
      //  5
      case 54:
      //  6
      case 55:
      //  7
      case 56:
      //  8
      case 57:
        return Bae(o, e, n, i, c, r);
      case 65:
      //  A
      case 66:
      //  B
      case 67:
      //  C
      case 68:
      //  D
      case 69:
      //  E
      case 70:
      //  F
      case 71:
      //  G
      case 72:
      //  H
      case 73:
      //  I
      case 74:
      //  J
      case 75:
      //  K
      case 76:
      //  L
      case 77:
      //  M
      case 78:
      //  N
      case 79:
      //  O
      case 80:
      //  P
      case 81:
      //  Q
      case 82:
      //  R
      case 83:
      //  S
      case 84:
      //  T
      case 85:
      //  U
      case 86:
      //  V
      case 87:
      //  W
      case 88:
      //  X
      case 89:
      //  Y
      case 90:
      //  Z
      case 95:
      //  _
      case 97:
      //  a
      case 98:
      //  b
      case 99:
      //  c
      case 100:
      // d
      case 101:
      // e
      case 102:
      // f
      case 103:
      // g
      case 104:
      // h
      case 105:
      // i
      case 106:
      // j
      case 107:
      // k
      case 108:
      // l
      case 109:
      // m
      case 110:
      // n
      case 111:
      // o
      case 112:
      // p
      case 113:
      // q
      case 114:
      // r
      case 115:
      // s
      case 116:
      // t
      case 117:
      // u
      case 118:
      // v
      case 119:
      // w
      case 120:
      // x
      case 121:
      // y
      case 122:
        return Qae(o, e, i, c, r);
    }
    throw An(o, e, Cae(n));
  }
  var s = u.line, d = 1 + e - u.lineStart;
  return new cr(Me.EOF, t, t, s, d, r);
}
function Cae(u) {
  return u < 32 && u !== 9 && u !== 10 && u !== 13 ? "Cannot contain the invalid character ".concat(Yf(u), ".") : u === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : "Cannot parse the unexpected character ".concat(Yf(u), ".");
}
function qae(u, r, o, a, t) {
  var e = u.body, n, i = r;
  do
    n = e.charCodeAt(++i);
  while (!isNaN(n) && // SourceCharacter but not LineTerminator
  (n > 31 || n === 9));
  return new cr(Me.COMMENT, r, i, o, a, t, e.slice(r + 1, i));
}
function Bae(u, r, o, a, t, e) {
  var n = u.body, i = o, c = r, s = !1;
  if (i === 45 && (i = n.charCodeAt(++c)), i === 48) {
    if (i = n.charCodeAt(++c), i >= 48 && i <= 57)
      throw An(u, c, "Invalid number, unexpected digit after 0: ".concat(Yf(i), "."));
  } else
    c = jA(u, c, i), i = n.charCodeAt(c);
  if (i === 46 && (s = !0, i = n.charCodeAt(++c), c = jA(u, c, i), i = n.charCodeAt(c)), (i === 69 || i === 101) && (s = !0, i = n.charCodeAt(++c), (i === 43 || i === 45) && (i = n.charCodeAt(++c)), c = jA(u, c, i), i = n.charCodeAt(c)), i === 46 || Hae(i))
    throw An(u, c, "Invalid number, expected digit but got: ".concat(Yf(i), "."));
  return new cr(s ? Me.FLOAT : Me.INT, r, c, a, t, e, n.slice(r, c));
}
function jA(u, r, o) {
  var a = u.body, t = r, e = o;
  if (e >= 48 && e <= 57) {
    do
      e = a.charCodeAt(++t);
    while (e >= 48 && e <= 57);
    return t;
  }
  throw An(u, t, "Invalid number, expected digit but got: ".concat(Yf(e), "."));
}
function $ae(u, r, o, a, t) {
  for (var e = u.body, n = r + 1, i = n, c = 0, s = ""; n < e.length && !isNaN(c = e.charCodeAt(n)) && // not LineTerminator
  c !== 10 && c !== 13; ) {
    if (c === 34)
      return s += e.slice(i, n), new cr(Me.STRING, r, n + 1, o, a, t, s);
    if (c < 32 && c !== 9)
      throw An(u, n, "Invalid character within String: ".concat(Yf(c), "."));
    if (++n, c === 92) {
      switch (s += e.slice(i, n - 1), c = e.charCodeAt(n), c) {
        case 34:
          s += '"';
          break;
        case 47:
          s += "/";
          break;
        case 92:
          s += "\\";
          break;
        case 98:
          s += "\b";
          break;
        case 102:
          s += "\f";
          break;
        case 110:
          s += `
`;
          break;
        case 114:
          s += "\r";
          break;
        case 116:
          s += "	";
          break;
        case 117: {
          var d = Vae(e.charCodeAt(n + 1), e.charCodeAt(n + 2), e.charCodeAt(n + 3), e.charCodeAt(n + 4));
          if (d < 0) {
            var l = e.slice(n + 1, n + 5);
            throw An(u, n, "Invalid character escape sequence: \\u".concat(l, "."));
          }
          s += String.fromCharCode(d), n += 4;
          break;
        }
        default:
          throw An(u, n, "Invalid character escape sequence: \\".concat(String.fromCharCode(c), "."));
      }
      ++n, i = n;
    }
  }
  throw An(u, n, "Unterminated string.");
}
function Uae(u, r, o, a, t, e) {
  for (var n = u.body, i = r + 3, c = i, s = 0, d = ""; i < n.length && !isNaN(s = n.charCodeAt(i)); ) {
    if (s === 34 && n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34)
      return d += n.slice(c, i), new cr(Me.BLOCK_STRING, r, i + 3, o, a, t, Pae(d));
    if (s < 32 && s !== 9 && s !== 10 && s !== 13)
      throw An(u, i, "Invalid character within String: ".concat(Yf(s), "."));
    s === 10 ? (++i, ++e.line, e.lineStart = i) : s === 13 ? (n.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i) : /* Escape Triple-Quote (\""") */ s === 92 && n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 && n.charCodeAt(i + 3) === 34 ? (d += n.slice(c, i) + '"""', i += 4, c = i) : ++i;
  }
  throw An(u, i, "Unterminated string.");
}
function Vae(u, r, o, a) {
  return o6(u) << 12 | o6(r) << 8 | o6(o) << 4 | o6(a);
}
function o6(u) {
  return u >= 48 && u <= 57 ? u - 48 : u >= 65 && u <= 70 ? u - 55 : u >= 97 && u <= 102 ? u - 87 : -1;
}
function Qae(u, r, o, a, t) {
  for (var e = u.body, n = e.length, i = r + 1, c = 0; i !== n && !isNaN(c = e.charCodeAt(i)) && (c === 95 || // _
  c >= 48 && c <= 57 || // 0-9
  c >= 65 && c <= 90 || // A-Z
  c >= 97 && c <= 122); )
    ++i;
  return new cr(Me.NAME, r, i, o, a, t, e.slice(r, i));
}
function Hae(u) {
  return u === 95 || u >= 65 && u <= 90 || u >= 97 && u <= 122;
}
var pW = Object.freeze({
  // Request Definitions
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  // Type System Definitions
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});
function Gae(u, r) {
  var o = new A8(u, r);
  return o.parseDocument();
}
function zae(u, r) {
  var o = new A8(u, r);
  o.expectToken(Me.SOF);
  var a = o.parseValueLiteral(!1);
  return o.expectToken(Me.EOF), a;
}
function kae(u, r) {
  var o = new A8(u, r);
  o.expectToken(Me.SOF);
  var a = o.parseTypeReference();
  return o.expectToken(Me.EOF), a;
}
var A8 = /* @__PURE__ */ function() {
  function u(o, a) {
    var t = _ae(o) ? o : new T8(o);
    this._lexer = new hW(t), this._options = a;
  }
  var r = u.prototype;
  return r.parseName = function() {
    var a = this.expectToken(Me.NAME);
    return {
      kind: We.NAME,
      value: a.value,
      loc: this.loc(a)
    };
  }, r.parseDocument = function() {
    var a = this._lexer.token;
    return {
      kind: We.DOCUMENT,
      definitions: this.many(Me.SOF, this.parseDefinition, Me.EOF),
      loc: this.loc(a)
    };
  }, r.parseDefinition = function() {
    if (this.peek(Me.NAME))
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    else {
      if (this.peek(Me.BRACE_L))
        return this.parseOperationDefinition();
      if (this.peekDescription())
        return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  }, r.parseOperationDefinition = function() {
    var a = this._lexer.token;
    if (this.peek(Me.BRACE_L))
      return {
        kind: We.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(a)
      };
    var t = this.parseOperationType(), e;
    return this.peek(Me.NAME) && (e = this.parseName()), {
      kind: We.OPERATION_DEFINITION,
      operation: t,
      name: e,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(a)
    };
  }, r.parseOperationType = function() {
    var a = this.expectToken(Me.NAME);
    switch (a.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(a);
  }, r.parseVariableDefinitions = function() {
    return this.optionalMany(Me.PAREN_L, this.parseVariableDefinition, Me.PAREN_R);
  }, r.parseVariableDefinition = function() {
    var a = this._lexer.token;
    return {
      kind: We.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(Me.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(Me.EQUALS) ? this.parseValueLiteral(!0) : void 0,
      directives: this.parseDirectives(!0),
      loc: this.loc(a)
    };
  }, r.parseVariable = function() {
    var a = this._lexer.token;
    return this.expectToken(Me.DOLLAR), {
      kind: We.VARIABLE,
      name: this.parseName(),
      loc: this.loc(a)
    };
  }, r.parseSelectionSet = function() {
    var a = this._lexer.token;
    return {
      kind: We.SELECTION_SET,
      selections: this.many(Me.BRACE_L, this.parseSelection, Me.BRACE_R),
      loc: this.loc(a)
    };
  }, r.parseSelection = function() {
    return this.peek(Me.SPREAD) ? this.parseFragment() : this.parseField();
  }, r.parseField = function() {
    var a = this._lexer.token, t = this.parseName(), e, n;
    return this.expectOptionalToken(Me.COLON) ? (e = t, n = this.parseName()) : n = t, {
      kind: We.FIELD,
      alias: e,
      name: n,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(Me.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(a)
    };
  }, r.parseArguments = function(a) {
    var t = a ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(Me.PAREN_L, t, Me.PAREN_R);
  }, r.parseArgument = function() {
    var a = this._lexer.token, t = this.parseName();
    return this.expectToken(Me.COLON), {
      kind: We.ARGUMENT,
      name: t,
      value: this.parseValueLiteral(!1),
      loc: this.loc(a)
    };
  }, r.parseConstArgument = function() {
    var a = this._lexer.token;
    return {
      kind: We.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(Me.COLON), this.parseValueLiteral(!0)),
      loc: this.loc(a)
    };
  }, r.parseFragment = function() {
    var a = this._lexer.token;
    this.expectToken(Me.SPREAD);
    var t = this.expectOptionalKeyword("on");
    return !t && this.peek(Me.NAME) ? {
      kind: We.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1),
      loc: this.loc(a)
    } : {
      kind: We.INLINE_FRAGMENT,
      typeCondition: t ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(a)
    };
  }, r.parseFragmentDefinition = function() {
    var a, t = this._lexer.token;
    return this.expectKeyword("fragment"), ((a = this._options) === null || a === void 0 ? void 0 : a.experimentalFragmentVariables) === !0 ? {
      kind: We.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(t)
    } : {
      kind: We.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(t)
    };
  }, r.parseFragmentName = function() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }, r.parseValueLiteral = function(a) {
    var t = this._lexer.token;
    switch (t.kind) {
      case Me.BRACKET_L:
        return this.parseList(a);
      case Me.BRACE_L:
        return this.parseObject(a);
      case Me.INT:
        return this._lexer.advance(), {
          kind: We.INT,
          value: t.value,
          loc: this.loc(t)
        };
      case Me.FLOAT:
        return this._lexer.advance(), {
          kind: We.FLOAT,
          value: t.value,
          loc: this.loc(t)
        };
      case Me.STRING:
      case Me.BLOCK_STRING:
        return this.parseStringLiteral();
      case Me.NAME:
        switch (this._lexer.advance(), t.value) {
          case "true":
            return {
              kind: We.BOOLEAN,
              value: !0,
              loc: this.loc(t)
            };
          case "false":
            return {
              kind: We.BOOLEAN,
              value: !1,
              loc: this.loc(t)
            };
          case "null":
            return {
              kind: We.NULL,
              loc: this.loc(t)
            };
          default:
            return {
              kind: We.ENUM,
              value: t.value,
              loc: this.loc(t)
            };
        }
      case Me.DOLLAR:
        if (!a)
          return this.parseVariable();
        break;
    }
    throw this.unexpected();
  }, r.parseStringLiteral = function() {
    var a = this._lexer.token;
    return this._lexer.advance(), {
      kind: We.STRING,
      value: a.value,
      block: a.kind === Me.BLOCK_STRING,
      loc: this.loc(a)
    };
  }, r.parseList = function(a) {
    var t = this, e = this._lexer.token, n = function() {
      return t.parseValueLiteral(a);
    };
    return {
      kind: We.LIST,
      values: this.any(Me.BRACKET_L, n, Me.BRACKET_R),
      loc: this.loc(e)
    };
  }, r.parseObject = function(a) {
    var t = this, e = this._lexer.token, n = function() {
      return t.parseObjectField(a);
    };
    return {
      kind: We.OBJECT,
      fields: this.any(Me.BRACE_L, n, Me.BRACE_R),
      loc: this.loc(e)
    };
  }, r.parseObjectField = function(a) {
    var t = this._lexer.token, e = this.parseName();
    return this.expectToken(Me.COLON), {
      kind: We.OBJECT_FIELD,
      name: e,
      value: this.parseValueLiteral(a),
      loc: this.loc(t)
    };
  }, r.parseDirectives = function(a) {
    for (var t = []; this.peek(Me.AT); )
      t.push(this.parseDirective(a));
    return t;
  }, r.parseDirective = function(a) {
    var t = this._lexer.token;
    return this.expectToken(Me.AT), {
      kind: We.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(a),
      loc: this.loc(t)
    };
  }, r.parseTypeReference = function() {
    var a = this._lexer.token, t;
    return this.expectOptionalToken(Me.BRACKET_L) ? (t = this.parseTypeReference(), this.expectToken(Me.BRACKET_R), t = {
      kind: We.LIST_TYPE,
      type: t,
      loc: this.loc(a)
    }) : t = this.parseNamedType(), this.expectOptionalToken(Me.BANG) ? {
      kind: We.NON_NULL_TYPE,
      type: t,
      loc: this.loc(a)
    } : t;
  }, r.parseNamedType = function() {
    var a = this._lexer.token;
    return {
      kind: We.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(a)
    };
  }, r.parseTypeSystemDefinition = function() {
    var a = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (a.kind === Me.NAME)
      switch (a.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    throw this.unexpected(a);
  }, r.peekDescription = function() {
    return this.peek(Me.STRING) || this.peek(Me.BLOCK_STRING);
  }, r.parseDescription = function() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }, r.parseSchemaDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("schema");
    var e = this.parseDirectives(!0), n = this.many(Me.BRACE_L, this.parseOperationTypeDefinition, Me.BRACE_R);
    return {
      kind: We.SCHEMA_DEFINITION,
      description: t,
      directives: e,
      operationTypes: n,
      loc: this.loc(a)
    };
  }, r.parseOperationTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseOperationType();
    this.expectToken(Me.COLON);
    var e = this.parseNamedType();
    return {
      kind: We.OPERATION_TYPE_DEFINITION,
      operation: t,
      type: e,
      loc: this.loc(a)
    };
  }, r.parseScalarTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("scalar");
    var e = this.parseName(), n = this.parseDirectives(!0);
    return {
      kind: We.SCALAR_TYPE_DEFINITION,
      description: t,
      name: e,
      directives: n,
      loc: this.loc(a)
    };
  }, r.parseObjectTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("type");
    var e = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseDirectives(!0), c = this.parseFieldsDefinition();
    return {
      kind: We.OBJECT_TYPE_DEFINITION,
      description: t,
      name: e,
      interfaces: n,
      directives: i,
      fields: c,
      loc: this.loc(a)
    };
  }, r.parseImplementsInterfaces = function() {
    var a;
    if (!this.expectOptionalKeyword("implements"))
      return [];
    if (((a = this._options) === null || a === void 0 ? void 0 : a.allowLegacySDLImplementsInterfaces) === !0) {
      var t = [];
      this.expectOptionalToken(Me.AMP);
      do
        t.push(this.parseNamedType());
      while (this.expectOptionalToken(Me.AMP) || this.peek(Me.NAME));
      return t;
    }
    return this.delimitedMany(Me.AMP, this.parseNamedType);
  }, r.parseFieldsDefinition = function() {
    var a;
    return ((a = this._options) === null || a === void 0 ? void 0 : a.allowLegacySDLEmptyFields) === !0 && this.peek(Me.BRACE_L) && this._lexer.lookahead().kind === Me.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(Me.BRACE_L, this.parseFieldDefinition, Me.BRACE_R);
  }, r.parseFieldDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription(), e = this.parseName(), n = this.parseArgumentDefs();
    this.expectToken(Me.COLON);
    var i = this.parseTypeReference(), c = this.parseDirectives(!0);
    return {
      kind: We.FIELD_DEFINITION,
      description: t,
      name: e,
      arguments: n,
      type: i,
      directives: c,
      loc: this.loc(a)
    };
  }, r.parseArgumentDefs = function() {
    return this.optionalMany(Me.PAREN_L, this.parseInputValueDef, Me.PAREN_R);
  }, r.parseInputValueDef = function() {
    var a = this._lexer.token, t = this.parseDescription(), e = this.parseName();
    this.expectToken(Me.COLON);
    var n = this.parseTypeReference(), i;
    this.expectOptionalToken(Me.EQUALS) && (i = this.parseValueLiteral(!0));
    var c = this.parseDirectives(!0);
    return {
      kind: We.INPUT_VALUE_DEFINITION,
      description: t,
      name: e,
      type: n,
      defaultValue: i,
      directives: c,
      loc: this.loc(a)
    };
  }, r.parseInterfaceTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("interface");
    var e = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseDirectives(!0), c = this.parseFieldsDefinition();
    return {
      kind: We.INTERFACE_TYPE_DEFINITION,
      description: t,
      name: e,
      interfaces: n,
      directives: i,
      fields: c,
      loc: this.loc(a)
    };
  }, r.parseUnionTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("union");
    var e = this.parseName(), n = this.parseDirectives(!0), i = this.parseUnionMemberTypes();
    return {
      kind: We.UNION_TYPE_DEFINITION,
      description: t,
      name: e,
      directives: n,
      types: i,
      loc: this.loc(a)
    };
  }, r.parseUnionMemberTypes = function() {
    return this.expectOptionalToken(Me.EQUALS) ? this.delimitedMany(Me.PIPE, this.parseNamedType) : [];
  }, r.parseEnumTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("enum");
    var e = this.parseName(), n = this.parseDirectives(!0), i = this.parseEnumValuesDefinition();
    return {
      kind: We.ENUM_TYPE_DEFINITION,
      description: t,
      name: e,
      directives: n,
      values: i,
      loc: this.loc(a)
    };
  }, r.parseEnumValuesDefinition = function() {
    return this.optionalMany(Me.BRACE_L, this.parseEnumValueDefinition, Me.BRACE_R);
  }, r.parseEnumValueDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription(), e = this.parseName(), n = this.parseDirectives(!0);
    return {
      kind: We.ENUM_VALUE_DEFINITION,
      description: t,
      name: e,
      directives: n,
      loc: this.loc(a)
    };
  }, r.parseInputObjectTypeDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("input");
    var e = this.parseName(), n = this.parseDirectives(!0), i = this.parseInputFieldsDefinition();
    return {
      kind: We.INPUT_OBJECT_TYPE_DEFINITION,
      description: t,
      name: e,
      directives: n,
      fields: i,
      loc: this.loc(a)
    };
  }, r.parseInputFieldsDefinition = function() {
    return this.optionalMany(Me.BRACE_L, this.parseInputValueDef, Me.BRACE_R);
  }, r.parseTypeSystemExtension = function() {
    var a = this._lexer.lookahead();
    if (a.kind === Me.NAME)
      switch (a.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(a);
  }, r.parseSchemaExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    var t = this.parseDirectives(!0), e = this.optionalMany(Me.BRACE_L, this.parseOperationTypeDefinition, Me.BRACE_R);
    if (t.length === 0 && e.length === 0)
      throw this.unexpected();
    return {
      kind: We.SCHEMA_EXTENSION,
      directives: t,
      operationTypes: e,
      loc: this.loc(a)
    };
  }, r.parseScalarTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    var t = this.parseName(), e = this.parseDirectives(!0);
    if (e.length === 0)
      throw this.unexpected();
    return {
      kind: We.SCALAR_TYPE_EXTENSION,
      name: t,
      directives: e,
      loc: this.loc(a)
    };
  }, r.parseObjectTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    var t = this.parseName(), e = this.parseImplementsInterfaces(), n = this.parseDirectives(!0), i = this.parseFieldsDefinition();
    if (e.length === 0 && n.length === 0 && i.length === 0)
      throw this.unexpected();
    return {
      kind: We.OBJECT_TYPE_EXTENSION,
      name: t,
      interfaces: e,
      directives: n,
      fields: i,
      loc: this.loc(a)
    };
  }, r.parseInterfaceTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    var t = this.parseName(), e = this.parseImplementsInterfaces(), n = this.parseDirectives(!0), i = this.parseFieldsDefinition();
    if (e.length === 0 && n.length === 0 && i.length === 0)
      throw this.unexpected();
    return {
      kind: We.INTERFACE_TYPE_EXTENSION,
      name: t,
      interfaces: e,
      directives: n,
      fields: i,
      loc: this.loc(a)
    };
  }, r.parseUnionTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    var t = this.parseName(), e = this.parseDirectives(!0), n = this.parseUnionMemberTypes();
    if (e.length === 0 && n.length === 0)
      throw this.unexpected();
    return {
      kind: We.UNION_TYPE_EXTENSION,
      name: t,
      directives: e,
      types: n,
      loc: this.loc(a)
    };
  }, r.parseEnumTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    var t = this.parseName(), e = this.parseDirectives(!0), n = this.parseEnumValuesDefinition();
    if (e.length === 0 && n.length === 0)
      throw this.unexpected();
    return {
      kind: We.ENUM_TYPE_EXTENSION,
      name: t,
      directives: e,
      values: n,
      loc: this.loc(a)
    };
  }, r.parseInputObjectTypeExtension = function() {
    var a = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    var t = this.parseName(), e = this.parseDirectives(!0), n = this.parseInputFieldsDefinition();
    if (e.length === 0 && n.length === 0)
      throw this.unexpected();
    return {
      kind: We.INPUT_OBJECT_TYPE_EXTENSION,
      name: t,
      directives: e,
      fields: n,
      loc: this.loc(a)
    };
  }, r.parseDirectiveDefinition = function() {
    var a = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(Me.AT);
    var e = this.parseName(), n = this.parseArgumentDefs(), i = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var c = this.parseDirectiveLocations();
    return {
      kind: We.DIRECTIVE_DEFINITION,
      description: t,
      name: e,
      arguments: n,
      repeatable: i,
      locations: c,
      loc: this.loc(a)
    };
  }, r.parseDirectiveLocations = function() {
    return this.delimitedMany(Me.PIPE, this.parseDirectiveLocation);
  }, r.parseDirectiveLocation = function() {
    var a = this._lexer.token, t = this.parseName();
    if (pW[t.value] !== void 0)
      return t;
    throw this.unexpected(a);
  }, r.loc = function(a) {
    var t;
    if (((t = this._options) === null || t === void 0 ? void 0 : t.noLocation) !== !0)
      return new S8(a, this._lexer.lastToken, this._lexer.source);
  }, r.peek = function(a) {
    return this._lexer.token.kind === a;
  }, r.expectToken = function(a) {
    var t = this._lexer.token;
    if (t.kind === a)
      return this._lexer.advance(), t;
    throw An(this._lexer.source, t.start, "Expected ".concat(bW(a), ", found ").concat(MA(t), "."));
  }, r.expectOptionalToken = function(a) {
    var t = this._lexer.token;
    if (t.kind === a)
      return this._lexer.advance(), t;
  }, r.expectKeyword = function(a) {
    var t = this._lexer.token;
    if (t.kind === Me.NAME && t.value === a)
      this._lexer.advance();
    else
      throw An(this._lexer.source, t.start, 'Expected "'.concat(a, '", found ').concat(MA(t), "."));
  }, r.expectOptionalKeyword = function(a) {
    var t = this._lexer.token;
    return t.kind === Me.NAME && t.value === a ? (this._lexer.advance(), !0) : !1;
  }, r.unexpected = function(a) {
    var t = a ?? this._lexer.token;
    return An(this._lexer.source, t.start, "Unexpected ".concat(MA(t), "."));
  }, r.any = function(a, t, e) {
    this.expectToken(a);
    for (var n = []; !this.expectOptionalToken(e); )
      n.push(t.call(this));
    return n;
  }, r.optionalMany = function(a, t, e) {
    if (this.expectOptionalToken(a)) {
      var n = [];
      do
        n.push(t.call(this));
      while (!this.expectOptionalToken(e));
      return n;
    }
    return [];
  }, r.many = function(a, t, e) {
    this.expectToken(a);
    var n = [];
    do
      n.push(t.call(this));
    while (!this.expectOptionalToken(e));
    return n;
  }, r.delimitedMany = function(a, t) {
    this.expectOptionalToken(a);
    var e = [];
    do
      e.push(t.call(this));
    while (this.expectOptionalToken(a));
    return e;
  }, u;
}();
function MA(u) {
  var r = u.value;
  return bW(u.kind) + (r != null ? ' "'.concat(r, '"') : "");
}
function bW(u) {
  return jae(u) ? '"'.concat(u, '"') : u;
}
var Xae = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, M0 = Object.freeze({});
function yW(u, r) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Xae, a = void 0, t = Array.isArray(u), e = [u], n = -1, i = [], c = void 0, s = void 0, d = void 0, l = [], f = [], h = u;
  do {
    n++;
    var p = n === e.length, b = p && i.length !== 0;
    if (p) {
      if (s = f.length === 0 ? void 0 : l[l.length - 1], c = d, d = f.pop(), b) {
        if (t)
          c = c.slice();
        else {
          for (var _ = {}, y = 0, m = Object.keys(c); y < m.length; y++) {
            var g = m[y];
            _[g] = c[g];
          }
          c = _;
        }
        for (var T = 0, v = 0; v < i.length; v++) {
          var E = i[v][0], R = i[v][1];
          t && (E -= T), t && R === null ? (c.splice(E, 1), T++) : c[E] = R;
        }
      }
      n = a.index, e = a.keys, i = a.edits, t = a.inArray, a = a.prev;
    } else {
      if (s = d ? t ? n : e[n] : void 0, c = d ? d[s] : h, c == null)
        continue;
      d && l.push(s);
    }
    var L = void 0;
    if (!Array.isArray(c)) {
      if (!sP(c))
        throw new Error("Invalid AST Node: ".concat(sW(c), "."));
      var A = OS(r, c.kind, p);
      if (A) {
        if (L = A.call(r, c, s, d, l, f), L === M0)
          break;
        if (L === !1) {
          if (!p) {
            l.pop();
            continue;
          }
        } else if (L !== void 0 && (i.push([s, L]), !p))
          if (sP(L))
            c = L;
          else {
            l.pop();
            continue;
          }
      }
    }
    if (L === void 0 && b && i.push([s, c]), p)
      l.pop();
    else {
      var w;
      a = {
        inArray: t,
        index: n,
        keys: e,
        edits: i,
        prev: a
      }, t = Array.isArray(c), e = t ? c : (w = o[c.kind]) !== null && w !== void 0 ? w : [], n = -1, i = [], d && f.push(d), d = c;
    }
  } while (a !== void 0);
  return i.length !== 0 && (h = i[i.length - 1][1]), h;
}
function Jae(u) {
  var r = new Array(u.length);
  return {
    enter: function(a) {
      for (var t = 0; t < u.length; t++)
        if (r[t] == null) {
          var e = OS(
            u[t],
            a.kind,
            /* isLeaving */
            !1
          );
          if (e) {
            var n = e.apply(u[t], arguments);
            if (n === !1)
              r[t] = a;
            else if (n === M0)
              r[t] = M0;
            else if (n !== void 0)
              return n;
          }
        }
    },
    leave: function(a) {
      for (var t = 0; t < u.length; t++)
        if (r[t] == null) {
          var e = OS(
            u[t],
            a.kind,
            /* isLeaving */
            !0
          );
          if (e) {
            var n = e.apply(u[t], arguments);
            if (n === M0)
              r[t] = M0;
            else if (n !== void 0 && n !== !1)
              return n;
          }
        } else r[t] === a && (r[t] = null);
    }
  };
}
function OS(u, r, o) {
  var a = u[r];
  if (a) {
    if (!o && typeof a == "function")
      return a;
    var t = o ? a.leave : a.enter;
    if (typeof t == "function")
      return t;
  } else {
    var e = o ? u.leave : u.enter;
    if (e) {
      if (typeof e == "function")
        return e;
      var n = e[r];
      if (typeof n == "function")
        return n;
    }
  }
}
function Kae(u) {
  return yW(u, {
    leave: Yae
  });
}
var Wae = 80, Yae = {
  Name: function(r) {
    return r.value;
  },
  Variable: function(r) {
    return "$" + r.name;
  },
  // Document
  Document: function(r) {
    return ut(r.definitions, `

`) + `
`;
  },
  OperationDefinition: function(r) {
    var o = r.operation, a = r.name, t = sr("(", ut(r.variableDefinitions, ", "), ")"), e = ut(r.directives, " "), n = r.selectionSet;
    return !a && !e && !t && o === "query" ? n : ut([o, ut([a, t]), e, n], " ");
  },
  VariableDefinition: function(r) {
    var o = r.variable, a = r.type, t = r.defaultValue, e = r.directives;
    return o + ": " + a + sr(" = ", t) + sr(" ", ut(e, " "));
  },
  SelectionSet: function(r) {
    var o = r.selections;
    return Zn(o);
  },
  Field: function(r) {
    var o = r.alias, a = r.name, t = r.arguments, e = r.directives, n = r.selectionSet, i = sr("", o, ": ") + a, c = i + sr("(", ut(t, ", "), ")");
    return c.length > Wae && (c = i + sr(`(
`, uS(ut(t, `
`)), `
)`)), ut([c, ut(e, " "), n], " ");
  },
  Argument: function(r) {
    var o = r.name, a = r.value;
    return o + ": " + a;
  },
  // Fragments
  FragmentSpread: function(r) {
    var o = r.name, a = r.directives;
    return "..." + o + sr(" ", ut(a, " "));
  },
  InlineFragment: function(r) {
    var o = r.typeCondition, a = r.directives, t = r.selectionSet;
    return ut(["...", sr("on ", o), ut(a, " "), t], " ");
  },
  FragmentDefinition: function(r) {
    var o = r.name, a = r.typeCondition, t = r.variableDefinitions, e = r.directives, n = r.selectionSet;
    return (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(o).concat(sr("(", ut(t, ", "), ")"), " ") + "on ".concat(a, " ").concat(sr("", ut(e, " "), " ")) + n
    );
  },
  // Value
  IntValue: function(r) {
    var o = r.value;
    return o;
  },
  FloatValue: function(r) {
    var o = r.value;
    return o;
  },
  StringValue: function(r, o) {
    var a = r.value, t = r.block;
    return t ? Lae(a, o === "description" ? "" : "  ") : JSON.stringify(a);
  },
  BooleanValue: function(r) {
    var o = r.value;
    return o ? "true" : "false";
  },
  NullValue: function() {
    return "null";
  },
  EnumValue: function(r) {
    var o = r.value;
    return o;
  },
  ListValue: function(r) {
    var o = r.values;
    return "[" + ut(o, ", ") + "]";
  },
  ObjectValue: function(r) {
    var o = r.fields;
    return "{" + ut(o, ", ") + "}";
  },
  ObjectField: function(r) {
    var o = r.name, a = r.value;
    return o + ": " + a;
  },
  // Directive
  Directive: function(r) {
    var o = r.name, a = r.arguments;
    return "@" + o + sr("(", ut(a, ", "), ")");
  },
  // Type
  NamedType: function(r) {
    var o = r.name;
    return o;
  },
  ListType: function(r) {
    var o = r.type;
    return "[" + o + "]";
  },
  NonNullType: function(r) {
    var o = r.type;
    return o + "!";
  },
  // Type System Definitions
  SchemaDefinition: Yn(function(u) {
    var r = u.directives, o = u.operationTypes;
    return ut(["schema", ut(r, " "), Zn(o)], " ");
  }),
  OperationTypeDefinition: function(r) {
    var o = r.operation, a = r.type;
    return o + ": " + a;
  },
  ScalarTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.directives;
    return ut(["scalar", r, ut(o, " ")], " ");
  }),
  ObjectTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.interfaces, a = u.directives, t = u.fields;
    return ut(["type", r, sr("implements ", ut(o, " & ")), ut(a, " "), Zn(t)], " ");
  }),
  FieldDefinition: Yn(function(u) {
    var r = u.name, o = u.arguments, a = u.type, t = u.directives;
    return r + (dP(o) ? sr(`(
`, uS(ut(o, `
`)), `
)`) : sr("(", ut(o, ", "), ")")) + ": " + a + sr(" ", ut(t, " "));
  }),
  InputValueDefinition: Yn(function(u) {
    var r = u.name, o = u.type, a = u.defaultValue, t = u.directives;
    return ut([r + ": " + o, sr("= ", a), ut(t, " ")], " ");
  }),
  InterfaceTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.interfaces, a = u.directives, t = u.fields;
    return ut(["interface", r, sr("implements ", ut(o, " & ")), ut(a, " "), Zn(t)], " ");
  }),
  UnionTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.directives, a = u.types;
    return ut(["union", r, ut(o, " "), a && a.length !== 0 ? "= " + ut(a, " | ") : ""], " ");
  }),
  EnumTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.directives, a = u.values;
    return ut(["enum", r, ut(o, " "), Zn(a)], " ");
  }),
  EnumValueDefinition: Yn(function(u) {
    var r = u.name, o = u.directives;
    return ut([r, ut(o, " ")], " ");
  }),
  InputObjectTypeDefinition: Yn(function(u) {
    var r = u.name, o = u.directives, a = u.fields;
    return ut(["input", r, ut(o, " "), Zn(a)], " ");
  }),
  DirectiveDefinition: Yn(function(u) {
    var r = u.name, o = u.arguments, a = u.repeatable, t = u.locations;
    return "directive @" + r + (dP(o) ? sr(`(
`, uS(ut(o, `
`)), `
)`) : sr("(", ut(o, ", "), ")")) + (a ? " repeatable" : "") + " on " + ut(t, " | ");
  }),
  SchemaExtension: function(r) {
    var o = r.directives, a = r.operationTypes;
    return ut(["extend schema", ut(o, " "), Zn(a)], " ");
  },
  ScalarTypeExtension: function(r) {
    var o = r.name, a = r.directives;
    return ut(["extend scalar", o, ut(a, " ")], " ");
  },
  ObjectTypeExtension: function(r) {
    var o = r.name, a = r.interfaces, t = r.directives, e = r.fields;
    return ut(["extend type", o, sr("implements ", ut(a, " & ")), ut(t, " "), Zn(e)], " ");
  },
  InterfaceTypeExtension: function(r) {
    var o = r.name, a = r.interfaces, t = r.directives, e = r.fields;
    return ut(["extend interface", o, sr("implements ", ut(a, " & ")), ut(t, " "), Zn(e)], " ");
  },
  UnionTypeExtension: function(r) {
    var o = r.name, a = r.directives, t = r.types;
    return ut(["extend union", o, ut(a, " "), t && t.length !== 0 ? "= " + ut(t, " | ") : ""], " ");
  },
  EnumTypeExtension: function(r) {
    var o = r.name, a = r.directives, t = r.values;
    return ut(["extend enum", o, ut(a, " "), Zn(t)], " ");
  },
  InputObjectTypeExtension: function(r) {
    var o = r.name, a = r.directives, t = r.fields;
    return ut(["extend input", o, ut(a, " "), Zn(t)], " ");
  }
};
function Yn(u) {
  return function(r) {
    return ut([r.description, u(r)], `
`);
  };
}
function ut(u) {
  var r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (r = u == null ? void 0 : u.filter(function(a) {
    return a;
  }).join(o)) !== null && r !== void 0 ? r : "";
}
function Zn(u) {
  return sr(`{
`, uS(ut(u, `
`)), `
}`);
}
function sr(u, r) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return r != null && r !== "" ? u + r + o : "";
}
function uS(u) {
  return sr("  ", u.replace(/\n/g, `
  `));
}
function Zae(u) {
  return u.indexOf(`
`) !== -1;
}
function dP(u) {
  return u != null && u.some(Zae);
}
function eue(u) {
  return _W(u) || gW(u) || vW(u);
}
function _W(u) {
  return u.kind === We.OPERATION_DEFINITION || u.kind === We.FRAGMENT_DEFINITION;
}
function tue(u) {
  return u.kind === We.FIELD || u.kind === We.FRAGMENT_SPREAD || u.kind === We.INLINE_FRAGMENT;
}
function rue(u) {
  return u.kind === We.VARIABLE || u.kind === We.INT || u.kind === We.FLOAT || u.kind === We.STRING || u.kind === We.BOOLEAN || u.kind === We.NULL || u.kind === We.ENUM || u.kind === We.LIST || u.kind === We.OBJECT;
}
function nue(u) {
  return u.kind === We.NAMED_TYPE || u.kind === We.LIST_TYPE || u.kind === We.NON_NULL_TYPE;
}
function gW(u) {
  return u.kind === We.SCHEMA_DEFINITION || mW(u) || u.kind === We.DIRECTIVE_DEFINITION;
}
function mW(u) {
  return u.kind === We.SCALAR_TYPE_DEFINITION || u.kind === We.OBJECT_TYPE_DEFINITION || u.kind === We.INTERFACE_TYPE_DEFINITION || u.kind === We.UNION_TYPE_DEFINITION || u.kind === We.ENUM_TYPE_DEFINITION || u.kind === We.INPUT_OBJECT_TYPE_DEFINITION;
}
function vW(u) {
  return u.kind === We.SCHEMA_EXTENSION || TW(u);
}
function TW(u) {
  return u.kind === We.SCALAR_TYPE_EXTENSION || u.kind === We.OBJECT_TYPE_EXTENSION || u.kind === We.INTERFACE_TYPE_EXTENSION || u.kind === We.UNION_TYPE_EXTENSION || u.kind === We.ENUM_TYPE_EXTENSION || u.kind === We.INPUT_OBJECT_TYPE_EXTENSION;
}
const iue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BREAK: M0,
  DirectiveLocation: pW,
  Kind: We,
  Lexer: hW,
  Location: S8,
  Source: T8,
  Token: cr,
  TokenKind: Me,
  getLocation: ES,
  getVisitFn: OS,
  isDefinitionNode: eue,
  isExecutableDefinitionNode: _W,
  isSelectionNode: tue,
  isTypeDefinitionNode: mW,
  isTypeExtensionNode: TW,
  isTypeNode: nue,
  isTypeSystemDefinitionNode: gW,
  isTypeSystemExtensionNode: vW,
  isValueNode: rue,
  parse: Gae,
  parseType: kae,
  parseValue: zae,
  print: Kae,
  printLocation: cW,
  printSourceLocation: w8,
  visit: yW,
  visitInParallel: Jae
}, Symbol.toStringTag, { value: "Module" })), aue = /* @__PURE__ */ jx(iue);
var o1 = {}, fo = {}, s1 = {}, ho = {}, Ji = {}, lP;
function uue() {
  if (lP) return Ji;
  lP = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.removeDotSegmentsOfPath = Ji.removeDotSegments = Ji.resolve = void 0;
  function u(t, e) {
    e = e || "";
    const n = e.indexOf("#");
    if (n > 0 && (e = e.substr(0, n)), !t.length) {
      if (e.indexOf(":") < 0)
        throw new Error(`Found invalid baseIRI '${e}' for value '${t}'`);
      return e;
    }
    if (t.startsWith("?")) {
      const h = e.indexOf("?");
      return h > 0 && (e = e.substr(0, h)), e + t;
    }
    if (t.startsWith("#"))
      return e + t;
    if (!e.length) {
      const h = t.indexOf(":");
      if (h < 0)
        throw new Error(`Found invalid relative IRI '${t}' for a missing baseIRI`);
      return o(t, h);
    }
    const i = t.indexOf(":");
    if (i >= 0)
      return o(t, i);
    const c = e.indexOf(":");
    if (c < 0)
      throw new Error(`Found invalid baseIRI '${e}' for value '${t}'`);
    const s = e.substr(0, c + 1);
    if (t.indexOf("//") === 0)
      return s + o(t, i);
    let d;
    if (e.indexOf("//", c) === c + 1) {
      if (d = e.indexOf("/", c + 3), d < 0)
        return e.length > c + 3 ? e + "/" + o(t, i) : s + o(t, i);
    } else if (d = e.indexOf("/", c + 1), d < 0)
      return s + o(t, i);
    if (t.indexOf("/") === 0)
      return e.substr(0, d) + r(t);
    let l = e.substr(d);
    const f = l.lastIndexOf("/");
    return f >= 0 && f < l.length - 1 && (l = l.substr(0, f + 1), t[0] === "." && t[1] !== "." && t[1] !== "/" && t[2] && (t = t.substr(1))), t = l + t, t = r(t), e.substr(0, d) + t;
  }
  Ji.resolve = u;
  function r(t) {
    const e = [];
    let n = 0;
    for (; n < t.length; )
      switch (t[n]) {
        case "/":
          if (t[n + 1] === ".")
            if (t[n + 2] === ".") {
              if (!a(t[n + 3])) {
                e.push([]), n++;
                break;
              }
              e.pop(), t[n + 3] || e.push([]), n += 3;
            } else {
              if (!a(t[n + 2])) {
                e.push([]), n++;
                break;
              }
              t[n + 2] || e.push([]), n += 2;
            }
          else
            e.push([]), n++;
          break;
        case "#":
        case "?":
          e.length || e.push([]), e[e.length - 1].push(t.substr(n)), n = t.length;
          break;
        default:
          e.length || e.push([]), e[e.length - 1].push(t[n]), n++;
          break;
      }
    return "/" + e.map((i) => i.join("")).join("/");
  }
  Ji.removeDotSegments = r;
  function o(t, e) {
    let n = e + 1;
    e >= 0 ? t[e + 1] === "/" && t[e + 2] === "/" && (n = e + 3) : t[0] === "/" && t[1] === "/" && (n = 2);
    const i = t.indexOf("/", n);
    if (i < 0)
      return t;
    const c = t.substr(0, i), s = t.substr(i);
    return c + r(s);
  }
  Ji.removeDotSegmentsOfPath = o;
  function a(t) {
    return !t || t === "#" || t === "?" || t === "/";
  }
  return Ji;
}
var fP;
function Tr() {
  return fP || (fP = 1, function(u) {
    var r = ho && ho.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e), Object.defineProperty(a, n, { enumerable: !0, get: function() {
        return t[e];
      } });
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ho && ho.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(uue(), u);
  }(ho)), ho;
}
var CA = {}, hP;
function WS() {
  return hP || (hP = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.ERROR_CODES = u.ErrorCoded = void 0;
    class r extends Error {
      /* istanbul ignore next */
      constructor(a, t) {
        super(a), this.code = t;
      }
    }
    u.ErrorCoded = r, function(o) {
      o.COLLIDING_KEYWORDS = "colliding keywords", o.CONFLICTING_INDEXES = "conflicting indexes", o.CYCLIC_IRI_MAPPING = "cyclic IRI mapping", o.INVALID_ID_VALUE = "invalid @id value", o.INVALID_INDEX_VALUE = "invalid @index value", o.INVALID_NEST_VALUE = "invalid @nest value", o.INVALID_PREFIX_VALUE = "invalid @prefix value", o.INVALID_PROPAGATE_VALUE = "invalid @propagate value", o.INVALID_REVERSE_VALUE = "invalid @reverse value", o.INVALID_IMPORT_VALUE = "invalid @import value", o.INVALID_VERSION_VALUE = "invalid @version value", o.INVALID_BASE_IRI = "invalid base IRI", o.INVALID_CONTAINER_MAPPING = "invalid container mapping", o.INVALID_CONTEXT_ENTRY = "invalid context entry", o.INVALID_CONTEXT_NULLIFICATION = "invalid context nullification", o.INVALID_DEFAULT_LANGUAGE = "invalid default language", o.INVALID_INCLUDED_VALUE = "invalid @included value", o.INVALID_IRI_MAPPING = "invalid IRI mapping", o.INVALID_JSON_LITERAL = "invalid JSON literal", o.INVALID_KEYWORD_ALIAS = "invalid keyword alias", o.INVALID_LANGUAGE_MAP_VALUE = "invalid language map value", o.INVALID_LANGUAGE_MAPPING = "invalid language mapping", o.INVALID_LANGUAGE_TAGGED_STRING = "invalid language-tagged string", o.INVALID_LANGUAGE_TAGGED_VALUE = "invalid language-tagged value", o.INVALID_LOCAL_CONTEXT = "invalid local context", o.INVALID_REMOTE_CONTEXT = "invalid remote context", o.INVALID_REVERSE_PROPERTY = "invalid reverse property", o.INVALID_REVERSE_PROPERTY_MAP = "invalid reverse property map", o.INVALID_REVERSE_PROPERTY_VALUE = "invalid reverse property value", o.INVALID_SCOPED_CONTEXT = "invalid scoped context", o.INVALID_SCRIPT_ELEMENT = "invalid script element", o.INVALID_SET_OR_LIST_OBJECT = "invalid set or list object", o.INVALID_TERM_DEFINITION = "invalid term definition", o.INVALID_TYPE_MAPPING = "invalid type mapping", o.INVALID_TYPE_VALUE = "invalid type value", o.INVALID_TYPED_VALUE = "invalid typed value", o.INVALID_VALUE_OBJECT = "invalid value object", o.INVALID_VALUE_OBJECT_VALUE = "invalid value object value", o.INVALID_VOCAB_MAPPING = "invalid vocab mapping", o.IRI_CONFUSED_WITH_PREFIX = "IRI confused with prefix", o.KEYWORD_REDEFINITION = "keyword redefinition", o.LOADING_DOCUMENT_FAILED = "loading document failed", o.LOADING_REMOTE_CONTEXT_FAILED = "loading remote context failed", o.MULTIPLE_CONTEXT_LINK_HEADERS = "multiple context link headers", o.PROCESSING_MODE_CONFLICT = "processing mode conflict", o.PROTECTED_TERM_REDEFINITION = "protected term redefinition", o.CONTEXT_OVERFLOW = "context overflow", o.INVALID_BASE_DIRECTION = "invalid base direction", o.RECURSIVE_CONTEXT_INCLUSION = "recursive context inclusion", o.INVALID_STREAMING_KEY_ORDER = "invalid streaming key order", o.INVALID_EMBEDDED_NODE = "invalid embedded node", o.INVALID_ANNOTATION = "invalid annotation";
    }(u.ERROR_CODES || (u.ERROR_CODES = {}));
  }(CA)), CA;
}
var c1 = {}, qA, pP;
function Aw() {
  if (pP) return qA;
  pP = 1;
  var u = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i, r = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /\s|\uFEFF|\xA0/, a = /\r?\n[\x20\x09]+/g, t = /[;,"]/, e = /[;,"]|\s/, n = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/, i = {
    IDLE: 1,
    URI: 2,
    ATTR: 4
  };
  function c(p) {
    return p.replace(r, "");
  }
  function s(p) {
    return o.test(p);
  }
  function d(p, b) {
    for (; s(p[b]); )
      b++;
    return b;
  }
  function l(p) {
    return e.test(p) || !n.test(p);
  }
  function f(p, b) {
    return Object.keys(p).length === Object.keys(b).length && Object.keys(p).every(
      (_) => _ in b && p[_] === b[_]
    );
  }
  class h {
    /**
     * Link
     * @constructor
     * @param {String} [value]
     * @returns {Link}
     */
    constructor(b) {
      this.refs = [], b && this.parse(b);
    }
    /**
     * Get refs with given relation type
     * @param {String} value
     * @returns {Array<Object>}
     */
    rel(b) {
      for (var _ = [], y = b.toLowerCase(), m = 0; m < this.refs.length; m++)
        typeof this.refs[m].rel == "string" && this.refs[m].rel.toLowerCase() === y && _.push(this.refs[m]);
      return _;
    }
    /**
     * Get refs where given attribute has a given value
     * @param {String} attr
     * @param {String} value
     * @returns {Array<Object>}
     */
    get(b, _) {
      b = b.toLowerCase(), _ = _.toLowerCase();
      for (var y = [], m = 0; m < this.refs.length; m++)
        typeof this.refs[m][b] == "string" && this.refs[m][b].toLowerCase() === _ && y.push(this.refs[m]);
      return y;
    }
    /** Sets a reference. */
    set(b) {
      return this.refs.push(b), this;
    }
    /**
     * Sets a reference if a reference with similar properties isnât already set.
     */
    setUnique(b) {
      return this.refs.some((_) => f(_, b)) || this.refs.push(b), this;
    }
    has(b, _) {
      b = b.toLowerCase(), _ = _.toLowerCase();
      for (var y = 0; y < this.refs.length; y++)
        if (typeof this.refs[y][b] == "string" && this.refs[y][b].toLowerCase() === _)
          return !0;
      return !1;
    }
    parse(b, g) {
      g = g || 0, b = g ? b.slice(g) : b, b = c(b).replace(a, "");
      for (var y = i.IDLE, m = b.length, g = 0, T = null; g < m; )
        if (y === i.IDLE) {
          if (s(b[g])) {
            g++;
            continue;
          } else if (b[g] === "<") {
            T != null && (T.rel != null ? this.refs.push(...h.expandRelations(T)) : this.refs.push(T));
            var v = b.indexOf(">", g);
            if (v === -1) throw new Error("Expected end of URI delimiter at offset " + g);
            T = { uri: b.slice(g + 1, v) }, g = v, y = i.URI;
          } else
            throw new Error('Unexpected character "' + b[g] + '" at offset ' + g);
          g++;
        } else if (y === i.URI)
          if (s(b[g])) {
            g++;
            continue;
          } else if (b[g] === ";")
            y = i.ATTR, g++;
          else if (b[g] === ",")
            y = i.IDLE, g++;
          else
            throw new Error('Unexpected character "' + b[g] + '" at offset ' + g);
        else if (y === i.ATTR) {
          if (b[g] === ";" || s(b[g])) {
            g++;
            continue;
          }
          var v = b.indexOf("=", g);
          v === -1 && (v = b.indexOf(";", g)), v === -1 && (v = b.length);
          var E = c(b.slice(g, v)).toLowerCase(), R = "";
          if (g = v + 1, g = d(b, g), b[g] === '"')
            for (g++; g < m; ) {
              if (b[g] === '"') {
                g++;
                break;
              }
              b[g] === "\\" && g++, R += b[g], g++;
            }
          else {
            for (var v = g + 1; !t.test(b[v]) && v < m; )
              v++;
            R = b.slice(g, v), g = v;
          }
          switch (T[E] && h.isSingleOccurenceAttr(E) || (E[E.length - 1] === "*" ? T[E] = h.parseExtendedValue(R) : (R = E === "type" ? R.toLowerCase() : R, T[E] != null ? Array.isArray(T[E]) ? T[E].push(R) : T[E] = [T[E], R] : T[E] = R)), b[g]) {
            case ",":
              y = i.IDLE;
              break;
            case ";":
              y = i.ATTR;
              break;
          }
          g++;
        } else
          throw new Error('Unknown parser state "' + y + '"');
      return T != null && (T.rel != null ? this.refs.push(...h.expandRelations(T)) : this.refs.push(T)), T = null, this;
    }
    toString() {
      for (var b = [], _ = "", y = null, m = 0; m < this.refs.length; m++)
        y = this.refs[m], _ = Object.keys(this.refs[m]).reduce(function(g, T) {
          return T === "uri" ? g : g + "; " + h.formatAttribute(T, y[T]);
        }, "<" + y.uri + ">"), b.push(_);
      return b.join(", ");
    }
  }
  return h.isCompatibleEncoding = function(p) {
    return u.test(p);
  }, h.parse = function(p, b) {
    return new h().parse(p, b);
  }, h.isSingleOccurenceAttr = function(p) {
    return p === "rel" || p === "type" || p === "media" || p === "title" || p === "title*";
  }, h.isTokenAttr = function(p) {
    return p === "rel" || p === "type" || p === "anchor";
  }, h.escapeQuotes = function(p) {
    return p.replace(/"/g, '\\"');
  }, h.expandRelations = function(p) {
    var b = p.rel.split(" ");
    return b.map(function(_) {
      var y = Object.assign({}, p);
      return y.rel = _, y;
    });
  }, h.parseExtendedValue = function(p) {
    var b = /([^']+)?(?:'([^']*)')?(.+)/.exec(p);
    return {
      language: b[2].toLowerCase(),
      encoding: h.isCompatibleEncoding(b[1]) ? null : b[1].toLowerCase(),
      value: h.isCompatibleEncoding(b[1]) ? decodeURIComponent(b[3]) : b[3]
    };
  }, h.formatExtendedAttribute = function(p, b) {
    var _ = (b.encoding || "utf-8").toUpperCase(), y = b.language || "en", m = "";
    return Buffer.isBuffer(b.value) && h.isCompatibleEncoding(_) ? m = b.value.toString(_) : Buffer.isBuffer(b.value) ? m = b.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1") : m = encodeURIComponent(b.value), p + "=" + _ + "'" + y + "'" + m;
  }, h.formatAttribute = function(p, b) {
    return Array.isArray(b) ? b.map((_) => h.formatAttribute(p, _)).join("; ") : p[p.length - 1] === "*" || typeof b != "string" ? h.formatExtendedAttribute(p, b) : (h.isTokenAttr(p) ? b = l(b) ? '"' + h.escapeQuotes(b) + '"' : h.escapeQuotes(b) : l(b) && (b = encodeURIComponent(b), b = b.replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";"), b = '"' + b + '"'), p + "=" + b);
  }, qA = h, qA;
}
var bP;
function wW() {
  if (bP) return c1;
  bP = 1, Object.defineProperty(c1, "__esModule", { value: !0 }), c1.FetchDocumentLoader = void 0;
  const u = /* @__PURE__ */ WS(), r = Aw(), o = Tr();
  class a {
    constructor(e) {
      this.fetcher = e;
    }
    async load(e) {
      const n = await (this.fetcher || fetch)(e, { headers: new Headers({ accept: "application/ld+json" }) });
      if (n.ok && n.headers) {
        let i = n.headers.get("Content-Type");
        if (i) {
          const c = i.indexOf(";");
          c > 0 && (i = i.substr(0, c));
        }
        if (i === "application/ld+json")
          return await n.json();
        if (n.headers.has("Link")) {
          let c;
          if (n.headers.forEach((s, d) => {
            if (d === "link") {
              const l = (0, r.parse)(s);
              for (const f of l.get("type", "application/ld+json"))
                if (f.rel === "alternate") {
                  if (c)
                    throw new Error("Multiple JSON-LD alternate links were found on " + e);
                  c = (0, o.resolve)(f.uri, e);
                }
            }
          }), c)
            return this.load(c);
        }
        throw new u.ErrorCoded(`Unsupported JSON-LD media type ${i}`, u.ERROR_CODES.LOADING_DOCUMENT_FAILED);
      } else
        throw new Error(n.statusText || `Status code: ${n.status}`);
    }
  }
  return c1.FetchDocumentLoader = a, c1;
}
var BA = {}, d1 = {}, yP;
function E8() {
  if (yP) return d1;
  yP = 1, Object.defineProperty(d1, "__esModule", { value: !0 }), d1.Util = void 0;
  class u {
    /**
     * Check if the given term is a valid compact IRI.
     * Otherwise, it may be an IRI.
     * @param {string} term A term.
     * @return {boolean} If it is a compact IRI.
     */
    static isCompactIri(o) {
      return o.indexOf(":") > 0 && !(o && o[0] === "#");
    }
    /**
     * Get the prefix from the given term.
     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {string} The prefix or null.
     */
    static getPrefix(o, a) {
      if (o && o[0] === "#")
        return null;
      const t = o.indexOf(":");
      if (t >= 0) {
        if (o.length > t + 1 && o.charAt(t + 1) === "/" && o.charAt(t + 2) === "/")
          return null;
        const e = o.substr(0, t);
        if (e === "_")
          return null;
        if (a[e])
          return e;
      }
      return null;
    }
    /**
     * From a given context entry value, get the string value, or the @id field.
     * @param contextValue A value for a term in a context.
     * @return {string} The id value, or null.
     */
    static getContextValueId(o) {
      if (o === null || typeof o == "string")
        return o;
      const a = o["@id"];
      return a || null;
    }
    /**
     * Check if the given simple term definition (string-based value of a context term)
     * should be considered a prefix.
     * @param value A simple term definition value.
     * @param options Options that define the way how expansion must be done.
     */
    static isSimpleTermDefinitionPrefix(o, a) {
      return !u.isPotentialKeyword(o) && (a.allowPrefixNonGenDelims || typeof o == "string" && (o[0] === "_" || u.isPrefixIriEndingWithGenDelim(o)));
    }
    /**
     * Check if the given keyword is of the keyword format "@"1*ALPHA.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is of the keyword format.
     */
    static isPotentialKeyword(o) {
      return typeof o == "string" && u.KEYWORD_REGEX.test(o);
    }
    /**
     * Check if the given prefix ends with a gen-delim character.
     * @param {string} prefixIri A prefix IRI.
     * @return {boolean} If the given prefix IRI is valid.
     */
    static isPrefixIriEndingWithGenDelim(o) {
      return u.ENDS_WITH_GEN_DELIM.test(o);
    }
    /**
     * Check if the given context value can be a prefix value.
     * @param value A context value.
     * @return {boolean} If it can be a prefix value.
     */
    static isPrefixValue(o) {
      return o && (typeof o == "string" || o && typeof o == "object");
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(o) {
      return !!(o && u.IRI_REGEX.test(o));
    }
    /**
     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIriWeak(o) {
      return !!o && o[0] !== ":" && u.IRI_REGEX_WEAK.test(o);
    }
    /**
     * Check if the given keyword is a defined according to the JSON-LD specification.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is valid.
     */
    static isValidKeyword(o) {
      return u.VALID_KEYWORDS[o];
    }
    /**
     * Check if the given term is protected in the context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {string} key A context term.
     * @return {boolean} If the given term has an @protected flag.
     */
    static isTermProtected(o, a) {
      const t = o[a];
      return typeof t != "string" && t && t["@protected"];
    }
    /**
     * Check if the given context has at least one protected term.
     * @param context A context.
     * @return If the context has a protected term.
     */
    static hasProtectedTerms(o) {
      for (const a of Object.keys(o))
        if (u.isTermProtected(o, a))
          return !0;
      return !1;
    }
    /**
     * Check if the given key is an internal reserved keyword.
     * @param key A context key.
     */
    static isReservedInternalKeyword(o) {
      return o.startsWith("@__");
    }
    /**
     * Check if two objects are deepEqual to on another.
     * @param object1 The first object to test.
     * @param object2 The second object to test.
     */
    static deepEqual(o, a) {
      const t = Object.keys(o), e = Object.keys(a);
      return t.length !== e.length ? !1 : t.every((n) => {
        const i = o[n], c = a[n];
        return i === c || i !== null && c !== null && typeof i == "object" && typeof c == "object" && this.deepEqual(i, c);
      });
    }
  }
  return u.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/, u.IRI_REGEX_WEAK = /(?::[^:])|\//, u.KEYWORD_REGEX = /^@[a-z]+$/i, u.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/, u.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/, u.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/, u.VALID_KEYWORDS = {
    "@annotation": !0,
    "@base": !0,
    "@container": !0,
    "@context": !0,
    "@direction": !0,
    "@graph": !0,
    "@id": !0,
    "@import": !0,
    "@included": !0,
    "@index": !0,
    "@json": !0,
    "@language": !0,
    "@list": !0,
    "@nest": !0,
    "@none": !0,
    "@prefix": !0,
    "@propagate": !0,
    "@protected": !0,
    "@reverse": !0,
    "@set": !0,
    "@type": !0,
    "@value": !0,
    "@version": !0,
    "@vocab": !0
  }, u.EXPAND_KEYS_BLACKLIST = [
    "@base",
    "@vocab",
    "@language",
    "@version",
    "@direction"
  ], u.ALIAS_DOMAIN_BLACKLIST = [
    "@container",
    "@graph",
    "@id",
    "@index",
    "@list",
    "@nest",
    "@none",
    "@prefix",
    "@reverse",
    "@set",
    "@type",
    "@value",
    "@version"
  ], u.ALIAS_RANGE_BLACKLIST = [
    "@context",
    "@preserve"
  ], u.CONTAINERS = [
    "@list",
    "@set",
    "@index",
    "@language",
    "@graph",
    "@id",
    "@type"
  ], u.CONTAINERS_1_0 = [
    "@list",
    "@set",
    "@index"
  ], d1.Util = u, d1;
}
var _P;
function SW() {
  return _P || (_P = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.defaultExpandOptions = u.JsonLdContextNormalized = void 0;
    const r = Tr(), o = /* @__PURE__ */ WS(), a = /* @__PURE__ */ E8();
    class t {
      constructor(n) {
        this.contextRaw = n;
      }
      /**
       * @return The raw inner context.
       */
      getContextRaw() {
        return this.contextRaw;
      }
      /**
       * Expand the term or prefix of the given term if it has one,
       * otherwise return the term as-is.
       *
       * This will try to expand the IRI as much as possible.
       *
       * Iff in vocab-mode, then other references to other terms in the context can be used,
       * such as to `myTerm`:
       * ```
       * {
       *   "myTerm": "http://example.org/myLongTerm"
       * }
       * ```
       *
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,
       *                              otherwise it is considered a regular term that is expanded based on @base.
       * @param {IExpandOptions} options Options that define the way how expansion must be done.
       * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
       * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).
       */
      expandTerm(n, i, c = u.defaultExpandOptions) {
        const s = this.contextRaw[n];
        if (s === null || s && s["@id"] === null)
          return null;
        let d = !0;
        if (s && i) {
          const _ = a.Util.getContextValueId(s);
          if (_ && _ !== n)
            if (typeof _ != "string" || !a.Util.isValidIri(_) && !a.Util.isValidKeyword(_))
              a.Util.isPotentialKeyword(_) || (d = !1);
            else
              return _;
        }
        const l = a.Util.getPrefix(n, this.contextRaw), f = this.contextRaw["@vocab"], h = (!!f || f === "") && f.indexOf(":") < 0, p = this.contextRaw["@base"], b = a.Util.isPotentialKeyword(n);
        if (l) {
          const _ = this.contextRaw[l], y = a.Util.getContextValueId(_);
          if (y) {
            if (typeof _ == "string" || !c.allowPrefixForcing) {
              if (!a.Util.isSimpleTermDefinitionPrefix(y, c))
                return n;
            } else if (y[0] !== "_" && !b && !_["@prefix"] && !(n in this.contextRaw))
              return n;
            return y + n.substr(l.length + 1);
          }
        } else if (i && (f || f === "" || c.allowVocabRelativeToBase && p && h) && !b && !a.Util.isCompactIri(n))
          if (h) {
            if (c.allowVocabRelativeToBase)
              return (f || p ? (0, r.resolve)(f, p) : "") + n;
            throw new o.ErrorCoded(`Relative vocab expansion for term '${n}' with vocab '${f}' is not allowed.`, o.ERROR_CODES.INVALID_VOCAB_MAPPING);
          } else
            return f + n;
        else if (!i && p && !b && !a.Util.isCompactIri(n))
          return (0, r.resolve)(n, p);
        if (d)
          return n;
        throw new o.ErrorCoded(`Invalid IRI mapping found for context entry '${n}': '${JSON.stringify(s)}'`, o.ERROR_CODES.INVALID_IRI_MAPPING);
      }
      /**
       * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
       *
       * This will try to compact the IRI as much as possible.
       *
       * @param {string} iri An IRI to compact.
       * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
       *                        otherwise it is considered a regular term that is compacted based on @base.
       * @return {string} The compacted term or the IRI as-is.
       */
      compactIri(n, i) {
        if (i && this.contextRaw["@vocab"] && n.startsWith(this.contextRaw["@vocab"]))
          return n.substr(this.contextRaw["@vocab"].length);
        if (!i && this.contextRaw["@base"] && n.startsWith(this.contextRaw["@base"]))
          return n.substr(this.contextRaw["@base"].length);
        const c = { prefix: "", suffix: n };
        for (const s in this.contextRaw) {
          const d = this.contextRaw[s];
          if (d && !a.Util.isPotentialKeyword(s)) {
            const l = a.Util.getContextValueId(d);
            if (n.startsWith(l)) {
              const f = n.substr(l.length);
              if (f)
                f.length < c.suffix.length && (c.prefix = s, c.suffix = f);
              else if (i)
                return s;
            }
          }
        }
        return c.prefix ? c.prefix + ":" + c.suffix : n;
      }
    }
    u.JsonLdContextNormalized = t, u.defaultExpandOptions = {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    };
  }(BA)), BA;
}
var gP;
function oue() {
  if (gP) return s1;
  gP = 1, Object.defineProperty(s1, "__esModule", { value: !0 }), s1.ContextParser = void 0;
  const u = Tr(), r = /* @__PURE__ */ WS(), o = /* @__PURE__ */ wW(), a = /* @__PURE__ */ SW(), t = /* @__PURE__ */ E8();
  class e {
    constructor(i) {
      i = i || {}, this.documentLoader = i.documentLoader || new o.FetchDocumentLoader(), this.documentCache = {}, this.validateContext = !i.skipValidation, this.expandContentTypeToBase = !!i.expandContentTypeToBase, this.remoteContextsDepthLimit = i.remoteContextsDepthLimit || 32, this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in i ? !!i.redirectSchemaOrgHttps : !0;
    }
    /**
     * Validate the given @language value.
     * An error will be thrown if it is invalid.
     * @param value An @language value.
     * @param {boolean} strictRange If the string value should be strictly checked against a regex.
     * @param {string} errorCode The error code to emit on errors.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateLanguage(i, c, s) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(i)}'`, s);
      if (!t.Util.REGEX_LANGUAGE_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(i)}'`, s);
        return !1;
      }
      return !0;
    }
    /**
     * Validate the given @direction value.
     * An error will be thrown if it is invalid.
     * @param value An @direction value.
     * @param {boolean} strictValues If the string value should be strictly checked against a regex.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateDirection(i, c) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
      if (!t.Util.REGEX_DIRECTION_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
        return !1;
      }
      return !0;
    }
    /**
     * Add an @id term for all @reverse terms.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     */
    idifyReverseTerms(i) {
      for (const c of Object.keys(i)) {
        let s = i[c];
        if (s && typeof s == "object" && s["@reverse"] && !s["@id"]) {
          if (typeof s["@reverse"] != "string" || t.Util.isValidKeyword(s["@reverse"]))
            throw new r.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${s["@reverse"]}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
          s = i[c] = Object.assign(Object.assign({}, s), { "@id": s["@reverse"] }), s["@id"] = s["@reverse"], t.Util.isPotentialKeyword(s["@reverse"]) ? delete s["@reverse"] : s["@reverse"] = !0;
        }
      }
      return i;
    }
    /**
     * Expand all prefixed terms in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
     *                                          via @base if @vocab is set to null.
     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all
     * keys in the context will be expanded.
     */
    expandPrefixedTerms(i, c, s) {
      const d = i.getContextRaw();
      for (const l of s || Object.keys(d))
        if (t.Util.EXPAND_KEYS_BLACKLIST.indexOf(l) < 0 && !t.Util.isReservedInternalKeyword(l)) {
          const f = d[l];
          if (t.Util.isPotentialKeyword(l) && t.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(l) >= 0 && (l !== "@type" || typeof d[l] == "object" && !(d[l]["@protected"] || d[l]["@container"] === "@set")))
            throw new r.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          if (t.Util.ALIAS_RANGE_BLACKLIST.indexOf(t.Util.getContextValueId(f)) >= 0)
            throw new r.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.INVALID_KEYWORD_ALIAS);
          if (f && t.Util.isPotentialKeyword(t.Util.getContextValueId(f)) && f["@prefix"] === !0)
            throw new r.ErrorCoded(`Tried to use keyword aliases as prefix: '${l}': '${JSON.stringify(f)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          for (; t.Util.isPrefixValue(d[l]); ) {
            const h = d[l];
            let p = !1;
            if (typeof h == "string")
              d[l] = i.expandTerm(h, !0), p = p || h !== d[l];
            else {
              const b = h["@id"], _ = h["@type"], y = !("@prefix" in h) || t.Util.isValidIri(l);
              if ("@id" in h)
                b != null && typeof b == "string" && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": i.expandTerm(b, !0) }), p = p || b !== d[l]["@id"]);
              else if (!t.Util.isPotentialKeyword(l) && y) {
                const m = i.expandTerm(l, !0);
                m !== l && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": m }), p = !0);
              }
              if (_ && typeof _ == "string" && _ !== "@vocab" && (!h["@container"] || !h["@container"]["@type"]) && y) {
                let m = i.expandTerm(_, !0);
                c && _ === m && (m = i.expandTerm(_, !1)), m !== _ && (p = !0, d[l] = Object.assign(Object.assign({}, d[l]), { "@type": m }));
              }
            }
            if (!p)
              break;
          }
        }
    }
    /**
     * Normalize the @language entries in the given context to lowercase.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} parseOptions The parsing options.
     */
    normalize(i, { processingMode: c, normalizeLanguageTags: s }) {
      if (s || c === 1)
        for (const d of Object.keys(i))
          if (d === "@language" && typeof i[d] == "string")
            i[d] = i[d].toLowerCase();
          else {
            const l = i[d];
            if (l && typeof l == "object" && typeof l["@language"] == "string") {
              const f = l["@language"].toLowerCase();
              f !== l["@language"] && (i[d] = Object.assign(Object.assign({}, l), { "@language": f }));
            }
          }
    }
    /**
     * Convert all @container strings and array values to hash-based values.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     */
    containersToHash(i) {
      for (const c of Object.keys(i)) {
        const s = i[c];
        if (s && typeof s == "object") {
          if (typeof s["@container"] == "string")
            i[c] = Object.assign(Object.assign({}, s), { "@container": { [s["@container"]]: !0 } });
          else if (Array.isArray(s["@container"])) {
            const d = {};
            for (const l of s["@container"])
              d[l] = !0;
            i[c] = Object.assign(Object.assign({}, s), { "@container": d });
          }
        }
      }
    }
    /**
     * Normalize and apply context-level @protected terms onto each term separately.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {number} processingMode The processing mode.
     */
    applyScopedProtected(i, { processingMode: c }, s) {
      if (c && c >= 1.1 && i["@protected"]) {
        for (const d of Object.keys(i))
          if (!t.Util.isReservedInternalKeyword(d) && !t.Util.isPotentialKeyword(d) && !t.Util.isTermProtected(i, d)) {
            const l = i[d];
            l && typeof l == "object" ? "@protected" in i[d] || (i[d] = Object.assign(Object.assign({}, i[d]), { "@protected": !0 })) : (i[d] = {
              "@id": l,
              "@protected": !0
            }, t.Util.isSimpleTermDefinitionPrefix(l, s) && (i[d] = Object.assign(Object.assign({}, i[d]), { "@prefix": !0 })));
          }
        delete i["@protected"];
      }
    }
    /**
     * Check if the given context inheritance does not contain any overrides of protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.
     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.
     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all
     * keys defined in contextAfter will be checked.
     */
    validateKeywordRedefinitions(i, c, s, d) {
      for (const l of d ?? Object.keys(c))
        if (t.Util.isTermProtected(i, l) && (typeof c[l] == "string" ? c[l] = { "@id": c[l], "@protected": !0 } : c[l] = Object.assign(Object.assign({}, c[l]), { "@protected": !0 }), !t.Util.deepEqual(i[l], c[l])))
          throw new r.ErrorCoded(`Attempted to override the protected keyword ${l} from ${JSON.stringify(t.Util.getContextValueId(i[l]))} to ${JSON.stringify(t.Util.getContextValueId(c[l]))}`, r.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
    }
    /**
     * Validate the entries of the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options The parse options.
     */
    validate(i, { processingMode: c }) {
      for (const s of Object.keys(i)) {
        if (t.Util.isReservedInternalKeyword(s))
          continue;
        if (s === "")
          throw new r.ErrorCoded(`The empty term is not allowed, got: '${s}': '${JSON.stringify(i[s])}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
        const d = i[s], l = typeof d;
        if (t.Util.isPotentialKeyword(s)) {
          switch (s.substr(1)) {
            case "vocab":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @vocab IRI: ${d}`, r.ERROR_CODES.INVALID_VOCAB_MAPPING);
              break;
            case "base":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @base IRI: ${i[s]}`, r.ERROR_CODES.INVALID_BASE_IRI);
              break;
            case "language":
              d !== null && e.validateLanguage(d, !0, r.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
              break;
            case "version":
              if (d !== null && l !== "number")
                throw new r.ErrorCoded(`Found an invalid @version number: ${d}`, r.ERROR_CODES.INVALID_VERSION_VALUE);
              break;
            case "direction":
              d !== null && e.validateDirection(d, !0);
              break;
            case "propagate":
              if (c === 1)
                throw new r.ErrorCoded(`Found an illegal @propagate keyword: ${d}`, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              if (d !== null && l !== "boolean")
                throw new r.ErrorCoded(`Found an invalid @propagate value: ${d}`, r.ERROR_CODES.INVALID_PROPAGATE_VALUE);
              break;
          }
          if (t.Util.isValidKeyword(s) && t.Util.isValidKeyword(t.Util.getContextValueId(d)))
            throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${t.Util.getContextValueId(d)}'`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          continue;
        }
        if (d !== null)
          switch (l) {
            case "string":
              if (t.Util.getPrefix(d, i) === s)
                throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
              if (t.Util.isValidIriWeak(s)) {
                if (d === "@type")
                  throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                if (t.Util.isValidIri(d) && d !== new a.JsonLdContextNormalized(i).expandTerm(s))
                  throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              }
              break;
            case "object":
              if (!t.Util.isCompactIri(s) && !("@id" in d) && (d["@type"] === "@id" ? !i["@base"] : !i["@vocab"]))
                throw new r.ErrorCoded(`Missing @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              for (const f of Object.keys(d)) {
                const h = d[f];
                if (h)
                  switch (f) {
                    case "@id":
                      if (t.Util.isValidKeyword(h) && h !== "@type" && h !== "@id" && h !== "@graph" && h !== "@nest")
                        throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.isValidIriWeak(s)) {
                        if (h === "@type")
                          throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                        if (t.Util.isValidIri(h) && h !== new a.JsonLdContextNormalized(i).expandTerm(s))
                          throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`Detected non-string @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.getPrefix(h, i) === s)
                        throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
                      break;
                    case "@type":
                      if (d["@container"] === "@type" && h !== "@id" && h !== "@vocab")
                        throw new r.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(l)}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (h !== "@id" && h !== "@vocab" && (c === 1 || h !== "@json") && (c === 1 || h !== "@none") && (h[0] === "_" || !t.Util.isValidIri(h)))
                        throw new r.ErrorCoded(`A context @type must be an absolute IRI, found: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      break;
                    case "@reverse":
                      if (typeof h == "string" && d["@id"] && d["@id"] !== h)
                        throw new r.ErrorCoded(`Found non-matching @id and @reverse term values in '${s}':'${h}' and '${d["@id"]}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      if ("@nest" in d)
                        throw new r.ErrorCoded(`@nest is not allowed in the reverse property '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      break;
                    case "@container":
                      if (c === 1 && (Object.keys(h).length > 1 || t.Util.CONTAINERS_1_0.indexOf(Object.keys(h)[0]) < 0))
                        throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${Object.keys(h)}') in 1.0, must be only one of ${t.Util.CONTAINERS_1_0.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      for (const p of Object.keys(h)) {
                        if (p === "@list" && d["@reverse"])
                          throw new r.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        if (t.Util.CONTAINERS.indexOf(p) < 0)
                          throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${p}'), must be one of ${t.Util.CONTAINERS.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      }
                      break;
                    case "@language":
                      e.validateLanguage(h, !0, r.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                      break;
                    case "@direction":
                      e.validateDirection(h, !0);
                      break;
                    case "@prefix":
                      if (h !== null && typeof h != "boolean")
                        throw new r.ErrorCoded(`Found an invalid term @prefix boolean in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_PREFIX_VALUE);
                      if (!("@id" in d) && !t.Util.isValidIri(s))
                        throw new r.ErrorCoded(`Invalid @prefix definition for '${s}' ('${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@index":
                      if (c === 1 || !d["@container"] || !d["@container"]["@index"])
                        throw new r.ErrorCoded(`Attempt to add illegal key to value object: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@nest":
                      if (t.Util.isPotentialKeyword(h) && h !== "@nest")
                        throw new r.ErrorCoded(`Found an invalid term @nest value in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_NEST_VALUE);
                  }
              }
              break;
            default:
              throw new r.ErrorCoded(`Found an invalid term value: '${s}': '${d}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          }
      }
    }
    /**
     * Apply the @base context entry to the given context under certain circumstances.
     * @param context A context.
     * @param options Parsing options.
     * @param inheritFromParent If the @base value from the parent context can be inherited.
     * @return The given context.
     */
    applyBaseEntry(i, c, s) {
      return typeof i == "string" || (s && !("@base" in i) && c.parentContext && typeof c.parentContext == "object" && "@base" in c.parentContext && (i["@base"] = c.parentContext["@base"], c.parentContext["@__baseDocument"] && (i["@__baseDocument"] = !0)), c.baseIRI && !c.external && ("@base" in i ? i["@base"] !== null && typeof i["@base"] == "string" && !t.Util.isValidIri(i["@base"]) && (i["@base"] = (0, u.resolve)(i["@base"], c.parentContext && c.parentContext["@base"] || c.baseIRI)) : (i["@base"] = c.baseIRI, i["@__baseDocument"] = !0))), i;
    }
    /**
     * Resolve relative context IRIs, or return full IRIs as-is.
     * @param {string} contextIri A context IRI.
     * @param {string} baseIRI A base IRI.
     * @return {string} The normalized context IRI.
     */
    normalizeContextIri(i, c) {
      if (!t.Util.isValidIri(i))
        try {
          i = (0, u.resolve)(i, c);
        } catch {
          throw new Error(`Invalid context IRI: ${i}`);
        }
      return this.redirectSchemaOrgHttps && i.startsWith("http://schema.org") && (i = "https://schema.org/"), i;
    }
    /**
     * Parse scoped contexts in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options Parsing options.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all
     * keys in the context will be iterated over.
     */
    async parseInnerContexts(i, c, s) {
      for (const d of s ?? Object.keys(i)) {
        const l = i[d];
        if (l && typeof l == "object" && "@context" in l && l["@context"] !== null && !c.ignoreScopedContexts) {
          if (this.validateContext)
            try {
              const f = Object.assign(Object.assign({}, i), { [d]: Object.assign({}, i[d]) });
              delete f[d]["@context"], await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, parentContext: f, ignoreProtection: !0, ignoreRemoteScopedContexts: !0, ignoreScopedContexts: !0 }));
            } catch (f) {
              throw new r.ErrorCoded(f.message, r.ERROR_CODES.INVALID_SCOPED_CONTEXT);
            }
          i[d] = Object.assign(Object.assign({}, l), { "@context": (await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, minimalProcessing: !0, ignoreRemoteScopedContexts: !0, parentContext: i }))).getContextRaw() });
        }
      }
      return i;
    }
    async parse(i, c = {}, s = {}) {
      const { baseIRI: d, parentContext: l, external: f, processingMode: h = e.DEFAULT_PROCESSING_MODE, normalizeLanguageTags: p, ignoreProtection: b, minimalProcessing: _ } = c, y = c.remoteContexts || {};
      if (Object.keys(y).length >= this.remoteContextsDepthLimit)
        throw new r.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(y), r.ERROR_CODES.CONTEXT_OVERFLOW);
      if (i == null) {
        if (!b && l && t.Util.hasProtectedTerms(l))
          throw new r.ErrorCoded("Illegal context nullification when terms are protected", r.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
        return new a.JsonLdContextNormalized(this.applyBaseEntry({}, c, !1));
      } else if (typeof i == "string") {
        const m = this.normalizeContextIri(i, d), g = this.getOverriddenLoad(m, c);
        if (g)
          return new a.JsonLdContextNormalized(g);
        const T = await this.parse(await this.load(m), Object.assign(Object.assign({}, c), { baseIRI: m, external: !0, remoteContexts: Object.assign(Object.assign({}, y), { [m]: !0 }) }));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (Array.isArray(i)) {
        const m = [], g = await Promise.all(i.map((v, E) => {
          if (typeof v == "string") {
            const R = this.normalizeContextIri(v, d);
            m[E] = R;
            const L = this.getOverriddenLoad(R, c);
            return L || this.load(R);
          } else
            return v;
        }));
        if (_)
          return new a.JsonLdContextNormalized(g);
        const T = await g.reduce((v, E, R) => v.then((L) => this.parse(
          E,
          Object.assign(Object.assign({}, c), { baseIRI: m[R] || c.baseIRI, external: !!m[R] || c.external, parentContext: L.getContextRaw(), remoteContexts: m[R] ? Object.assign(Object.assign({}, y), { [m[R]]: !0 }) : y }),
          // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers
          {
            skipValidation: R < g.length - 1
          }
        )), Promise.resolve(new a.JsonLdContextNormalized(l || {})));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (typeof i == "object") {
        if ("@context" in i)
          return await this.parse(i["@context"], c);
        if (i = Object.assign({}, i), f && delete i["@base"], this.applyBaseEntry(i, c, !0), this.containersToHash(i), _)
          return new a.JsonLdContextNormalized(i);
        let m = {};
        if ("@import" in i)
          if (h >= 1.1) {
            if (typeof i["@import"] != "string")
              throw new r.ErrorCoded("An @import value must be a string, but got " + typeof i["@import"], r.ERROR_CODES.INVALID_IMPORT_VALUE);
            m = await this.loadImportContext(this.normalizeContextIri(i["@import"], d)), delete i["@import"];
          } else
            throw new r.ErrorCoded("Context importing is not supported in JSON-LD 1.0", r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        this.applyScopedProtected(m, { processingMode: h }, a.defaultExpandOptions);
        const g = Object.assign(m, i);
        this.idifyReverseTerms(g), this.normalize(g, { processingMode: h, normalizeLanguageTags: p }), this.applyScopedProtected(g, { processingMode: h }, a.defaultExpandOptions);
        const T = Object.keys(g), v = [];
        if (typeof l == "object")
          for (const R in l)
            R in g ? v.push(R) : g[R] = l[R];
        await this.parseInnerContexts(g, c, T);
        const E = new a.JsonLdContextNormalized(g);
        return (g && g["@version"] || e.DEFAULT_PROCESSING_MODE) >= 1.1 && (i["@vocab"] && typeof i["@vocab"] == "string" || i["@vocab"] === "") && (l && "@vocab" in l && i["@vocab"].indexOf(":") < 0 ? g["@vocab"] = l["@vocab"] + i["@vocab"] : (t.Util.isCompactIri(i["@vocab"]) || i["@vocab"] in g) && (g["@vocab"] = E.expandTerm(i["@vocab"], !0))), this.expandPrefixedTerms(E, this.expandContentTypeToBase, T), !b && l && h >= 1.1 && this.validateKeywordRedefinitions(l, g, a.defaultExpandOptions, v), this.validateContext && !s.skipValidation && this.validate(g, { processingMode: h }), E;
      } else
        throw new r.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${i}`, r.ERROR_CODES.INVALID_LOCAL_CONTEXT);
    }
    /**
     * Fetch the given URL as a raw JSON-LD context.
     * @param url An URL.
     * @return A promise resolving to a raw JSON-LD context.
     */
    async load(i) {
      const c = this.documentCache[i];
      if (c)
        return c;
      let s;
      try {
        s = await this.documentLoader.load(i);
      } catch (d) {
        throw new r.ErrorCoded(`Failed to load remote context ${i}: ${d.message}`, r.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
      }
      if (!("@context" in s))
        throw new r.ErrorCoded(`Missing @context in remote context at ${i}`, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      return this.documentCache[i] = s["@context"];
    }
    /**
     * Override the given context that may be loaded.
     *
     * This will check whether or not the url is recursively being loaded.
     * @param url An URL.
     * @param options Parsing options.
     * @return An overridden context, or null.
     *         Optionally an error can be thrown if a cyclic context is detected.
     */
    getOverriddenLoad(i, c) {
      if (i in (c.remoteContexts || {})) {
        if (c.ignoreRemoteScopedContexts)
          return i;
        throw new r.ErrorCoded("Detected a cyclic context inclusion of " + i, r.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
      }
      return null;
    }
    /**
     * Load an @import'ed context.
     * @param importContextIri The full URI of an @import value.
     */
    async loadImportContext(i) {
      let c = await this.load(i);
      if (typeof c != "object" || Array.isArray(c))
        throw new r.ErrorCoded("An imported context must be a single object: " + i, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      if ("@import" in c)
        throw new r.ErrorCoded("An imported context can not import another context: " + i, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
      return c = Object.assign({}, c), this.containersToHash(c), c;
    }
  }
  return e.DEFAULT_PROCESSING_MODE = 1.1, s1.ContextParser = e, s1;
}
var $A = {}, mP;
function sue() {
  return mP || (mP = 1, Object.defineProperty($A, "__esModule", { value: !0 })), $A;
}
var UA = {}, vP;
function cue() {
  return vP || (vP = 1, Object.defineProperty(UA, "__esModule", { value: !0 })), UA;
}
var TP;
function due() {
  return TP || (TP = 1, function(u) {
    var r = fo && fo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = fo && fo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ oue(), u), o(/* @__PURE__ */ WS(), u), o(/* @__PURE__ */ wW(), u), o(/* @__PURE__ */ sue(), u), o(/* @__PURE__ */ cue(), u), o(/* @__PURE__ */ SW(), u), o(/* @__PURE__ */ E8(), u);
  }(fo)), fo;
}
var wP;
function AW() {
  if (wP) return o1;
  wP = 1, Object.defineProperty(o1, "__esModule", { value: !0 }), o1.Util = void 0;
  const u = Or(), r = /* @__PURE__ */ due(), o = ft();
  class a {
    constructor(e) {
      this.nodeHandlers = {}, this.nodeValueHandlers = {}, this.directiveNodeHandlers = {}, this.settings = e, this.dataFactory = e.dataFactory || new u.DataFactory(), this.operationFactory = new o.Factory(this.dataFactory), this.contextParser = new r.ContextParser();
    }
    /**
     * Register a new {@link NodeHandlerAdapter}.
     * @param {NodeHandlerAdapter<any>} nodeHandler A handler for converting GraphQL nodes to operations.
     */
    registerNodeHandler(e) {
      this.nodeHandlers[e.targetKind] = e;
    }
    /**
     * Register a new {@link NodeValueHandlerAdapter}
     * @param {NodeValueHandlerAdapter<any>} nodeValueHandler A handler for converting GraphQL value nodes
     *                                                        to terms and patterns.
     */
    registerNodeValueHandler(e) {
      this.nodeValueHandlers[e.targetKind] = e;
    }
    /**
     * Register a new {@link DirectiveNodeHandlerAdapter}
     * @param {DirectiveNodeHandlerAdapter} directiveNodeHandler A handler for handling GraphQL directives.
     */
    registerDirectiveNodeHandler(e) {
      this.directiveNodeHandlers[e.targetKind] = e;
    }
    /**
     * Get the operation for the given GraphQL node.
     * @param {T} node A GraphQL node.
     * @param {IConvertContext} convertContext A conversion context.
     * @return {Operation} A SPARQL algebra operation.
     */
    handleNode(e, n) {
      const i = this.nodeHandlers[e.kind];
      if (!i)
        throw new Error(`Unsupported GraphQL node '${e.kind}'`);
      return i.handle(e, n);
    }
    /**
     * Get the terms and patterns for the given value node.
     * @param {T} node A GraphQL node.
     * @param {string} fieldName The name of the field or argument in which the value was encapsulated.
     * @param {IConvertContext} convertContext A conversion context.
     * @return {IValueNodeHandlerOutput} The RDF terms and patterns.
     */
    handleNodeValue(e, n, i) {
      const c = this.nodeValueHandlers[e.kind];
      if (!c)
        throw new Error(`Unsupported GraphQL value node '${e.kind}'`);
      return c.handle(e, n, i);
    }
    /**
     * Get the handler output for the given directive.
     * @param {IDirectiveContext} directiveContext The current directive context.
     * @param {IConvertContext} convertContext A conversion context.
     * @return {IDirectiveNodeHandlerOutput} The directive node handler output or null.
     */
    handleDirectiveNode(e, n) {
      const i = this.directiveNodeHandlers[e.directive.name.value];
      return i ? i.handle(e, n) : null;
    }
    /**
     * Join the given array of operations.
     * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.
     * @param {Operation[]} operations An array of operations.
     * @return {Operation} A single joined operation.
     */
    joinOperations(e) {
      if (e.length === 1)
        return e[0];
      const n = [], i = [];
      for (const c of e)
        c.type === "bgp" ? n.push(c) : i.push(c);
      if (n.length === e.length)
        return this.joinOperationsAsBgp(n);
      if (n.length === e.length - 1 && i[0].type === "leftjoin" && i[0].input[0].type === "bgp") {
        const c = i[0];
        return n.push(c.input[0]), this.operationFactory.createLeftJoin(this.joinOperationsAsBgp(n), c.input[1]);
      } else return i.length === e.length ? this.joinOperationsAsNestedJoin(i) : this.joinOperationsAsNestedJoin([
        this.joinOperationsAsBgp(n),
        this.joinOperationsAsNestedJoin(i)
      ]);
    }
    joinOperationsAsBgp(e) {
      return this.operationFactory.createBgp([].concat.apply([], e.map((n) => n.patterns)));
    }
    joinOperationsAsNestedJoin(e) {
      return this.operationFactory.createJoin(e);
    }
    /**
     * Append a field's label to a path.
     * @param {string[]} path A path.
     * @param {string} fieldLabel A field label.
     * @return {string[]} A new path array.
     */
    appendFieldToPath(e, n) {
      return e.concat([n]);
    }
    /**
     * Get the label of a field by taking into account the alias.
     * @param {FieldNode} field A field node.
     * @return {string} The field name or alias.
     */
    getFieldLabel(e) {
      return (e.alias ? e.alias : e.name).value;
    }
    /**
     * Convert a field node to a variable built from the node name and the current path inside the context.
     * @param {string} fieldLabel A field label.
     * @param {IConvertContext} convertContext A convert context.
     * @param {string} variableDelimiter A variable delimiter.
     * @return {Variable} A variable.
     */
    nameToVariable(e, n) {
      return this.dataFactory.variable((n.path.length ? n.path.join(this.settings.variableDelimiter) + this.settings.variableDelimiter : "") + e);
    }
    /**
     * Convert a GraphQL term into a URI using the given context.
     * @param {string} value A GraphQL term.
     * @param {IContext} context A JSON-LD context.
     * @return {NamedNode} A named node.
     */
    valueToNamedNode(e, n) {
      const i = n.expandTerm(e, !0);
      if (this.settings.requireContext && !i)
        throw new Error("No context entry was found for " + e);
      return this.dataFactory.namedNode(i || e);
    }
    /**
     * Get an argument by name.
     * This will return null if the argument could not be found.
     * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.
     * @param {string} name The name of an argument.
     * @return {ArgumentNode} The named argument.
     */
    getArgument(e, n) {
      if (e) {
        for (const i of e)
          if (i.name.value === n)
            return i;
      }
    }
    /**
     * Create a pattern with an rdf:type predicate.
     * @param {Term} subject The subject.
     * @param {NamedTypeNode} typeCondition The object name.
     * @param {IConvertContext} convertContext A convert context.
     * @return {Pattern} A pattern.
     */
    newTypePattern(e, n, i) {
      return this.operationFactory.createPattern(e, this.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), this.valueToNamedNode(n.name.value, i.context), i.graph);
    }
    /**
     * Create a quad pattern when the predicate is a name node that needs to be translated using the context.
     * @param {Term} subject The subject.
     * @param {NameNode} predicateName The name node for the predicate.
     * @param {Term} object The object.
     * @param {Term} graph The graph.
     * @param {IContext} context A context.
     * @return {Pattern} A quad pattern.
     */
    createQuadPattern(e, n, i, c, s) {
      const d = this.valueToNamedNode(n.value, s);
      return s && s.getContextRaw()[n.value] && s.getContextRaw()[n.value]["@reverse"] ? this.operationFactory.createPattern(i, d, e, c) : this.operationFactory.createPattern(e, d, i, c);
    }
    /**
     * Create a quad path when the predicate is a list node with field alternatives
     * that need to be translated using the context.
     * @param {Term} subject The subject.
     * @param {NameNode} predicateName The name node for the predicate.
     * @param {Term} object The object.
     * @param {Term} graph The graph.
     * @param {IContext} context A context.
     * @return {Path} A quad property path.
     */
    createQuadPath(e, n, i, c, s, d) {
      const l = this.valueToNamedNode(n.value, d);
      let f = this.operationFactory.createLink(l);
      for (const h of i.values) {
        if (h.kind !== "EnumValue")
          throw new Error("Invalid value type for 'alt' argument, must be EnumValue, but got " + h.kind);
        f = this.operationFactory.createAlt([
          f,
          this.operationFactory.createLink(this.valueToNamedNode(h.value, d))
        ]);
      }
      return d && d.getContextRaw()[n.value] && d.getContextRaw()[n.value]["@reverse"] ? this.operationFactory.createPath(c, f, e, s) : this.operationFactory.createPath(e, f, c, s);
    }
  }
  return o1.Util = a, o1;
}
var SP;
function lue() {
  if (SP) return lo;
  SP = 1;
  var u = lo && lo.__awaiter || function(i, c, s, d) {
    function l(f) {
      return f instanceof s ? f : new s(function(h) {
        h(f);
      });
    }
    return new (s || (s = Promise))(function(f, h) {
      function p(y) {
        try {
          _(d.next(y));
        } catch (m) {
          h(m);
        }
      }
      function b(y) {
        try {
          _(d.throw(y));
        } catch (m) {
          h(m);
        }
      }
      function _(y) {
        y.done ? f(y.value) : l(y.value).then(p, b);
      }
      _((d = d.apply(i, c || [])).next());
    });
  };
  Object.defineProperty(lo, "__esModule", { value: !0 }), lo.Converter = void 0;
  const r = aue, o = aW(), a = iW(), t = Sw(), e = AW();
  class n {
    constructor(c) {
      c = c || {}, c.variableDelimiter = c.variableDelimiter || "_", c.expressionVariableCounter = c.expressionVariableCounter || 0, this.util = new e.Util(c), this.initializeNodeHandlers(c);
    }
    static registerNodeHandlers(c, s) {
      c.registerNodeHandler(new o.NodeHandlerDocument(c, s)), c.registerNodeHandler(new o.NodeHandlerDefinitionOperation(c, s)), c.registerNodeHandler(new o.NodeHandlerDefinitionFragment(c, s)), c.registerNodeHandler(new o.NodeHandlerSelectionFragmentSpread(c, s)), c.registerNodeHandler(new o.NodeHandlerSelectionInlineFragment(c, s)), c.registerNodeHandler(new o.NodeHandlerSelectionField(c, s));
    }
    static registerNodeValueHandlers(c, s) {
      c.registerNodeValueHandler(new o.NodeValueHandlerVariable(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerInt(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerFloat(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerString(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerBoolean(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerNull(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerEnum(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerList(c, s)), c.registerNodeValueHandler(new o.NodeValueHandlerObject(c, s));
    }
    static registerDirectiveNodeHandlers(c, s) {
      c.registerDirectiveNodeHandler(new a.DirectiveNodeHandlerInclude(c, s)), c.registerDirectiveNodeHandler(new a.DirectiveNodeHandlerOptional(c, s)), c.registerDirectiveNodeHandler(new a.DirectiveNodeHandlerPlural(c, s)), c.registerDirectiveNodeHandler(new a.DirectiveNodeHandlerSingle(c, s)), c.registerDirectiveNodeHandler(new a.DirectiveNodeHandlerSkip(c, s));
    }
    /**
     * Translates a GraphQL query into SPARQL algebra.
     * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.
     * @param {IContext} context A JSON-LD context.
     * @param {IConvertOptions} options An options object.
     * @return {Promise<Operation>} A promise resolving to an operation.
     */
    graphqlToSparqlAlgebra(c, s, d) {
      return u(this, void 0, void 0, function* () {
        return this.graphqlToSparqlAlgebraRawContext(c, yield this.util.contextParser.parse(s), d);
      });
    }
    /**
     * Translates a GraphQL query into SPARQL algebra.
     * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.
     * @param {IContext} context A JSON-LD context.
     * @param {IConvertOptions} options An options object.
     * @return {Operation} An operation.
     */
    graphqlToSparqlAlgebraRawContext(c, s, d) {
      d = d || {};
      const l = typeof c == "string" ? (0, r.parse)(c) : c, f = this.indexFragments(l), h = {
        context: s,
        fragmentDefinitions: f,
        graph: this.util.dataFactory.defaultGraph(),
        path: [],
        singularizeState: t.SingularizeState.PLURAL,
        singularizeVariables: d.singularizeVariables || {},
        subject: null,
        terminalVariables: [],
        variablesDict: d.variablesDict || {},
        variablesMetaDict: {}
      };
      return this.util.handleNode(l, h);
    }
    /**
     * Create an index of all fragment definitions in the given document.
     *
     * This will assign a new array of definition nodes without fragment definition.
     *
     * @param {DocumentNode} document A document node.
     * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.
     */
    indexFragments(c) {
      const s = {}, d = [];
      for (const l of c.definitions)
        l.kind === "FragmentDefinition" ? s[l.name.value] = l : d.push(l);
      return c.definitions = d, s;
    }
    initializeNodeHandlers(c) {
      n.registerNodeHandlers(this.util, c), n.registerNodeValueHandlers(this.util, c), n.registerDirectiveNodeHandlers(this.util, c);
    }
  }
  return lo.Converter = n, lo;
}
var VA = {}, AP;
function fue() {
  return AP || (AP = 1, Object.defineProperty(VA, "__esModule", { value: !0 })), VA;
}
var EP;
function hue() {
  return EP || (EP = 1, function(u) {
    var r = uo && uo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = uo && uo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(aW(), u), o(lue(), u), o(Sw(), u), o(fue(), u), o(AW(), u);
  }(uo)), uo;
}
var OP;
function pue() {
  if (OP) return jp;
  OP = 1, Object.defineProperty(jp, "__esModule", { value: !0 }), jp.ActorQueryParseGraphql = void 0;
  const u = /* @__PURE__ */ nW(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = hue();
  let t = class extends u.ActorQueryParse {
    constructor(n) {
      super(n), this.graphqlToSparql = new a.Converter({ requireContext: !0 });
    }
    async test(n) {
      var i;
      return ((i = n.queryFormat) == null ? void 0 : i.language) !== "graphql" ? (0, o.failTest)("This actor can only parse GraphQL queries") : (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.get(r.KeysInitQuery.jsonLdContext) || {}, c = {
        // eslint-disable-next-line ts/no-unnecessary-type-assertion
        singularizeVariables: n.context.get(r.KeysInitQuery.graphqlSingularizeVariables)
      };
      return { operation: await this.graphqlToSparql.graphqlToSparqlAlgebra(n.query, i, c) };
    }
  };
  return jp.ActorQueryParseGraphql = t, jp;
}
var xP;
function bue() {
  return xP || (xP = 1, function(u) {
    var r = ao && ao.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ao && ao.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ pue(), u);
  }(ao)), ao;
}
var po = {}, l1 = {}, bo = {}, f1 = {}, yo = {}, h1 = {}, IP;
function EW() {
  if (IP) return h1;
  IP = 1, Object.defineProperty(h1, "__esModule", { value: !0 }), h1.ActorAbstractMediaTyped = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    constructor(a) {
      super(a);
    }
    async run(a) {
      if ("handle" in a) {
        const t = a;
        return { handle: await this.runHandle(t.handle, t.handleMediaType, a.context) };
      }
      if ("mediaTypes" in a)
        return { mediaTypes: await this.getMediaTypes(a.context) };
      if ("mediaTypeFormats" in a)
        return { mediaTypeFormats: await this.getMediaTypeFormats(a.context) };
      throw new Error("Either a handle, mediaTypes or mediaTypeFormats action needs to be provided");
    }
    async test(a) {
      if ("handle" in a) {
        const t = a;
        return (await this.testHandle(t.handle, t.handleMediaType, a.context)).map((e) => ({ handle: e }));
      }
      return "mediaTypes" in a ? (await this.testMediaType(a.context)).map((t) => ({ mediaTypes: t })) : "mediaTypeFormats" in a ? (await this.testMediaTypeFormats(a.context)).map((t) => ({ mediaTypeFormats: t })) : (0, u.failTest)("Either a handle, mediaTypes or mediaTypeFormats action needs to be provided");
    }
  };
  return h1.ActorAbstractMediaTyped = r, h1;
}
var p1 = {}, RP;
function yue() {
  if (RP) return p1;
  RP = 1, Object.defineProperty(p1, "__esModule", { value: !0 }), p1.ActorAbstractMediaTypedFixed = void 0;
  const u = /* @__PURE__ */ _e(), r = /* @__PURE__ */ EW();
  let o = class extends r.ActorAbstractMediaTyped {
    constructor(t) {
      super(t);
      const e = this.priorityScale || this.priorityScale === 0 ? this.priorityScale : 1;
      if (this.mediaTypePriorities)
        for (const [n, [i, c]] of Object.entries(this.mediaTypePriorities).entries())
          this.mediaTypePriorities[i] = e * c;
      this.mediaTypePriorities = Object.freeze(this.mediaTypePriorities), this.mediaTypeFormats = Object.freeze(this.mediaTypeFormats);
    }
    async testHandle(t, e, n) {
      return !e || !(e in this.mediaTypePriorities) ? (0, u.failTest)(`Unrecognized media type: ${e}`) : await this.testHandleChecked(t, n);
    }
    async testMediaType(t) {
      return (0, u.passTestVoid)();
    }
    async getMediaTypes(t) {
      return this.mediaTypePriorities;
    }
    async testMediaTypeFormats(t) {
      return (0, u.passTestVoid)();
    }
    async getMediaTypeFormats(t) {
      return this.mediaTypeFormats;
    }
  };
  return p1.ActorAbstractMediaTypedFixed = o, p1;
}
var FP;
function ph() {
  return FP || (FP = 1, function(u) {
    var r = yo && yo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = yo && yo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ EW(), u), o(/* @__PURE__ */ yue(), u);
  }(yo)), yo;
}
var NP;
function _ue() {
  if (NP) return f1;
  NP = 1, Object.defineProperty(f1, "__esModule", { value: !0 }), f1.ActorQueryResultSerialize = void 0;
  const u = /* @__PURE__ */ ph();
  let r = class extends u.ActorAbstractMediaTyped {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return f1.ActorQueryResultSerialize = r, f1;
}
var b1 = {}, PP;
function gue() {
  if (PP) return b1;
  PP = 1, Object.defineProperty(b1, "__esModule", { value: !0 }), b1.ActorQueryResultSerializeFixedMediaTypes = void 0;
  const u = /* @__PURE__ */ ph(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorAbstractMediaTypedFixed {
    /* eslint-disable max-len */
    /**
     * TODO: rm this (and eslint-disable) once we remove the abstract media typed actor
     * @param args -
     *   \ @defaultNested {<cbqrs:components/ActorQueryResultSerialize.jsonld#ActorQueryResultSerialize_default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}} busFailMessage
     */
    constructor(t) {
      super(t);
    }
    /* eslint-enable max-len */
    async testHandleChecked(t, e) {
      return (0, r.passTestVoid)();
    }
  };
  return b1.ActorQueryResultSerializeFixedMediaTypes = o, b1;
}
var DP;
function Ci() {
  return DP || (DP = 1, function(u) {
    var r = bo && bo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bo && bo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _ue(), u), o(/* @__PURE__ */ gue(), u);
  }(bo)), bo;
}
var QA = { exports: {} }, HA = { exports: {} }, GA = {}, y1 = {}, LP;
function mue() {
  if (LP) return y1;
  LP = 1, y1.byteLength = i, y1.toByteArray = s, y1.fromByteArray = f;
  for (var u = [], r = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, e = a.length; t < e; ++t)
    u[t] = a[t], r[a.charCodeAt(t)] = t;
  r[45] = 62, r[95] = 63;
  function n(h) {
    var p = h.length;
    if (p % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var b = h.indexOf("=");
    b === -1 && (b = p);
    var _ = b === p ? 0 : 4 - b % 4;
    return [b, _];
  }
  function i(h) {
    var p = n(h), b = p[0], _ = p[1];
    return (b + _) * 3 / 4 - _;
  }
  function c(h, p, b) {
    return (p + b) * 3 / 4 - b;
  }
  function s(h) {
    var p, b = n(h), _ = b[0], y = b[1], m = new o(c(h, _, y)), g = 0, T = y > 0 ? _ - 4 : _, v;
    for (v = 0; v < T; v += 4)
      p = r[h.charCodeAt(v)] << 18 | r[h.charCodeAt(v + 1)] << 12 | r[h.charCodeAt(v + 2)] << 6 | r[h.charCodeAt(v + 3)], m[g++] = p >> 16 & 255, m[g++] = p >> 8 & 255, m[g++] = p & 255;
    return y === 2 && (p = r[h.charCodeAt(v)] << 2 | r[h.charCodeAt(v + 1)] >> 4, m[g++] = p & 255), y === 1 && (p = r[h.charCodeAt(v)] << 10 | r[h.charCodeAt(v + 1)] << 4 | r[h.charCodeAt(v + 2)] >> 2, m[g++] = p >> 8 & 255, m[g++] = p & 255), m;
  }
  function d(h) {
    return u[h >> 18 & 63] + u[h >> 12 & 63] + u[h >> 6 & 63] + u[h & 63];
  }
  function l(h, p, b) {
    for (var _, y = [], m = p; m < b; m += 3)
      _ = (h[m] << 16 & 16711680) + (h[m + 1] << 8 & 65280) + (h[m + 2] & 255), y.push(d(_));
    return y.join("");
  }
  function f(h) {
    for (var p, b = h.length, _ = b % 3, y = [], m = 16383, g = 0, T = b - _; g < T; g += m)
      y.push(l(h, g, g + m > T ? T : g + m));
    return _ === 1 ? (p = h[b - 1], y.push(
      u[p >> 2] + u[p << 4 & 63] + "=="
    )) : _ === 2 && (p = (h[b - 2] << 8) + h[b - 1], y.push(
      u[p >> 10] + u[p >> 4 & 63] + u[p << 2 & 63] + "="
    )), y.join("");
  }
  return y1;
}
var s6 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var jP;
function vue() {
  return jP || (jP = 1, s6.read = function(u, r, o, a, t) {
    var e, n, i = t * 8 - a - 1, c = (1 << i) - 1, s = c >> 1, d = -7, l = o ? t - 1 : 0, f = o ? -1 : 1, h = u[r + l];
    for (l += f, e = h & (1 << -d) - 1, h >>= -d, d += i; d > 0; e = e * 256 + u[r + l], l += f, d -= 8)
      ;
    for (n = e & (1 << -d) - 1, e >>= -d, d += a; d > 0; n = n * 256 + u[r + l], l += f, d -= 8)
      ;
    if (e === 0)
      e = 1 - s;
    else {
      if (e === c)
        return n ? NaN : (h ? -1 : 1) * (1 / 0);
      n = n + Math.pow(2, a), e = e - s;
    }
    return (h ? -1 : 1) * n * Math.pow(2, e - a);
  }, s6.write = function(u, r, o, a, t, e) {
    var n, i, c, s = e * 8 - t - 1, d = (1 << s) - 1, l = d >> 1, f = t === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = a ? 0 : e - 1, p = a ? 1 : -1, b = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (i = isNaN(r) ? 1 : 0, n = d) : (n = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -n)) < 1 && (n--, c *= 2), n + l >= 1 ? r += f / c : r += f * Math.pow(2, 1 - l), r * c >= 2 && (n++, c /= 2), n + l >= d ? (i = 0, n = d) : n + l >= 1 ? (i = (r * c - 1) * Math.pow(2, t), n = n + l) : (i = r * Math.pow(2, l - 1) * Math.pow(2, t), n = 0)); t >= 8; u[o + h] = i & 255, h += p, i /= 256, t -= 8)
      ;
    for (n = n << t | i, s += t; s > 0; u[o + h] = n & 255, h += p, n /= 256, s -= 8)
      ;
    u[o + h - p] |= b * 128;
  }), s6;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var MP;
function qi() {
  return MP || (MP = 1, function(u) {
    const r = mue(), o = vue(), a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    u.Buffer = i, u.SlowBuffer = m, u.INSPECT_MAX_BYTES = 50;
    const t = 2147483647;
    u.kMaxLength = t, i.TYPED_ARRAY_SUPPORT = e(), !i.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function e() {
      try {
        const $ = new Uint8Array(1), D = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(D, Uint8Array.prototype), Object.setPrototypeOf($, D), $.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(i.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (i.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(i.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (i.isBuffer(this))
          return this.byteOffset;
      }
    });
    function n($) {
      if ($ > t)
        throw new RangeError('The value "' + $ + '" is invalid for option "size"');
      const D = new Uint8Array($);
      return Object.setPrototypeOf(D, i.prototype), D;
    }
    function i($, D, C) {
      if (typeof $ == "number") {
        if (typeof D == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return l($);
      }
      return c($, D, C);
    }
    i.poolSize = 8192;
    function c($, D, C) {
      if (typeof $ == "string")
        return f($, D);
      if (ArrayBuffer.isView($))
        return p($);
      if ($ == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
        );
      if (fe($, ArrayBuffer) || $ && fe($.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fe($, SharedArrayBuffer) || $ && fe($.buffer, SharedArrayBuffer)))
        return b($, D, C);
      if (typeof $ == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const X = $.valueOf && $.valueOf();
      if (X != null && X !== $)
        return i.from(X, D, C);
      const te = _($);
      if (te) return te;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] == "function")
        return i.from($[Symbol.toPrimitive]("string"), D, C);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
      );
    }
    i.from = function($, D, C) {
      return c($, D, C);
    }, Object.setPrototypeOf(i.prototype, Uint8Array.prototype), Object.setPrototypeOf(i, Uint8Array);
    function s($) {
      if (typeof $ != "number")
        throw new TypeError('"size" argument must be of type number');
      if ($ < 0)
        throw new RangeError('The value "' + $ + '" is invalid for option "size"');
    }
    function d($, D, C) {
      return s($), $ <= 0 ? n($) : D !== void 0 ? typeof C == "string" ? n($).fill(D, C) : n($).fill(D) : n($);
    }
    i.alloc = function($, D, C) {
      return d($, D, C);
    };
    function l($) {
      return s($), n($ < 0 ? 0 : y($) | 0);
    }
    i.allocUnsafe = function($) {
      return l($);
    }, i.allocUnsafeSlow = function($) {
      return l($);
    };
    function f($, D) {
      if ((typeof D != "string" || D === "") && (D = "utf8"), !i.isEncoding(D))
        throw new TypeError("Unknown encoding: " + D);
      const C = g($, D) | 0;
      let X = n(C);
      const te = X.write($, D);
      return te !== C && (X = X.slice(0, te)), X;
    }
    function h($) {
      const D = $.length < 0 ? 0 : y($.length) | 0, C = n(D);
      for (let X = 0; X < D; X += 1)
        C[X] = $[X] & 255;
      return C;
    }
    function p($) {
      if (fe($, Uint8Array)) {
        const D = new Uint8Array($);
        return b(D.buffer, D.byteOffset, D.byteLength);
      }
      return h($);
    }
    function b($, D, C) {
      if (D < 0 || $.byteLength < D)
        throw new RangeError('"offset" is outside of buffer bounds');
      if ($.byteLength < D + (C || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let X;
      return D === void 0 && C === void 0 ? X = new Uint8Array($) : C === void 0 ? X = new Uint8Array($, D) : X = new Uint8Array($, D, C), Object.setPrototypeOf(X, i.prototype), X;
    }
    function _($) {
      if (i.isBuffer($)) {
        const D = y($.length) | 0, C = n(D);
        return C.length === 0 || $.copy(C, 0, 0, D), C;
      }
      if ($.length !== void 0)
        return typeof $.length != "number" || me($.length) ? n(0) : h($);
      if ($.type === "Buffer" && Array.isArray($.data))
        return h($.data);
    }
    function y($) {
      if ($ >= t)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + t.toString(16) + " bytes");
      return $ | 0;
    }
    function m($) {
      return +$ != $ && ($ = 0), i.alloc(+$);
    }
    i.isBuffer = function(D) {
      return D != null && D._isBuffer === !0 && D !== i.prototype;
    }, i.compare = function(D, C) {
      if (fe(D, Uint8Array) && (D = i.from(D, D.offset, D.byteLength)), fe(C, Uint8Array) && (C = i.from(C, C.offset, C.byteLength)), !i.isBuffer(D) || !i.isBuffer(C))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (D === C) return 0;
      let X = D.length, te = C.length;
      for (let de = 0, oe = Math.min(X, te); de < oe; ++de)
        if (D[de] !== C[de]) {
          X = D[de], te = C[de];
          break;
        }
      return X < te ? -1 : te < X ? 1 : 0;
    }, i.isEncoding = function(D) {
      switch (String(D).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, i.concat = function(D, C) {
      if (!Array.isArray(D))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (D.length === 0)
        return i.alloc(0);
      let X;
      if (C === void 0)
        for (C = 0, X = 0; X < D.length; ++X)
          C += D[X].length;
      const te = i.allocUnsafe(C);
      let de = 0;
      for (X = 0; X < D.length; ++X) {
        let oe = D[X];
        if (fe(oe, Uint8Array))
          de + oe.length > te.length ? (i.isBuffer(oe) || (oe = i.from(oe)), oe.copy(te, de)) : Uint8Array.prototype.set.call(
            te,
            oe,
            de
          );
        else if (i.isBuffer(oe))
          oe.copy(te, de);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        de += oe.length;
      }
      return te;
    };
    function g($, D) {
      if (i.isBuffer($))
        return $.length;
      if (ArrayBuffer.isView($) || fe($, ArrayBuffer))
        return $.byteLength;
      if (typeof $ != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $
        );
      const C = $.length, X = arguments.length > 2 && arguments[2] === !0;
      if (!X && C === 0) return 0;
      let te = !1;
      for (; ; )
        switch (D) {
          case "ascii":
          case "latin1":
          case "binary":
            return C;
          case "utf8":
          case "utf-8":
            return H($).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return C * 2;
          case "hex":
            return C >>> 1;
          case "base64":
            return W($).length;
          default:
            if (te)
              return X ? -1 : H($).length;
            D = ("" + D).toLowerCase(), te = !0;
        }
    }
    i.byteLength = g;
    function T($, D, C) {
      let X = !1;
      if ((D === void 0 || D < 0) && (D = 0), D > this.length || ((C === void 0 || C > this.length) && (C = this.length), C <= 0) || (C >>>= 0, D >>>= 0, C <= D))
        return "";
      for ($ || ($ = "utf8"); ; )
        switch ($) {
          case "hex":
            return K(this, D, C);
          case "utf8":
          case "utf-8":
            return F(this, D, C);
          case "ascii":
            return Q(this, D, C);
          case "latin1":
          case "binary":
            return G(this, D, C);
          case "base64":
            return x(this, D, C);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U(this, D, C);
          default:
            if (X) throw new TypeError("Unknown encoding: " + $);
            $ = ($ + "").toLowerCase(), X = !0;
        }
    }
    i.prototype._isBuffer = !0;
    function v($, D, C) {
      const X = $[D];
      $[D] = $[C], $[C] = X;
    }
    i.prototype.swap16 = function() {
      const D = this.length;
      if (D % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let C = 0; C < D; C += 2)
        v(this, C, C + 1);
      return this;
    }, i.prototype.swap32 = function() {
      const D = this.length;
      if (D % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let C = 0; C < D; C += 4)
        v(this, C, C + 3), v(this, C + 1, C + 2);
      return this;
    }, i.prototype.swap64 = function() {
      const D = this.length;
      if (D % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let C = 0; C < D; C += 8)
        v(this, C, C + 7), v(this, C + 1, C + 6), v(this, C + 2, C + 5), v(this, C + 3, C + 4);
      return this;
    }, i.prototype.toString = function() {
      const D = this.length;
      return D === 0 ? "" : arguments.length === 0 ? F(this, 0, D) : T.apply(this, arguments);
    }, i.prototype.toLocaleString = i.prototype.toString, i.prototype.equals = function(D) {
      if (!i.isBuffer(D)) throw new TypeError("Argument must be a Buffer");
      return this === D ? !0 : i.compare(this, D) === 0;
    }, i.prototype.inspect = function() {
      let D = "";
      const C = u.INSPECT_MAX_BYTES;
      return D = this.toString("hex", 0, C).replace(/(.{2})/g, "$1 ").trim(), this.length > C && (D += " ... "), "<Buffer " + D + ">";
    }, a && (i.prototype[a] = i.prototype.inspect), i.prototype.compare = function(D, C, X, te, de) {
      if (fe(D, Uint8Array) && (D = i.from(D, D.offset, D.byteLength)), !i.isBuffer(D))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof D
        );
      if (C === void 0 && (C = 0), X === void 0 && (X = D ? D.length : 0), te === void 0 && (te = 0), de === void 0 && (de = this.length), C < 0 || X > D.length || te < 0 || de > this.length)
        throw new RangeError("out of range index");
      if (te >= de && C >= X)
        return 0;
      if (te >= de)
        return -1;
      if (C >= X)
        return 1;
      if (C >>>= 0, X >>>= 0, te >>>= 0, de >>>= 0, this === D) return 0;
      let oe = de - te, De = X - C;
      const Ve = Math.min(oe, De), qe = this.slice(te, de), Ke = D.slice(C, X);
      for (let Y = 0; Y < Ve; ++Y)
        if (qe[Y] !== Ke[Y]) {
          oe = qe[Y], De = Ke[Y];
          break;
        }
      return oe < De ? -1 : De < oe ? 1 : 0;
    };
    function E($, D, C, X, te) {
      if ($.length === 0) return -1;
      if (typeof C == "string" ? (X = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), C = +C, me(C) && (C = te ? 0 : $.length - 1), C < 0 && (C = $.length + C), C >= $.length) {
        if (te) return -1;
        C = $.length - 1;
      } else if (C < 0)
        if (te) C = 0;
        else return -1;
      if (typeof D == "string" && (D = i.from(D, X)), i.isBuffer(D))
        return D.length === 0 ? -1 : R($, D, C, X, te);
      if (typeof D == "number")
        return D = D & 255, typeof Uint8Array.prototype.indexOf == "function" ? te ? Uint8Array.prototype.indexOf.call($, D, C) : Uint8Array.prototype.lastIndexOf.call($, D, C) : R($, [D], C, X, te);
      throw new TypeError("val must be string, number or Buffer");
    }
    function R($, D, C, X, te) {
      let de = 1, oe = $.length, De = D.length;
      if (X !== void 0 && (X = String(X).toLowerCase(), X === "ucs2" || X === "ucs-2" || X === "utf16le" || X === "utf-16le")) {
        if ($.length < 2 || D.length < 2)
          return -1;
        de = 2, oe /= 2, De /= 2, C /= 2;
      }
      function Ve(Ke, Y) {
        return de === 1 ? Ke[Y] : Ke.readUInt16BE(Y * de);
      }
      let qe;
      if (te) {
        let Ke = -1;
        for (qe = C; qe < oe; qe++)
          if (Ve($, qe) === Ve(D, Ke === -1 ? 0 : qe - Ke)) {
            if (Ke === -1 && (Ke = qe), qe - Ke + 1 === De) return Ke * de;
          } else
            Ke !== -1 && (qe -= qe - Ke), Ke = -1;
      } else
        for (C + De > oe && (C = oe - De), qe = C; qe >= 0; qe--) {
          let Ke = !0;
          for (let Y = 0; Y < De; Y++)
            if (Ve($, qe + Y) !== Ve(D, Y)) {
              Ke = !1;
              break;
            }
          if (Ke) return qe;
        }
      return -1;
    }
    i.prototype.includes = function(D, C, X) {
      return this.indexOf(D, C, X) !== -1;
    }, i.prototype.indexOf = function(D, C, X) {
      return E(this, D, C, X, !0);
    }, i.prototype.lastIndexOf = function(D, C, X) {
      return E(this, D, C, X, !1);
    };
    function L($, D, C, X) {
      C = Number(C) || 0;
      const te = $.length - C;
      X ? (X = Number(X), X > te && (X = te)) : X = te;
      const de = D.length;
      X > de / 2 && (X = de / 2);
      let oe;
      for (oe = 0; oe < X; ++oe) {
        const De = parseInt(D.substr(oe * 2, 2), 16);
        if (me(De)) return oe;
        $[C + oe] = De;
      }
      return oe;
    }
    function A($, D, C, X) {
      return le(H(D, $.length - C), $, C, X);
    }
    function w($, D, C, X) {
      return le(J(D), $, C, X);
    }
    function S($, D, C, X) {
      return le(W(D), $, C, X);
    }
    function O($, D, C, X) {
      return le(k(D, $.length - C), $, C, X);
    }
    i.prototype.write = function(D, C, X, te) {
      if (C === void 0)
        te = "utf8", X = this.length, C = 0;
      else if (X === void 0 && typeof C == "string")
        te = C, X = this.length, C = 0;
      else if (isFinite(C))
        C = C >>> 0, isFinite(X) ? (X = X >>> 0, te === void 0 && (te = "utf8")) : (te = X, X = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const de = this.length - C;
      if ((X === void 0 || X > de) && (X = de), D.length > 0 && (X < 0 || C < 0) || C > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      te || (te = "utf8");
      let oe = !1;
      for (; ; )
        switch (te) {
          case "hex":
            return L(this, D, C, X);
          case "utf8":
          case "utf-8":
            return A(this, D, C, X);
          case "ascii":
          case "latin1":
          case "binary":
            return w(this, D, C, X);
          case "base64":
            return S(this, D, C, X);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return O(this, D, C, X);
          default:
            if (oe) throw new TypeError("Unknown encoding: " + te);
            te = ("" + te).toLowerCase(), oe = !0;
        }
    }, i.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function x($, D, C) {
      return D === 0 && C === $.length ? r.fromByteArray($) : r.fromByteArray($.slice(D, C));
    }
    function F($, D, C) {
      C = Math.min($.length, C);
      const X = [];
      let te = D;
      for (; te < C; ) {
        const de = $[te];
        let oe = null, De = de > 239 ? 4 : de > 223 ? 3 : de > 191 ? 2 : 1;
        if (te + De <= C) {
          let Ve, qe, Ke, Y;
          switch (De) {
            case 1:
              de < 128 && (oe = de);
              break;
            case 2:
              Ve = $[te + 1], (Ve & 192) === 128 && (Y = (de & 31) << 6 | Ve & 63, Y > 127 && (oe = Y));
              break;
            case 3:
              Ve = $[te + 1], qe = $[te + 2], (Ve & 192) === 128 && (qe & 192) === 128 && (Y = (de & 15) << 12 | (Ve & 63) << 6 | qe & 63, Y > 2047 && (Y < 55296 || Y > 57343) && (oe = Y));
              break;
            case 4:
              Ve = $[te + 1], qe = $[te + 2], Ke = $[te + 3], (Ve & 192) === 128 && (qe & 192) === 128 && (Ke & 192) === 128 && (Y = (de & 15) << 18 | (Ve & 63) << 12 | (qe & 63) << 6 | Ke & 63, Y > 65535 && Y < 1114112 && (oe = Y));
          }
        }
        oe === null ? (oe = 65533, De = 1) : oe > 65535 && (oe -= 65536, X.push(oe >>> 10 & 1023 | 55296), oe = 56320 | oe & 1023), X.push(oe), te += De;
      }
      return q(X);
    }
    const j = 4096;
    function q($) {
      const D = $.length;
      if (D <= j)
        return String.fromCharCode.apply(String, $);
      let C = "", X = 0;
      for (; X < D; )
        C += String.fromCharCode.apply(
          String,
          $.slice(X, X += j)
        );
      return C;
    }
    function Q($, D, C) {
      let X = "";
      C = Math.min($.length, C);
      for (let te = D; te < C; ++te)
        X += String.fromCharCode($[te] & 127);
      return X;
    }
    function G($, D, C) {
      let X = "";
      C = Math.min($.length, C);
      for (let te = D; te < C; ++te)
        X += String.fromCharCode($[te]);
      return X;
    }
    function K($, D, C) {
      const X = $.length;
      (!D || D < 0) && (D = 0), (!C || C < 0 || C > X) && (C = X);
      let te = "";
      for (let de = D; de < C; ++de)
        te += Ne[$[de]];
      return te;
    }
    function U($, D, C) {
      const X = $.slice(D, C);
      let te = "";
      for (let de = 0; de < X.length - 1; de += 2)
        te += String.fromCharCode(X[de] + X[de + 1] * 256);
      return te;
    }
    i.prototype.slice = function(D, C) {
      const X = this.length;
      D = ~~D, C = C === void 0 ? X : ~~C, D < 0 ? (D += X, D < 0 && (D = 0)) : D > X && (D = X), C < 0 ? (C += X, C < 0 && (C = 0)) : C > X && (C = X), C < D && (C = D);
      const te = this.subarray(D, C);
      return Object.setPrototypeOf(te, i.prototype), te;
    };
    function ae($, D, C) {
      if ($ % 1 !== 0 || $ < 0) throw new RangeError("offset is not uint");
      if ($ + D > C) throw new RangeError("Trying to access beyond buffer length");
    }
    i.prototype.readUintLE = i.prototype.readUIntLE = function(D, C, X) {
      D = D >>> 0, C = C >>> 0, X || ae(D, C, this.length);
      let te = this[D], de = 1, oe = 0;
      for (; ++oe < C && (de *= 256); )
        te += this[D + oe] * de;
      return te;
    }, i.prototype.readUintBE = i.prototype.readUIntBE = function(D, C, X) {
      D = D >>> 0, C = C >>> 0, X || ae(D, C, this.length);
      let te = this[D + --C], de = 1;
      for (; C > 0 && (de *= 256); )
        te += this[D + --C] * de;
      return te;
    }, i.prototype.readUint8 = i.prototype.readUInt8 = function(D, C) {
      return D = D >>> 0, C || ae(D, 1, this.length), this[D];
    }, i.prototype.readUint16LE = i.prototype.readUInt16LE = function(D, C) {
      return D = D >>> 0, C || ae(D, 2, this.length), this[D] | this[D + 1] << 8;
    }, i.prototype.readUint16BE = i.prototype.readUInt16BE = function(D, C) {
      return D = D >>> 0, C || ae(D, 2, this.length), this[D] << 8 | this[D + 1];
    }, i.prototype.readUint32LE = i.prototype.readUInt32LE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), (this[D] | this[D + 1] << 8 | this[D + 2] << 16) + this[D + 3] * 16777216;
    }, i.prototype.readUint32BE = i.prototype.readUInt32BE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), this[D] * 16777216 + (this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3]);
    }, i.prototype.readBigUInt64LE = xe(function(D) {
      D = D >>> 0, I(D, "offset");
      const C = this[D], X = this[D + 7];
      (C === void 0 || X === void 0) && P(D, this.length - 8);
      const te = C + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24, de = this[++D] + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + X * 2 ** 24;
      return BigInt(te) + (BigInt(de) << BigInt(32));
    }), i.prototype.readBigUInt64BE = xe(function(D) {
      D = D >>> 0, I(D, "offset");
      const C = this[D], X = this[D + 7];
      (C === void 0 || X === void 0) && P(D, this.length - 8);
      const te = C * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D], de = this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + X;
      return (BigInt(te) << BigInt(32)) + BigInt(de);
    }), i.prototype.readIntLE = function(D, C, X) {
      D = D >>> 0, C = C >>> 0, X || ae(D, C, this.length);
      let te = this[D], de = 1, oe = 0;
      for (; ++oe < C && (de *= 256); )
        te += this[D + oe] * de;
      return de *= 128, te >= de && (te -= Math.pow(2, 8 * C)), te;
    }, i.prototype.readIntBE = function(D, C, X) {
      D = D >>> 0, C = C >>> 0, X || ae(D, C, this.length);
      let te = C, de = 1, oe = this[D + --te];
      for (; te > 0 && (de *= 256); )
        oe += this[D + --te] * de;
      return de *= 128, oe >= de && (oe -= Math.pow(2, 8 * C)), oe;
    }, i.prototype.readInt8 = function(D, C) {
      return D = D >>> 0, C || ae(D, 1, this.length), this[D] & 128 ? (255 - this[D] + 1) * -1 : this[D];
    }, i.prototype.readInt16LE = function(D, C) {
      D = D >>> 0, C || ae(D, 2, this.length);
      const X = this[D] | this[D + 1] << 8;
      return X & 32768 ? X | 4294901760 : X;
    }, i.prototype.readInt16BE = function(D, C) {
      D = D >>> 0, C || ae(D, 2, this.length);
      const X = this[D + 1] | this[D] << 8;
      return X & 32768 ? X | 4294901760 : X;
    }, i.prototype.readInt32LE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), this[D] | this[D + 1] << 8 | this[D + 2] << 16 | this[D + 3] << 24;
    }, i.prototype.readInt32BE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), this[D] << 24 | this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3];
    }, i.prototype.readBigInt64LE = xe(function(D) {
      D = D >>> 0, I(D, "offset");
      const C = this[D], X = this[D + 7];
      (C === void 0 || X === void 0) && P(D, this.length - 8);
      const te = this[D + 4] + this[D + 5] * 2 ** 8 + this[D + 6] * 2 ** 16 + (X << 24);
      return (BigInt(te) << BigInt(32)) + BigInt(C + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24);
    }), i.prototype.readBigInt64BE = xe(function(D) {
      D = D >>> 0, I(D, "offset");
      const C = this[D], X = this[D + 7];
      (C === void 0 || X === void 0) && P(D, this.length - 8);
      const te = (C << 24) + // Overflow
      this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D];
      return (BigInt(te) << BigInt(32)) + BigInt(this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + X);
    }), i.prototype.readFloatLE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), o.read(this, D, !0, 23, 4);
    }, i.prototype.readFloatBE = function(D, C) {
      return D = D >>> 0, C || ae(D, 4, this.length), o.read(this, D, !1, 23, 4);
    }, i.prototype.readDoubleLE = function(D, C) {
      return D = D >>> 0, C || ae(D, 8, this.length), o.read(this, D, !0, 52, 8);
    }, i.prototype.readDoubleBE = function(D, C) {
      return D = D >>> 0, C || ae(D, 8, this.length), o.read(this, D, !1, 52, 8);
    };
    function ye($, D, C, X, te, de) {
      if (!i.isBuffer($)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (D > te || D < de) throw new RangeError('"value" argument is out of bounds');
      if (C + X > $.length) throw new RangeError("Index out of range");
    }
    i.prototype.writeUintLE = i.prototype.writeUIntLE = function(D, C, X, te) {
      if (D = +D, C = C >>> 0, X = X >>> 0, !te) {
        const De = Math.pow(2, 8 * X) - 1;
        ye(this, D, C, X, De, 0);
      }
      let de = 1, oe = 0;
      for (this[C] = D & 255; ++oe < X && (de *= 256); )
        this[C + oe] = D / de & 255;
      return C + X;
    }, i.prototype.writeUintBE = i.prototype.writeUIntBE = function(D, C, X, te) {
      if (D = +D, C = C >>> 0, X = X >>> 0, !te) {
        const De = Math.pow(2, 8 * X) - 1;
        ye(this, D, C, X, De, 0);
      }
      let de = X - 1, oe = 1;
      for (this[C + de] = D & 255; --de >= 0 && (oe *= 256); )
        this[C + de] = D / oe & 255;
      return C + X;
    }, i.prototype.writeUint8 = i.prototype.writeUInt8 = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 1, 255, 0), this[C] = D & 255, C + 1;
    }, i.prototype.writeUint16LE = i.prototype.writeUInt16LE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 2, 65535, 0), this[C] = D & 255, this[C + 1] = D >>> 8, C + 2;
    }, i.prototype.writeUint16BE = i.prototype.writeUInt16BE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 2, 65535, 0), this[C] = D >>> 8, this[C + 1] = D & 255, C + 2;
    }, i.prototype.writeUint32LE = i.prototype.writeUInt32LE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 4, 4294967295, 0), this[C + 3] = D >>> 24, this[C + 2] = D >>> 16, this[C + 1] = D >>> 8, this[C] = D & 255, C + 4;
    }, i.prototype.writeUint32BE = i.prototype.writeUInt32BE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 4, 4294967295, 0), this[C] = D >>> 24, this[C + 1] = D >>> 16, this[C + 2] = D >>> 8, this[C + 3] = D & 255, C + 4;
    };
    function pe($, D, C, X, te) {
      M(D, X, te, $, C, 7);
      let de = Number(D & BigInt(4294967295));
      $[C++] = de, de = de >> 8, $[C++] = de, de = de >> 8, $[C++] = de, de = de >> 8, $[C++] = de;
      let oe = Number(D >> BigInt(32) & BigInt(4294967295));
      return $[C++] = oe, oe = oe >> 8, $[C++] = oe, oe = oe >> 8, $[C++] = oe, oe = oe >> 8, $[C++] = oe, C;
    }
    function ee($, D, C, X, te) {
      M(D, X, te, $, C, 7);
      let de = Number(D & BigInt(4294967295));
      $[C + 7] = de, de = de >> 8, $[C + 6] = de, de = de >> 8, $[C + 5] = de, de = de >> 8, $[C + 4] = de;
      let oe = Number(D >> BigInt(32) & BigInt(4294967295));
      return $[C + 3] = oe, oe = oe >> 8, $[C + 2] = oe, oe = oe >> 8, $[C + 1] = oe, oe = oe >> 8, $[C] = oe, C + 8;
    }
    i.prototype.writeBigUInt64LE = xe(function(D, C = 0) {
      return pe(this, D, C, BigInt(0), BigInt("0xffffffffffffffff"));
    }), i.prototype.writeBigUInt64BE = xe(function(D, C = 0) {
      return ee(this, D, C, BigInt(0), BigInt("0xffffffffffffffff"));
    }), i.prototype.writeIntLE = function(D, C, X, te) {
      if (D = +D, C = C >>> 0, !te) {
        const Ve = Math.pow(2, 8 * X - 1);
        ye(this, D, C, X, Ve - 1, -Ve);
      }
      let de = 0, oe = 1, De = 0;
      for (this[C] = D & 255; ++de < X && (oe *= 256); )
        D < 0 && De === 0 && this[C + de - 1] !== 0 && (De = 1), this[C + de] = (D / oe >> 0) - De & 255;
      return C + X;
    }, i.prototype.writeIntBE = function(D, C, X, te) {
      if (D = +D, C = C >>> 0, !te) {
        const Ve = Math.pow(2, 8 * X - 1);
        ye(this, D, C, X, Ve - 1, -Ve);
      }
      let de = X - 1, oe = 1, De = 0;
      for (this[C + de] = D & 255; --de >= 0 && (oe *= 256); )
        D < 0 && De === 0 && this[C + de + 1] !== 0 && (De = 1), this[C + de] = (D / oe >> 0) - De & 255;
      return C + X;
    }, i.prototype.writeInt8 = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 1, 127, -128), D < 0 && (D = 255 + D + 1), this[C] = D & 255, C + 1;
    }, i.prototype.writeInt16LE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 2, 32767, -32768), this[C] = D & 255, this[C + 1] = D >>> 8, C + 2;
    }, i.prototype.writeInt16BE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 2, 32767, -32768), this[C] = D >>> 8, this[C + 1] = D & 255, C + 2;
    }, i.prototype.writeInt32LE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 4, 2147483647, -2147483648), this[C] = D & 255, this[C + 1] = D >>> 8, this[C + 2] = D >>> 16, this[C + 3] = D >>> 24, C + 4;
    }, i.prototype.writeInt32BE = function(D, C, X) {
      return D = +D, C = C >>> 0, X || ye(this, D, C, 4, 2147483647, -2147483648), D < 0 && (D = 4294967295 + D + 1), this[C] = D >>> 24, this[C + 1] = D >>> 16, this[C + 2] = D >>> 8, this[C + 3] = D & 255, C + 4;
    }, i.prototype.writeBigInt64LE = xe(function(D, C = 0) {
      return pe(this, D, C, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), i.prototype.writeBigInt64BE = xe(function(D, C = 0) {
      return ee(this, D, C, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Te($, D, C, X, te, de) {
      if (C + X > $.length) throw new RangeError("Index out of range");
      if (C < 0) throw new RangeError("Index out of range");
    }
    function we($, D, C, X, te) {
      return D = +D, C = C >>> 0, te || Te($, D, C, 4), o.write($, D, C, X, 23, 4), C + 4;
    }
    i.prototype.writeFloatLE = function(D, C, X) {
      return we(this, D, C, !0, X);
    }, i.prototype.writeFloatBE = function(D, C, X) {
      return we(this, D, C, !1, X);
    };
    function Oe($, D, C, X, te) {
      return D = +D, C = C >>> 0, te || Te($, D, C, 8), o.write($, D, C, X, 52, 8), C + 8;
    }
    i.prototype.writeDoubleLE = function(D, C, X) {
      return Oe(this, D, C, !0, X);
    }, i.prototype.writeDoubleBE = function(D, C, X) {
      return Oe(this, D, C, !1, X);
    }, i.prototype.copy = function(D, C, X, te) {
      if (!i.isBuffer(D)) throw new TypeError("argument should be a Buffer");
      if (X || (X = 0), !te && te !== 0 && (te = this.length), C >= D.length && (C = D.length), C || (C = 0), te > 0 && te < X && (te = X), te === X || D.length === 0 || this.length === 0) return 0;
      if (C < 0)
        throw new RangeError("targetStart out of bounds");
      if (X < 0 || X >= this.length) throw new RangeError("Index out of range");
      if (te < 0) throw new RangeError("sourceEnd out of bounds");
      te > this.length && (te = this.length), D.length - C < te - X && (te = D.length - C + X);
      const de = te - X;
      return this === D && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(C, X, te) : Uint8Array.prototype.set.call(
        D,
        this.subarray(X, te),
        C
      ), de;
    }, i.prototype.fill = function(D, C, X, te) {
      if (typeof D == "string") {
        if (typeof C == "string" ? (te = C, C = 0, X = this.length) : typeof X == "string" && (te = X, X = this.length), te !== void 0 && typeof te != "string")
          throw new TypeError("encoding must be a string");
        if (typeof te == "string" && !i.isEncoding(te))
          throw new TypeError("Unknown encoding: " + te);
        if (D.length === 1) {
          const oe = D.charCodeAt(0);
          (te === "utf8" && oe < 128 || te === "latin1") && (D = oe);
        }
      } else typeof D == "number" ? D = D & 255 : typeof D == "boolean" && (D = Number(D));
      if (C < 0 || this.length < C || this.length < X)
        throw new RangeError("Out of range index");
      if (X <= C)
        return this;
      C = C >>> 0, X = X === void 0 ? this.length : X >>> 0, D || (D = 0);
      let de;
      if (typeof D == "number")
        for (de = C; de < X; ++de)
          this[de] = D;
      else {
        const oe = i.isBuffer(D) ? D : i.from(D, te), De = oe.length;
        if (De === 0)
          throw new TypeError('The value "' + D + '" is invalid for argument "value"');
        for (de = 0; de < X - C; ++de)
          this[de + C] = oe[de % De];
      }
      return this;
    };
    const be = {};
    function he($, D, C) {
      be[$] = class extends C {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: D.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${$}]`, this.stack, delete this.name;
        }
        get code() {
          return $;
        }
        set code(te) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: te,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${$}]: ${this.message}`;
        }
      };
    }
    he(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function($) {
        return $ ? `${$} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), he(
      "ERR_INVALID_ARG_TYPE",
      function($, D) {
        return `The "${$}" argument must be of type number. Received type ${typeof D}`;
      },
      TypeError
    ), he(
      "ERR_OUT_OF_RANGE",
      function($, D, C) {
        let X = `The value of "${$}" is out of range.`, te = C;
        return Number.isInteger(C) && Math.abs(C) > 2 ** 32 ? te = V(String(C)) : typeof C == "bigint" && (te = String(C), (C > BigInt(2) ** BigInt(32) || C < -(BigInt(2) ** BigInt(32))) && (te = V(te)), te += "n"), X += ` It must be ${D}. Received ${te}`, X;
      },
      RangeError
    );
    function V($) {
      let D = "", C = $.length;
      const X = $[0] === "-" ? 1 : 0;
      for (; C >= X + 4; C -= 3)
        D = `_${$.slice(C - 3, C)}${D}`;
      return `${$.slice(0, C)}${D}`;
    }
    function N($, D, C) {
      I(D, "offset"), ($[D] === void 0 || $[D + C] === void 0) && P(D, $.length - (C + 1));
    }
    function M($, D, C, X, te, de) {
      if ($ > C || $ < D) {
        const oe = typeof D == "bigint" ? "n" : "";
        let De;
        throw D === 0 || D === BigInt(0) ? De = `>= 0${oe} and < 2${oe} ** ${(de + 1) * 8}${oe}` : De = `>= -(2${oe} ** ${(de + 1) * 8 - 1}${oe}) and < 2 ** ${(de + 1) * 8 - 1}${oe}`, new be.ERR_OUT_OF_RANGE("value", De, $);
      }
      N(X, te, de);
    }
    function I($, D) {
      if (typeof $ != "number")
        throw new be.ERR_INVALID_ARG_TYPE(D, "number", $);
    }
    function P($, D, C) {
      throw Math.floor($) !== $ ? (I($, C), new be.ERR_OUT_OF_RANGE("offset", "an integer", $)) : D < 0 ? new be.ERR_BUFFER_OUT_OF_BOUNDS() : new be.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${D}`,
        $
      );
    }
    const B = /[^+/0-9A-Za-z-_]/g;
    function z($) {
      if ($ = $.split("=")[0], $ = $.trim().replace(B, ""), $.length < 2) return "";
      for (; $.length % 4 !== 0; )
        $ = $ + "=";
      return $;
    }
    function H($, D) {
      D = D || 1 / 0;
      let C;
      const X = $.length;
      let te = null;
      const de = [];
      for (let oe = 0; oe < X; ++oe) {
        if (C = $.charCodeAt(oe), C > 55295 && C < 57344) {
          if (!te) {
            if (C > 56319) {
              (D -= 3) > -1 && de.push(239, 191, 189);
              continue;
            } else if (oe + 1 === X) {
              (D -= 3) > -1 && de.push(239, 191, 189);
              continue;
            }
            te = C;
            continue;
          }
          if (C < 56320) {
            (D -= 3) > -1 && de.push(239, 191, 189), te = C;
            continue;
          }
          C = (te - 55296 << 10 | C - 56320) + 65536;
        } else te && (D -= 3) > -1 && de.push(239, 191, 189);
        if (te = null, C < 128) {
          if ((D -= 1) < 0) break;
          de.push(C);
        } else if (C < 2048) {
          if ((D -= 2) < 0) break;
          de.push(
            C >> 6 | 192,
            C & 63 | 128
          );
        } else if (C < 65536) {
          if ((D -= 3) < 0) break;
          de.push(
            C >> 12 | 224,
            C >> 6 & 63 | 128,
            C & 63 | 128
          );
        } else if (C < 1114112) {
          if ((D -= 4) < 0) break;
          de.push(
            C >> 18 | 240,
            C >> 12 & 63 | 128,
            C >> 6 & 63 | 128,
            C & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return de;
    }
    function J($) {
      const D = [];
      for (let C = 0; C < $.length; ++C)
        D.push($.charCodeAt(C) & 255);
      return D;
    }
    function k($, D) {
      let C, X, te;
      const de = [];
      for (let oe = 0; oe < $.length && !((D -= 2) < 0); ++oe)
        C = $.charCodeAt(oe), X = C >> 8, te = C % 256, de.push(te), de.push(X);
      return de;
    }
    function W($) {
      return r.toByteArray(z($));
    }
    function le($, D, C, X) {
      let te;
      for (te = 0; te < X && !(te + C >= D.length || te >= $.length); ++te)
        D[te + C] = $[te];
      return te;
    }
    function fe($, D) {
      return $ instanceof D || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === D.name;
    }
    function me($) {
      return $ !== $;
    }
    const Ne = function() {
      const $ = "0123456789abcdef", D = new Array(256);
      for (let C = 0; C < 16; ++C) {
        const X = C * 16;
        for (let te = 0; te < 16; ++te)
          D[X + te] = $[C] + $[te];
      }
      return D;
    }();
    function xe($) {
      return typeof BigInt > "u" ? ue : $;
    }
    function ue() {
      throw new Error("BigInt not supported");
    }
  }(GA)), GA;
}
var zA, CP;
function dr() {
  if (CP) return zA;
  CP = 1;
  class u extends Error {
    constructor(o) {
      if (!Array.isArray(o))
        throw new TypeError(`Expected input to be an Array, got ${typeof o}`);
      let a = "";
      for (let t = 0; t < o.length; t++)
        a += `    ${o[t].stack}
`;
      super(a), this.name = "AggregateError", this.errors = o;
    }
  }
  return zA = {
    AggregateError: u,
    ArrayIsArray(r) {
      return Array.isArray(r);
    },
    ArrayPrototypeIncludes(r, o) {
      return r.includes(o);
    },
    ArrayPrototypeIndexOf(r, o) {
      return r.indexOf(o);
    },
    ArrayPrototypeJoin(r, o) {
      return r.join(o);
    },
    ArrayPrototypeMap(r, o) {
      return r.map(o);
    },
    ArrayPrototypePop(r, o) {
      return r.pop(o);
    },
    ArrayPrototypePush(r, o) {
      return r.push(o);
    },
    ArrayPrototypeSlice(r, o, a) {
      return r.slice(o, a);
    },
    Error,
    FunctionPrototypeCall(r, o, ...a) {
      return r.call(o, ...a);
    },
    FunctionPrototypeSymbolHasInstance(r, o) {
      return Function.prototype[Symbol.hasInstance].call(r, o);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(r, o) {
      return Object.defineProperties(r, o);
    },
    ObjectDefineProperty(r, o, a) {
      return Object.defineProperty(r, o, a);
    },
    ObjectGetOwnPropertyDescriptor(r, o) {
      return Object.getOwnPropertyDescriptor(r, o);
    },
    ObjectKeys(r) {
      return Object.keys(r);
    },
    ObjectSetPrototypeOf(r, o) {
      return Object.setPrototypeOf(r, o);
    },
    Promise,
    PromisePrototypeCatch(r, o) {
      return r.catch(o);
    },
    PromisePrototypeThen(r, o, a) {
      return r.then(o, a);
    },
    PromiseReject(r) {
      return Promise.reject(r);
    },
    PromiseResolve(r) {
      return Promise.resolve(r);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(r, o) {
      return r.test(o);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(r, o, a) {
      return r.slice(o, a);
    },
    StringPrototypeToLowerCase(r) {
      return r.toLowerCase();
    },
    StringPrototypeToUpperCase(r) {
      return r.toUpperCase();
    },
    StringPrototypeTrim(r) {
      return r.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(r, o, a) {
      return r.set(o, a);
    },
    Boolean,
    Uint8Array
  }, zA;
}
var kA = { exports: {} }, XA, qP;
function OW() {
  return qP || (qP = 1, XA = {
    format(u, ...r) {
      return u.replace(/%([sdifj])/g, function(...[o, a]) {
        const t = r.shift();
        return a === "f" ? t.toFixed(6) : a === "j" ? JSON.stringify(t) : a === "s" && typeof t == "object" ? `${t.constructor !== Object ? t.constructor.name : ""} {}`.trim() : t.toString();
      });
    },
    inspect(u) {
      switch (typeof u) {
        case "string":
          if (u.includes("'"))
            if (u.includes('"')) {
              if (!u.includes("`") && !u.includes("${"))
                return `\`${u}\``;
            } else return `"${u}"`;
          return `'${u}'`;
        case "number":
          return isNaN(u) ? "NaN" : Object.is(u, -0) ? String(u) : u;
        case "bigint":
          return `${String(u)}n`;
        case "boolean":
        case "undefined":
          return String(u);
        case "object":
          return "{}";
      }
    }
  }), XA;
}
var JA, BP;
function sn() {
  if (BP) return JA;
  BP = 1;
  const { format: u, inspect: r } = OW(), { AggregateError: o } = dr(), a = globalThis.AggregateError || o, t = Symbol("kIsNodeError"), e = [
    "string",
    "function",
    "number",
    "object",
    // Accept 'Function' and 'Object' as alternative to the lower cased version.
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ], n = /^([A-Z][a-z0-9]*)+$/, i = "__node_internal_", c = {};
  function s(_, y) {
    if (!_)
      throw new c.ERR_INTERNAL_ASSERTION(y);
  }
  function d(_) {
    let y = "", m = _.length;
    const g = _[0] === "-" ? 1 : 0;
    for (; m >= g + 4; m -= 3)
      y = `_${_.slice(m - 3, m)}${y}`;
    return `${_.slice(0, m)}${y}`;
  }
  function l(_, y, m) {
    if (typeof y == "function")
      return s(
        y.length <= m.length,
        // Default options do not count.
        `Code: ${_}; The provided arguments length (${m.length}) does not match the required ones (${y.length}).`
      ), y(...m);
    const g = (y.match(/%[dfijoOs]/g) || []).length;
    return s(
      g === m.length,
      `Code: ${_}; The provided arguments length (${m.length}) does not match the required ones (${g}).`
    ), m.length === 0 ? y : u(y, ...m);
  }
  function f(_, y, m) {
    m || (m = Error);
    class g extends m {
      constructor(...v) {
        super(l(_, y, v));
      }
      toString() {
        return `${this.name} [${_}]: ${this.message}`;
      }
    }
    Object.defineProperties(g.prototype, {
      name: {
        value: m.name,
        writable: !0,
        enumerable: !1,
        configurable: !0
      },
      toString: {
        value() {
          return `${this.name} [${_}]: ${this.message}`;
        },
        writable: !0,
        enumerable: !1,
        configurable: !0
      }
    }), g.prototype.code = _, g.prototype[t] = !0, c[_] = g;
  }
  function h(_) {
    const y = i + _.name;
    return Object.defineProperty(_, "name", {
      value: y
    }), _;
  }
  function p(_, y) {
    if (_ && y && _ !== y) {
      if (Array.isArray(y.errors))
        return y.errors.push(_), y;
      const m = new a([y, _], y.message);
      return m.code = y.code, m;
    }
    return _ || y;
  }
  class b extends Error {
    constructor(y = "The operation was aborted", m = void 0) {
      if (m !== void 0 && typeof m != "object")
        throw new c.ERR_INVALID_ARG_TYPE("options", "Object", m);
      super(y, m), this.code = "ABORT_ERR", this.name = "AbortError";
    }
  }
  return f("ERR_ASSERTION", "%s", Error), f(
    "ERR_INVALID_ARG_TYPE",
    (_, y, m) => {
      s(typeof _ == "string", "'name' must be a string"), Array.isArray(y) || (y = [y]);
      let g = "The ";
      _.endsWith(" argument") ? g += `${_} ` : g += `"${_}" ${_.includes(".") ? "property" : "argument"} `, g += "must be ";
      const T = [], v = [], E = [];
      for (const L of y)
        s(typeof L == "string", "All expected entries have to be of type string"), e.includes(L) ? T.push(L.toLowerCase()) : n.test(L) ? v.push(L) : (s(L !== "object", 'The value "object" should be written as "Object"'), E.push(L));
      if (v.length > 0) {
        const L = T.indexOf("object");
        L !== -1 && (T.splice(T, L, 1), v.push("Object"));
      }
      if (T.length > 0) {
        switch (T.length) {
          case 1:
            g += `of type ${T[0]}`;
            break;
          case 2:
            g += `one of type ${T[0]} or ${T[1]}`;
            break;
          default: {
            const L = T.pop();
            g += `one of type ${T.join(", ")}, or ${L}`;
          }
        }
        (v.length > 0 || E.length > 0) && (g += " or ");
      }
      if (v.length > 0) {
        switch (v.length) {
          case 1:
            g += `an instance of ${v[0]}`;
            break;
          case 2:
            g += `an instance of ${v[0]} or ${v[1]}`;
            break;
          default: {
            const L = v.pop();
            g += `an instance of ${v.join(", ")}, or ${L}`;
          }
        }
        E.length > 0 && (g += " or ");
      }
      switch (E.length) {
        case 0:
          break;
        case 1:
          E[0].toLowerCase() !== E[0] && (g += "an "), g += `${E[0]}`;
          break;
        case 2:
          g += `one of ${E[0]} or ${E[1]}`;
          break;
        default: {
          const L = E.pop();
          g += `one of ${E.join(", ")}, or ${L}`;
        }
      }
      if (m == null)
        g += `. Received ${m}`;
      else if (typeof m == "function" && m.name)
        g += `. Received function ${m.name}`;
      else if (typeof m == "object") {
        var R;
        if ((R = m.constructor) !== null && R !== void 0 && R.name)
          g += `. Received an instance of ${m.constructor.name}`;
        else {
          const L = r(m, {
            depth: -1
          });
          g += `. Received ${L}`;
        }
      } else {
        let L = r(m, {
          colors: !1
        });
        L.length > 25 && (L = `${L.slice(0, 25)}...`), g += `. Received type ${typeof m} (${L})`;
      }
      return g;
    },
    TypeError
  ), f(
    "ERR_INVALID_ARG_VALUE",
    (_, y, m = "is invalid") => {
      let g = r(y);
      return g.length > 128 && (g = g.slice(0, 128) + "..."), `The ${_.includes(".") ? "property" : "argument"} '${_}' ${m}. Received ${g}`;
    },
    TypeError
  ), f(
    "ERR_INVALID_RETURN_VALUE",
    (_, y, m) => {
      var g;
      const T = m != null && (g = m.constructor) !== null && g !== void 0 && g.name ? `instance of ${m.constructor.name}` : `type ${typeof m}`;
      return `Expected ${_} to be returned from the "${y}" function but got ${T}.`;
    },
    TypeError
  ), f(
    "ERR_MISSING_ARGS",
    (..._) => {
      s(_.length > 0, "At least one arg needs to be specified");
      let y;
      const m = _.length;
      switch (_ = (Array.isArray(_) ? _ : [_]).map((g) => `"${g}"`).join(" or "), m) {
        case 1:
          y += `The ${_[0]} argument`;
          break;
        case 2:
          y += `The ${_[0]} and ${_[1]} arguments`;
          break;
        default:
          {
            const g = _.pop();
            y += `The ${_.join(", ")}, and ${g} arguments`;
          }
          break;
      }
      return `${y} must be specified`;
    },
    TypeError
  ), f(
    "ERR_OUT_OF_RANGE",
    (_, y, m) => {
      s(y, 'Missing "range" argument');
      let g;
      if (Number.isInteger(m) && Math.abs(m) > 2 ** 32)
        g = d(String(m));
      else if (typeof m == "bigint") {
        g = String(m);
        const T = BigInt(2) ** BigInt(32);
        (m > T || m < -T) && (g = d(g)), g += "n";
      } else
        g = r(m);
      return `The value of "${_}" is out of range. It must be ${y}. Received ${g}`;
    },
    RangeError
  ), f("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), f("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), f("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), f("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), f("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), f("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), f("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), f("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), f("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), f("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), f("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), JA = {
    AbortError: b,
    aggregateTwoErrors: h(p),
    hideStackFrames: h,
    codes: c
  }, JA;
}
var _1 = { exports: {} }, $P;
function KT() {
  if ($P) return _1.exports;
  $P = 1;
  const { AbortController: u, AbortSignal: r } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return _1.exports = u, _1.exports.AbortSignal = r, _1.exports.default = u, _1.exports;
}
var UP;
function pn() {
  return UP || (UP = 1, function(u) {
    const r = qi(), { format: o, inspect: a } = OW(), {
      codes: { ERR_INVALID_ARG_TYPE: t }
    } = sn(), { kResistStopPropagation: e, AggregateError: n, SymbolDispose: i } = dr(), c = globalThis.AbortSignal || KT().AbortSignal, s = globalThis.AbortController || KT().AbortController, d = Object.getPrototypeOf(async function() {
    }).constructor, l = globalThis.Blob || r.Blob, f = typeof l < "u" ? function(_) {
      return _ instanceof l;
    } : function(_) {
      return !1;
    }, h = (b, _) => {
      if (b !== void 0 && (b === null || typeof b != "object" || !("aborted" in b)))
        throw new t(_, "AbortSignal", b);
    }, p = (b, _) => {
      if (typeof b != "function")
        throw new t(_, "Function", b);
    };
    u.exports = {
      AggregateError: n,
      kEmptyObject: Object.freeze({}),
      once(b) {
        let _ = !1;
        return function(...y) {
          _ || (_ = !0, b.apply(this, y));
        };
      },
      createDeferredPromise: function() {
        let b, _;
        return {
          promise: new Promise((m, g) => {
            b = m, _ = g;
          }),
          resolve: b,
          reject: _
        };
      },
      promisify(b) {
        return new Promise((_, y) => {
          b((m, ...g) => m ? y(m) : _(...g));
        });
      },
      debuglog() {
        return function() {
        };
      },
      format: o,
      inspect: a,
      types: {
        isAsyncFunction(b) {
          return b instanceof d;
        },
        isArrayBufferView(b) {
          return ArrayBuffer.isView(b);
        }
      },
      isBlob: f,
      deprecate(b, _) {
        return b;
      },
      addAbortListener: ww().addAbortListener || function(_, y) {
        if (_ === void 0)
          throw new t("signal", "AbortSignal", _);
        h(_, "signal"), p(y, "listener");
        let m;
        return _.aborted ? queueMicrotask(() => y()) : (_.addEventListener("abort", y, {
          __proto__: null,
          once: !0,
          [e]: !0
        }), m = () => {
          _.removeEventListener("abort", y);
        }), {
          __proto__: null,
          [i]() {
            var g;
            (g = m) === null || g === void 0 || g();
          }
        };
      },
      AbortSignalAny: c.any || function(_) {
        if (_.length === 1)
          return _[0];
        const y = new s(), m = () => y.abort();
        return _.forEach((g) => {
          h(g, "signals"), g.addEventListener("abort", m, {
            once: !0
          });
        }), y.signal.addEventListener(
          "abort",
          () => {
            _.forEach((g) => g.removeEventListener("abort", m));
          },
          {
            once: !0
          }
        ), y.signal;
      }
    }, u.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }(kA)), kA.exports;
}
var c6 = {}, KA, VP;
function Ew() {
  if (VP) return KA;
  VP = 1;
  const {
    ArrayIsArray: u,
    ArrayPrototypeIncludes: r,
    ArrayPrototypeJoin: o,
    ArrayPrototypeMap: a,
    NumberIsInteger: t,
    NumberIsNaN: e,
    NumberMAX_SAFE_INTEGER: n,
    NumberMIN_SAFE_INTEGER: i,
    NumberParseInt: c,
    ObjectPrototypeHasOwnProperty: s,
    RegExpPrototypeExec: d,
    String: l,
    StringPrototypeToUpperCase: f,
    StringPrototypeTrim: h
  } = dr(), {
    hideStackFrames: p,
    codes: { ERR_SOCKET_BAD_PORT: b, ERR_INVALID_ARG_TYPE: _, ERR_INVALID_ARG_VALUE: y, ERR_OUT_OF_RANGE: m, ERR_UNKNOWN_SIGNAL: g }
  } = sn(), { normalizeEncoding: T } = pn(), { isAsyncFunction: v, isArrayBufferView: E } = pn().types, R = {};
  function L(k) {
    return k === (k | 0);
  }
  function A(k) {
    return k === k >>> 0;
  }
  const w = /^[0-7]+$/, S = "must be a 32-bit unsigned integer or an octal string";
  function O(k, W, le) {
    if (typeof k > "u" && (k = le), typeof k == "string") {
      if (d(w, k) === null)
        throw new y(W, k, S);
      k = c(k, 8);
    }
    return j(k, W), k;
  }
  const x = p((k, W, le = i, fe = n) => {
    if (typeof k != "number") throw new _(W, "number", k);
    if (!t(k)) throw new m(W, "an integer", k);
    if (k < le || k > fe) throw new m(W, `>= ${le} && <= ${fe}`, k);
  }), F = p((k, W, le = -2147483648, fe = 2147483647) => {
    if (typeof k != "number")
      throw new _(W, "number", k);
    if (!t(k))
      throw new m(W, "an integer", k);
    if (k < le || k > fe)
      throw new m(W, `>= ${le} && <= ${fe}`, k);
  }), j = p((k, W, le = !1) => {
    if (typeof k != "number")
      throw new _(W, "number", k);
    if (!t(k))
      throw new m(W, "an integer", k);
    const fe = le ? 1 : 0, me = 4294967295;
    if (k < fe || k > me)
      throw new m(W, `>= ${fe} && <= ${me}`, k);
  });
  function q(k, W) {
    if (typeof k != "string") throw new _(W, "string", k);
  }
  function Q(k, W, le = void 0, fe) {
    if (typeof k != "number") throw new _(W, "number", k);
    if (le != null && k < le || fe != null && k > fe || (le != null || fe != null) && e(k))
      throw new m(
        W,
        `${le != null ? `>= ${le}` : ""}${le != null && fe != null ? " && " : ""}${fe != null ? `<= ${fe}` : ""}`,
        k
      );
  }
  const G = p((k, W, le) => {
    if (!r(le, k)) {
      const me = "must be one of: " + o(
        a(le, (Ne) => typeof Ne == "string" ? `'${Ne}'` : l(Ne)),
        ", "
      );
      throw new y(W, k, me);
    }
  });
  function K(k, W) {
    if (typeof k != "boolean") throw new _(W, "boolean", k);
  }
  function U(k, W, le) {
    return k == null || !s(k, W) ? le : k[W];
  }
  const ae = p((k, W, le = null) => {
    const fe = U(le, "allowArray", !1), me = U(le, "allowFunction", !1);
    if (!U(le, "nullable", !1) && k === null || !fe && u(k) || typeof k != "object" && (!me || typeof k != "function"))
      throw new _(W, "Object", k);
  }), ye = p((k, W) => {
    if (k != null && typeof k != "object" && typeof k != "function")
      throw new _(W, "a dictionary", k);
  }), pe = p((k, W, le = 0) => {
    if (!u(k))
      throw new _(W, "Array", k);
    if (k.length < le) {
      const fe = `must be longer than ${le}`;
      throw new y(W, k, fe);
    }
  });
  function ee(k, W) {
    pe(k, W);
    for (let le = 0; le < k.length; le++)
      q(k[le], `${W}[${le}]`);
  }
  function Te(k, W) {
    pe(k, W);
    for (let le = 0; le < k.length; le++)
      K(k[le], `${W}[${le}]`);
  }
  function we(k, W) {
    pe(k, W);
    for (let le = 0; le < k.length; le++) {
      const fe = k[le], me = `${W}[${le}]`;
      if (fe == null)
        throw new _(me, "AbortSignal", fe);
      N(fe, me);
    }
  }
  function Oe(k, W = "signal") {
    if (q(k, W), R[k] === void 0)
      throw R[f(k)] !== void 0 ? new g(k + " (signals must use all capital letters)") : new g(k);
  }
  const be = p((k, W = "buffer") => {
    if (!E(k))
      throw new _(W, ["Buffer", "TypedArray", "DataView"], k);
  });
  function he(k, W) {
    const le = T(W), fe = k.length;
    if (le === "hex" && fe % 2 !== 0)
      throw new y("encoding", W, `is invalid for data of length ${fe}`);
  }
  function V(k, W = "Port", le = !0) {
    if (typeof k != "number" && typeof k != "string" || typeof k == "string" && h(k).length === 0 || +k !== +k >>> 0 || k > 65535 || k === 0 && !le)
      throw new b(W, k, le);
    return k | 0;
  }
  const N = p((k, W) => {
    if (k !== void 0 && (k === null || typeof k != "object" || !("aborted" in k)))
      throw new _(W, "AbortSignal", k);
  }), M = p((k, W) => {
    if (typeof k != "function") throw new _(W, "Function", k);
  }), I = p((k, W) => {
    if (typeof k != "function" || v(k)) throw new _(W, "Function", k);
  }), P = p((k, W) => {
    if (k !== void 0) throw new _(W, "undefined", k);
  });
  function B(k, W, le) {
    if (!r(le, k))
      throw new _(W, `('${o(le, "|")}')`, k);
  }
  const z = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function H(k, W) {
    if (typeof k > "u" || !d(z, k))
      throw new y(
        W,
        k,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
  }
  function J(k) {
    if (typeof k == "string")
      return H(k, "hints"), k;
    if (u(k)) {
      const W = k.length;
      let le = "";
      if (W === 0)
        return le;
      for (let fe = 0; fe < W; fe++) {
        const me = k[fe];
        H(me, "hints"), le += me, fe !== W - 1 && (le += ", ");
      }
      return le;
    }
    throw new y(
      "hints",
      k,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
  }
  return KA = {
    isInt32: L,
    isUint32: A,
    parseFileMode: O,
    validateArray: pe,
    validateStringArray: ee,
    validateBooleanArray: Te,
    validateAbortSignalArray: we,
    validateBoolean: K,
    validateBuffer: be,
    validateDictionary: ye,
    validateEncoding: he,
    validateFunction: M,
    validateInt32: F,
    validateInteger: x,
    validateNumber: Q,
    validateObject: ae,
    validateOneOf: G,
    validatePlainFunction: I,
    validatePort: V,
    validateSignalName: Oe,
    validateString: q,
    validateUint32: j,
    validateUndefined: P,
    validateUnion: B,
    validateAbortSignal: N,
    validateLinkHeaderValue: J
  }, KA;
}
var d6 = { exports: {} }, WA, QP;
function wa() {
  if (QP) return WA;
  QP = 1;
  const { SymbolAsyncIterator: u, SymbolIterator: r, SymbolFor: o } = dr(), a = o("nodejs.stream.destroyed"), t = o("nodejs.stream.errored"), e = o("nodejs.stream.readable"), n = o("nodejs.stream.writable"), i = o("nodejs.stream.disturbed"), c = o("nodejs.webstream.isClosedPromise"), s = o("nodejs.webstream.controllerErrorFunction");
  function d(U, ae = !1) {
    var ye;
    return !!(U && typeof U.pipe == "function" && typeof U.on == "function" && (!ae || typeof U.pause == "function" && typeof U.resume == "function") && (!U._writableState || ((ye = U._readableState) === null || ye === void 0 ? void 0 : ye.readable) !== !1) && // Duplex
    (!U._writableState || U._readableState));
  }
  function l(U) {
    var ae;
    return !!(U && typeof U.write == "function" && typeof U.on == "function" && (!U._readableState || ((ae = U._writableState) === null || ae === void 0 ? void 0 : ae.writable) !== !1));
  }
  function f(U) {
    return !!(U && typeof U.pipe == "function" && U._readableState && typeof U.on == "function" && typeof U.write == "function");
  }
  function h(U) {
    return U && (U._readableState || U._writableState || typeof U.write == "function" && typeof U.on == "function" || typeof U.pipe == "function" && typeof U.on == "function");
  }
  function p(U) {
    return !!(U && !h(U) && typeof U.pipeThrough == "function" && typeof U.getReader == "function" && typeof U.cancel == "function");
  }
  function b(U) {
    return !!(U && !h(U) && typeof U.getWriter == "function" && typeof U.abort == "function");
  }
  function _(U) {
    return !!(U && !h(U) && typeof U.readable == "object" && typeof U.writable == "object");
  }
  function y(U) {
    return p(U) || b(U) || _(U);
  }
  function m(U, ae) {
    return U == null ? !1 : ae === !0 ? typeof U[u] == "function" : ae === !1 ? typeof U[r] == "function" : typeof U[u] == "function" || typeof U[r] == "function";
  }
  function g(U) {
    if (!h(U)) return null;
    const ae = U._writableState, ye = U._readableState, pe = ae || ye;
    return !!(U.destroyed || U[a] || pe != null && pe.destroyed);
  }
  function T(U) {
    if (!l(U)) return null;
    if (U.writableEnded === !0) return !0;
    const ae = U._writableState;
    return ae != null && ae.errored ? !1 : typeof (ae == null ? void 0 : ae.ended) != "boolean" ? null : ae.ended;
  }
  function v(U, ae) {
    if (!l(U)) return null;
    if (U.writableFinished === !0) return !0;
    const ye = U._writableState;
    return ye != null && ye.errored ? !1 : typeof (ye == null ? void 0 : ye.finished) != "boolean" ? null : !!(ye.finished || ae === !1 && ye.ended === !0 && ye.length === 0);
  }
  function E(U) {
    if (!d(U)) return null;
    if (U.readableEnded === !0) return !0;
    const ae = U._readableState;
    return !ae || ae.errored ? !1 : typeof (ae == null ? void 0 : ae.ended) != "boolean" ? null : ae.ended;
  }
  function R(U, ae) {
    if (!d(U)) return null;
    const ye = U._readableState;
    return ye != null && ye.errored ? !1 : typeof (ye == null ? void 0 : ye.endEmitted) != "boolean" ? null : !!(ye.endEmitted || ae === !1 && ye.ended === !0 && ye.length === 0);
  }
  function L(U) {
    return U && U[e] != null ? U[e] : typeof (U == null ? void 0 : U.readable) != "boolean" ? null : g(U) ? !1 : d(U) && U.readable && !R(U);
  }
  function A(U) {
    return U && U[n] != null ? U[n] : typeof (U == null ? void 0 : U.writable) != "boolean" ? null : g(U) ? !1 : l(U) && U.writable && !T(U);
  }
  function w(U, ae) {
    return h(U) ? g(U) ? !0 : !((ae == null ? void 0 : ae.readable) !== !1 && L(U) || (ae == null ? void 0 : ae.writable) !== !1 && A(U)) : null;
  }
  function S(U) {
    var ae, ye;
    return h(U) ? U.writableErrored ? U.writableErrored : (ae = (ye = U._writableState) === null || ye === void 0 ? void 0 : ye.errored) !== null && ae !== void 0 ? ae : null : null;
  }
  function O(U) {
    var ae, ye;
    return h(U) ? U.readableErrored ? U.readableErrored : (ae = (ye = U._readableState) === null || ye === void 0 ? void 0 : ye.errored) !== null && ae !== void 0 ? ae : null : null;
  }
  function x(U) {
    if (!h(U))
      return null;
    if (typeof U.closed == "boolean")
      return U.closed;
    const ae = U._writableState, ye = U._readableState;
    return typeof (ae == null ? void 0 : ae.closed) == "boolean" || typeof (ye == null ? void 0 : ye.closed) == "boolean" ? (ae == null ? void 0 : ae.closed) || (ye == null ? void 0 : ye.closed) : typeof U._closed == "boolean" && F(U) ? U._closed : null;
  }
  function F(U) {
    return typeof U._closed == "boolean" && typeof U._defaultKeepAlive == "boolean" && typeof U._removedConnection == "boolean" && typeof U._removedContLen == "boolean";
  }
  function j(U) {
    return typeof U._sent100 == "boolean" && F(U);
  }
  function q(U) {
    var ae;
    return typeof U._consuming == "boolean" && typeof U._dumped == "boolean" && ((ae = U.req) === null || ae === void 0 ? void 0 : ae.upgradeOrConnect) === void 0;
  }
  function Q(U) {
    if (!h(U)) return null;
    const ae = U._writableState, ye = U._readableState, pe = ae || ye;
    return !pe && j(U) || !!(pe && pe.autoDestroy && pe.emitClose && pe.closed === !1);
  }
  function G(U) {
    var ae;
    return !!(U && ((ae = U[i]) !== null && ae !== void 0 ? ae : U.readableDidRead || U.readableAborted));
  }
  function K(U) {
    var ae, ye, pe, ee, Te, we, Oe, be, he, V;
    return !!(U && ((ae = (ye = (pe = (ee = (Te = (we = U[t]) !== null && we !== void 0 ? we : U.readableErrored) !== null && Te !== void 0 ? Te : U.writableErrored) !== null && ee !== void 0 ? ee : (Oe = U._readableState) === null || Oe === void 0 ? void 0 : Oe.errorEmitted) !== null && pe !== void 0 ? pe : (be = U._writableState) === null || be === void 0 ? void 0 : be.errorEmitted) !== null && ye !== void 0 ? ye : (he = U._readableState) === null || he === void 0 ? void 0 : he.errored) !== null && ae !== void 0 ? ae : !((V = U._writableState) === null || V === void 0) && V.errored));
  }
  return WA = {
    isDestroyed: g,
    kIsDestroyed: a,
    isDisturbed: G,
    kIsDisturbed: i,
    isErrored: K,
    kIsErrored: t,
    isReadable: L,
    kIsReadable: e,
    kIsClosedPromise: c,
    kControllerErrorFunction: s,
    kIsWritable: n,
    isClosed: x,
    isDuplexNodeStream: f,
    isFinished: w,
    isIterable: m,
    isReadableNodeStream: d,
    isReadableStream: p,
    isReadableEnded: E,
    isReadableFinished: R,
    isReadableErrored: O,
    isNodeStream: h,
    isWebStream: y,
    isWritable: A,
    isWritableNodeStream: l,
    isWritableStream: b,
    isWritableEnded: T,
    isWritableFinished: v,
    isWritableErrored: S,
    isServerRequest: q,
    isServerResponse: j,
    willEmitClose: Q,
    isTransformStream: _
  }, WA;
}
var HP;
function nu() {
  if (HP) return d6.exports;
  HP = 1;
  const u = tu(), { AbortError: r, codes: o } = sn(), { ERR_INVALID_ARG_TYPE: a, ERR_STREAM_PREMATURE_CLOSE: t } = o, { kEmptyObject: e, once: n } = pn(), { validateAbortSignal: i, validateFunction: c, validateObject: s, validateBoolean: d } = Ew(), { Promise: l, PromisePrototypeThen: f, SymbolDispose: h } = dr(), {
    isClosed: p,
    isReadable: b,
    isReadableNodeStream: _,
    isReadableStream: y,
    isReadableFinished: m,
    isReadableErrored: g,
    isWritable: T,
    isWritableNodeStream: v,
    isWritableStream: E,
    isWritableFinished: R,
    isWritableErrored: L,
    isNodeStream: A,
    willEmitClose: w,
    kIsClosedPromise: S
  } = wa();
  let O;
  function x(G) {
    return G.setHeader && typeof G.abort == "function";
  }
  const F = () => {
  };
  function j(G, K, U) {
    var ae, ye;
    if (arguments.length === 2 ? (U = K, K = e) : K == null ? K = e : s(K, "options"), c(U, "callback"), i(K.signal, "options.signal"), U = n(U), y(G) || E(G))
      return q(G, K, U);
    if (!A(G))
      throw new a("stream", ["ReadableStream", "WritableStream", "Stream"], G);
    const pe = (ae = K.readable) !== null && ae !== void 0 ? ae : _(G), ee = (ye = K.writable) !== null && ye !== void 0 ? ye : v(G), Te = G._writableState, we = G._readableState, Oe = () => {
      G.writable || V();
    };
    let be = w(G) && _(G) === pe && v(G) === ee, he = R(G, !1);
    const V = () => {
      he = !0, G.destroyed && (be = !1), !(be && (!G.readable || pe)) && (!pe || N) && U.call(G);
    };
    let N = m(G, !1);
    const M = () => {
      N = !0, G.destroyed && (be = !1), !(be && (!G.writable || ee)) && (!ee || he) && U.call(G);
    }, I = (k) => {
      U.call(G, k);
    };
    let P = p(G);
    const B = () => {
      P = !0;
      const k = L(G) || g(G);
      if (k && typeof k != "boolean")
        return U.call(G, k);
      if (pe && !N && _(G, !0) && !m(G, !1))
        return U.call(G, new t());
      if (ee && !he && !R(G, !1))
        return U.call(G, new t());
      U.call(G);
    }, z = () => {
      P = !0;
      const k = L(G) || g(G);
      if (k && typeof k != "boolean")
        return U.call(G, k);
      U.call(G);
    }, H = () => {
      G.req.on("finish", V);
    };
    x(G) ? (G.on("complete", V), be || G.on("abort", B), G.req ? H() : G.on("request", H)) : ee && !Te && (G.on("end", Oe), G.on("close", Oe)), !be && typeof G.aborted == "boolean" && G.on("aborted", B), G.on("end", M), G.on("finish", V), K.error !== !1 && G.on("error", I), G.on("close", B), P ? u.nextTick(B) : Te != null && Te.errorEmitted || we != null && we.errorEmitted ? be || u.nextTick(z) : (!pe && (!be || b(G)) && (he || T(G) === !1) || !ee && (!be || T(G)) && (N || b(G) === !1) || we && G.req && G.aborted) && u.nextTick(z);
    const J = () => {
      U = F, G.removeListener("aborted", B), G.removeListener("complete", V), G.removeListener("abort", B), G.removeListener("request", H), G.req && G.req.removeListener("finish", V), G.removeListener("end", Oe), G.removeListener("close", Oe), G.removeListener("finish", V), G.removeListener("end", M), G.removeListener("error", I), G.removeListener("close", B);
    };
    if (K.signal && !P) {
      const k = () => {
        const W = U;
        J(), W.call(
          G,
          new r(void 0, {
            cause: K.signal.reason
          })
        );
      };
      if (K.signal.aborted)
        u.nextTick(k);
      else {
        O = O || pn().addAbortListener;
        const W = O(K.signal, k), le = U;
        U = n((...fe) => {
          W[h](), le.apply(G, fe);
        });
      }
    }
    return J;
  }
  function q(G, K, U) {
    let ae = !1, ye = F;
    if (K.signal)
      if (ye = () => {
        ae = !0, U.call(
          G,
          new r(void 0, {
            cause: K.signal.reason
          })
        );
      }, K.signal.aborted)
        u.nextTick(ye);
      else {
        O = O || pn().addAbortListener;
        const ee = O(K.signal, ye), Te = U;
        U = n((...we) => {
          ee[h](), Te.apply(G, we);
        });
      }
    const pe = (...ee) => {
      ae || u.nextTick(() => U.apply(G, ee));
    };
    return f(G[S].promise, pe, pe), F;
  }
  function Q(G, K) {
    var U;
    let ae = !1;
    return K === null && (K = e), (U = K) !== null && U !== void 0 && U.cleanup && (d(K.cleanup, "cleanup"), ae = K.cleanup), new l((ye, pe) => {
      const ee = j(G, K, (Te) => {
        ae && ee(), Te ? pe(Te) : ye();
      });
    });
  }
  return d6.exports = j, d6.exports.finished = Q, d6.exports;
}
var YA, GP;
function bh() {
  if (GP) return YA;
  GP = 1;
  const u = tu(), {
    aggregateTwoErrors: r,
    codes: { ERR_MULTIPLE_CALLBACK: o },
    AbortError: a
  } = sn(), { Symbol: t } = dr(), { kIsDestroyed: e, isDestroyed: n, isFinished: i, isServerRequest: c } = wa(), s = t("kDestroy"), d = t("kConstruct");
  function l(w, S, O) {
    w && (w.stack, S && !S.errored && (S.errored = w), O && !O.errored && (O.errored = w));
  }
  function f(w, S) {
    const O = this._readableState, x = this._writableState, F = x || O;
    return x != null && x.destroyed || O != null && O.destroyed ? (typeof S == "function" && S(), this) : (l(w, x, O), x && (x.destroyed = !0), O && (O.destroyed = !0), F.constructed ? h(this, w, S) : this.once(s, function(j) {
      h(this, r(j, w), S);
    }), this);
  }
  function h(w, S, O) {
    let x = !1;
    function F(j) {
      if (x)
        return;
      x = !0;
      const q = w._readableState, Q = w._writableState;
      l(j, Q, q), Q && (Q.closed = !0), q && (q.closed = !0), typeof O == "function" && O(j), j ? u.nextTick(p, w, j) : u.nextTick(b, w);
    }
    try {
      w._destroy(S || null, F);
    } catch (j) {
      F(j);
    }
  }
  function p(w, S) {
    _(w, S), b(w);
  }
  function b(w) {
    const S = w._readableState, O = w._writableState;
    O && (O.closeEmitted = !0), S && (S.closeEmitted = !0), (O != null && O.emitClose || S != null && S.emitClose) && w.emit("close");
  }
  function _(w, S) {
    const O = w._readableState, x = w._writableState;
    x != null && x.errorEmitted || O != null && O.errorEmitted || (x && (x.errorEmitted = !0), O && (O.errorEmitted = !0), w.emit("error", S));
  }
  function y() {
    const w = this._readableState, S = this._writableState;
    w && (w.constructed = !0, w.closed = !1, w.closeEmitted = !1, w.destroyed = !1, w.errored = null, w.errorEmitted = !1, w.reading = !1, w.ended = w.readable === !1, w.endEmitted = w.readable === !1), S && (S.constructed = !0, S.destroyed = !1, S.closed = !1, S.closeEmitted = !1, S.errored = null, S.errorEmitted = !1, S.finalCalled = !1, S.prefinished = !1, S.ended = S.writable === !1, S.ending = S.writable === !1, S.finished = S.writable === !1);
  }
  function m(w, S, O) {
    const x = w._readableState, F = w._writableState;
    if (F != null && F.destroyed || x != null && x.destroyed)
      return this;
    x != null && x.autoDestroy || F != null && F.autoDestroy ? w.destroy(S) : S && (S.stack, F && !F.errored && (F.errored = S), x && !x.errored && (x.errored = S), O ? u.nextTick(_, w, S) : _(w, S));
  }
  function g(w, S) {
    if (typeof w._construct != "function")
      return;
    const O = w._readableState, x = w._writableState;
    O && (O.constructed = !1), x && (x.constructed = !1), w.once(d, S), !(w.listenerCount(d) > 1) && u.nextTick(T, w);
  }
  function T(w) {
    let S = !1;
    function O(x) {
      if (S) {
        m(w, x ?? new o());
        return;
      }
      S = !0;
      const F = w._readableState, j = w._writableState, q = j || F;
      F && (F.constructed = !0), j && (j.constructed = !0), q.destroyed ? w.emit(s, x) : x ? m(w, x, !0) : u.nextTick(v, w);
    }
    try {
      w._construct((x) => {
        u.nextTick(O, x);
      });
    } catch (x) {
      u.nextTick(O, x);
    }
  }
  function v(w) {
    w.emit(d);
  }
  function E(w) {
    return (w == null ? void 0 : w.setHeader) && typeof w.abort == "function";
  }
  function R(w) {
    w.emit("close");
  }
  function L(w, S) {
    w.emit("error", S), u.nextTick(R, w);
  }
  function A(w, S) {
    !w || n(w) || (!S && !i(w) && (S = new a()), c(w) ? (w.socket = null, w.destroy(S)) : E(w) ? w.abort() : E(w.req) ? w.req.abort() : typeof w.destroy == "function" ? w.destroy(S) : typeof w.close == "function" ? w.close() : S ? u.nextTick(L, w, S) : u.nextTick(R, w), w.destroyed || (w[e] = !0));
  }
  return YA = {
    construct: g,
    destroyer: A,
    destroy: f,
    undestroy: y,
    errorOrDestroy: m
  }, YA;
}
var ZA, zP;
function O8() {
  if (zP) return ZA;
  zP = 1;
  const { ArrayIsArray: u, ObjectSetPrototypeOf: r } = dr(), { EventEmitter: o } = ww();
  function a(e) {
    o.call(this, e);
  }
  r(a.prototype, o.prototype), r(a, o), a.prototype.pipe = function(e, n) {
    const i = this;
    function c(b) {
      e.writable && e.write(b) === !1 && i.pause && i.pause();
    }
    i.on("data", c);
    function s() {
      i.readable && i.resume && i.resume();
    }
    e.on("drain", s), !e._isStdio && (!n || n.end !== !1) && (i.on("end", l), i.on("close", f));
    let d = !1;
    function l() {
      d || (d = !0, e.end());
    }
    function f() {
      d || (d = !0, typeof e.destroy == "function" && e.destroy());
    }
    function h(b) {
      p(), o.listenerCount(this, "error") === 0 && this.emit("error", b);
    }
    t(i, "error", h), t(e, "error", h);
    function p() {
      i.removeListener("data", c), e.removeListener("drain", s), i.removeListener("end", l), i.removeListener("close", f), i.removeListener("error", h), e.removeListener("error", h), i.removeListener("end", p), i.removeListener("close", p), e.removeListener("close", p);
    }
    return i.on("end", p), i.on("close", p), e.on("close", p), e.emit("pipe", i), e;
  };
  function t(e, n, i) {
    if (typeof e.prependListener == "function") return e.prependListener(n, i);
    !e._events || !e._events[n] ? e.on(n, i) : u(e._events[n]) ? e._events[n].unshift(i) : e._events[n] = [i, e._events[n]];
  }
  return ZA = {
    Stream: a,
    prependListener: t
  }, ZA;
}
var eE = { exports: {} }, kP;
function YS() {
  return kP || (kP = 1, function(u) {
    const { SymbolDispose: r } = dr(), { AbortError: o, codes: a } = sn(), { isNodeStream: t, isWebStream: e, kControllerErrorFunction: n } = wa(), i = nu(), { ERR_INVALID_ARG_TYPE: c } = a;
    let s;
    const d = (l, f) => {
      if (typeof l != "object" || !("aborted" in l))
        throw new c(f, "AbortSignal", l);
    };
    u.exports.addAbortSignal = function(f, h) {
      if (d(f, "signal"), !t(h) && !e(h))
        throw new c("stream", ["ReadableStream", "WritableStream", "Stream"], h);
      return u.exports.addAbortSignalNoValidate(f, h);
    }, u.exports.addAbortSignalNoValidate = function(l, f) {
      if (typeof l != "object" || !("aborted" in l))
        return f;
      const h = t(f) ? () => {
        f.destroy(
          new o(void 0, {
            cause: l.reason
          })
        );
      } : () => {
        f[n](
          new o(void 0, {
            cause: l.reason
          })
        );
      };
      if (l.aborted)
        h();
      else {
        s = s || pn().addAbortListener;
        const p = s(l, h);
        i(f, p[r]);
      }
      return f;
    };
  }(eE)), eE.exports;
}
var tE, XP;
function Tue() {
  if (XP) return tE;
  XP = 1;
  const { StringPrototypeSlice: u, SymbolIterator: r, TypedArrayPrototypeSet: o, Uint8Array: a } = dr(), { Buffer: t } = qi(), { inspect: e } = pn();
  return tE = class {
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    push(i) {
      const c = {
        data: i,
        next: null
      };
      this.length > 0 ? this.tail.next = c : this.head = c, this.tail = c, ++this.length;
    }
    unshift(i) {
      const c = {
        data: i,
        next: this.head
      };
      this.length === 0 && (this.tail = c), this.head = c, ++this.length;
    }
    shift() {
      if (this.length === 0) return;
      const i = this.head.data;
      return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, i;
    }
    clear() {
      this.head = this.tail = null, this.length = 0;
    }
    join(i) {
      if (this.length === 0) return "";
      let c = this.head, s = "" + c.data;
      for (; (c = c.next) !== null; ) s += i + c.data;
      return s;
    }
    concat(i) {
      if (this.length === 0) return t.alloc(0);
      const c = t.allocUnsafe(i >>> 0);
      let s = this.head, d = 0;
      for (; s; )
        o(c, s.data, d), d += s.data.length, s = s.next;
      return c;
    }
    // Consumes a specified amount of bytes or characters from the buffered data.
    consume(i, c) {
      const s = this.head.data;
      if (i < s.length) {
        const d = s.slice(0, i);
        return this.head.data = s.slice(i), d;
      }
      return i === s.length ? this.shift() : c ? this._getString(i) : this._getBuffer(i);
    }
    first() {
      return this.head.data;
    }
    *[r]() {
      for (let i = this.head; i; i = i.next)
        yield i.data;
    }
    // Consumes a specified amount of characters from the buffered data.
    _getString(i) {
      let c = "", s = this.head, d = 0;
      do {
        const l = s.data;
        if (i > l.length)
          c += l, i -= l.length;
        else {
          i === l.length ? (c += l, ++d, s.next ? this.head = s.next : this.head = this.tail = null) : (c += u(l, 0, i), this.head = s, s.data = u(l, i));
          break;
        }
        ++d;
      } while ((s = s.next) !== null);
      return this.length -= d, c;
    }
    // Consumes a specified amount of bytes from the buffered data.
    _getBuffer(i) {
      const c = t.allocUnsafe(i), s = i;
      let d = this.head, l = 0;
      do {
        const f = d.data;
        if (i > f.length)
          o(c, f, s - i), i -= f.length;
        else {
          i === f.length ? (o(c, f, s - i), ++l, d.next ? this.head = d.next : this.head = this.tail = null) : (o(c, new a(f.buffer, f.byteOffset, i), s - i), this.head = d, d.data = f.slice(i));
          break;
        }
        ++l;
      } while ((d = d.next) !== null);
      return this.length -= l, c;
    }
    // Make sure the linked list only shows the minimal necessary information.
    [Symbol.for("nodejs.util.inspect.custom")](i, c) {
      return e(this, {
        ...c,
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: !1
      });
    }
  }, tE;
}
var rE, JP;
function ZS() {
  if (JP) return rE;
  JP = 1;
  const { MathFloor: u, NumberIsInteger: r } = dr(), { validateInteger: o } = Ew(), { ERR_INVALID_ARG_VALUE: a } = sn().codes;
  let t = 16 * 1024, e = 16;
  function n(d, l, f) {
    return d.highWaterMark != null ? d.highWaterMark : l ? d[f] : null;
  }
  function i(d) {
    return d ? e : t;
  }
  function c(d, l) {
    o(l, "value", 0), d ? e = l : t = l;
  }
  function s(d, l, f, h) {
    const p = n(l, h, f);
    if (p != null) {
      if (!r(p) || p < 0) {
        const b = h ? `options.${f}` : "options.highWaterMark";
        throw new a(b, p);
      }
      return u(p);
    }
    return i(d.objectMode);
  }
  return rE = {
    getHighWaterMark: s,
    getDefaultHighWaterMark: i,
    setDefaultHighWaterMark: c
  }, rE;
}
var nE = {}, l6 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var KP;
function wue() {
  return KP || (KP = 1, function(u, r) {
    var o = qi(), a = o.Buffer;
    function t(n, i) {
      for (var c in n)
        i[c] = n[c];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? u.exports = o : (t(o, r), r.Buffer = e);
    function e(n, i, c) {
      return a(n, i, c);
    }
    e.prototype = Object.create(a.prototype), t(a, e), e.from = function(n, i, c) {
      if (typeof n == "number")
        throw new TypeError("Argument must not be a number");
      return a(n, i, c);
    }, e.alloc = function(n, i, c) {
      if (typeof n != "number")
        throw new TypeError("Argument must be a number");
      var s = a(n);
      return i !== void 0 ? typeof c == "string" ? s.fill(i, c) : s.fill(i) : s.fill(0), s;
    }, e.allocUnsafe = function(n) {
      if (typeof n != "number")
        throw new TypeError("Argument must be a number");
      return a(n);
    }, e.allocUnsafeSlow = function(n) {
      if (typeof n != "number")
        throw new TypeError("Argument must be a number");
      return o.SlowBuffer(n);
    };
  }(l6, l6.exports)), l6.exports;
}
var WP;
function Sue() {
  if (WP) return nE;
  WP = 1;
  var u = wue().Buffer, r = u.isEncoding || function(y) {
    switch (y = "" + y, y && y.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function o(y) {
    if (!y) return "utf8";
    for (var m; ; )
      switch (y) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return y;
        default:
          if (m) return;
          y = ("" + y).toLowerCase(), m = !0;
      }
  }
  function a(y) {
    var m = o(y);
    if (typeof m != "string" && (u.isEncoding === r || !r(y))) throw new Error("Unknown encoding: " + y);
    return m || y;
  }
  nE.StringDecoder = t;
  function t(y) {
    this.encoding = a(y);
    var m;
    switch (this.encoding) {
      case "utf16le":
        this.text = l, this.end = f, m = 4;
        break;
      case "utf8":
        this.fillLast = c, m = 4;
        break;
      case "base64":
        this.text = h, this.end = p, m = 3;
        break;
      default:
        this.write = b, this.end = _;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = u.allocUnsafe(m);
  }
  t.prototype.write = function(y) {
    if (y.length === 0) return "";
    var m, g;
    if (this.lastNeed) {
      if (m = this.fillLast(y), m === void 0) return "";
      g = this.lastNeed, this.lastNeed = 0;
    } else
      g = 0;
    return g < y.length ? m ? m + this.text(y, g) : this.text(y, g) : m || "";
  }, t.prototype.end = d, t.prototype.text = s, t.prototype.fillLast = function(y) {
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, y.length), this.lastNeed -= y.length;
  };
  function e(y) {
    return y <= 127 ? 0 : y >> 5 === 6 ? 2 : y >> 4 === 14 ? 3 : y >> 3 === 30 ? 4 : y >> 6 === 2 ? -1 : -2;
  }
  function n(y, m, g) {
    var T = m.length - 1;
    if (T < g) return 0;
    var v = e(m[T]);
    return v >= 0 ? (v > 0 && (y.lastNeed = v - 1), v) : --T < g || v === -2 ? 0 : (v = e(m[T]), v >= 0 ? (v > 0 && (y.lastNeed = v - 2), v) : --T < g || v === -2 ? 0 : (v = e(m[T]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : y.lastNeed = v - 3), v) : 0));
  }
  function i(y, m, g) {
    if ((m[0] & 192) !== 128)
      return y.lastNeed = 0, "ï¿½";
    if (y.lastNeed > 1 && m.length > 1) {
      if ((m[1] & 192) !== 128)
        return y.lastNeed = 1, "ï¿½";
      if (y.lastNeed > 2 && m.length > 2 && (m[2] & 192) !== 128)
        return y.lastNeed = 2, "ï¿½";
    }
  }
  function c(y) {
    var m = this.lastTotal - this.lastNeed, g = i(this, y);
    if (g !== void 0) return g;
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, m, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, m, 0, y.length), this.lastNeed -= y.length;
  }
  function s(y, m) {
    var g = n(this, y, m);
    if (!this.lastNeed) return y.toString("utf8", m);
    this.lastTotal = g;
    var T = y.length - (g - this.lastNeed);
    return y.copy(this.lastChar, 0, T), y.toString("utf8", m, T);
  }
  function d(y) {
    var m = y && y.length ? this.write(y) : "";
    return this.lastNeed ? m + "ï¿½" : m;
  }
  function l(y, m) {
    if ((y.length - m) % 2 === 0) {
      var g = y.toString("utf16le", m);
      if (g) {
        var T = g.charCodeAt(g.length - 1);
        if (T >= 55296 && T <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1], g.slice(0, -1);
      }
      return g;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = y[y.length - 1], y.toString("utf16le", m, y.length - 1);
  }
  function f(y) {
    var m = y && y.length ? this.write(y) : "";
    if (this.lastNeed) {
      var g = this.lastTotal - this.lastNeed;
      return m + this.lastChar.toString("utf16le", 0, g);
    }
    return m;
  }
  function h(y, m) {
    var g = (y.length - m) % 3;
    return g === 0 ? y.toString("base64", m) : (this.lastNeed = 3 - g, this.lastTotal = 3, g === 1 ? this.lastChar[0] = y[y.length - 1] : (this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1]), y.toString("base64", m, y.length - g));
  }
  function p(y) {
    var m = y && y.length ? this.write(y) : "";
    return this.lastNeed ? m + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : m;
  }
  function b(y) {
    return y.toString(this.encoding);
  }
  function _(y) {
    return y && y.length ? this.write(y) : "";
  }
  return nE;
}
var iE, YP;
function xW() {
  if (YP) return iE;
  YP = 1;
  const u = tu(), { PromisePrototypeThen: r, SymbolAsyncIterator: o, SymbolIterator: a } = dr(), { Buffer: t } = qi(), { ERR_INVALID_ARG_TYPE: e, ERR_STREAM_NULL_VALUES: n } = sn().codes;
  function i(c, s, d) {
    let l;
    if (typeof s == "string" || s instanceof t)
      return new c({
        objectMode: !0,
        ...d,
        read() {
          this.push(s), this.push(null);
        }
      });
    let f;
    if (s && s[o])
      f = !0, l = s[o]();
    else if (s && s[a])
      f = !1, l = s[a]();
    else
      throw new e("iterable", ["Iterable"], s);
    const h = new c({
      objectMode: !0,
      highWaterMark: 1,
      // TODO(ronag): What options should be allowed?
      ...d
    });
    let p = !1;
    h._read = function() {
      p || (p = !0, _());
    }, h._destroy = function(y, m) {
      r(
        b(y),
        () => u.nextTick(m, y),
        // nextTick is here in case cb throws
        (g) => u.nextTick(m, g || y)
      );
    };
    async function b(y) {
      const m = y != null, g = typeof l.throw == "function";
      if (m && g) {
        const { value: T, done: v } = await l.throw(y);
        if (await T, v)
          return;
      }
      if (typeof l.return == "function") {
        const { value: T } = await l.return();
        await T;
      }
    }
    async function _() {
      for (; ; ) {
        try {
          const { value: y, done: m } = f ? await l.next() : l.next();
          if (m)
            h.push(null);
          else {
            const g = y && typeof y.then == "function" ? await y : y;
            if (g === null)
              throw p = !1, new n();
            if (h.push(g))
              continue;
            p = !1;
          }
        } catch (y) {
          h.destroy(y);
        }
        break;
      }
    }
    return h;
  }
  return iE = i, iE;
}
var aE, ZP;
function e4() {
  if (ZP) return aE;
  ZP = 1;
  const u = tu(), {
    ArrayPrototypeIndexOf: r,
    NumberIsInteger: o,
    NumberIsNaN: a,
    NumberParseInt: t,
    ObjectDefineProperties: e,
    ObjectKeys: n,
    ObjectSetPrototypeOf: i,
    Promise: c,
    SafeSet: s,
    SymbolAsyncDispose: d,
    SymbolAsyncIterator: l,
    Symbol: f
  } = dr();
  aE = fe, fe.ReadableState = le;
  const { EventEmitter: h } = ww(), { Stream: p, prependListener: b } = O8(), { Buffer: _ } = qi(), { addAbortSignal: y } = YS(), m = nu();
  let g = pn().debuglog("stream", (ne) => {
    g = ne;
  });
  const T = Tue(), v = bh(), { getHighWaterMark: E, getDefaultHighWaterMark: R } = ZS(), {
    aggregateTwoErrors: L,
    codes: {
      ERR_INVALID_ARG_TYPE: A,
      ERR_METHOD_NOT_IMPLEMENTED: w,
      ERR_OUT_OF_RANGE: S,
      ERR_STREAM_PUSH_AFTER_EOF: O,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: x
    },
    AbortError: F
  } = sn(), { validateObject: j } = Ew(), q = f("kPaused"), { StringDecoder: Q } = Sue(), G = xW();
  i(fe.prototype, p.prototype), i(fe, p);
  const K = () => {
  }, { errorOrDestroy: U } = v, ae = 1, ye = 2, pe = 4, ee = 8, Te = 16, we = 32, Oe = 64, be = 128, he = 256, V = 512, N = 1024, M = 2048, I = 4096, P = 8192, B = 16384, z = 32768, H = 65536, J = 1 << 17, k = 1 << 18;
  function W(ne) {
    return {
      enumerable: !1,
      get() {
        return (this.state & ne) !== 0;
      },
      set(ie) {
        ie ? this.state |= ne : this.state &= ~ne;
      }
    };
  }
  e(le.prototype, {
    objectMode: W(ae),
    ended: W(ye),
    endEmitted: W(pe),
    reading: W(ee),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: W(Te),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: W(we),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: W(Oe),
    emittedReadable: W(be),
    readableListening: W(he),
    resumeScheduled: W(V),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: W(N),
    emitClose: W(M),
    autoDestroy: W(I),
    // Has it been destroyed.
    destroyed: W(P),
    // Indicates whether the stream has finished destroying.
    closed: W(B),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: W(z),
    multiAwaitDrain: W(H),
    // If true, a maybeReadMore has been scheduled.
    readingMore: W(J),
    dataEmitted: W(k)
  });
  function le(ne, ie, je) {
    typeof je != "boolean" && (je = ie instanceof ma()), this.state = M | I | Te | we, ne && ne.objectMode && (this.state |= ae), je && ne && ne.readableObjectMode && (this.state |= ae), this.highWaterMark = ne ? E(this, ne, "readableHighWaterMark", je) : R(!1), this.buffer = new T(), this.length = 0, this.pipes = [], this.flowing = null, this[q] = null, ne && ne.emitClose === !1 && (this.state &= ~M), ne && ne.autoDestroy === !1 && (this.state &= ~I), this.errored = null, this.defaultEncoding = ne && ne.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, ne && ne.encoding && (this.decoder = new Q(ne.encoding), this.encoding = ne.encoding);
  }
  function fe(ne) {
    if (!(this instanceof fe)) return new fe(ne);
    const ie = this instanceof ma();
    this._readableState = new le(ne, this, ie), ne && (typeof ne.read == "function" && (this._read = ne.read), typeof ne.destroy == "function" && (this._destroy = ne.destroy), typeof ne.construct == "function" && (this._construct = ne.construct), ne.signal && !ie && y(ne.signal, this)), p.call(this, ne), v.construct(this, () => {
      this._readableState.needReadable && te(this, this._readableState);
    });
  }
  fe.prototype.destroy = v.destroy, fe.prototype._undestroy = v.undestroy, fe.prototype._destroy = function(ne, ie) {
    ie(ne);
  }, fe.prototype[h.captureRejectionSymbol] = function(ne) {
    this.destroy(ne);
  }, fe.prototype[d] = function() {
    let ne;
    return this.destroyed || (ne = this.readableEnded ? null : new F(), this.destroy(ne)), new c((ie, je) => m(this, ($e) => $e && $e !== ne ? je($e) : ie(null)));
  }, fe.prototype.push = function(ne, ie) {
    return me(this, ne, ie, !1);
  }, fe.prototype.unshift = function(ne, ie) {
    return me(this, ne, ie, !0);
  };
  function me(ne, ie, je, $e) {
    g("readableAddChunk", ie);
    const He = ne._readableState;
    let At;
    if ((He.state & ae) === 0 && (typeof ie == "string" ? (je = je || He.defaultEncoding, He.encoding !== je && ($e && He.encoding ? ie = _.from(ie, je).toString(He.encoding) : (ie = _.from(ie, je), je = ""))) : ie instanceof _ ? je = "" : p._isUint8Array(ie) ? (ie = p._uint8ArrayToBuffer(ie), je = "") : ie != null && (At = new A("chunk", ["string", "Buffer", "Uint8Array"], ie))), At)
      U(ne, At);
    else if (ie === null)
      He.state &= ~ee, D(ne, He);
    else if ((He.state & ae) !== 0 || ie && ie.length > 0)
      if ($e)
        if ((He.state & pe) !== 0) U(ne, new x());
        else {
          if (He.destroyed || He.errored) return !1;
          Ne(ne, He, ie, !0);
        }
      else if (He.ended)
        U(ne, new O());
      else {
        if (He.destroyed || He.errored)
          return !1;
        He.state &= ~ee, He.decoder && !je ? (ie = He.decoder.write(ie), He.objectMode || ie.length !== 0 ? Ne(ne, He, ie, !1) : te(ne, He)) : Ne(ne, He, ie, !1);
      }
    else $e || (He.state &= ~ee, te(ne, He));
    return !He.ended && (He.length < He.highWaterMark || He.length === 0);
  }
  function Ne(ne, ie, je, $e) {
    ie.flowing && ie.length === 0 && !ie.sync && ne.listenerCount("data") > 0 ? ((ie.state & H) !== 0 ? ie.awaitDrainWriters.clear() : ie.awaitDrainWriters = null, ie.dataEmitted = !0, ne.emit("data", je)) : (ie.length += ie.objectMode ? 1 : je.length, $e ? ie.buffer.unshift(je) : ie.buffer.push(je), (ie.state & Oe) !== 0 && C(ne)), te(ne, ie);
  }
  fe.prototype.isPaused = function() {
    const ne = this._readableState;
    return ne[q] === !0 || ne.flowing === !1;
  }, fe.prototype.setEncoding = function(ne) {
    const ie = new Q(ne);
    this._readableState.decoder = ie, this._readableState.encoding = this._readableState.decoder.encoding;
    const je = this._readableState.buffer;
    let $e = "";
    for (const He of je)
      $e += ie.write(He);
    return je.clear(), $e !== "" && je.push($e), this._readableState.length = $e.length, this;
  };
  const xe = 1073741824;
  function ue(ne) {
    if (ne > xe)
      throw new S("size", "<= 1GiB", ne);
    return ne--, ne |= ne >>> 1, ne |= ne >>> 2, ne |= ne >>> 4, ne |= ne >>> 8, ne |= ne >>> 16, ne++, ne;
  }
  function $(ne, ie) {
    return ne <= 0 || ie.length === 0 && ie.ended ? 0 : (ie.state & ae) !== 0 ? 1 : a(ne) ? ie.flowing && ie.length ? ie.buffer.first().length : ie.length : ne <= ie.length ? ne : ie.ended ? ie.length : 0;
  }
  fe.prototype.read = function(ne) {
    g("read", ne), ne === void 0 ? ne = NaN : o(ne) || (ne = t(ne, 10));
    const ie = this._readableState, je = ne;
    if (ne > ie.highWaterMark && (ie.highWaterMark = ue(ne)), ne !== 0 && (ie.state &= ~be), ne === 0 && ie.needReadable && ((ie.highWaterMark !== 0 ? ie.length >= ie.highWaterMark : ie.length > 0) || ie.ended))
      return g("read: emitReadable", ie.length, ie.ended), ie.length === 0 && ie.ended ? Le(this) : C(this), null;
    if (ne = $(ne, ie), ne === 0 && ie.ended)
      return ie.length === 0 && Le(this), null;
    let $e = (ie.state & Oe) !== 0;
    if (g("need readable", $e), (ie.length === 0 || ie.length - ne < ie.highWaterMark) && ($e = !0, g("length less than watermark", $e)), ie.ended || ie.reading || ie.destroyed || ie.errored || !ie.constructed)
      $e = !1, g("reading, ended or constructing", $e);
    else if ($e) {
      g("do read"), ie.state |= ee | we, ie.length === 0 && (ie.state |= Oe);
      try {
        this._read(ie.highWaterMark);
      } catch (At) {
        U(this, At);
      }
      ie.state &= ~we, ie.reading || (ne = $(je, ie));
    }
    let He;
    return ne > 0 ? He = Ue(ne, ie) : He = null, He === null ? (ie.needReadable = ie.length <= ie.highWaterMark, ne = 0) : (ie.length -= ne, ie.multiAwaitDrain ? ie.awaitDrainWriters.clear() : ie.awaitDrainWriters = null), ie.length === 0 && (ie.ended || (ie.needReadable = !0), je !== ne && ie.ended && Le(this)), He !== null && !ie.errorEmitted && !ie.closeEmitted && (ie.dataEmitted = !0, this.emit("data", He)), He;
  };
  function D(ne, ie) {
    if (g("onEofChunk"), !ie.ended) {
      if (ie.decoder) {
        const je = ie.decoder.end();
        je && je.length && (ie.buffer.push(je), ie.length += ie.objectMode ? 1 : je.length);
      }
      ie.ended = !0, ie.sync ? C(ne) : (ie.needReadable = !1, ie.emittedReadable = !0, X(ne));
    }
  }
  function C(ne) {
    const ie = ne._readableState;
    g("emitReadable", ie.needReadable, ie.emittedReadable), ie.needReadable = !1, ie.emittedReadable || (g("emitReadable", ie.flowing), ie.emittedReadable = !0, u.nextTick(X, ne));
  }
  function X(ne) {
    const ie = ne._readableState;
    g("emitReadable_", ie.destroyed, ie.length, ie.ended), !ie.destroyed && !ie.errored && (ie.length || ie.ended) && (ne.emit("readable"), ie.emittedReadable = !1), ie.needReadable = !ie.flowing && !ie.ended && ie.length <= ie.highWaterMark, Y(ne);
  }
  function te(ne, ie) {
    !ie.readingMore && ie.constructed && (ie.readingMore = !0, u.nextTick(de, ne, ie));
  }
  function de(ne, ie) {
    for (; !ie.reading && !ie.ended && (ie.length < ie.highWaterMark || ie.flowing && ie.length === 0); ) {
      const je = ie.length;
      if (g("maybeReadMore read 0"), ne.read(0), je === ie.length)
        break;
    }
    ie.readingMore = !1;
  }
  fe.prototype._read = function(ne) {
    throw new w("_read()");
  }, fe.prototype.pipe = function(ne, ie) {
    const je = this, $e = this._readableState;
    $e.pipes.length === 1 && ($e.multiAwaitDrain || ($e.multiAwaitDrain = !0, $e.awaitDrainWriters = new s($e.awaitDrainWriters ? [$e.awaitDrainWriters] : []))), $e.pipes.push(ne), g("pipe count=%d opts=%j", $e.pipes.length, ie);
    const At = (!ie || ie.end !== !1) && ne !== u.stdout && ne !== u.stderr ? bt : se;
    $e.endEmitted ? u.nextTick(At) : je.once("end", At), ne.on("unpipe", Qe);
    function Qe(ge, Se) {
      g("onunpipe"), ge === je && Se && Se.hasUnpiped === !1 && (Se.hasUnpiped = !0, rt());
    }
    function bt() {
      g("onend"), ne.end();
    }
    let Ge, Je = !1;
    function rt() {
      g("cleanup"), ne.removeListener("close", Ur), ne.removeListener("finish", ze), Ge && ne.removeListener("drain", Ge), ne.removeListener("error", Xe), ne.removeListener("unpipe", Qe), je.removeListener("end", bt), je.removeListener("end", se), je.removeListener("data", ot), Je = !0, Ge && $e.awaitDrainWriters && (!ne._writableState || ne._writableState.needDrain) && Ge();
    }
    function Et() {
      Je || ($e.pipes.length === 1 && $e.pipes[0] === ne ? (g("false write response, pause", 0), $e.awaitDrainWriters = ne, $e.multiAwaitDrain = !1) : $e.pipes.length > 1 && $e.pipes.includes(ne) && (g("false write response, pause", $e.awaitDrainWriters.size), $e.awaitDrainWriters.add(ne)), je.pause()), Ge || (Ge = oe(je, ne), ne.on("drain", Ge));
    }
    je.on("data", ot);
    function ot(ge) {
      g("ondata");
      const Se = ne.write(ge);
      g("dest.write", Se), Se === !1 && Et();
    }
    function Xe(ge) {
      if (g("onerror", ge), se(), ne.removeListener("error", Xe), ne.listenerCount("error") === 0) {
        const Se = ne._writableState || ne._readableState;
        Se && !Se.errorEmitted ? U(ne, ge) : ne.emit("error", ge);
      }
    }
    b(ne, "error", Xe);
    function Ur() {
      ne.removeListener("finish", ze), se();
    }
    ne.once("close", Ur);
    function ze() {
      g("onfinish"), ne.removeListener("close", Ur), se();
    }
    ne.once("finish", ze);
    function se() {
      g("unpipe"), je.unpipe(ne);
    }
    return ne.emit("pipe", je), ne.writableNeedDrain === !0 ? Et() : $e.flowing || (g("pipe resume"), je.resume()), ne;
  };
  function oe(ne, ie) {
    return function() {
      const $e = ne._readableState;
      $e.awaitDrainWriters === ie ? (g("pipeOnDrain", 1), $e.awaitDrainWriters = null) : $e.multiAwaitDrain && (g("pipeOnDrain", $e.awaitDrainWriters.size), $e.awaitDrainWriters.delete(ie)), (!$e.awaitDrainWriters || $e.awaitDrainWriters.size === 0) && ne.listenerCount("data") && ne.resume();
    };
  }
  fe.prototype.unpipe = function(ne) {
    const ie = this._readableState, je = {
      hasUnpiped: !1
    };
    if (ie.pipes.length === 0) return this;
    if (!ne) {
      const He = ie.pipes;
      ie.pipes = [], this.pause();
      for (let At = 0; At < He.length; At++)
        He[At].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const $e = r(ie.pipes, ne);
    return $e === -1 ? this : (ie.pipes.splice($e, 1), ie.pipes.length === 0 && this.pause(), ne.emit("unpipe", this, je), this);
  }, fe.prototype.on = function(ne, ie) {
    const je = p.prototype.on.call(this, ne, ie), $e = this._readableState;
    return ne === "data" ? ($e.readableListening = this.listenerCount("readable") > 0, $e.flowing !== !1 && this.resume()) : ne === "readable" && !$e.endEmitted && !$e.readableListening && ($e.readableListening = $e.needReadable = !0, $e.flowing = !1, $e.emittedReadable = !1, g("on readable", $e.length, $e.reading), $e.length ? C(this) : $e.reading || u.nextTick(Ve, this)), je;
  }, fe.prototype.addListener = fe.prototype.on, fe.prototype.removeListener = function(ne, ie) {
    const je = p.prototype.removeListener.call(this, ne, ie);
    return ne === "readable" && u.nextTick(De, this), je;
  }, fe.prototype.off = fe.prototype.removeListener, fe.prototype.removeAllListeners = function(ne) {
    const ie = p.prototype.removeAllListeners.apply(this, arguments);
    return (ne === "readable" || ne === void 0) && u.nextTick(De, this), ie;
  };
  function De(ne) {
    const ie = ne._readableState;
    ie.readableListening = ne.listenerCount("readable") > 0, ie.resumeScheduled && ie[q] === !1 ? ie.flowing = !0 : ne.listenerCount("data") > 0 ? ne.resume() : ie.readableListening || (ie.flowing = null);
  }
  function Ve(ne) {
    g("readable nexttick read 0"), ne.read(0);
  }
  fe.prototype.resume = function() {
    const ne = this._readableState;
    return ne.flowing || (g("resume"), ne.flowing = !ne.readableListening, qe(this, ne)), ne[q] = !1, this;
  };
  function qe(ne, ie) {
    ie.resumeScheduled || (ie.resumeScheduled = !0, u.nextTick(Ke, ne, ie));
  }
  function Ke(ne, ie) {
    g("resume", ie.reading), ie.reading || ne.read(0), ie.resumeScheduled = !1, ne.emit("resume"), Y(ne), ie.flowing && !ie.reading && ne.read(0);
  }
  fe.prototype.pause = function() {
    return g("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (g("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[q] = !0, this;
  };
  function Y(ne) {
    const ie = ne._readableState;
    for (g("flow", ie.flowing); ie.flowing && ne.read() !== null; ) ;
  }
  fe.prototype.wrap = function(ne) {
    let ie = !1;
    ne.on("data", ($e) => {
      !this.push($e) && ne.pause && (ie = !0, ne.pause());
    }), ne.on("end", () => {
      this.push(null);
    }), ne.on("error", ($e) => {
      U(this, $e);
    }), ne.on("close", () => {
      this.destroy();
    }), ne.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      ie && ne.resume && (ie = !1, ne.resume());
    };
    const je = n(ne);
    for (let $e = 1; $e < je.length; $e++) {
      const He = je[$e];
      this[He] === void 0 && typeof ne[He] == "function" && (this[He] = ne[He].bind(ne));
    }
    return this;
  }, fe.prototype[l] = function() {
    return Ee(this);
  }, fe.prototype.iterator = function(ne) {
    return ne !== void 0 && j(ne, "options"), Ee(this, ne);
  };
  function Ee(ne, ie) {
    typeof ne.read != "function" && (ne = fe.wrap(ne, {
      objectMode: !0
    }));
    const je = Ie(ne, ie);
    return je.stream = ne, je;
  }
  async function* Ie(ne, ie) {
    let je = K;
    function $e(Qe) {
      this === ne ? (je(), je = K) : je = Qe;
    }
    ne.on("readable", $e);
    let He;
    const At = m(
      ne,
      {
        writable: !1
      },
      (Qe) => {
        He = Qe ? L(He, Qe) : null, je(), je = K;
      }
    );
    try {
      for (; ; ) {
        const Qe = ne.destroyed ? null : ne.read();
        if (Qe !== null)
          yield Qe;
        else {
          if (He)
            throw He;
          if (He === null)
            return;
          await new c($e);
        }
      }
    } catch (Qe) {
      throw He = L(He, Qe), He;
    } finally {
      (He || (ie == null ? void 0 : ie.destroyOnReturn) !== !1) && (He === void 0 || ne._readableState.autoDestroy) ? v.destroyer(ne, null) : (ne.off("readable", $e), At());
    }
  }
  e(fe.prototype, {
    readable: {
      __proto__: null,
      get() {
        const ne = this._readableState;
        return !!ne && ne.readable !== !1 && !ne.destroyed && !ne.errorEmitted && !ne.endEmitted;
      },
      set(ne) {
        this._readableState && (this._readableState.readable = !!ne);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(ne) {
        this._readableState && (this._readableState.flowing = ne);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(ne) {
        this._readableState && (this._readableState.destroyed = ne);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), e(le.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[q] !== !1;
      },
      set(ne) {
        this[q] = !!ne;
      }
    }
  }), fe._fromList = Ue;
  function Ue(ne, ie) {
    if (ie.length === 0) return null;
    let je;
    return ie.objectMode ? je = ie.buffer.shift() : !ne || ne >= ie.length ? (ie.decoder ? je = ie.buffer.join("") : ie.buffer.length === 1 ? je = ie.buffer.first() : je = ie.buffer.concat(ie.length), ie.buffer.clear()) : je = ie.buffer.consume(ne, ie.decoder), je;
  }
  function Le(ne) {
    const ie = ne._readableState;
    g("endReadable", ie.endEmitted), ie.endEmitted || (ie.ended = !0, u.nextTick(tt, ie, ne));
  }
  function tt(ne, ie) {
    if (g("endReadableNT", ne.endEmitted, ne.length), !ne.errored && !ne.closeEmitted && !ne.endEmitted && ne.length === 0) {
      if (ne.endEmitted = !0, ie.emit("end"), ie.writable && ie.allowHalfOpen === !1)
        u.nextTick(it, ie);
      else if (ne.autoDestroy) {
        const je = ie._writableState;
        (!je || je.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (je.finished || je.writable === !1)) && ie.destroy();
      }
    }
  }
  function it(ne) {
    ne.writable && !ne.writableEnded && !ne.destroyed && ne.end();
  }
  fe.from = function(ne, ie) {
    return G(fe, ne, ie);
  };
  let Ye;
  function ht() {
    return Ye === void 0 && (Ye = {}), Ye;
  }
  return fe.fromWeb = function(ne, ie) {
    return ht().newStreamReadableFromReadableStream(ne, ie);
  }, fe.toWeb = function(ne, ie) {
    return ht().newReadableStreamFromStreamReadable(ne, ie);
  }, fe.wrap = function(ne, ie) {
    var je, $e;
    return new fe({
      objectMode: (je = ($e = ne.readableObjectMode) !== null && $e !== void 0 ? $e : ne.objectMode) !== null && je !== void 0 ? je : !0,
      ...ie,
      destroy(He, At) {
        v.destroyer(ne, He), At(He);
      }
    }).wrap(ne);
  }, aE;
}
var uE, e9;
function x8() {
  if (e9) return uE;
  e9 = 1;
  const u = tu(), {
    ArrayPrototypeSlice: r,
    Error: o,
    FunctionPrototypeSymbolHasInstance: a,
    ObjectDefineProperty: t,
    ObjectDefineProperties: e,
    ObjectSetPrototypeOf: n,
    StringPrototypeToLowerCase: i,
    Symbol: c,
    SymbolHasInstance: s
  } = dr();
  uE = j, j.WritableState = x;
  const { EventEmitter: d } = ww(), l = O8().Stream, { Buffer: f } = qi(), h = bh(), { addAbortSignal: p } = YS(), { getHighWaterMark: b, getDefaultHighWaterMark: _ } = ZS(), {
    ERR_INVALID_ARG_TYPE: y,
    ERR_METHOD_NOT_IMPLEMENTED: m,
    ERR_MULTIPLE_CALLBACK: g,
    ERR_STREAM_CANNOT_PIPE: T,
    ERR_STREAM_DESTROYED: v,
    ERR_STREAM_ALREADY_FINISHED: E,
    ERR_STREAM_NULL_VALUES: R,
    ERR_STREAM_WRITE_AFTER_END: L,
    ERR_UNKNOWN_ENCODING: A
  } = sn().codes, { errorOrDestroy: w } = h;
  n(j.prototype, l.prototype), n(j, l);
  function S() {
  }
  const O = c("kOnFinished");
  function x(I, P, B) {
    typeof B != "boolean" && (B = P instanceof ma()), this.objectMode = !!(I && I.objectMode), B && (this.objectMode = this.objectMode || !!(I && I.writableObjectMode)), this.highWaterMark = I ? b(this, I, "writableHighWaterMark", B) : _(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const z = !!(I && I.decodeStrings === !1);
    this.decodeStrings = !z, this.defaultEncoding = I && I.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = U.bind(void 0, P), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, F(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !I || I.emitClose !== !1, this.autoDestroy = !I || I.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[O] = [];
  }
  function F(I) {
    I.buffered = [], I.bufferedIndex = 0, I.allBuffers = !0, I.allNoop = !0;
  }
  x.prototype.getBuffer = function() {
    return r(this.buffered, this.bufferedIndex);
  }, t(x.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function j(I) {
    const P = this instanceof ma();
    if (!P && !a(j, this)) return new j(I);
    this._writableState = new x(I, this, P), I && (typeof I.write == "function" && (this._write = I.write), typeof I.writev == "function" && (this._writev = I.writev), typeof I.destroy == "function" && (this._destroy = I.destroy), typeof I.final == "function" && (this._final = I.final), typeof I.construct == "function" && (this._construct = I.construct), I.signal && p(I.signal, this)), l.call(this, I), h.construct(this, () => {
      const B = this._writableState;
      B.writing || ee(this, B), be(this, B);
    });
  }
  t(j, s, {
    __proto__: null,
    value: function(I) {
      return a(this, I) ? !0 : this !== j ? !1 : I && I._writableState instanceof x;
    }
  }), j.prototype.pipe = function() {
    w(this, new T());
  };
  function q(I, P, B, z) {
    const H = I._writableState;
    if (typeof B == "function")
      z = B, B = H.defaultEncoding;
    else {
      if (!B) B = H.defaultEncoding;
      else if (B !== "buffer" && !f.isEncoding(B)) throw new A(B);
      typeof z != "function" && (z = S);
    }
    if (P === null)
      throw new R();
    if (!H.objectMode)
      if (typeof P == "string")
        H.decodeStrings !== !1 && (P = f.from(P, B), B = "buffer");
      else if (P instanceof f)
        B = "buffer";
      else if (l._isUint8Array(P))
        P = l._uint8ArrayToBuffer(P), B = "buffer";
      else
        throw new y("chunk", ["string", "Buffer", "Uint8Array"], P);
    let J;
    return H.ending ? J = new L() : H.destroyed && (J = new v("write")), J ? (u.nextTick(z, J), w(I, J, !0), J) : (H.pendingcb++, Q(I, H, P, B, z));
  }
  j.prototype.write = function(I, P, B) {
    return q(this, I, P, B) === !0;
  }, j.prototype.cork = function() {
    this._writableState.corked++;
  }, j.prototype.uncork = function() {
    const I = this._writableState;
    I.corked && (I.corked--, I.writing || ee(this, I));
  }, j.prototype.setDefaultEncoding = function(P) {
    if (typeof P == "string" && (P = i(P)), !f.isEncoding(P)) throw new A(P);
    return this._writableState.defaultEncoding = P, this;
  };
  function Q(I, P, B, z, H) {
    const J = P.objectMode ? 1 : B.length;
    P.length += J;
    const k = P.length < P.highWaterMark;
    return k || (P.needDrain = !0), P.writing || P.corked || P.errored || !P.constructed ? (P.buffered.push({
      chunk: B,
      encoding: z,
      callback: H
    }), P.allBuffers && z !== "buffer" && (P.allBuffers = !1), P.allNoop && H !== S && (P.allNoop = !1)) : (P.writelen = J, P.writecb = H, P.writing = !0, P.sync = !0, I._write(B, z, P.onwrite), P.sync = !1), k && !P.errored && !P.destroyed;
  }
  function G(I, P, B, z, H, J, k) {
    P.writelen = z, P.writecb = k, P.writing = !0, P.sync = !0, P.destroyed ? P.onwrite(new v("write")) : B ? I._writev(H, P.onwrite) : I._write(H, J, P.onwrite), P.sync = !1;
  }
  function K(I, P, B, z) {
    --P.pendingcb, z(B), pe(P), w(I, B);
  }
  function U(I, P) {
    const B = I._writableState, z = B.sync, H = B.writecb;
    if (typeof H != "function") {
      w(I, new g());
      return;
    }
    B.writing = !1, B.writecb = null, B.length -= B.writelen, B.writelen = 0, P ? (P.stack, B.errored || (B.errored = P), I._readableState && !I._readableState.errored && (I._readableState.errored = P), z ? u.nextTick(K, I, B, P, H) : K(I, B, P, H)) : (B.buffered.length > B.bufferedIndex && ee(I, B), z ? B.afterWriteTickInfo !== null && B.afterWriteTickInfo.cb === H ? B.afterWriteTickInfo.count++ : (B.afterWriteTickInfo = {
      count: 1,
      cb: H,
      stream: I,
      state: B
    }, u.nextTick(ae, B.afterWriteTickInfo)) : ye(I, B, 1, H));
  }
  function ae({ stream: I, state: P, count: B, cb: z }) {
    return P.afterWriteTickInfo = null, ye(I, P, B, z);
  }
  function ye(I, P, B, z) {
    for (!P.ending && !I.destroyed && P.length === 0 && P.needDrain && (P.needDrain = !1, I.emit("drain")); B-- > 0; )
      P.pendingcb--, z();
    P.destroyed && pe(P), be(I, P);
  }
  function pe(I) {
    if (I.writing)
      return;
    for (let H = I.bufferedIndex; H < I.buffered.length; ++H) {
      var P;
      const { chunk: J, callback: k } = I.buffered[H], W = I.objectMode ? 1 : J.length;
      I.length -= W, k(
        (P = I.errored) !== null && P !== void 0 ? P : new v("write")
      );
    }
    const B = I[O].splice(0);
    for (let H = 0; H < B.length; H++) {
      var z;
      B[H](
        (z = I.errored) !== null && z !== void 0 ? z : new v("end")
      );
    }
    F(I);
  }
  function ee(I, P) {
    if (P.corked || P.bufferProcessing || P.destroyed || !P.constructed)
      return;
    const { buffered: B, bufferedIndex: z, objectMode: H } = P, J = B.length - z;
    if (!J)
      return;
    let k = z;
    if (P.bufferProcessing = !0, J > 1 && I._writev) {
      P.pendingcb -= J - 1;
      const W = P.allNoop ? S : (fe) => {
        for (let me = k; me < B.length; ++me)
          B[me].callback(fe);
      }, le = P.allNoop && k === 0 ? B : r(B, k);
      le.allBuffers = P.allBuffers, G(I, P, !0, P.length, le, "", W), F(P);
    } else {
      do {
        const { chunk: W, encoding: le, callback: fe } = B[k];
        B[k++] = null;
        const me = H ? 1 : W.length;
        G(I, P, !1, me, W, le, fe);
      } while (k < B.length && !P.writing);
      k === B.length ? F(P) : k > 256 ? (B.splice(0, k), P.bufferedIndex = 0) : P.bufferedIndex = k;
    }
    P.bufferProcessing = !1;
  }
  j.prototype._write = function(I, P, B) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: I,
            encoding: P
          }
        ],
        B
      );
    else
      throw new m("_write()");
  }, j.prototype._writev = null, j.prototype.end = function(I, P, B) {
    const z = this._writableState;
    typeof I == "function" ? (B = I, I = null, P = null) : typeof P == "function" && (B = P, P = null);
    let H;
    if (I != null) {
      const J = q(this, I, P);
      J instanceof o && (H = J);
    }
    return z.corked && (z.corked = 1, this.uncork()), H || (!z.errored && !z.ending ? (z.ending = !0, be(this, z, !0), z.ended = !0) : z.finished ? H = new E("end") : z.destroyed && (H = new v("end"))), typeof B == "function" && (H || z.finished ? u.nextTick(B, H) : z[O].push(B)), this;
  };
  function Te(I) {
    return I.ending && !I.destroyed && I.constructed && I.length === 0 && !I.errored && I.buffered.length === 0 && !I.finished && !I.writing && !I.errorEmitted && !I.closeEmitted;
  }
  function we(I, P) {
    let B = !1;
    function z(H) {
      if (B) {
        w(I, H ?? g());
        return;
      }
      if (B = !0, P.pendingcb--, H) {
        const J = P[O].splice(0);
        for (let k = 0; k < J.length; k++)
          J[k](H);
        w(I, H, P.sync);
      } else Te(P) && (P.prefinished = !0, I.emit("prefinish"), P.pendingcb++, u.nextTick(he, I, P));
    }
    P.sync = !0, P.pendingcb++;
    try {
      I._final(z);
    } catch (H) {
      z(H);
    }
    P.sync = !1;
  }
  function Oe(I, P) {
    !P.prefinished && !P.finalCalled && (typeof I._final == "function" && !P.destroyed ? (P.finalCalled = !0, we(I, P)) : (P.prefinished = !0, I.emit("prefinish")));
  }
  function be(I, P, B) {
    Te(P) && (Oe(I, P), P.pendingcb === 0 && (B ? (P.pendingcb++, u.nextTick(
      (z, H) => {
        Te(H) ? he(z, H) : H.pendingcb--;
      },
      I,
      P
    )) : Te(P) && (P.pendingcb++, he(I, P))));
  }
  function he(I, P) {
    P.pendingcb--, P.finished = !0;
    const B = P[O].splice(0);
    for (let z = 0; z < B.length; z++)
      B[z]();
    if (I.emit("finish"), P.autoDestroy) {
      const z = I._readableState;
      (!z || z.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (z.endEmitted || z.readable === !1)) && I.destroy();
    }
  }
  e(j.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(I) {
        this._writableState && (this._writableState.destroyed = I);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const I = this._writableState;
        return !!I && I.writable !== !1 && !I.destroyed && !I.errored && !I.ending && !I.ended;
      },
      set(I) {
        this._writableState && (this._writableState.writable = !!I);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const I = this._writableState;
        return I ? !I.destroyed && !I.ending && I.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const V = h.destroy;
  j.prototype.destroy = function(I, P) {
    const B = this._writableState;
    return !B.destroyed && (B.bufferedIndex < B.buffered.length || B[O].length) && u.nextTick(pe, B), V.call(this, I, P), this;
  }, j.prototype._undestroy = h.undestroy, j.prototype._destroy = function(I, P) {
    P(I);
  }, j.prototype[d.captureRejectionSymbol] = function(I) {
    this.destroy(I);
  };
  let N;
  function M() {
    return N === void 0 && (N = {}), N;
  }
  return j.fromWeb = function(I, P) {
    return M().newStreamWritableFromWritableStream(I, P);
  }, j.toWeb = function(I) {
    return M().newWritableStreamFromStreamWritable(I);
  }, uE;
}
var oE, t9;
function Aue() {
  if (t9) return oE;
  t9 = 1;
  const u = tu(), r = qi(), {
    isReadable: o,
    isWritable: a,
    isIterable: t,
    isNodeStream: e,
    isReadableNodeStream: n,
    isWritableNodeStream: i,
    isDuplexNodeStream: c,
    isReadableStream: s,
    isWritableStream: d
  } = wa(), l = nu(), {
    AbortError: f,
    codes: { ERR_INVALID_ARG_TYPE: h, ERR_INVALID_RETURN_VALUE: p }
  } = sn(), { destroyer: b } = bh(), _ = ma(), y = e4(), m = x8(), { createDeferredPromise: g } = pn(), T = xW(), v = globalThis.Blob || r.Blob, E = typeof v < "u" ? function(x) {
    return x instanceof v;
  } : function(x) {
    return !1;
  }, R = globalThis.AbortController || KT().AbortController, { FunctionPrototypeCall: L } = dr();
  class A extends _ {
    constructor(x) {
      super(x), (x == null ? void 0 : x.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (x == null ? void 0 : x.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  oE = function O(x, F) {
    if (c(x))
      return x;
    if (n(x))
      return S({
        readable: x
      });
    if (i(x))
      return S({
        writable: x
      });
    if (e(x))
      return S({
        writable: !1,
        readable: !1
      });
    if (s(x))
      return S({
        readable: y.fromWeb(x)
      });
    if (d(x))
      return S({
        writable: m.fromWeb(x)
      });
    if (typeof x == "function") {
      const { value: q, write: Q, final: G, destroy: K } = w(x);
      if (t(q))
        return T(A, q, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: Q,
          final: G,
          destroy: K
        });
      const U = q == null ? void 0 : q.then;
      if (typeof U == "function") {
        let ae;
        const ye = L(
          U,
          q,
          (pe) => {
            if (pe != null)
              throw new p("nully", "body", pe);
          },
          (pe) => {
            b(ae, pe);
          }
        );
        return ae = new A({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: Q,
          final(pe) {
            G(async () => {
              try {
                await ye, u.nextTick(pe, null);
              } catch (ee) {
                u.nextTick(pe, ee);
              }
            });
          },
          destroy: K
        });
      }
      throw new p("Iterable, AsyncIterable or AsyncFunction", F, q);
    }
    if (E(x))
      return O(x.arrayBuffer());
    if (t(x))
      return T(A, x, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (s(x == null ? void 0 : x.readable) && d(x == null ? void 0 : x.writable))
      return A.fromWeb(x);
    if (typeof (x == null ? void 0 : x.writable) == "object" || typeof (x == null ? void 0 : x.readable) == "object") {
      const q = x != null && x.readable ? n(x == null ? void 0 : x.readable) ? x == null ? void 0 : x.readable : O(x.readable) : void 0, Q = x != null && x.writable ? i(x == null ? void 0 : x.writable) ? x == null ? void 0 : x.writable : O(x.writable) : void 0;
      return S({
        readable: q,
        writable: Q
      });
    }
    const j = x == null ? void 0 : x.then;
    if (typeof j == "function") {
      let q;
      return L(
        j,
        x,
        (Q) => {
          Q != null && q.push(Q), q.push(null);
        },
        (Q) => {
          b(q, Q);
        }
      ), q = new A({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new h(
      F,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      x
    );
  };
  function w(O) {
    let { promise: x, resolve: F } = g();
    const j = new R(), q = j.signal;
    return {
      value: O(
        async function* () {
          for (; ; ) {
            const G = x;
            x = null;
            const { chunk: K, done: U, cb: ae } = await G;
            if (u.nextTick(ae), U) return;
            if (q.aborted)
              throw new f(void 0, {
                cause: q.reason
              });
            ({ promise: x, resolve: F } = g()), yield K;
          }
        }(),
        {
          signal: q
        }
      ),
      write(G, K, U) {
        const ae = F;
        F = null, ae({
          chunk: G,
          done: !1,
          cb: U
        });
      },
      final(G) {
        const K = F;
        F = null, K({
          done: !0,
          cb: G
        });
      },
      destroy(G, K) {
        j.abort(), K(G);
      }
    };
  }
  function S(O) {
    const x = O.readable && typeof O.readable.read != "function" ? y.wrap(O.readable) : O.readable, F = O.writable;
    let j = !!o(x), q = !!a(F), Q, G, K, U, ae;
    function ye(pe) {
      const ee = U;
      U = null, ee ? ee(pe) : pe && ae.destroy(pe);
    }
    return ae = new A({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(x != null && x.readableObjectMode),
      writableObjectMode: !!(F != null && F.writableObjectMode),
      readable: j,
      writable: q
    }), q && (l(F, (pe) => {
      q = !1, pe && b(x, pe), ye(pe);
    }), ae._write = function(pe, ee, Te) {
      F.write(pe, ee) ? Te() : Q = Te;
    }, ae._final = function(pe) {
      F.end(), G = pe;
    }, F.on("drain", function() {
      if (Q) {
        const pe = Q;
        Q = null, pe();
      }
    }), F.on("finish", function() {
      if (G) {
        const pe = G;
        G = null, pe();
      }
    })), j && (l(x, (pe) => {
      j = !1, pe && b(x, pe), ye(pe);
    }), x.on("readable", function() {
      if (K) {
        const pe = K;
        K = null, pe();
      }
    }), x.on("end", function() {
      ae.push(null);
    }), ae._read = function() {
      for (; ; ) {
        const pe = x.read();
        if (pe === null) {
          K = ae._read;
          return;
        }
        if (!ae.push(pe))
          return;
      }
    }), ae._destroy = function(pe, ee) {
      !pe && U !== null && (pe = new f()), K = null, Q = null, G = null, U === null ? ee(pe) : (U = ee, b(F, pe), b(x, pe));
    }, ae;
  }
  return oE;
}
var sE, r9;
function ma() {
  if (r9) return sE;
  r9 = 1;
  const {
    ObjectDefineProperties: u,
    ObjectGetOwnPropertyDescriptor: r,
    ObjectKeys: o,
    ObjectSetPrototypeOf: a
  } = dr();
  sE = n;
  const t = e4(), e = x8();
  a(n.prototype, t.prototype), a(n, t);
  {
    const d = o(e.prototype);
    for (let l = 0; l < d.length; l++) {
      const f = d[l];
      n.prototype[f] || (n.prototype[f] = e.prototype[f]);
    }
  }
  function n(d) {
    if (!(this instanceof n)) return new n(d);
    t.call(this, d), e.call(this, d), d ? (this.allowHalfOpen = d.allowHalfOpen !== !1, d.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), d.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  u(n.prototype, {
    writable: {
      __proto__: null,
      ...r(e.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...r(e.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...r(e.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...r(e.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...r(e.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...r(e.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...r(e.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...r(e.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...r(e.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(d) {
        this._readableState && this._writableState && (this._readableState.destroyed = d, this._writableState.destroyed = d);
      }
    }
  });
  let i;
  function c() {
    return i === void 0 && (i = {}), i;
  }
  n.fromWeb = function(d, l) {
    return c().newStreamDuplexFromReadableWritablePair(d, l);
  }, n.toWeb = function(d) {
    return c().newReadableWritablePairFromDuplex(d);
  };
  let s;
  return n.from = function(d) {
    return s || (s = Aue()), s(d, "body");
  }, sE;
}
var cE, n9;
function IW() {
  if (n9) return cE;
  n9 = 1;
  const { ObjectSetPrototypeOf: u, Symbol: r } = dr();
  cE = n;
  const { ERR_METHOD_NOT_IMPLEMENTED: o } = sn().codes, a = ma(), { getHighWaterMark: t } = ZS();
  u(n.prototype, a.prototype), u(n, a);
  const e = r("kCallback");
  function n(s) {
    if (!(this instanceof n)) return new n(s);
    const d = s ? t(this, s, "readableHighWaterMark", !0) : null;
    d === 0 && (s = {
      ...s,
      highWaterMark: null,
      readableHighWaterMark: d,
      // TODO (ronag): 0 is not optimal since we have
      // a "bug" where we check needDrain before calling _write and not after.
      // Refs: https://github.com/nodejs/node/pull/32887
      // Refs: https://github.com/nodejs/node/pull/35941
      writableHighWaterMark: s.writableHighWaterMark || 0
    }), a.call(this, s), this._readableState.sync = !1, this[e] = null, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", c);
  }
  function i(s) {
    typeof this._flush == "function" && !this.destroyed ? this._flush((d, l) => {
      if (d) {
        s ? s(d) : this.destroy(d);
        return;
      }
      l != null && this.push(l), this.push(null), s && s();
    }) : (this.push(null), s && s());
  }
  function c() {
    this._final !== i && i.call(this);
  }
  return n.prototype._final = i, n.prototype._transform = function(s, d, l) {
    throw new o("_transform()");
  }, n.prototype._write = function(s, d, l) {
    const f = this._readableState, h = this._writableState, p = f.length;
    this._transform(s, d, (b, _) => {
      if (b) {
        l(b);
        return;
      }
      _ != null && this.push(_), h.ended || // Backwards compat.
      p === f.length || // Backwards compat.
      f.length < f.highWaterMark ? l() : this[e] = l;
    });
  }, n.prototype._read = function() {
    if (this[e]) {
      const s = this[e];
      this[e] = null, s();
    }
  }, cE;
}
var dE, i9;
function RW() {
  if (i9) return dE;
  i9 = 1;
  const { ObjectSetPrototypeOf: u } = dr();
  dE = o;
  const r = IW();
  u(o.prototype, r.prototype), u(o, r);
  function o(a) {
    if (!(this instanceof o)) return new o(a);
    r.call(this, a);
  }
  return o.prototype._transform = function(a, t, e) {
    e(null, a);
  }, dE;
}
var lE, a9;
function I8() {
  if (a9) return lE;
  a9 = 1;
  const u = tu(), { ArrayIsArray: r, Promise: o, SymbolAsyncIterator: a, SymbolDispose: t } = dr(), e = nu(), { once: n } = pn(), i = bh(), c = ma(), {
    aggregateTwoErrors: s,
    codes: {
      ERR_INVALID_ARG_TYPE: d,
      ERR_INVALID_RETURN_VALUE: l,
      ERR_MISSING_ARGS: f,
      ERR_STREAM_DESTROYED: h,
      ERR_STREAM_PREMATURE_CLOSE: p
    },
    AbortError: b
  } = sn(), { validateFunction: _, validateAbortSignal: y } = Ew(), {
    isIterable: m,
    isReadable: g,
    isReadableNodeStream: T,
    isNodeStream: v,
    isTransformStream: E,
    isWebStream: R,
    isReadableStream: L,
    isReadableFinished: A
  } = wa(), w = globalThis.AbortController || KT().AbortController;
  let S, O, x;
  function F(pe, ee, Te) {
    let we = !1;
    pe.on("close", () => {
      we = !0;
    });
    const Oe = e(
      pe,
      {
        readable: ee,
        writable: Te
      },
      (be) => {
        we = !be;
      }
    );
    return {
      destroy: (be) => {
        we || (we = !0, i.destroyer(pe, be || new h("pipe")));
      },
      cleanup: Oe
    };
  }
  function j(pe) {
    return _(pe[pe.length - 1], "streams[stream.length - 1]"), pe.pop();
  }
  function q(pe) {
    if (m(pe))
      return pe;
    if (T(pe))
      return Q(pe);
    throw new d("val", ["Readable", "Iterable", "AsyncIterable"], pe);
  }
  async function* Q(pe) {
    O || (O = e4()), yield* O.prototype[a].call(pe);
  }
  async function G(pe, ee, Te, { end: we }) {
    let Oe, be = null;
    const he = (M) => {
      if (M && (Oe = M), be) {
        const I = be;
        be = null, I();
      }
    }, V = () => new o((M, I) => {
      Oe ? I(Oe) : be = () => {
        Oe ? I(Oe) : M();
      };
    });
    ee.on("drain", he);
    const N = e(
      ee,
      {
        readable: !1
      },
      he
    );
    try {
      ee.writableNeedDrain && await V();
      for await (const M of pe)
        ee.write(M) || await V();
      we && (ee.end(), await V()), Te();
    } catch (M) {
      Te(Oe !== M ? s(Oe, M) : M);
    } finally {
      N(), ee.off("drain", he);
    }
  }
  async function K(pe, ee, Te, { end: we }) {
    E(ee) && (ee = ee.writable);
    const Oe = ee.getWriter();
    try {
      for await (const be of pe)
        await Oe.ready, Oe.write(be).catch(() => {
        });
      await Oe.ready, we && await Oe.close(), Te();
    } catch (be) {
      try {
        await Oe.abort(be), Te(be);
      } catch (he) {
        Te(he);
      }
    }
  }
  function U(...pe) {
    return ae(pe, n(j(pe)));
  }
  function ae(pe, ee, Te) {
    if (pe.length === 1 && r(pe[0]) && (pe = pe[0]), pe.length < 2)
      throw new f("streams");
    const we = new w(), Oe = we.signal, be = Te == null ? void 0 : Te.signal, he = [];
    y(be, "options.signal");
    function V() {
      H(new b());
    }
    x = x || pn().addAbortListener;
    let N;
    be && (N = x(be, V));
    let M, I;
    const P = [];
    let B = 0;
    function z(fe) {
      H(fe, --B === 0);
    }
    function H(fe, me) {
      var Ne;
      if (fe && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = fe), !(!M && !me)) {
        for (; P.length; )
          P.shift()(M);
        (Ne = N) === null || Ne === void 0 || Ne[t](), we.abort(), me && (M || he.forEach((xe) => xe()), u.nextTick(ee, M, I));
      }
    }
    let J;
    for (let fe = 0; fe < pe.length; fe++) {
      const me = pe[fe], Ne = fe < pe.length - 1, xe = fe > 0, ue = Ne || (Te == null ? void 0 : Te.end) !== !1, $ = fe === pe.length - 1;
      if (v(me)) {
        let D = function(C) {
          C && C.name !== "AbortError" && C.code !== "ERR_STREAM_PREMATURE_CLOSE" && z(C);
        };
        var le = D;
        if (ue) {
          const { destroy: C, cleanup: X } = F(me, Ne, xe);
          P.push(C), g(me) && $ && he.push(X);
        }
        me.on("error", D), g(me) && $ && he.push(() => {
          me.removeListener("error", D);
        });
      }
      if (fe === 0)
        if (typeof me == "function") {
          if (J = me({
            signal: Oe
          }), !m(J))
            throw new l("Iterable, AsyncIterable or Stream", "source", J);
        } else m(me) || T(me) || E(me) ? J = me : J = c.from(me);
      else if (typeof me == "function") {
        if (E(J)) {
          var k;
          J = q((k = J) === null || k === void 0 ? void 0 : k.readable);
        } else
          J = q(J);
        if (J = me(J, {
          signal: Oe
        }), Ne) {
          if (!m(J, !0))
            throw new l("AsyncIterable", `transform[${fe - 1}]`, J);
        } else {
          var W;
          S || (S = RW());
          const D = new S({
            objectMode: !0
          }), C = (W = J) === null || W === void 0 ? void 0 : W.then;
          if (typeof C == "function")
            B++, C.call(
              J,
              (de) => {
                I = de, de != null && D.write(de), ue && D.end(), u.nextTick(z);
              },
              (de) => {
                D.destroy(de), u.nextTick(z, de);
              }
            );
          else if (m(J, !0))
            B++, G(J, D, z, {
              end: ue
            });
          else if (L(J) || E(J)) {
            const de = J.readable || J;
            B++, G(de, D, z, {
              end: ue
            });
          } else
            throw new l("AsyncIterable or Promise", "destination", J);
          J = D;
          const { destroy: X, cleanup: te } = F(J, !1, !0);
          P.push(X), $ && he.push(te);
        }
      } else if (v(me)) {
        if (T(J)) {
          B += 2;
          const D = ye(J, me, z, {
            end: ue
          });
          g(me) && $ && he.push(D);
        } else if (E(J) || L(J)) {
          const D = J.readable || J;
          B++, G(D, me, z, {
            end: ue
          });
        } else if (m(J))
          B++, G(J, me, z, {
            end: ue
          });
        else
          throw new d(
            "val",
            ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
            J
          );
        J = me;
      } else if (R(me)) {
        if (T(J))
          B++, K(q(J), me, z, {
            end: ue
          });
        else if (L(J) || m(J))
          B++, K(J, me, z, {
            end: ue
          });
        else if (E(J))
          B++, K(J.readable, me, z, {
            end: ue
          });
        else
          throw new d(
            "val",
            ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
            J
          );
        J = me;
      } else
        J = c.from(me);
    }
    return (Oe != null && Oe.aborted || be != null && be.aborted) && u.nextTick(V), J;
  }
  function ye(pe, ee, Te, { end: we }) {
    let Oe = !1;
    if (ee.on("close", () => {
      Oe || Te(new p());
    }), pe.pipe(ee, {
      end: !1
    }), we) {
      let he = function() {
        Oe = !0, ee.end();
      };
      var be = he;
      A(pe) ? u.nextTick(he) : pe.once("end", he);
    } else
      Te();
    return e(
      pe,
      {
        readable: !0,
        writable: !1
      },
      (he) => {
        const V = pe._readableState;
        he && he.code === "ERR_STREAM_PREMATURE_CLOSE" && V && V.ended && !V.errored && !V.errorEmitted ? pe.once("end", Te).once("error", Te) : Te(he);
      }
    ), e(
      ee,
      {
        readable: !1,
        writable: !0
      },
      Te
    );
  }
  return lE = {
    pipelineImpl: ae,
    pipeline: U
  }, lE;
}
var fE, u9;
function FW() {
  if (u9) return fE;
  u9 = 1;
  const { pipeline: u } = I8(), r = ma(), { destroyer: o } = bh(), {
    isNodeStream: a,
    isReadable: t,
    isWritable: e,
    isWebStream: n,
    isTransformStream: i,
    isWritableStream: c,
    isReadableStream: s
  } = wa(), {
    AbortError: d,
    codes: { ERR_INVALID_ARG_VALUE: l, ERR_MISSING_ARGS: f }
  } = sn(), h = nu();
  return fE = function(...b) {
    if (b.length === 0)
      throw new f("streams");
    if (b.length === 1)
      return r.from(b[0]);
    const _ = [...b];
    if (typeof b[0] == "function" && (b[0] = r.from(b[0])), typeof b[b.length - 1] == "function") {
      const S = b.length - 1;
      b[S] = r.from(b[S]);
    }
    for (let S = 0; S < b.length; ++S)
      if (!(!a(b[S]) && !n(b[S]))) {
        if (S < b.length - 1 && !(t(b[S]) || s(b[S]) || i(b[S])))
          throw new l(`streams[${S}]`, _[S], "must be readable");
        if (S > 0 && !(e(b[S]) || c(b[S]) || i(b[S])))
          throw new l(`streams[${S}]`, _[S], "must be writable");
      }
    let y, m, g, T, v;
    function E(S) {
      const O = T;
      T = null, O ? O(S) : S ? v.destroy(S) : !w && !A && v.destroy();
    }
    const R = b[0], L = u(b, E), A = !!(e(R) || c(R) || i(R)), w = !!(t(L) || s(L) || i(L));
    if (v = new r({
      // TODO (ronag): highWaterMark?
      writableObjectMode: !!(R != null && R.writableObjectMode),
      readableObjectMode: !!(L != null && L.readableObjectMode),
      writable: A,
      readable: w
    }), A) {
      if (a(R))
        v._write = function(O, x, F) {
          R.write(O, x) ? F() : y = F;
        }, v._final = function(O) {
          R.end(), m = O;
        }, R.on("drain", function() {
          if (y) {
            const O = y;
            y = null, O();
          }
        });
      else if (n(R)) {
        const x = (i(R) ? R.writable : R).getWriter();
        v._write = async function(F, j, q) {
          try {
            await x.ready, x.write(F).catch(() => {
            }), q();
          } catch (Q) {
            q(Q);
          }
        }, v._final = async function(F) {
          try {
            await x.ready, x.close().catch(() => {
            }), m = F;
          } catch (j) {
            F(j);
          }
        };
      }
      const S = i(L) ? L.readable : L;
      h(S, () => {
        if (m) {
          const O = m;
          m = null, O();
        }
      });
    }
    if (w) {
      if (a(L))
        L.on("readable", function() {
          if (g) {
            const S = g;
            g = null, S();
          }
        }), L.on("end", function() {
          v.push(null);
        }), v._read = function() {
          for (; ; ) {
            const S = L.read();
            if (S === null) {
              g = v._read;
              return;
            }
            if (!v.push(S))
              return;
          }
        };
      else if (n(L)) {
        const O = (i(L) ? L.readable : L).getReader();
        v._read = async function() {
          for (; ; )
            try {
              const { value: x, done: F } = await O.read();
              if (!v.push(x))
                return;
              if (F) {
                v.push(null);
                return;
              }
            } catch {
              return;
            }
        };
      }
    }
    return v._destroy = function(S, O) {
      !S && T !== null && (S = new d()), g = null, y = null, m = null, T === null ? O(S) : (T = O, a(L) && o(L, S));
    }, v;
  }, fE;
}
var o9;
function Eue() {
  if (o9) return c6;
  o9 = 1;
  const u = globalThis.AbortController || KT().AbortController, {
    codes: { ERR_INVALID_ARG_VALUE: r, ERR_INVALID_ARG_TYPE: o, ERR_MISSING_ARGS: a, ERR_OUT_OF_RANGE: t },
    AbortError: e
  } = sn(), { validateAbortSignal: n, validateInteger: i, validateObject: c } = Ew(), s = dr().Symbol("kWeak"), d = dr().Symbol("kResistStopPropagation"), { finished: l } = nu(), f = FW(), { addAbortSignalNoValidate: h } = YS(), { isWritable: p, isNodeStream: b } = wa(), { deprecate: _ } = pn(), {
    ArrayPrototypePush: y,
    Boolean: m,
    MathFloor: g,
    Number: T,
    NumberIsNaN: v,
    Promise: E,
    PromiseReject: R,
    PromiseResolve: L,
    PromisePrototypeThen: A,
    Symbol: w
  } = dr(), S = w("kEmpty"), O = w("kEof");
  function x(be, he) {
    if (he != null && c(he, "options"), (he == null ? void 0 : he.signal) != null && n(he.signal, "options.signal"), b(be) && !p(be))
      throw new r("stream", be, "must be writable");
    const V = f(this, be);
    return he != null && he.signal && h(he.signal, V), V;
  }
  function F(be, he) {
    if (typeof be != "function")
      throw new o("fn", ["Function", "AsyncFunction"], be);
    he != null && c(he, "options"), (he == null ? void 0 : he.signal) != null && n(he.signal, "options.signal");
    let V = 1;
    (he == null ? void 0 : he.concurrency) != null && (V = g(he.concurrency));
    let N = V - 1;
    return (he == null ? void 0 : he.highWaterMark) != null && (N = g(he.highWaterMark)), i(V, "options.concurrency", 1), i(N, "options.highWaterMark", 0), N += V, (async function* () {
      const I = pn().AbortSignalAny(
        [he == null ? void 0 : he.signal].filter(m)
      ), P = this, B = [], z = {
        signal: I
      };
      let H, J, k = !1, W = 0;
      function le() {
        k = !0, fe();
      }
      function fe() {
        W -= 1, me();
      }
      function me() {
        J && !k && W < V && B.length < N && (J(), J = null);
      }
      async function Ne() {
        try {
          for await (let xe of P) {
            if (k)
              return;
            if (I.aborted)
              throw new e();
            try {
              if (xe = be(xe, z), xe === S)
                continue;
              xe = L(xe);
            } catch (ue) {
              xe = R(ue);
            }
            W += 1, A(xe, fe, le), B.push(xe), H && (H(), H = null), !k && (B.length >= N || W >= V) && await new E((ue) => {
              J = ue;
            });
          }
          B.push(O);
        } catch (xe) {
          const ue = R(xe);
          A(ue, fe, le), B.push(ue);
        } finally {
          k = !0, H && (H(), H = null);
        }
      }
      Ne();
      try {
        for (; ; ) {
          for (; B.length > 0; ) {
            const xe = await B[0];
            if (xe === O)
              return;
            if (I.aborted)
              throw new e();
            xe !== S && (yield xe), B.shift(), me();
          }
          await new E((xe) => {
            H = xe;
          });
        }
      } finally {
        k = !0, J && (J(), J = null);
      }
    }).call(this);
  }
  function j(be = void 0) {
    return be != null && c(be, "options"), (be == null ? void 0 : be.signal) != null && n(be.signal, "options.signal"), (async function* () {
      let V = 0;
      for await (const M of this) {
        var N;
        if (be != null && (N = be.signal) !== null && N !== void 0 && N.aborted)
          throw new e({
            cause: be.signal.reason
          });
        yield [V++, M];
      }
    }).call(this);
  }
  async function q(be, he = void 0) {
    for await (const V of U.call(this, be, he))
      return !0;
    return !1;
  }
  async function Q(be, he = void 0) {
    if (typeof be != "function")
      throw new o("fn", ["Function", "AsyncFunction"], be);
    return !await q.call(
      this,
      async (...V) => !await be(...V),
      he
    );
  }
  async function G(be, he) {
    for await (const V of U.call(this, be, he))
      return V;
  }
  async function K(be, he) {
    if (typeof be != "function")
      throw new o("fn", ["Function", "AsyncFunction"], be);
    async function V(N, M) {
      return await be(N, M), S;
    }
    for await (const N of F.call(this, V, he)) ;
  }
  function U(be, he) {
    if (typeof be != "function")
      throw new o("fn", ["Function", "AsyncFunction"], be);
    async function V(N, M) {
      return await be(N, M) ? N : S;
    }
    return F.call(this, V, he);
  }
  class ae extends a {
    constructor() {
      super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function ye(be, he, V) {
    var N;
    if (typeof be != "function")
      throw new o("reducer", ["Function", "AsyncFunction"], be);
    V != null && c(V, "options"), (V == null ? void 0 : V.signal) != null && n(V.signal, "options.signal");
    let M = arguments.length > 1;
    if (V != null && (N = V.signal) !== null && N !== void 0 && N.aborted) {
      const H = new e(void 0, {
        cause: V.signal.reason
      });
      throw this.once("error", () => {
      }), await l(this.destroy(H)), H;
    }
    const I = new u(), P = I.signal;
    if (V != null && V.signal) {
      const H = {
        once: !0,
        [s]: this,
        [d]: !0
      };
      V.signal.addEventListener("abort", () => I.abort(), H);
    }
    let B = !1;
    try {
      for await (const H of this) {
        var z;
        if (B = !0, V != null && (z = V.signal) !== null && z !== void 0 && z.aborted)
          throw new e();
        M ? he = await be(he, H, {
          signal: P
        }) : (he = H, M = !0);
      }
      if (!B && !M)
        throw new ae();
    } finally {
      I.abort();
    }
    return he;
  }
  async function pe(be) {
    be != null && c(be, "options"), (be == null ? void 0 : be.signal) != null && n(be.signal, "options.signal");
    const he = [];
    for await (const N of this) {
      var V;
      if (be != null && (V = be.signal) !== null && V !== void 0 && V.aborted)
        throw new e(void 0, {
          cause: be.signal.reason
        });
      y(he, N);
    }
    return he;
  }
  function ee(be, he) {
    const V = F.call(this, be, he);
    return (async function* () {
      for await (const M of V)
        yield* M;
    }).call(this);
  }
  function Te(be) {
    if (be = T(be), v(be))
      return 0;
    if (be < 0)
      throw new t("number", ">= 0", be);
    return be;
  }
  function we(be, he = void 0) {
    return he != null && c(he, "options"), (he == null ? void 0 : he.signal) != null && n(he.signal, "options.signal"), be = Te(be), (async function* () {
      var N;
      if (he != null && (N = he.signal) !== null && N !== void 0 && N.aborted)
        throw new e();
      for await (const I of this) {
        var M;
        if (he != null && (M = he.signal) !== null && M !== void 0 && M.aborted)
          throw new e();
        be-- <= 0 && (yield I);
      }
    }).call(this);
  }
  function Oe(be, he = void 0) {
    return he != null && c(he, "options"), (he == null ? void 0 : he.signal) != null && n(he.signal, "options.signal"), be = Te(be), (async function* () {
      var N;
      if (he != null && (N = he.signal) !== null && N !== void 0 && N.aborted)
        throw new e();
      for await (const I of this) {
        var M;
        if (he != null && (M = he.signal) !== null && M !== void 0 && M.aborted)
          throw new e();
        if (be-- > 0 && (yield I), be <= 0)
          return;
      }
    }).call(this);
  }
  return c6.streamReturningOperators = {
    asIndexedPairs: _(j, "readable.asIndexedPairs will be removed in a future version."),
    drop: we,
    filter: U,
    flatMap: ee,
    map: F,
    take: Oe,
    compose: x
  }, c6.promiseReturningOperators = {
    every: Q,
    forEach: K,
    reduce: ye,
    toArray: pe,
    some: q,
    find: G
  }, c6;
}
var hE, s9;
function NW() {
  if (s9) return hE;
  s9 = 1;
  const { ArrayPrototypePop: u, Promise: r } = dr(), { isIterable: o, isNodeStream: a, isWebStream: t } = wa(), { pipelineImpl: e } = I8(), { finished: n } = nu();
  PW();
  function i(...c) {
    return new r((s, d) => {
      let l, f;
      const h = c[c.length - 1];
      if (h && typeof h == "object" && !a(h) && !o(h) && !t(h)) {
        const p = u(c);
        l = p.signal, f = p.end;
      }
      e(
        c,
        (p, b) => {
          p ? d(p) : s(b);
        },
        {
          signal: l,
          end: f
        }
      );
    });
  }
  return hE = {
    finished: n,
    pipeline: i
  }, hE;
}
var c9;
function PW() {
  if (c9) return HA.exports;
  c9 = 1;
  const { Buffer: u } = qi(), { ObjectDefineProperty: r, ObjectKeys: o, ReflectApply: a } = dr(), {
    promisify: { custom: t }
  } = pn(), { streamReturningOperators: e, promiseReturningOperators: n } = Eue(), {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: i }
  } = sn(), c = FW(), { setDefaultHighWaterMark: s, getDefaultHighWaterMark: d } = ZS(), { pipeline: l } = I8(), { destroyer: f } = bh(), h = nu(), p = NW(), b = wa(), _ = HA.exports = O8().Stream;
  _.isDestroyed = b.isDestroyed, _.isDisturbed = b.isDisturbed, _.isErrored = b.isErrored, _.isReadable = b.isReadable, _.isWritable = b.isWritable, _.Readable = e4();
  for (const g of o(e)) {
    let v = function(...E) {
      if (new.target)
        throw i();
      return _.Readable.from(a(T, this, E));
    };
    var m = v;
    const T = e[g];
    r(v, "name", {
      __proto__: null,
      value: T.name
    }), r(v, "length", {
      __proto__: null,
      value: T.length
    }), r(_.Readable.prototype, g, {
      __proto__: null,
      value: v,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const g of o(n)) {
    let v = function(...R) {
      if (new.target)
        throw i();
      return a(T, this, R);
    };
    var m = v;
    const T = n[g];
    r(v, "name", {
      __proto__: null,
      value: T.name
    }), r(v, "length", {
      __proto__: null,
      value: T.length
    }), r(_.Readable.prototype, g, {
      __proto__: null,
      value: v,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _.Writable = x8(), _.Duplex = ma(), _.Transform = IW(), _.PassThrough = RW(), _.pipeline = l;
  const { addAbortSignal: y } = YS();
  return _.addAbortSignal = y, _.finished = h, _.destroy = f, _.compose = c, _.setDefaultHighWaterMark = s, _.getDefaultHighWaterMark = d, r(_, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return p;
    }
  }), r(l, t, {
    __proto__: null,
    enumerable: !0,
    get() {
      return p.pipeline;
    }
  }), r(h, t, {
    __proto__: null,
    enumerable: !0,
    get() {
      return p.finished;
    }
  }), _.Stream = _, _._isUint8Array = function(T) {
    return T instanceof Uint8Array;
  }, _._uint8ArrayToBuffer = function(T) {
    return u.from(T.buffer, T.byteOffset, T.byteLength);
  }, HA.exports;
}
var d9;
function Bt() {
  return d9 || (d9 = 1, function(u) {
    const r = PW(), o = NW(), a = r.Readable.destroy;
    u.exports = r.Readable, u.exports._uint8ArrayToBuffer = r._uint8ArrayToBuffer, u.exports._isUint8Array = r._isUint8Array, u.exports.isDisturbed = r.isDisturbed, u.exports.isErrored = r.isErrored, u.exports.isReadable = r.isReadable, u.exports.Readable = r.Readable, u.exports.Writable = r.Writable, u.exports.Duplex = r.Duplex, u.exports.Transform = r.Transform, u.exports.PassThrough = r.PassThrough, u.exports.addAbortSignal = r.addAbortSignal, u.exports.finished = r.finished, u.exports.destroy = r.destroy, u.exports.destroy = a, u.exports.pipeline = r.pipeline, u.exports.compose = r.compose, Object.defineProperty(r, "promises", {
      configurable: !0,
      enumerable: !0,
      get() {
        return o;
      }
    }), u.exports.Stream = r.Stream, u.exports.default = u.exports;
  }(QA)), QA.exports;
}
var l9;
function Oue() {
  if (l9) return l1;
  l9 = 1, Object.defineProperty(l1, "__esModule", { value: !0 }), l1.ActorQueryResultSerializeJson = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ yt(), a = lr(), t = Bt();
  let e = class extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/json": 1.0
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/json": "https://comunica.linkeddatafragments.org/#results_JSON"
     *     }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    async testHandleChecked(i, c) {
      return ["bindings", "quads", "boolean"].includes(i.type) ? (0, r.passTestVoid)() : (0, r.failTest)("This actor can only handle bindings or quad streams.");
    }
    async runHandle(i, c, s) {
      const d = new t.Readable();
      if (d._read = () => {
      }, i.type === "bindings" || i.type === "quads") {
        let l = i.type === "bindings" ? (0, o.wrap)(i.bindingsStream).map((h) => JSON.stringify(Object.fromEntries([...h].map(([p, b]) => [p.value, a.termToString(b)])))) : (0, o.wrap)(i.quadStream).map((h) => JSON.stringify(a.quadToStringQuad(h))), f = !0;
        l = l.map((h) => {
          const p = `${f ? "" : ","}
${h}`;
          return f = !1, p;
        }).prepend(["["]).append([`
]
`]), d.wrap(l);
      } else
        try {
          d.push(`${JSON.stringify(await i.execute())}
`), d.push(null);
        } catch (l) {
          setTimeout(() => d.emit("error", l));
        }
      return { data: d };
    }
  };
  return l1.ActorQueryResultSerializeJson = e, l1;
}
var f9;
function xue() {
  return f9 || (f9 = 1, function(u) {
    var r = po && po.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = po && po.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Oue(), u);
  }(po)), po;
}
var _o = {}, g1 = {}, h9;
function Iue() {
  if (h9) return g1;
  h9 = 1, Object.defineProperty(g1, "__esModule", { value: !0 }), g1.ActorQueryResultSerializeSimple = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ yt(), a = lr(), t = Bt();
  let e = class F0 extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{ "simple": 0.9 }} mediaTypePriorities
     *   \ @defaultNested {{ "simple": "https://comunica.linkeddatafragments.org/#results_simple" }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    async testHandleChecked(i, c) {
      return ["bindings", "quads", "boolean", "void"].includes(i.type) ? (0, r.passTestVoid)() : (0, r.failTest)("This actor can only handle bindings streams, quad streams, booleans, or updates.");
    }
    static termToString(i) {
      return i.termType === "Quad" ? (0, a.termToString)(i) : i.value;
    }
    async runHandle(i, c, s) {
      const d = new t.Readable();
      return i.type === "bindings" ? d.wrap(i.bindingsStream.map((l) => `${[...l].map(([f, h]) => `?${f.value}: ${F0.termToString(h)}`).join(`
`)}

`)) : i.type === "quads" ? d.wrap(i.quadStream.map((l) => `subject: ${F0.termToString(l.subject)}
predicate: ${F0.termToString(l.predicate)}
object: ${F0.termToString(l.object)}
graph: ${F0.termToString(l.graph)}

`)) : d.wrap((0, o.wrap)(i.type === "boolean" ? i.execute().then((l) => [`${l}
`]) : i.execute().then(() => [`ok
`]))), { data: d };
    }
  };
  return g1.ActorQueryResultSerializeSimple = e, g1;
}
var p9;
function Rue() {
  return p9 || (p9 = 1, function(u) {
    var r = _o && _o.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _o && _o.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Iue(), u);
  }(_o)), _o;
}
var go = {}, m1 = {}, b9;
function Fue() {
  if (b9) return m1;
  b9 = 1, Object.defineProperty(m1, "__esModule", { value: !0 }), m1.ActorQueryResultSerializeSparqlCsv = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = Bt();
  let a = class gT extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "text/csv": 0.75
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "text/csv": "http://www.w3.org/ns/formats/SPARQL_Results_CSV"
     *     }} mediaTypeFormats
     */
    constructor(e) {
      super(e);
    }
    /**
     * Converts an RDF term to its CSV representation.
     * @param {RDF.Term} value An RDF term.
     * @return {string} A string representation of the given value.
     */
    static bindingToCsvBindings(e) {
      if (!e)
        return "";
      let n = e.value;
      if (e.termType === "Literal")
        n = `${n}`;
      else if (e.termType === "BlankNode")
        n = `_:${n}`;
      else if (e.termType === "Quad") {
        let i = gT.bindingToCsvBindings(e.object);
        e.object.termType === "Literal" && (i = `"${i.replaceAll('"', '""')}"`), n = `<< ${gT.bindingToCsvBindings(e.subject)} ${gT.bindingToCsvBindings(e.predicate)} ${i} >>`;
      } else
        n = `<${n}>`;
      return /[",\n\r]/u.test(n) && (n = `"${n.replaceAll('"', '""')}"`), n;
    }
    async testHandleChecked(e, n) {
      return e.type !== "bindings" ? (0, r.failTest)("This actor can only handle bindings streams.") : (0, r.passTestVoid)();
    }
    async runHandle(e, n, i) {
      const c = e, s = new o.Readable(), d = await c.metadata();
      return s.push(`${d.variables.map((l) => l.variable.value).join(",")}\r
`), s.wrap(c.bindingsStream.map((l) => `${d.variables.map((f) => gT.bindingToCsvBindings(l.get(f.variable))).join(",")}\r
`)), { data: s };
    }
  };
  return m1.ActorQueryResultSerializeSparqlCsv = a, m1;
}
var y9;
function Nue() {
  return y9 || (y9 = 1, function(u) {
    var r = go && go.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = go && go.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Fue(), u);
  }(go)), go;
}
var mo = {}, v1 = {}, pE = {}, Cr = {}, _9;
function Pue() {
  if (_9) return Cr;
  _9 = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.stringQuadToQuad = Cr.quadToStringQuad = Cr.stringToTerm = Cr.getLiteralLanguage = Cr.getLiteralType = Cr.getLiteralValue = Cr.termToString = void 0;
  const u = Or(), r = new u.DataFactory();
  function o(p) {
    if (p)
      switch (p.termType) {
        case "NamedNode":
          return `<${s(p.value)}>`;
        case "BlankNode":
          return `_:${p.value}`;
        case "Literal": {
          const b = p;
          return `"${d(b.value)}"${b.datatype && b.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" && b.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? `^^<${b.datatype.value}>` : ""}${b.language ? `@${b.language}` : ""}`;
        }
        case "Quad":
          return `<<${o(p.subject)} ${o(p.predicate)} ${o(p.object)}${p.graph.termType === "DefaultGraph" ? "" : ` ${o(p.graph)}`}>>`;
        case "Variable":
          return `?${p.value}`;
        case "DefaultGraph":
          return p.value;
      }
  }
  Cr.termToString = o;
  function a(p) {
    const b = /^"([^]*)"((\^\^.*)|(@.*))?$/u.exec(p);
    if (!b)
      throw new Error(`${p} is not a literal`);
    return b[1].replace(/\\"/ug, '"');
  }
  Cr.getLiteralValue = a;
  function t(p) {
    const b = /^"[^]*"(?:\^\^<([^"]+)>|(@)[^@"]+)?$/u.exec(p);
    if (!b)
      throw new Error(`${p} is not a literal`);
    return b[1] || (b[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string");
  }
  Cr.getLiteralType = t;
  function e(p) {
    const b = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/u.exec(p);
    if (!b)
      throw new Error(`${p} is not a literal`);
    return b[1] ? b[1].toLowerCase() : "";
  }
  Cr.getLiteralLanguage = e;
  function n(p, b) {
    if (b = b || r, !p || p.length === 0)
      return b.defaultGraph();
    switch (p[0]) {
      case "_":
        return b.blankNode(p.slice(2));
      case "?":
        if (!b.variable)
          throw new Error("Missing 'variable()' method on the given DataFactory");
        return b.variable(p.slice(1));
      case '"': {
        const _ = e(p), y = b.namedNode(t(p));
        return b.literal(a(p), _ || y);
      }
      case "<":
      default:
        if (p.startsWith("<<") && p.endsWith(">>")) {
          const _ = p.slice(2, -2), y = [];
          let m = 0, g = 0;
          for (let T = 0; T < _.length; T++) {
            const v = _[T];
            if (v === "<" && m++, v === ">") {
              if (m === 0)
                throw new Error(`Found closing tag without opening tag in ${p}`);
              m--;
            }
            v === " " && m === 0 && (y.push(_.slice(g, T)), g = T + 1);
          }
          if (m !== 0)
            throw new Error(`Found opening tag without closing tag in ${p}`);
          if (y.push(_.slice(g, _.length)), y.length !== 3 && y.length !== 4)
            throw new Error(`Nested quad syntax error ${p}`);
          return b.quad(n(y[0]), n(y[1]), n(y[2]), y[3] ? n(y[3]) : void 0);
        }
        if (!p.startsWith("<") || !p.endsWith(">"))
          throw new Error(`Detected invalid iri for named node (must be wrapped in <>): ${p}`);
        return b.namedNode(p.slice(1, -1));
    }
  }
  Cr.stringToTerm = n;
  function i(p) {
    return {
      subject: o(p.subject),
      predicate: o(p.predicate),
      object: o(p.object),
      graph: o(p.graph)
    };
  }
  Cr.quadToStringQuad = i;
  function c(p, b) {
    return b = b || r, b.quad(n(p.subject, b), n(p.predicate, b), n(p.object, b), n(p.graph, b));
  }
  Cr.stringQuadToQuad = c;
  function s(p) {
    return p.replace(l, h);
  }
  function d(p) {
    return l.test(p) && (p = p.replace(l, h)), p;
  }
  const l = /["\\\t\n\r\b\f\u0000-\u0019]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, f = /* @__PURE__ */ new Map([
    ["\\", "\\\\"],
    ['"', '\\"'],
    ["	", "\\t"],
    [`
`, "\\n"],
    ["\r", "\\r"],
    ["\b", "\\b"],
    ["\f", "\\f"]
  ]);
  function h(p) {
    const b = f.get(p);
    if (!b) {
      if (p.length === 1) {
        const y = p.charCodeAt(0).toString(16);
        return `${"\\u0000".slice(0, -y.length)}${y}`;
      }
      const _ = ((p.charCodeAt(0) - 55296) * 1024 + p.charCodeAt(1) + 9216).toString(16);
      return `${"\\U00000000".slice(0, -_.length)}${_}`;
    }
    return b;
  }
  return Cr;
}
var g9;
function Ow() {
  return g9 || (g9 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.termToString = u.stringToTerm = u.stringQuadToQuad = u.quadToStringQuad = u.getLiteralValue = u.getLiteralType = u.getLiteralLanguage = void 0;
    const r = Pue();
    Object.defineProperty(u, "getLiteralLanguage", { enumerable: !0, get: function() {
      return r.getLiteralLanguage;
    } }), Object.defineProperty(u, "getLiteralType", { enumerable: !0, get: function() {
      return r.getLiteralType;
    } }), Object.defineProperty(u, "getLiteralValue", { enumerable: !0, get: function() {
      return r.getLiteralValue;
    } }), Object.defineProperty(u, "quadToStringQuad", { enumerable: !0, get: function() {
      return r.quadToStringQuad;
    } }), Object.defineProperty(u, "stringQuadToQuad", { enumerable: !0, get: function() {
      return r.stringQuadToQuad;
    } }), Object.defineProperty(u, "stringToTerm", { enumerable: !0, get: function() {
      return r.stringToTerm;
    } }), Object.defineProperty(u, "termToString", { enumerable: !0, get: function() {
      return r.termToString;
    } });
  }(pE)), pE;
}
var m9;
function Due() {
  if (m9) return v1;
  m9 = 1, Object.defineProperty(v1, "__esModule", { value: !0 }), v1.ActorQueryResultSerializeSparqlTsv = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = Ow(), a = Bt();
  let t = class DW extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "text/tab-separated-values": 0.75
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "text/tab-separated-values": "http://www.w3.org/ns/formats/SPARQL_Results_TSV"
     *     }} mediaTypeFormats
     */
    constructor(n) {
      super(n);
    }
    /**
     * Converts an RDF term to its TSV representation.
     * @param {RDF.Term} value An RDF term.
     * @return {string} A string representation of the given value.
     */
    static bindingToTsvBindings(n) {
      return n ? (0, o.termToString)(n).replaceAll("	", "\\t").replaceAll(`
`, "\\n").replaceAll("\r", "\\r") : "";
    }
    async testHandleChecked(n, i) {
      return n.type !== "bindings" ? (0, r.failTest)("This actor can only handle bindings streams.") : (0, r.passTestVoid)();
    }
    async runHandle(n, i, c) {
      const s = n, d = new a.Readable(), l = await s.metadata();
      return d.push(`${l.variables.map((f) => f.variable.value).join("	")}
`), d.wrap(s.bindingsStream.map((f) => `${l.variables.map((h) => DW.bindingToTsvBindings(f.get(h.variable))).join("	")}
`)), { data: d };
    }
  };
  return v1.ActorQueryResultSerializeSparqlTsv = t, v1;
}
var v9;
function Lue() {
  return v9 || (v9 = 1, function(u) {
    var r = mo && mo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = mo && mo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Due(), u);
  }(mo)), mo;
}
var vo = {}, T1 = {}, w1 = {}, T9;
function jue() {
  if (T9) return w1;
  T9 = 1, Object.defineProperty(w1, "__esModule", { value: !0 }), w1.XmlSerializer = void 0;
  let u = class {
    constructor() {
      this.stack = [];
    }
    /**
     *
     * @param name should be a valid XML tag name
     * @param attributes keys should be valid attribute names
     */
    open(o, a) {
      const t = `${this.identation() + this.formatTag(o, a, "open")}
`;
      return this.stack.push(o), t;
    }
    close() {
      const o = this.stack.pop();
      if (o === void 0)
        throw new Error("There is no tag left to close");
      return `${this.identation() + this.formatTag(o, {}, "close")}
`;
    }
    serializeNode(o) {
      if (o.children === void 0)
        return `${this.identation() + this.formatTag(o.name, o.attributes, "self-closing")}
`;
      if (typeof o.children == "string")
        return `${this.identation() + this.formatTag(o.name, o.attributes, "open") + this.escape(o.children) + this.formatTag(o.name, {}, "close")}
`;
      const a = [];
      a.push(`${this.identation() + this.formatTag(o.name, o.attributes, "open")}
`), this.stack.push(o.name);
      for (const t of o.children)
        a.push(this.serializeNode(t));
      return this.stack.pop(), a.push(`${this.identation() + this.formatTag(o.name, {}, "close")}
`), a.join("");
    }
    identation() {
      return this.stack.map((o) => "  ").join("");
    }
    formatTag(o, a, t) {
      return `<${t === "close" ? "/" : ""}${o}${Object.entries(a ?? {}).map((e) => ` ${e[0]}="${this.escape(e[1])}"`)}${t === "self-closing" ? "/" : ""}>`;
    }
    escape(o) {
      return o.replaceAll(/["&'<>]/gu, (a) => {
        switch (a) {
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case "&":
            return "&amp;";
          case "'":
            return "&apos;";
          case '"':
            return "&quot;";
        }
      });
    }
  };
  return w1.XmlSerializer = u, u.header = `<?xml version="1.0" encoding="UTF-8"?>
`, w1;
}
var w9;
function Mue() {
  if (w9) return T1;
  w9 = 1, Object.defineProperty(T1, "__esModule", { value: !0 }), T1.ActorQueryResultSerializeSparqlXml = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ yt(), a = Bt(), t = /* @__PURE__ */ jue();
  let e = class LW extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/sparql-results+xml": 0.8
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/sparql-results+xml": "http://www.w3.org/ns/formats/SPARQL_Results_XML"
     *     }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    /**
     * Converts an RDF term to its object-based XML representation.
     * @param {RDF.Term} value An RDF term.
     * @param {string} key A variable name, '?' must be included as a prefix.
     * @return {IXmlNode} An object-based XML tag.
     */
    static bindingToXmlBindings(i, c) {
      return { name: "binding", attributes: { name: c.value }, children: [this.valueToXmlValue(i)] };
    }
    static valueToXmlValue(i) {
      let c;
      switch (i.termType) {
        case "Literal":
          return i.language ? c = { "xml:lang": i.language } : i.datatype && i.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? c = { datatype: i.datatype.value } : c = {}, { name: "literal", attributes: c, children: i.value };
        case "BlankNode":
          return { name: "bnode", children: i.value };
        case "Quad":
          return {
            name: "triple",
            children: [
              { name: "subject", children: [this.valueToXmlValue(i.subject)] },
              { name: "predicate", children: [this.valueToXmlValue(i.predicate)] },
              { name: "object", children: [this.valueToXmlValue(i.object)] }
            ]
          };
        default:
          return { name: "uri", children: i.value };
      }
    }
    async testHandleChecked(i, c) {
      return ["bindings", "boolean"].includes(i.type) ? (0, r.passTestVoid)() : (0, r.failTest)("This actor can only handle bindings streams or booleans.");
    }
    async runHandle(i, c, s) {
      const d = new a.Readable();
      d._read = () => {
      };
      const l = new t.XmlSerializer(), f = await i.metadata();
      if (d.push(t.XmlSerializer.header), d.push(l.open("sparql", { xmlns: "http://www.w3.org/2005/sparql-results#" })), d.push(l.serializeNode({
        name: "head",
        children: f.variables.map((h) => ({ name: "variable", attributes: { name: h.variable.value } }))
      })), i.type === "bindings") {
        function* h() {
          yield l.close(), yield l.close();
        }
        d.push(l.open("results"));
        const p = (0, o.wrap)(i.bindingsStream).map((b) => l.serializeNode({
          name: "result",
          children: [...b].map(([_, y]) => LW.bindingToXmlBindings(y, _))
        })).append((0, o.wrap)(h()));
        d.wrap(p);
      } else
        try {
          const h = await i.execute();
          d.push(l.serializeNode({ name: "boolean", children: h.toString() })), d.push(l.close()), setTimeout(() => d.push(null));
        } catch (h) {
          setTimeout(() => d.emit("error", h));
        }
      return { data: d };
    }
  };
  return T1.ActorQueryResultSerializeSparqlXml = e, T1;
}
var S9;
function Cue() {
  return S9 || (S9 = 1, function(u) {
    var r = vo && vo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vo && vo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Mue(), u);
  }(vo)), vo;
}
var To = {}, S1 = {}, A9;
function que() {
  if (A9) return S1;
  A9 = 1, Object.defineProperty(S1, "__esModule", { value: !0 }), S1.ActorQueryResultSerializeTable = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = lr(), t = zn(), e = Bt();
  let n = class sx extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{ "table": 0.6 }} mediaTypePriorities
     *   \ @defaultNested {{ "table": "https://comunica.linkeddatafragments.org/#results_table" }} mediaTypeFormats
     */
    constructor(c) {
      super(c), this.padding = sx.repeat(" ", this.columnWidth);
    }
    static repeat(c, s) {
      return c.repeat(s);
    }
    async testHandleChecked(c, s) {
      return ["bindings", "quads"].includes(c.type) ? (0, o.passTestVoid)() : (0, o.failTest)("This actor can only handle bindings or quad streams.");
    }
    termToString(c) {
      return c.termType === "Quad" ? (0, a.termToString)(c) : c.value;
    }
    pad(c) {
      return c.length <= this.columnWidth ? c + this.padding.slice(c.length) : `${c.slice(0, this.columnWidth - 1)}â¦`;
    }
    pushHeader(c, s) {
      const d = s.map((l) => this.pad(l.value)).join(" ");
      c.push(`${d}
${sx.repeat("-", d.length)}
`);
    }
    createRow(c, s) {
      return `${c.map((d) => s.has(d) ? this.termToString(s.get(d)) : "").map((d) => this.pad(d)).join(" ")}
`;
    }
    async runHandle(c, s, d) {
      const l = new e.Readable();
      let f;
      if (c.type === "bindings") {
        f = c.bindingsStream.map((p) => this.createRow(h, p));
        const h = (await c.metadata()).variables.map((p) => p.variable);
        this.pushHeader(l, h);
      } else {
        f = c.quadStream.map((p) => `${(0, t.getTerms)(p).map((b) => this.pad(this.termToString(b))).join(" ")}
`);
        const h = c.context.getSafe(r.KeysInitQuery.dataFactory);
        this.pushHeader(l, t.QUAD_TERM_NAMES.map((p) => h.variable(p)));
      }
      return l.wrap(f), { data: l };
    }
  };
  return S1.ActorQueryResultSerializeTable = n, S1;
}
var E9;
function Bue() {
  return E9 || (E9 = 1, function(u) {
    var r = To && To.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = To && To.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ que(), u);
  }(To)), To;
}
var wo = {}, A1 = {}, So = {}, E1 = {}, Ao = {}, Eo = {}, O1 = {}, x1 = {}, O9;
function Y0() {
  if (O9) return x1;
  O9 = 1, Object.defineProperty(x1, "__esModule", { value: !0 }), x1.Translator = void 0;
  let u = class {
    constructor() {
      this.supportedRdfDatatypes = [], this.fromRdfHandlers = {}, this.toRdfHandlers = {};
    }
    static incorrectRdfDataType(o) {
      throw new Error(`Invalid RDF ${o.datatype.value} value: '${o.value}'`);
    }
    registerHandler(o, a, t) {
      for (const e of a)
        this.supportedRdfDatatypes.push(e), this.fromRdfHandlers[e.value] = o;
      for (const e of t) {
        let n = this.toRdfHandlers[e];
        n || (this.toRdfHandlers[e] = n = []), n.push(o);
      }
    }
    fromRdf(o, a) {
      const t = this.fromRdfHandlers[o.datatype.value];
      return t ? t.fromRdf(o, a) : o.value;
    }
    toRdf(o, a) {
      const t = this.toRdfHandlers[typeof o];
      if (t)
        for (const e of t) {
          const n = e.toRdf(o, a);
          if (n)
            return n;
        }
      throw new Error(`Invalid JavaScript value: '${o}'`);
    }
    /**
     * @return {NamedNode[]} An array of all supported RDF datatypes.
     */
    getSupportedRdfDatatypes() {
      return this.supportedRdfDatatypes;
    }
    /**
     * @return {string[]} An array of all supported JavaScript types.
     */
    getSupportedJavaScriptPrimitives() {
      return Object.keys(this.toRdfHandlers);
    }
  };
  return x1.Translator = u, x1;
}
var x9;
function $ue() {
  if (x9) return O1;
  x9 = 1, Object.defineProperty(O1, "__esModule", { value: !0 }), O1.TypeHandlerBoolean = void 0;
  const u = Y0();
  let r = class jW {
    fromRdf(a, t) {
      switch (a.value) {
        case "true":
          return !0;
        case "false":
          return !1;
        case "1":
          return !0;
        case "0":
          return !1;
      }
      return t && u.Translator.incorrectRdfDataType(a), !1;
    }
    toRdf(a, { datatype: t, dataFactory: e }) {
      return e.literal(a ? "true" : "false", t || e.namedNode(jW.TYPE));
    }
  };
  return r.TYPE = "http://www.w3.org/2001/XMLSchema#boolean", O1.TypeHandlerBoolean = r, O1;
}
var I1 = {}, I9;
function Uue() {
  if (I9) return I1;
  I9 = 1, Object.defineProperty(I1, "__esModule", { value: !0 }), I1.TypeHandlerDate = void 0;
  const u = Y0();
  let r = class cx {
    fromRdf(a, t) {
      switch (t && !a.value.match(cx.VALIDATORS[a.datatype.value.substr(33, a.datatype.value.length)]) && u.Translator.incorrectRdfDataType(a), a.datatype.value) {
        case "http://www.w3.org/2001/XMLSchema#gDay":
          return new Date(0, 0, parseInt(a.value, 10));
        case "http://www.w3.org/2001/XMLSchema#gMonthDay":
          const e = a.value.split("-");
          return new Date(0, parseInt(e[0], 10) - 1, parseInt(e[1], 10));
        case "http://www.w3.org/2001/XMLSchema#gYear":
          return /* @__PURE__ */ new Date(a.value + "-01-01");
        case "http://www.w3.org/2001/XMLSchema#gYearMonth":
          return /* @__PURE__ */ new Date(a.value + "-01");
        default:
          return new Date(a.value);
      }
    }
    toRdf(a, { datatype: t, dataFactory: e }) {
      if (t = t || e.namedNode(cx.TYPES[0]), !(a instanceof Date))
        return null;
      const n = a;
      let i;
      switch (t.value) {
        case "http://www.w3.org/2001/XMLSchema#gDay":
          i = String(n.getUTCDate());
          break;
        case "http://www.w3.org/2001/XMLSchema#gMonthDay":
          i = n.getUTCMonth() + 1 + "-" + n.getUTCDate();
          break;
        case "http://www.w3.org/2001/XMLSchema#gYear":
          i = String(n.getUTCFullYear());
          break;
        case "http://www.w3.org/2001/XMLSchema#gYearMonth":
          i = n.getUTCFullYear() + "-" + (n.getUTCMonth() + 1);
          break;
        case "http://www.w3.org/2001/XMLSchema#date":
          i = n.toISOString().replace(/T.*$/, "");
          break;
        default:
          i = n.toISOString();
      }
      return e.literal(i, t);
    }
  };
  return r.TYPES = [
    "http://www.w3.org/2001/XMLSchema#dateTime",
    "http://www.w3.org/2001/XMLSchema#date",
    "http://www.w3.org/2001/XMLSchema#gDay",
    "http://www.w3.org/2001/XMLSchema#gMonthDay",
    "http://www.w3.org/2001/XMLSchema#gYear",
    "http://www.w3.org/2001/XMLSchema#gYearMonth"
  ], r.VALIDATORS = {
    date: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
    dateTime: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9](\.[0-9][0-9][0-9])?((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    gDay: /^[0-9]+$/,
    gMonthDay: /^[0-9]+-[0-9][0-9]$/,
    gYear: /^[0-9]+$/,
    gYearMonth: /^[0-9]+-[0-9][0-9]$/
  }, I1.TypeHandlerDate = r, I1;
}
var R1 = {}, R9;
function Vue() {
  if (R9) return R1;
  R9 = 1, Object.defineProperty(R1, "__esModule", { value: !0 }), R1.TypeHandlerNumberDouble = void 0;
  const u = Y0();
  let r = class MW {
    fromRdf(a, t) {
      const e = parseFloat(a.value);
      return t && isNaN(e) && u.Translator.incorrectRdfDataType(a), e;
    }
    toRdf(a, { datatype: t, dataFactory: e }) {
      return t = t || e.namedNode(MW.TYPES[0]), isNaN(a) ? e.literal("NaN", t) : isFinite(a) ? a % 1 === 0 ? null : e.literal(a.toExponential(15).replace(/(\d)0*e\+?/, "$1E"), t) : e.literal(a > 0 ? "INF" : "-INF", t);
    }
  };
  return r.TYPES = [
    "http://www.w3.org/2001/XMLSchema#double",
    "http://www.w3.org/2001/XMLSchema#decimal",
    "http://www.w3.org/2001/XMLSchema#float"
  ], R1.TypeHandlerNumberDouble = r, R1;
}
var F1 = {}, F9;
function Que() {
  if (F9) return F1;
  F9 = 1, Object.defineProperty(F1, "__esModule", { value: !0 }), F1.TypeHandlerNumberInteger = void 0;
  const u = Y0();
  let r = class mT {
    fromRdf(a, t) {
      const e = parseInt(a.value, 10);
      return t && (isNaN(e) || a.value.indexOf(".") >= 0) && u.Translator.incorrectRdfDataType(a), e;
    }
    toRdf(a, { datatype: t, dataFactory: e }) {
      return e.literal(String(a), t || (a <= mT.MAX_INT && a >= mT.MIN_INT ? e.namedNode(mT.TYPES[0]) : e.namedNode(mT.TYPES[1])));
    }
  };
  return r.TYPES = [
    "http://www.w3.org/2001/XMLSchema#integer",
    "http://www.w3.org/2001/XMLSchema#long",
    "http://www.w3.org/2001/XMLSchema#int",
    "http://www.w3.org/2001/XMLSchema#byte",
    "http://www.w3.org/2001/XMLSchema#short",
    "http://www.w3.org/2001/XMLSchema#negativeInteger",
    "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
    "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
    "http://www.w3.org/2001/XMLSchema#positiveInteger",
    "http://www.w3.org/2001/XMLSchema#unsignedByte",
    "http://www.w3.org/2001/XMLSchema#unsignedInt",
    "http://www.w3.org/2001/XMLSchema#unsignedLong",
    "http://www.w3.org/2001/XMLSchema#unsignedShort"
  ], r.MAX_INT = 2147483647, r.MIN_INT = -2147483648, F1.TypeHandlerNumberInteger = r, F1;
}
var N1 = {}, N9;
function Hue() {
  if (N9) return N1;
  N9 = 1, Object.defineProperty(N1, "__esModule", { value: !0 }), N1.TypeHandlerString = void 0;
  let u = class {
    fromRdf(o) {
      return o.value;
    }
    toRdf(o, { datatype: a, dataFactory: t }) {
      return t.literal(o, a);
    }
  };
  return u.TYPES = [
    "http://www.w3.org/2001/XMLSchema#string",
    "http://www.w3.org/2001/XMLSchema#normalizedString",
    "http://www.w3.org/2001/XMLSchema#anyURI",
    "http://www.w3.org/2001/XMLSchema#base64Binary",
    "http://www.w3.org/2001/XMLSchema#language",
    "http://www.w3.org/2001/XMLSchema#Name",
    "http://www.w3.org/2001/XMLSchema#NCName",
    "http://www.w3.org/2001/XMLSchema#NMTOKEN",
    "http://www.w3.org/2001/XMLSchema#token",
    "http://www.w3.org/2001/XMLSchema#hexBinary",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",
    "http://www.w3.org/2001/XMLSchema#time",
    "http://www.w3.org/2001/XMLSchema#duration"
  ], N1.TypeHandlerString = u, N1;
}
var P9;
function D9() {
  return P9 || (P9 = 1, function(u) {
    var r = Eo && Eo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Eo && Eo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o($ue(), u), o(Uue(), u), o(Vue(), u), o(Que(), u), o(Hue(), u);
  }(Eo)), Eo;
}
var bE = {}, L9;
function Gue() {
  return L9 || (L9 = 1, Object.defineProperty(bE, "__esModule", { value: !0 })), bE;
}
var j9;
function zue() {
  return j9 || (j9 = 1, function(u) {
    var r = Ao && Ao.__createBinding || (Object.create ? function(h, p, b, _) {
      _ === void 0 && (_ = b);
      var y = Object.getOwnPropertyDescriptor(p, b);
      (!y || ("get" in y ? !p.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
        return p[b];
      } }), Object.defineProperty(h, _, y);
    } : function(h, p, b, _) {
      _ === void 0 && (_ = b), h[_] = p[b];
    }), o = Ao && Ao.__exportStar || function(h, p) {
      for (var b in h) b !== "default" && !Object.prototype.hasOwnProperty.call(p, b) && r(p, h, b);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.getSupportedJavaScriptPrimitives = u.getSupportedRdfDatatypes = u.getTermRaw = u.toRdf = u.fromRdf = void 0;
    const a = Or(), t = D9(), e = Y0();
    o(D9(), u), o(Gue(), u), o(Y0(), u);
    const n = new a.DataFactory(), i = new e.Translator();
    i.registerHandler(new t.TypeHandlerString(), t.TypeHandlerString.TYPES.map((h) => n.namedNode(h)), ["string"]), i.registerHandler(new t.TypeHandlerBoolean(), [t.TypeHandlerBoolean.TYPE].map((h) => n.namedNode(h)), ["boolean"]), i.registerHandler(new t.TypeHandlerNumberDouble(), t.TypeHandlerNumberDouble.TYPES.map((h) => n.namedNode(h)), ["number"]), i.registerHandler(new t.TypeHandlerNumberInteger(), t.TypeHandlerNumberInteger.TYPES.map((h) => n.namedNode(h)), ["number"]), i.registerHandler(new t.TypeHandlerDate(), t.TypeHandlerDate.TYPES.map((h) => n.namedNode(h)), ["object"]);
    function c(h, p) {
      return i.fromRdf(h, p);
    }
    u.fromRdf = c;
    function s(h, p) {
      return p && "namedNode" in p && (p = { dataFactory: p }), p = p || {}, p && !p.dataFactory && (p.dataFactory = n), i.toRdf(h, p);
    }
    u.toRdf = s;
    function d(h, p) {
      return h.termType === "Literal" ? c(h, p) : h.value;
    }
    u.getTermRaw = d;
    function l() {
      return i.getSupportedRdfDatatypes();
    }
    u.getSupportedRdfDatatypes = l;
    function f() {
      return i.getSupportedJavaScriptPrimitives();
    }
    u.getSupportedJavaScriptPrimitives = f;
  }(Ao)), Ao;
}
var Oo = {}, P1 = {}, yE, M9;
function CW() {
  if (M9) return yE;
  M9 = 1;
  var { Buffer: u } = qi(), r = {}, o = r.LEFT_BRACE = 1, a = r.RIGHT_BRACE = 2, t = r.LEFT_BRACKET = 3, e = r.RIGHT_BRACKET = 4, n = r.COLON = 5, i = r.COMMA = 6, c = r.TRUE = 7, s = r.FALSE = 8, d = r.NULL = 9, l = r.STRING = 10, f = r.NUMBER = 11, h = r.START = 17, p = r.STOP = 18, b = r.TRUE1 = 33, _ = r.TRUE2 = 34, y = r.TRUE3 = 35, m = r.FALSE1 = 49, g = r.FALSE2 = 50, T = r.FALSE3 = 51, v = r.FALSE4 = 52, E = r.NULL1 = 65, R = r.NULL2 = 66, L = r.NULL3 = 67, A = r.NUMBER1 = 81, w = r.NUMBER3 = 83, S = r.STRING1 = 97, O = r.STRING2 = 98, x = r.STRING3 = 99, F = r.STRING4 = 100, j = r.STRING5 = 101, q = r.STRING6 = 102, Q = r.VALUE = 113, G = r.KEY = 114, K = r.OBJECT = 129, U = r.ARRAY = 130, ae = 92, ye = 47, pe = 8, ee = 12, Te = 10, we = 13, Oe = 9, be = 64 * 1024;
  function he(M) {
    return u.alloc ? u.alloc(M) : new u(M);
  }
  function V() {
    this.tState = h, this.value = void 0, this.string = void 0, this.stringBuffer = he(be), this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, this.key = void 0, this.mode = void 0, this.stack = [], this.state = Q, this.bytes_remaining = 0, this.bytes_in_sequence = 0, this.temp_buffs = { 2: he(2), 3: he(3), 4: he(4) }, this.offset = -1;
  }
  V.toknam = function(M) {
    for (var I = Object.keys(r), P = 0, B = I.length; P < B; P++) {
      var z = I[P];
      if (r[z] === M)
        return z;
    }
    return M && "0x" + M.toString(16);
  };
  var N = V.prototype;
  return N.onError = function(M) {
    throw M;
  }, N.charError = function(M, I) {
    this.tState = p, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(M[I])) + " at position " + I + " in state " + V.toknam(this.tState)));
  }, N.appendStringChar = function(M) {
    this.stringBufferOffset >= be && (this.string += this.stringBuffer.toString("utf8"), this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = M;
  }, N.appendStringBuf = function(M, I, P) {
    var B = M.length;
    typeof I == "number" && (typeof P == "number" ? P < 0 ? B = M.length - I + P : B = P - I : B = M.length - I), B < 0 && (B = 0), this.stringBufferOffset + B > be && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0), M.copy(this.stringBuffer, this.stringBufferOffset, I, P), this.stringBufferOffset += B;
  }, N.write = function(M) {
    typeof M == "string" && (M = new u(M));
    for (var I, P = 0, B = M.length; P < B; P++)
      if (this.tState === h) {
        if (I = M[P], this.offset++, I === 123)
          this.onToken(o, "{");
        else if (I === 125)
          this.onToken(a, "}");
        else if (I === 91)
          this.onToken(t, "[");
        else if (I === 93)
          this.onToken(e, "]");
        else if (I === 58)
          this.onToken(n, ":");
        else if (I === 44)
          this.onToken(i, ",");
        else if (I === 116)
          this.tState = b;
        else if (I === 102)
          this.tState = m;
        else if (I === 110)
          this.tState = E;
        else if (I === 34)
          this.string = "", this.stringBufferOffset = 0, this.tState = S;
        else if (I === 45)
          this.string = "-", this.tState = A;
        else if (I >= 48 && I < 64)
          this.string = String.fromCharCode(I), this.tState = w;
        else if (!(I === 32 || I === 9 || I === 10 || I === 13)) return this.charError(M, P);
      } else if (this.tState === S)
        if (I = M[P], this.bytes_remaining > 0) {
          for (var z = 0; z < this.bytes_remaining; z++)
            this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + z] = M[z];
          this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, P = P + z - 1;
        } else if (this.bytes_remaining === 0 && I >= 128) {
          if (I <= 193 || I > 244)
            return this.onError(new Error("Invalid UTF-8 character at position " + P + " in state " + V.toknam(this.tState)));
          if (I >= 194 && I <= 223 && (this.bytes_in_sequence = 2), I >= 224 && I <= 239 && (this.bytes_in_sequence = 3), I >= 240 && I <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + P > M.length) {
            for (var H = 0; H <= M.length - 1 - P; H++)
              this.temp_buffs[this.bytes_in_sequence][H] = M[P + H];
            this.bytes_remaining = P + this.bytes_in_sequence - M.length, P = M.length - 1;
          } else
            this.appendStringBuf(M, P, P + this.bytes_in_sequence), P = P + this.bytes_in_sequence - 1;
        } else if (I === 34)
          this.tState = h, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0, this.onToken(l, this.string), this.offset += u.byteLength(this.string, "utf8") + 1, this.string = void 0;
        else if (I === 92)
          this.tState = O;
        else if (I >= 32)
          this.appendStringChar(I);
        else
          return this.charError(M, P);
      else if (this.tState === O)
        if (I = M[P], I === 34)
          this.appendStringChar(I), this.tState = S;
        else if (I === 92)
          this.appendStringChar(ae), this.tState = S;
        else if (I === 47)
          this.appendStringChar(ye), this.tState = S;
        else if (I === 98)
          this.appendStringChar(pe), this.tState = S;
        else if (I === 102)
          this.appendStringChar(ee), this.tState = S;
        else if (I === 110)
          this.appendStringChar(Te), this.tState = S;
        else if (I === 114)
          this.appendStringChar(we), this.tState = S;
        else if (I === 116)
          this.appendStringChar(Oe), this.tState = S;
        else if (I === 117)
          this.unicode = "", this.tState = x;
        else
          return this.charError(M, P);
      else if (this.tState === x || this.tState === F || this.tState === j || this.tState === q)
        if (I = M[P], I >= 48 && I < 64 || I > 64 && I <= 70 || I > 96 && I <= 102) {
          if (this.unicode += String.fromCharCode(I), this.tState++ === q) {
            var J = parseInt(this.unicode, 16);
            this.unicode = void 0, this.highSurrogate !== void 0 && J >= 56320 && J < 57344 ? (this.appendStringBuf(new u(String.fromCharCode(this.highSurrogate, J))), this.highSurrogate = void 0) : this.highSurrogate === void 0 && J >= 55296 && J < 56320 ? this.highSurrogate = J : (this.highSurrogate !== void 0 && (this.appendStringBuf(new u(String.fromCharCode(this.highSurrogate))), this.highSurrogate = void 0), this.appendStringBuf(new u(String.fromCharCode(J)))), this.tState = S;
          }
        } else
          return this.charError(M, P);
      else if (this.tState === A || this.tState === w)
        switch (I = M[P], I) {
          case 48:
          // 0
          case 49:
          // 1
          case 50:
          // 2
          case 51:
          // 3
          case 52:
          // 4
          case 53:
          // 5
          case 54:
          // 6
          case 55:
          // 7
          case 56:
          // 8
          case 57:
          // 9
          case 46:
          // .
          case 101:
          // e
          case 69:
          // E
          case 43:
          // +
          case 45:
            this.string += String.fromCharCode(I), this.tState = w;
            break;
          default:
            this.tState = h;
            var k = this.numberReviver(this.string, M, P);
            if (k)
              return k;
            this.offset += this.string.length - 1, this.string = void 0, P--;
            break;
        }
      else if (this.tState === b)
        if (M[P] === 114)
          this.tState = _;
        else
          return this.charError(M, P);
      else if (this.tState === _)
        if (M[P] === 117)
          this.tState = y;
        else
          return this.charError(M, P);
      else if (this.tState === y)
        if (M[P] === 101)
          this.tState = h, this.onToken(c, !0), this.offset += 3;
        else
          return this.charError(M, P);
      else if (this.tState === m)
        if (M[P] === 97)
          this.tState = g;
        else
          return this.charError(M, P);
      else if (this.tState === g)
        if (M[P] === 108)
          this.tState = T;
        else
          return this.charError(M, P);
      else if (this.tState === T)
        if (M[P] === 115)
          this.tState = v;
        else
          return this.charError(M, P);
      else if (this.tState === v)
        if (M[P] === 101)
          this.tState = h, this.onToken(s, !1), this.offset += 4;
        else
          return this.charError(M, P);
      else if (this.tState === E)
        if (M[P] === 117)
          this.tState = R;
        else
          return this.charError(M, P);
      else if (this.tState === R)
        if (M[P] === 108)
          this.tState = L;
        else
          return this.charError(M, P);
      else if (this.tState === L)
        if (M[P] === 108)
          this.tState = h, this.onToken(d, null), this.offset += 3;
        else
          return this.charError(M, P);
  }, N.onToken = function(M, I) {
  }, N.parseError = function(M, I) {
    this.tState = p, this.onError(new Error("Unexpected " + V.toknam(M) + (I ? "(" + JSON.stringify(I) + ")" : "") + " in state " + V.toknam(this.state)));
  }, N.push = function() {
    this.stack.push({ value: this.value, key: this.key, mode: this.mode });
  }, N.pop = function() {
    var M = this.value, I = this.stack.pop();
    this.value = I.value, this.key = I.key, this.mode = I.mode, this.emit(M), this.mode || (this.state = Q);
  }, N.emit = function(M) {
    this.mode && (this.state = i), this.onValue(M);
  }, N.onValue = function(M) {
  }, N.onToken = function(M, I) {
    if (this.state === Q)
      if (M === l || M === f || M === c || M === s || M === d)
        this.value && (this.value[this.key] = I), this.emit(I);
      else if (M === o)
        this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, this.key = void 0, this.state = G, this.mode = K;
      else if (M === t)
        this.push(), this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, this.mode = U, this.state = Q;
      else if (M === a)
        if (this.mode === K)
          this.pop();
        else
          return this.parseError(M, I);
      else if (M === e)
        if (this.mode === U)
          this.pop();
        else
          return this.parseError(M, I);
      else
        return this.parseError(M, I);
    else if (this.state === G)
      if (M === l)
        this.key = I, this.state = n;
      else if (M === a)
        this.pop();
      else
        return this.parseError(M, I);
    else if (this.state === n)
      if (M === n)
        this.state = Q;
      else
        return this.parseError(M, I);
    else if (this.state === i)
      if (M === i)
        this.mode === U ? (this.key++, this.state = Q) : this.mode === K && (this.state = G);
      else if (M === e && this.mode === U || M === a && this.mode === K)
        this.pop();
      else
        return this.parseError(M, I);
    else
      return this.parseError(M, I);
  }, N.numberReviver = function(M, I, P) {
    var B = Number(M);
    if (isNaN(B))
      return this.charError(I, P);
    M.match(/[0-9]+/) == M && B.toString() != M ? this.onToken(l, M) : this.onToken(f, B);
  }, V.C = r, yE = V, yE;
}
var C9;
function kue() {
  if (C9) return P1;
  C9 = 1, Object.defineProperty(P1, "__esModule", { value: !0 }), P1.SparqlJsonParser = void 0;
  const u = Or(), r = Bt(), o = CW();
  let a = class {
    constructor(e) {
      var n;
      e = e || {}, this.dataFactory = e.dataFactory || new u.DataFactory(), this.prefixVariableQuestionMark = !!e.prefixVariableQuestionMark, this.suppressMissingStreamResultsError = (n = e.suppressMissingStreamResultsError) !== null && n !== void 0 ? n : !0;
    }
    /**
     * Convert a SPARQL JSON bindings response to an array of bindings objects.
     * @param sparqlResponse A SPARQL JSON response.
     * @return {IBindings[]} An array of bindings.
     */
    parseJsonResults(e) {
      return e.results.bindings.map((n) => this.parseJsonBindings(n));
    }
    /**
     * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.
     *
     * The bindings stream will emit a 'variables' event that will contain
     * the array of variables (as RDF.Variable[]), as defined in the response head.
     *
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.
     * @return {NodeJS.ReadableStream} A stream of bindings.
     */
    parseJsonResultsStream(e) {
      const n = (l) => d.emit("error", l);
      e.on("error", n);
      const i = new o();
      i.onError = n;
      let c = !1, s = !1;
      i.onValue = (l) => {
        if (i.key === "vars" && i.stack.length === 2 && i.stack[1].key === "head")
          d.emit("variables", l.map((f) => this.dataFactory.variable(f))), c = !0;
        else if (i.key === "results" && i.stack.length === 1)
          s = !0;
        else if (typeof i.key == "number" && i.stack.length === 3 && i.stack[1].key === "results" && i.stack[2].key === "bindings")
          try {
            d.push(this.parseJsonBindings(l));
          } catch (f) {
            d.emit("error", f);
          }
        else i.key === "metadata" && i.stack.length === 1 && d.emit("metadata", l);
      };
      const d = e.on("end", (l) => {
        !s && !this.suppressMissingStreamResultsError ? d.emit("error", new Error("No valid SPARQL query results were found.")) : c || d.emit("variables", []);
      }).pipe(new r.Transform({
        objectMode: !0,
        transform(l, f, h) {
          i.write(l), h();
        }
      }));
      return d;
    }
    /**
     * Convert a SPARQL JSON result binding to a bindings object.
     * @param rawBindings A SPARQL JSON result binding.
     * @return {IBindings} A bindings object.
     */
    parseJsonBindings(e) {
      const n = {};
      for (const i in e) {
        const c = e[i];
        n[this.prefixVariableQuestionMark ? "?" + i : i] = this.parseJsonValue(c);
      }
      return n;
    }
    /**
     * Convert a SPARQL JSON result value to an RDF term.
     * @param rawValue A SPARQL JSON result value
     * @return {RDF.Term} An RDF term.
     */
    parseJsonValue(e) {
      let n;
      switch (e.type) {
        case "bnode":
          n = this.dataFactory.blankNode(e.value);
          break;
        case "literal":
          e["xml:lang"] ? n = this.dataFactory.literal(e.value, e["xml:lang"]) : e.datatype ? n = this.dataFactory.literal(e.value, this.dataFactory.namedNode(e.datatype)) : n = this.dataFactory.literal(e.value);
          break;
        case "typed-literal":
          n = this.dataFactory.literal(e.value, this.dataFactory.namedNode(e.datatype));
          break;
        case "triple":
          const i = e.value;
          if (!i || !i.subject || !i.predicate || !i.object)
            throw new Error("Invalid quoted triple: " + JSON.stringify(e));
          n = this.dataFactory.quad(this.parseJsonValue(i.subject), this.parseJsonValue(i.predicate), this.parseJsonValue(i.object));
          break;
        default:
          n = this.dataFactory.namedNode(e.value);
          break;
      }
      return n;
    }
    /**
     * Convert a SPARQL JSON boolean response to a boolean.
     * This will throw an error if the given reponse was not a valid boolean response.
     * @param sparqlResponse A SPARQL JSON response.
     * @return {IBindings[]} An array of bindings.
     */
    parseJsonBoolean(e) {
      if ("boolean" in e)
        return e.boolean;
      throw new Error("No valid ASK response was found.");
    }
    /**
     * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.
     * This will reject if the given reponse was not a valid boolean response.
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.
     * @return {Promise<boolean>} The response boolean.
     */
    parseJsonBooleanStream(e) {
      return new Promise((n, i) => {
        const c = new o();
        c.onError = i, c.onValue = (s) => {
          c.key === "boolean" && typeof s == "boolean" && c.stack.length === 1 && n(s);
        }, e.on("error", i).on("data", (s) => c.write(s)).on("end", () => i(new Error("No valid ASK response was found.")));
      });
    }
  };
  return P1.SparqlJsonParser = a, P1;
}
var q9;
function qW() {
  return q9 || (q9 = 1, function(u) {
    var r = Oo && Oo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Oo && Oo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ kue(), u);
  }(Oo)), Oo;
}
var B9;
function Xue() {
  if (B9) return E1;
  B9 = 1, Object.defineProperty(E1, "__esModule", { value: !0 }), E1.Converter = void 0;
  const u = zue(), r = /* @__PURE__ */ qW();
  let o = class aa {
    constructor(t) {
      t = t || { delimiter: "_" }, t.prefixVariableQuestionMark = !1, this.delimiter = t.delimiter || "_", this.parser = new r.SparqlJsonParser(t), this.materializeRdfJsTerms = t.materializeRdfJsTerms;
    }
    /**
     * Adds a value to a tree.
     * @param tree A tree datastructure.
     * @param {string[]} path The path of keys in the tree.
     * @param {Term} value A value to add.
     * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)
     *                             through recursive calls, can be empty.
     * @param {ISchema} schema A schema.
     * @param {string} delimiter The string to join key paths by.
     */
    static addValueToTree(t, e, n, i, c, s) {
      const d = e[0], l = i ? i + s + d : d, f = c.singularizeVariables[l];
      if (e.length === 1)
        f ? t[d] || (t[d] = n) : (t[d] || (t[d] = []), t[d].push(n));
      else {
        let h;
        f ? (t[d] || (t[d] = {}), h = t[d]) : (t[d] || (t[d] = [{}]), h = t[d][0]), aa.addValueToTree(h, e.slice(1), n, l, c, s);
      }
    }
    /**
     * Recursively merge the two given trees.
     * @param tree1 A first tree (has key priority on literals).
     * @param tree2 A second tree. All arrays will/should only have a single element.
     * @return {any} The merged tree.
     */
    static mergeTrees(t, e) {
      if (typeof t != typeof e)
        throw new Error(`Two incompatible tree nodes were found: ${typeof t} and ${typeof e}`);
      if (Array.isArray(t) !== Array.isArray(e))
        throw new Error(`Two incompatible tree nodes were found: Array?${Array.isArray(t)} and Array?${Array.isArray(e)}`);
      if (typeof t == "object" && typeof e == "object") {
        if (t.termType && e.termType)
          return t.equals(e) ? { valid: !0, result: t } : { valid: !1, result: t };
        if (Array.isArray(t) && Array.isArray(e)) {
          if (t.length > 0) {
            const n = [];
            let i = !1;
            for (const c of t) {
              const s = aa.mergeTrees(c, e[0]);
              s.valid ? (i = !0, n.push(s.result)) : n.push(c);
            }
            if (i)
              return { valid: !0, result: n };
          }
          return { valid: !0, result: t.concat(e) };
        } else {
          const n = {};
          for (const i in e)
            n[i] = e[i];
          for (const i in t)
            if (n[i]) {
              const c = aa.mergeTrees(t[i], n[i]);
              if (c.valid)
                n[i] = c.result;
              else
                return { valid: !1, result: t };
            } else
              n[i] = t[i];
          return { valid: !0, result: n };
        }
      } else
        throw new Error(`Unmergable tree types: ${typeof t} and ${typeof e}`);
    }
    /**
     * Materialize all RDF terms in the given tree to raw values.
     * This does not mutate the original tree.
     * @param tree A tree.
     * @return {any} A materialized tree.
     */
    static materializeTree(t) {
      if (t.termType)
        return (0, u.getTermRaw)(t);
      if (Array.isArray(t))
        return t.map(aa.materializeTree);
      {
        const e = {};
        for (const n in t)
          e[n] = aa.materializeTree(t[n]);
        return e;
      }
    }
    /**
     * Convert a complete SPARQL JSON response to a GraphQL results tree.
     * @param sparqlResponse A SPARQL JSON response.
     * @param {ISchema} schema A schema.
     * @return {any} A GraphQL results tree.
     */
    sparqlJsonResultsToTree(t, e) {
      return this.bindingsToTree(this.parser.parseJsonResults(t), e || { singularizeVariables: {} });
    }
    /**
     * Convert an array of bindings to a GraphQL results tree.
     * @param {IBindings[]} bindingsArray An array of bindings.
     * @param {ISchema} schema A schema.
     * @return {any} A GraphQL results tree.
     */
    bindingsToTree(t, e) {
      const n = e && e.singularizeVariables[""];
      let i = n ? {} : [];
      for (const c of t) {
        const s = n ? {} : [{}];
        for (const d in c) {
          const l = d.split(this.delimiter), f = c[d];
          aa.addValueToTree(n ? s : s[0], l, f, "", e, this.delimiter);
        }
        i = aa.mergeTrees(i, s).result;
      }
      return this.materializeRdfJsTerms && (i = aa.materializeTree(i)), i;
    }
  };
  return E1.Converter = o, E1;
}
var $9;
function Jue() {
  return $9 || ($9 = 1, function(u) {
    var r = So && So.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = So && So.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Xue(), u);
  }(So)), So;
}
var U9;
function V9() {
  if (U9) return A1;
  U9 = 1, Object.defineProperty(A1, "__esModule", { value: !0 }), A1.ActorQueryResultSerializeTree = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = Bt(), t = /* @__PURE__ */ Jue();
  let e = class BW extends u.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{ "tree": 0.5 }} mediaTypePriorities
     *   \ @defaultNested {{ "tree": "https://comunica.linkeddatafragments.org/#results_tree" }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    /**
     *
     * @param {BindingsStream} bindingsStream
     * @param context
     * @param {IConverterSettings} converterSettings
     * @return {Promise<string>}
     */
    static async bindingsStreamToGraphQl(i, c, s) {
      const d = o.ActionContext.ensureActionContext(c), l = new t.Converter(s), f = {
        singularizeVariables: d.get(r.KeysInitQuery.graphqlSingularizeVariables) ?? {}
      };
      return l.bindingsToTree(await i.map((h) => Object.fromEntries([...h].map(([p, b]) => [p.value, b]))).toArray(), f);
    }
    async testHandleChecked(i) {
      return i.type !== "bindings" ? (0, o.failTest)("This actor can only handle bindings streams.") : (0, o.passTestVoid)();
    }
    async runHandle(i, c) {
      const s = new a.Readable();
      return s._read = () => {
        s._read = () => {
        }, BW.bindingsStreamToGraphQl(i.bindingsStream, i.context, { materializeRdfJsTerms: !0 }).then((d) => {
          s.push(JSON.stringify(d, null, "  ")), s.push(null);
        }).catch((d) => s.emit("error", d));
      }, { data: s };
    }
  };
  return A1.ActorQueryResultSerializeTree = e, A1;
}
var Q9;
function Kue() {
  return Q9 || (Q9 = 1, function(u) {
    var r = wo && wo.__createBinding || (Object.create ? function(e, n, i, c) {
      c === void 0 && (c = i);
      var s = Object.getOwnPropertyDescriptor(n, i);
      (!s || ("get" in s ? !n.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
        return n[i];
      } }), Object.defineProperty(e, c, s);
    } : function(e, n, i, c) {
      c === void 0 && (c = i), e[c] = n[i];
    }), o = wo && wo.__exportStar || function(e, n) {
      for (var i in e) i !== "default" && !Object.prototype.hasOwnProperty.call(n, i) && r(n, e, i);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.bindingsStreamToGraphQl = void 0;
    const a = /* @__PURE__ */ V9(), { bindingsStreamToGraphQl: t } = a.ActorQueryResultSerializeTree;
    u.bindingsStreamToGraphQl = t, o(/* @__PURE__ */ V9(), u);
  }(wo)), wo;
}
var xo = {}, D1 = {}, H9;
function Wue() {
  if (H9) return D1;
  H9 = 1, Object.defineProperty(D1, "__esModule", { value: !0 }), D1.MediatorCombineUnion = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Mediator {
    constructor(a) {
      super(a), this.combiner = this.createCombiner();
    }
    async mediate(a) {
      let t;
      try {
        t = this.publish(a);
      } catch {
        t = [];
      }
      if (this.filterFailures) {
        const i = [];
        for (const c of t)
          (await c.reply).isPassed() && i.push(c);
        t = i;
      }
      const e = [];
      await Promise.all(t.map(async ({ reply: i }, c) => {
        const s = await i, d = s.getOrThrow();
        return e[c] = s.getSideData(), d;
      }));
      const n = await Promise.all(t.map((i, c) => i.actor.runObservable(a, e[c])));
      return this.combiner(n);
    }
    mediateWith() {
      throw new Error("Method not supported.");
    }
    createCombiner() {
      return (a) => {
        const t = {};
        return t[this.field] = {}, [{}].concat(a.map((e) => e[this.field])).forEach((e) => {
          t[this.field] = { ...e, ...t[this.field] };
        }), t;
      };
    }
  };
  return D1.MediatorCombineUnion = r, D1;
}
var G9;
function Ra() {
  return G9 || (G9 = 1, function(u) {
    var r = xo && xo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xo && xo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Wue(), u);
  }(xo)), xo;
}
var Io = {}, L1 = {}, z9;
function Yue() {
  if (z9) return L1;
  z9 = 1, Object.defineProperty(L1, "__esModule", { value: !0 }), L1.MediatorNumber = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Mediator {
    constructor(a) {
      super(a), this.indexPicker = this.createIndexPicker();
    }
    /**
     * @return {(tests: T[]) => number} A function that returns the index of the test result
     *                                  that has been chosen by this mediator.
     */
    createIndexPicker() {
      switch (this.type) {
        case "min":
          return (a) => a.reduce((t, e, n) => {
            const i = this.getOrDefault(e[this.field], Number.POSITIVE_INFINITY);
            return i !== null && (Number.isNaN(t[0]) || t[0] > i) ? [i, n] : t;
          }, [Number.NaN, -1])[1];
        case "max":
          return (a) => a.reduce((t, e, n) => {
            const i = this.getOrDefault(e[this.field], Number.NEGATIVE_INFINITY);
            return i !== null && (Number.isNaN(t[0]) || t[0] < i) ? [i, n] : t;
          }, [Number.NaN, -1])[1];
        default:
          throw new Error(`No valid "type" value was given, must be either 'min' or 'max', but got: ${this.type}`);
      }
    }
    getOrDefault(a, t) {
      return a === void 0 ? t : a;
    }
    async mediateWith(a, t) {
      let e = await Promise.all(t.map(({ reply: d }) => d));
      const n = [];
      if (this.ignoreFailures) {
        const d = {};
        d[this.field] = null, e = e.map((l) => l.isFailed() ? (n.push(l.getFailMessage()), (0, u.passTestWithSideData)(d, void 0)) : l);
      }
      const i = [], c = e.map((d, l) => {
        const f = d.getOrThrow();
        return i[l] = d.getSideData(), f;
      }), s = this.indexPicker(c);
      return s < 0 ? (0, u.failTest)(this.constructFailureMessage(a, n)) : (0, u.passTestWithSideData)(t[s].actor, i[s]);
    }
  };
  return L1.MediatorNumber = r, L1;
}
var k9;
function m0() {
  return k9 || (k9 = 1, function(u) {
    var r = Io && Io.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Io && Io.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Yue(), u);
  }(Io)), Io;
}
var Ro = {}, j1 = {}, Fo = {}, M1 = {}, Ki = {}, X9;
function R8() {
  if (X9) return Ki;
  X9 = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.ActorDereferenceBase = Ki.isHardError = Ki.emptyReadable = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e(), o = Bt();
  function a() {
    const n = new o.Readable();
    return n.push(null), n;
  }
  Ki.emptyReadable = a;
  function t(n) {
    return !n.get(u.KeysInitQuery.lenient);
  }
  Ki.isHardError = t;
  let e = class extends r.Actor {
    constructor(i) {
      super(i);
    }
    /**
     * Handle the given error as a rejection or delegate it to the logger,
     * depending on whether or not hard errors are enabled.
     * @param {I} action An action.
     * @param {Error} error An error that has occurred.
     * @param {N} output Data to add to the output
     */
    async dereferenceErrorHandler(i, c, s) {
      if (t(i.context))
        throw c;
      return this.logWarn(i.context, c.message, () => ({ url: i.url })), { ...s, data: a() };
    }
  };
  return Ki.ActorDereferenceBase = e, Ki;
}
var J9;
function Zue() {
  if (J9) return M1;
  J9 = 1, Object.defineProperty(M1, "__esModule", { value: !0 }), M1.ActorDereference = void 0;
  const u = /* @__PURE__ */ R8();
  let r = class extends u.ActorDereferenceBase {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Dereferencing failed: none of the configured actors were able to handle ${action.url}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
    /**
     * Handle the given error as a rejection or delegate it to the logger,
     * depending on whether or not hard errors are enabled.
     * @param {IActionDereference} action A dereference action.
     * @param {Error} error An error that has occurred.
     * @param headers Optional HTTP headers to pass.
     * @param {number} requestTime The time it took to request the page in milliseconds.
     * @return {Promise<IActorDereferenceOutput>} A promise that rejects or resolves to an empty output.
     */
    async handleDereferenceErrors(a, t, e, n = 0) {
      return this.dereferenceErrorHandler(a, t, { url: a.url, exists: !1, headers: e, requestTime: n });
    }
  };
  return M1.ActorDereference = r, M1;
}
var No = {}, K9;
function eoe() {
  if (K9) return No;
  K9 = 1, Object.defineProperty(No, "__esModule", { value: !0 }), No.ActorDereferenceParse = No.getMediaTypeFromExtension = void 0;
  const u = /* @__PURE__ */ _e(), r = Bt(), o = /* @__PURE__ */ R8();
  function a(e, n) {
    const i = e.lastIndexOf(".");
    return i >= 0 && (n == null ? void 0 : n[e.slice(i + 1)]) || "";
  }
  No.getMediaTypeFromExtension = a;
  let t = class extends o.ActorDereferenceBase {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, u.passTestVoid)();
    }
    /**
     * If hard errors are disabled, modify the given stream so that errors are delegated to the logger.
     * @param {IActionDereferenceParse} action A dereference action.
     * @param {Readable} data A data stream.
     * @return {Readable} The resulting data stream.
     */
    handleDereferenceStreamErrors(n, i) {
      return (0, o.isHardError)(n.context) || (i.on("error", (c) => {
        this.logWarn(n.context, c.message, () => ({ url: n.url })), i.push(null);
      }), i = i.pipe(new r.PassThrough({ objectMode: !0 }))), i;
    }
    async run(n) {
      var d, l, f, h;
      const { context: i } = n, c = await this.mediatorDereference.mediate({
        ...n,
        mediaTypes: async () => {
          var p, b;
          return (b = await ((p = this.mediatorParseMediatypes) == null ? void 0 : p.mediate({ context: i, mediaTypes: !0 }))) == null ? void 0 : b.mediaTypes;
        }
      });
      let s;
      if (c.exists)
        try {
          s = (await this.mediatorParse.mediate({
            context: i,
            handle: { context: i, ...c, metadata: await this.getMetadata(c) },
            // eslint-disable-next-line ts/prefer-nullish-coalescing
            handleMediaType: c.mediaType || n.mediaType || a(c.url, this.mediaMappings)
          })).handle, s.data = this.handleDereferenceStreamErrors(n, s.data);
        } catch (p) {
          await ((l = (d = c.data).close) == null ? void 0 : l.call(d)), s = await this.dereferenceErrorHandler(n, p, {});
        }
      else
        await ((h = (f = c.data).close) == null ? void 0 : h.call(f)), s = { data: (0, o.emptyReadable)() };
      return { ...c, ...s };
    }
  };
  return No.ActorDereferenceParse = t, No;
}
var W9;
function F8() {
  return W9 || (W9 = 1, function(u) {
    var r = Fo && Fo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Fo && Fo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Zue(), u), o(/* @__PURE__ */ eoe(), u), o(/* @__PURE__ */ R8(), u);
  }(Fo)), Fo;
}
var Y9;
function toe() {
  if (Y9) return j1;
  Y9 = 1, Object.defineProperty(j1, "__esModule", { value: !0 }), j1.ActorDereferenceFallback = void 0;
  const u = /* @__PURE__ */ F8(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorDereference {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return this.handleDereferenceErrors(t, new Error(`Could not dereference '${t.url}'`));
    }
  };
  return j1.ActorDereferenceFallback = o, j1;
}
var Z9;
function roe() {
  return Z9 || (Z9 = 1, function(u) {
    var r = Ro && Ro.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ro && Ro.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ toe(), u);
  }(Ro)), Ro;
}
var Po = {}, C1 = {}, Do = {}, q1 = {}, eD;
function noe() {
  if (eD) return q1;
  eD = 1, Object.defineProperty(q1, "__esModule", { value: !0 }), q1.ActorRdfJoinEntriesSort = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Sorting join entries failed: none of the configured actors were able to sort} busFailMessage
     */
    constructor(a) {
      super(a);
    }
  };
  return q1.ActorRdfJoinEntriesSort = r, q1;
}
var tD;
function $W() {
  return tD || (tD = 1, function(u) {
    var r = Do && Do.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Do && Do.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ noe(), u);
  }(Do)), Do;
}
var rD;
function ioe() {
  if (rD) return C1;
  rD = 1, Object.defineProperty(C1, "__esModule", { value: !0 }), C1.ActorRdfJoinEntriesSortCardinality = void 0;
  const u = /* @__PURE__ */ $W(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfJoinEntriesSort {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTest)({
        accuracy: t.entries.length === 0 ? 1 : t.entries.reduce((e, n) => e + (Number.isFinite(n.metadata.cardinality.value) ? 1 : 0), 0) / t.entries.length
      });
    }
    async run(t) {
      return { entries: [...t.entries].sort((n, i) => n.metadata.cardinality.value - i.metadata.cardinality.value) };
    }
  };
  return C1.ActorRdfJoinEntriesSortCardinality = o, C1;
}
var nD;
function aoe() {
  return nD || (nD = 1, function(u) {
    var r = Po && Po.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Po && Po.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ioe(), u);
  }(Po)), Po;
}
var Lo = {}, jo = {}, Mo = {}, B1 = {}, iD;
function uoe() {
  if (iD) return B1;
  iD = 1, Object.defineProperty(B1, "__esModule", { value: !0 }), B1.ActorRdfJoinSelectivity = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Determining join selectivity failed: none of the configured actors were able to calculate selectivities} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return B1.ActorRdfJoinSelectivity = r, B1;
}
var aD;
function ooe() {
  return aD || (aD = 1, function(u) {
    var r = Mo && Mo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Mo && Mo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ uoe(), u);
  }(Mo)), Mo;
}
var uD;
function soe() {
  if (uD) return jo;
  uD = 1, Object.defineProperty(jo, "__esModule", { value: !0 }), jo.JoinTypes = jo.ActorRdfJoinSelectivityVariableCounting = void 0;
  const u = /* @__PURE__ */ ooe(), r = /* @__PURE__ */ _e(), o = ft();
  let a = class qf extends u.ActorRdfJoinSelectivity {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, r.passTest)({ accuracy: 0.5 });
    }
    static getPatternCost(n) {
      let i = 1;
      return n.subject.termType === "Variable" && (i += 4), (n.predicate.termType === "Variable" || n.type === o.Algebra.types.PATH) && (i += 1), n.object.termType === "Variable" && (i += 2), n.graph.termType === "Variable" && (i += 1), i / 9;
    }
    static getJoinTypes(n, i) {
      const c = [];
      return n.subject.termType === "Variable" ? (n.subject.equals(i.subject) && c.push(t.unboundSS), i.type === "pattern" && n.subject.equals(i.predicate) && c.push(t.unboundSP), n.subject.equals(i.object) && c.push(t.unboundSO), n.subject.equals(i.graph) && c.push(t.unboundSG)) : (n.subject.equals(i.subject) && c.push(t.boundSS), i.type === "pattern" && n.subject.equals(i.predicate) && c.push(t.boundSP), n.subject.equals(i.object) && c.push(t.boundSO), n.subject.equals(i.graph) && c.push(t.boundSG)), n.type === "pattern" && (n.predicate.termType === "Variable" ? (n.predicate.equals(i.subject) && c.push(t.unboundPS), i.type === "pattern" && n.predicate.equals(i.predicate) && c.push(t.unboundPP), n.predicate.equals(i.object) && c.push(t.unboundPO), n.predicate.equals(i.graph) && c.push(t.unboundPG)) : (n.predicate.equals(i.subject) && c.push(t.boundPS), i.type === "pattern" && n.predicate.equals(i.predicate) && c.push(t.boundPP), n.predicate.equals(i.object) && c.push(t.boundPO), n.predicate.equals(i.graph) && c.push(t.boundPG))), n.object.termType === "Variable" ? (n.object.equals(i.subject) && c.push(t.unboundOS), i.type === "pattern" && n.object.equals(i.predicate) && c.push(t.unboundOP), n.object.equals(i.object) && c.push(t.unboundOO), n.object.equals(i.graph) && c.push(t.unboundOG)) : (n.object.equals(i.subject) && c.push(t.boundOS), i.type === "pattern" && n.object.equals(i.predicate) && c.push(t.boundOP), n.object.equals(i.object) && c.push(t.boundOO), n.object.equals(i.graph) && c.push(t.boundOG)), n.graph.termType === "Variable" ? (n.graph.equals(i.subject) && c.push(t.unboundGS), i.type === "pattern" && n.graph.equals(i.predicate) && c.push(t.unboundGP), n.graph.equals(i.object) && c.push(t.unboundGO), n.graph.equals(i.graph) && c.push(t.unboundGG)) : (n.graph.equals(i.subject) && c.push(t.boundGS), i.type === "pattern" && n.graph.equals(i.predicate) && c.push(t.boundGP), n.graph.equals(i.object) && c.push(t.boundGO), n.graph.equals(i.graph) && c.push(t.boundGG)), c;
    }
    static getOperationsPairwiseJoinCost(n, i) {
      let c = qf.MAX_PAIRWISE_COST;
      for (const s of qf.getJoinTypes(n, i))
        switch (s) {
          case t.boundSS:
            c -= 2 * 2;
            break;
          case t.boundSP:
            c -= 3 * 2;
            break;
          case t.boundSO:
            c -= 1 * 2;
            break;
          case t.boundSG:
            c -= 3 * 2;
            break;
          case t.boundPS:
            c -= 3 * 2;
            break;
          case t.boundPP:
            return 1;
          case t.boundPO:
            c -= 3 * 2;
            break;
          case t.boundPG:
            c -= 3 * 2;
            break;
          case t.boundOS:
            c -= 1 * 2;
            break;
          case t.boundOP:
            c -= 3 * 2;
            break;
          case t.boundOO:
            c -= 1 * 2;
            break;
          case t.boundOG:
            c -= 3 * 2;
            break;
          case t.boundGS:
            c -= 3 * 2;
            break;
          case t.boundGP:
            c -= 3 * 2;
            break;
          case t.boundGO:
            c -= 3 * 2;
            break;
          case t.boundGG:
            c -= 3 * 2;
            break;
          case t.unboundSS:
            c -= 2;
            break;
          case t.unboundSP:
            c -= 3;
            break;
          case t.unboundSO:
            c -= 1;
            break;
          case t.unboundSG:
            c -= 3;
            break;
          case t.unboundPS:
            c -= 3;
            break;
          case t.unboundPP:
            c -= 3;
            break;
          case t.unboundPO:
            c -= 3;
            break;
          case t.unboundPG:
            c -= 3;
            break;
          case t.unboundOS:
            c -= 1;
            break;
          case t.unboundOP:
            c -= 3;
            break;
          case t.unboundOO:
            c -= 1;
            break;
          case t.unboundOG:
            c -= 3;
            break;
          case t.unboundGS:
            c -= 3;
            break;
          case t.unboundGP:
            c -= 3;
            break;
          case t.unboundGO:
            c -= 3;
            break;
          case t.unboundGG:
            c -= 3;
            break;
        }
      return c / qf.MAX_PAIRWISE_COST;
    }
    static getOperationsJoinCost(n) {
      const i = [];
      for (const d of n)
        o.Util.recurseOperation(d, {
          [o.Algebra.types.PATTERN](l) {
            return i.push(l), !1;
          },
          [o.Algebra.types.PATH](l) {
            return i.push(l), !1;
          }
        });
      let c = 0, s = 0;
      for (const d of i)
        for (const l of i)
          d !== l && (c += qf.getOperationsPairwiseJoinCost(d, l), s++);
      return s === 0 ? 1 : c / s * i.reduce((d, l) => d * qf.getPatternCost(l), 1);
    }
    async run(n) {
      return n.entries.length <= 1 ? { selectivity: 1 } : {
        selectivity: qf.getOperationsJoinCost(n.entries.map((i) => i.operation))
      };
    }
  };
  jo.ActorRdfJoinSelectivityVariableCounting = a, a.MAX_PAIRWISE_COST = 41 * 2;
  var t;
  return function(e) {
    e[e.boundSS = 0] = "boundSS", e[e.boundSP = 1] = "boundSP", e[e.boundSO = 2] = "boundSO", e[e.boundSG = 3] = "boundSG", e[e.boundPS = 4] = "boundPS", e[e.boundPP = 5] = "boundPP", e[e.boundPO = 6] = "boundPO", e[e.boundPG = 7] = "boundPG", e[e.boundOS = 8] = "boundOS", e[e.boundOP = 9] = "boundOP", e[e.boundOO = 10] = "boundOO", e[e.boundOG = 11] = "boundOG", e[e.boundGS = 12] = "boundGS", e[e.boundGP = 13] = "boundGP", e[e.boundGO = 14] = "boundGO", e[e.boundGG = 15] = "boundGG", e[e.unboundSS = 16] = "unboundSS", e[e.unboundSP = 17] = "unboundSP", e[e.unboundSO = 18] = "unboundSO", e[e.unboundSG = 19] = "unboundSG", e[e.unboundPS = 20] = "unboundPS", e[e.unboundPP = 21] = "unboundPP", e[e.unboundPO = 22] = "unboundPO", e[e.unboundPG = 23] = "unboundPG", e[e.unboundOS = 24] = "unboundOS", e[e.unboundOP = 25] = "unboundOP", e[e.unboundOO = 26] = "unboundOO", e[e.unboundOG = 27] = "unboundOG", e[e.unboundGS = 28] = "unboundGS", e[e.unboundGP = 29] = "unboundGP", e[e.unboundGO = 30] = "unboundGO", e[e.unboundGG = 31] = "unboundGG";
  }(t || (jo.JoinTypes = t = {})), jo;
}
var oD;
function coe() {
  return oD || (oD = 1, function(u) {
    var r = Lo && Lo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Lo && Lo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ soe(), u);
  }(Lo)), Lo;
}
var Co = {}, $1 = {}, qo = {}, U1 = {}, sD;
function doe() {
  if (sD) return U1;
  sD = 1, Object.defineProperty(U1, "__esModule", { value: !0 }), U1.ActorRdfMetadata = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Metadata splicing failed: none of the configured actors were able to splice metadata from ${action.url}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return U1.ActorRdfMetadata = r, U1;
}
var cD;
function UW() {
  return cD || (cD = 1, function(u) {
    var r = qo && qo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = qo && qo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ doe(), u);
  }(qo)), qo;
}
var dD;
function loe() {
  if (dD) return $1;
  dD = 1, Object.defineProperty($1, "__esModule", { value: !0 }), $1.ActorRdfMetadataPrimaryTopic = void 0;
  const u = /* @__PURE__ */ UW(), r = /* @__PURE__ */ _e(), o = Bt();
  let a = class extends u.ActorRdfMetadata {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return e.triples ? (0, r.failTest)("This actor only supports non-triple quad streams.") : (0, r.passTestVoid)();
    }
    async run(e) {
      const n = new o.Readable({ objectMode: !0 }), i = new o.Readable({ objectMode: !0 }), c = () => {
        n._read = i._read = () => {
        }, e.quads.on("error", (f) => {
          n.emit("error", f), i.emit("error", f);
        });
        const s = {};
        let d;
        const l = {};
        e.quads.on("data", (f) => {
          f.predicate.value === "http://rdfs.org/ns/void#subset" && f.object.value === e.url ? d = f.subject.value : f.predicate.value === "http://xmlns.com/foaf/0.1/primaryTopic" && (l[f.object.value] = f.subject.value);
          let h = s[f.graph.value];
          h || (h = s[f.graph.value] = []), h.push(f);
        }), e.quads.on("end", () => {
          const f = d ? l[d] : void 0;
          for (const h in s)
            if (h === f) {
              for (const p of s[h])
                i.push(p);
              if (this.metadataToData)
                for (const p of s[h])
                  n.push(p);
            } else {
              for (const p of s[h])
                n.push(p);
              if (!f && this.dataToMetadataOnInvalidMetadataGraph)
                for (const p of s[h])
                  i.push(p);
            }
          n.push(null), i.push(null);
        });
      };
      return n._read = i._read = () => {
        c();
      }, { data: n, metadata: i };
    }
  };
  return $1.ActorRdfMetadataPrimaryTopic = a, $1;
}
var lD;
function foe() {
  return lD || (lD = 1, function(u) {
    var r = Co && Co.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Co && Co.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ loe(), u);
  }(Co)), Co;
}
var Bo = {}, V1 = {}, fD;
function hoe() {
  if (fD) return V1;
  fD = 1, Object.defineProperty(V1, "__esModule", { value: !0 }), V1.ActorRdfMetadataAll = void 0;
  const u = /* @__PURE__ */ UW(), r = /* @__PURE__ */ _e(), o = Bt();
  let a = class extends u.ActorRdfMetadata {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      const n = new o.Readable({ objectMode: !0 }), i = new o.Readable({ objectMode: !0 });
      e.quads.on("error", (s) => {
        n.emit("error", s), i.emit("error", s);
      }), e.quads.on("end", () => {
        n.push(null), i.push(null);
      });
      const c = n._read = i._read = (s) => {
        for (; s > 0; ) {
          const d = e.quads.read();
          if (d === null)
            return e.quads.once("readable", () => c(s));
          s--, n.push(d), i.push(d);
        }
      };
      return { data: n, metadata: i };
    }
  };
  return V1.ActorRdfMetadataAll = a, V1;
}
var hD;
function poe() {
  return hD || (hD = 1, function(u) {
    var r = Bo && Bo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bo && Bo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hoe(), u);
  }(Bo)), Bo;
}
var $o = {}, Q1 = {}, Uo = {}, H1 = {}, pD;
function boe() {
  if (pD) return H1;
  pD = 1, Object.defineProperty(H1, "__esModule", { value: !0 }), H1.ActorRdfMetadataAccumulate = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Metadata accumulation failed: none of the configured actors were able to accumulate metadata in mode ${action.mode}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return H1.ActorRdfMetadataAccumulate = r, H1;
}
var bD;
function N8() {
  return bD || (bD = 1, function(u) {
    var r = Uo && Uo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Uo && Uo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ boe(), u);
  }(Uo)), Uo;
}
var yD;
function yoe() {
  if (yD) return Q1;
  yD = 1, Object.defineProperty(Q1, "__esModule", { value: !0 }), Q1.ActorRdfMetadataAccumulateCardinality = void 0;
  const u = /* @__PURE__ */ N8(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataAccumulate {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      if (t.mode === "initialize")
        return { metadata: { cardinality: { type: "exact", value: 0 } } };
      const e = { ...t.accumulatedMetadata.cardinality };
      if (e.dataset) {
        if (t.accumulatedMetadata.defaultGraph === e.dataset && e.dataset !== t.appendingMetadata.cardinality.dataset)
          return { metadata: { cardinality: t.appendingMetadata.cardinality } };
        if (t.appendingMetadata.cardinality.dataset) {
          if (e.dataset !== t.appendingMetadata.cardinality.dataset && t.appendingMetadata.subsetOf === e.dataset)
            return { metadata: { cardinality: t.appendingMetadata.cardinality } };
          if (e.dataset === t.appendingMetadata.cardinality.dataset)
            return { metadata: { cardinality: e } };
          delete e.dataset;
        } else
          return { metadata: { cardinality: e } };
      }
      return !t.appendingMetadata.cardinality || !Number.isFinite(t.appendingMetadata.cardinality.value) ? (e.type = "estimate", e.value = Number.POSITIVE_INFINITY) : (t.appendingMetadata.cardinality.type === "estimate" && (e.type = "estimate"), e.value += t.appendingMetadata.cardinality.value), { metadata: { cardinality: e } };
    }
  };
  return Q1.ActorRdfMetadataAccumulateCardinality = o, Q1;
}
var _D;
function _oe() {
  return _D || (_D = 1, function(u) {
    var r = $o && $o.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $o && $o.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ yoe(), u);
  }($o)), $o;
}
var Vo = {}, G1 = {}, gD;
function goe() {
  if (gD) return G1;
  gD = 1, Object.defineProperty(G1, "__esModule", { value: !0 }), G1.ActorRdfMetadataAccumulatePageSize = void 0;
  const u = /* @__PURE__ */ N8(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataAccumulate {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return t.mode === "initialize" ? { metadata: {} } : {
        metadata: {
          ..."pageSize" in t.accumulatedMetadata || "pageSize" in t.appendingMetadata ? {
            pageSize: (t.accumulatedMetadata.pageSize ?? 0) + (t.appendingMetadata.pageSize ?? 0)
          } : {}
        }
      };
    }
  };
  return G1.ActorRdfMetadataAccumulatePageSize = o, G1;
}
var mD;
function moe() {
  return mD || (mD = 1, function(u) {
    var r = Vo && Vo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vo && Vo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ goe(), u);
  }(Vo)), Vo;
}
var Qo = {}, z1 = {}, vD;
function voe() {
  if (vD) return z1;
  vD = 1, Object.defineProperty(z1, "__esModule", { value: !0 }), z1.ActorRdfMetadataAccumulateRequestTime = void 0;
  const u = /* @__PURE__ */ N8(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataAccumulate {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return t.mode === "initialize" ? { metadata: {} } : {
        metadata: {
          ..."requestTime" in t.accumulatedMetadata || "requestTime" in t.appendingMetadata ? {
            requestTime: (t.accumulatedMetadata.requestTime ?? 0) + (t.appendingMetadata.requestTime ?? 0)
          } : {}
        }
      };
    }
  };
  return z1.ActorRdfMetadataAccumulateRequestTime = o, z1;
}
var TD;
function Toe() {
  return TD || (TD = 1, function(u) {
    var r = Qo && Qo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Qo && Qo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ voe(), u);
  }(Qo)), Qo;
}
var Ho = {}, k1 = {}, Go = {}, X1 = {}, wD;
function woe() {
  if (wD) return X1;
  wD = 1, Object.defineProperty(X1, "__esModule", { value: !0 }), X1.ActorRdfMetadataExtract = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return X1.ActorRdfMetadataExtract = r, X1;
}
var SD;
function Sa() {
  return SD || (SD = 1, function(u) {
    var r = Go && Go.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Go && Go.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ woe(), u);
  }(Go)), Go;
}
var _E = { exports: {} }, AD;
function Soe() {
  return AD || (AD = 1, function(u) {
    (function(r) {
      var o = function() {
        function p(b) {
          this.options = b;
        }
        return p.prototype.toString = function() {
          return JSON && JSON.stringify ? JSON.stringify(this.options) : this.options;
        }, p;
      }(), a = /* @__PURE__ */ function() {
        function p(R) {
          return Object.prototype.toString.apply(R) === "[object Array]";
        }
        function b(R) {
          return Object.prototype.toString.apply(R) === "[object String]";
        }
        function _(R) {
          return Object.prototype.toString.apply(R) === "[object Number]";
        }
        function y(R) {
          return Object.prototype.toString.apply(R) === "[object Boolean]";
        }
        function m(R, L) {
          var A = "", w = !0, S;
          for (S = 0; S < R.length; S += 1)
            w ? w = !1 : A += L, A += R[S];
          return A;
        }
        function g(R, L) {
          for (var A = [], w = 0; w < R.length; w += 1)
            A.push(L(R[w]));
          return A;
        }
        function T(R, L) {
          for (var A = [], w = 0; w < R.length; w += 1)
            L(R[w]) && A.push(R[w]);
          return A;
        }
        function v(R) {
          if (typeof R != "object" || R === null)
            return R;
          Object.freeze(R);
          var L, A;
          for (A in R)
            R.hasOwnProperty(A) && (L = R[A], typeof L == "object" && E(L));
          return R;
        }
        function E(R) {
          return typeof Object.freeze == "function" ? v(R) : R;
        }
        return {
          isArray: p,
          isString: b,
          isNumber: _,
          isBoolean: y,
          join: m,
          map: g,
          filter: T,
          deepFreeze: E
        };
      }(), t = /* @__PURE__ */ function() {
        function p(y) {
          return y >= "a" && y <= "z" || y >= "A" && y <= "Z";
        }
        function b(y) {
          return y >= "0" && y <= "9";
        }
        function _(y) {
          return b(y) || y >= "a" && y <= "f" || y >= "A" && y <= "F";
        }
        return {
          isAlpha: p,
          isDigit: b,
          isHexDigit: _
        };
      }(), e = /* @__PURE__ */ function() {
        var p = {
          encode: function(T) {
            return unescape(encodeURIComponent(T));
          },
          numBytes: function(T) {
            return T <= 127 ? 1 : 194 <= T && T <= 223 ? 2 : 224 <= T && T <= 239 ? 3 : 240 <= T && T <= 244 ? 4 : 0;
          },
          isValidFollowingCharCode: function(T) {
            return 128 <= T && T <= 191;
          }
        };
        function b(T) {
          var v = "", E = p.encode(T), R, L;
          for (L = 0; L < E.length; L += 1)
            R = E.charCodeAt(L), v += "%" + (R < 16 ? "0" : "") + R.toString(16).toUpperCase();
          return v;
        }
        function _(T, v) {
          return T.charAt(v) === "%" && t.isHexDigit(T.charAt(v + 1)) && t.isHexDigit(T.charAt(v + 2));
        }
        function y(T, v) {
          return parseInt(T.substr(v, 2), 16);
        }
        function m(T) {
          if (!_(T, 0))
            return !1;
          var v = y(T, 1), E = p.numBytes(v);
          if (E === 0)
            return !1;
          for (var R = 1; R < E; R += 1)
            if (!_(T, 3 * R) || !p.isValidFollowingCharCode(y(T, 3 * R + 1)))
              return !1;
          return !0;
        }
        function g(T, v) {
          var E = T.charAt(v);
          if (!_(T, v))
            return E;
          var R = y(T, v + 1), L = p.numBytes(R);
          if (L === 0)
            return E;
          for (var A = 1; A < L; A += 1)
            if (!_(T, v + 3 * A) || !p.isValidFollowingCharCode(y(T, v + 3 * A + 1)))
              return E;
          return T.substr(v, 3 * L);
        }
        return {
          encodeCharacter: b,
          isPctEncoded: m,
          pctCharAt: g
        };
      }(), n = /* @__PURE__ */ function() {
        function p(y) {
          return t.isAlpha(y) || t.isDigit(y) || y === "_" || e.isPctEncoded(y);
        }
        function b(y) {
          return t.isAlpha(y) || t.isDigit(y) || y === "-" || y === "." || y === "_" || y === "~";
        }
        function _(y) {
          return y === ":" || y === "/" || y === "?" || y === "#" || y === "[" || y === "]" || y === "@" || y === "!" || y === "$" || y === "&" || y === "(" || y === ")" || y === "*" || y === "+" || y === "," || y === ";" || y === "=" || y === "'";
        }
        return {
          isVarchar: p,
          isUnreserved: b,
          isReserved: _
        };
      }(), i = /* @__PURE__ */ function() {
        function p(m, g) {
          var T = "", v, E = "";
          for ((typeof m == "number" || typeof m == "boolean") && (m = m.toString()), v = 0; v < m.length; v += E.length)
            E = m.charAt(v), T += n.isUnreserved(E) || g && n.isReserved(E) ? E : e.encodeCharacter(E);
          return T;
        }
        function b(m) {
          return p(m, !0);
        }
        function _(m, g) {
          var T = e.pctCharAt(m, g);
          return T.length > 1 || n.isReserved(T) || n.isUnreserved(T) ? T : e.encodeCharacter(T);
        }
        function y(m) {
          var g = "", T, v = "";
          for (T = 0; T < m.length; T += v.length)
            v = e.pctCharAt(m, T), v.length > 1 ? g += v : g += n.isReserved(v) || n.isUnreserved(v) ? v : e.encodeCharacter(v);
          return g;
        }
        return {
          encode: p,
          encodePassReserved: b,
          encodeLiteral: y,
          encodeLiteralCharacter: _
        };
      }(), c = function() {
        var p = {};
        function b(_) {
          p[_] = {
            symbol: _,
            separator: _ === "?" ? "&" : _ === "" || _ === "+" || _ === "#" ? "," : _,
            named: _ === ";" || _ === "&" || _ === "?",
            ifEmpty: _ === "&" || _ === "?" ? "=" : "",
            first: _ === "+" ? "" : _,
            encode: _ === "+" || _ === "#" ? i.encodePassReserved : i.encode,
            toString: function() {
              return this.symbol;
            }
          };
        }
        return b(""), b("+"), b("#"), b("."), b("/"), b(";"), b("?"), b("&"), {
          valueOf: function(_) {
            return p[_] ? p[_] : "=,!@|".indexOf(_) >= 0 ? null : p[""];
          }
        };
      }();
      function s(p) {
        var b;
        if (p == null)
          return !1;
        if (a.isArray(p))
          return p.length > 0;
        if (typeof p == "string" || typeof p == "number" || typeof p == "boolean")
          return !0;
        for (b in p)
          if (p.hasOwnProperty(b) && s(p[b]))
            return !0;
        return !1;
      }
      var d = function() {
        function p(b) {
          this.literal = i.encodeLiteral(b);
        }
        return p.prototype.expand = function() {
          return this.literal;
        }, p.prototype.toString = p.prototype.expand, p;
      }(), l = /* @__PURE__ */ function() {
        function p(_) {
          var y, m = [], g = null, T = null, v = null, E, R = "";
          function L() {
            var w = _.substring(T, E);
            if (w.length === 0)
              throw new o({ expressionText: _, message: "a varname must be specified", position: E });
            g = { varname: w, exploded: !1, maxLength: null }, T = null;
          }
          function A() {
            if (v === E)
              throw new o({ expressionText: _, message: "after a ':' you have to specify the length", position: E });
            g.maxLength = parseInt(_.substring(v, E), 10), v = null;
          }
          for (y = function(w) {
            var S = c.valueOf(w);
            if (S === null)
              throw new o({ expressionText: _, message: "illegal use of reserved operator", position: E, operator: w });
            return S;
          }(_.charAt(0)), E = y.symbol.length, T = E; E < _.length; E += R.length) {
            if (R = e.pctCharAt(_, E), T !== null) {
              if (R === ".") {
                if (T === E)
                  throw new o({ expressionText: _, message: "a varname MUST NOT start with a dot", position: E });
                continue;
              }
              if (n.isVarchar(R))
                continue;
              L();
            }
            if (v !== null) {
              if (E === v && R === "0")
                throw new o({ expressionText: _, message: "A :prefix must not start with digit 0", position: E });
              if (t.isDigit(R)) {
                if (E - v >= 4)
                  throw new o({ expressionText: _, message: "A :prefix must have max 4 digits", position: E });
                continue;
              }
              A();
            }
            if (R === ":") {
              if (g.maxLength !== null)
                throw new o({ expressionText: _, message: "only one :maxLength is allowed per varspec", position: E });
              if (g.exploded)
                throw new o({ expressionText: _, message: "an exploeded varspec MUST NOT be varspeced", position: E });
              v = E + 1;
              continue;
            }
            if (R === "*") {
              if (g === null)
                throw new o({ expressionText: _, message: "exploded without varspec", position: E });
              if (g.exploded)
                throw new o({ expressionText: _, message: "exploded twice", position: E });
              if (g.maxLength)
                throw new o({ expressionText: _, message: "an explode (*) MUST NOT follow to a prefix", position: E });
              g.exploded = !0;
              continue;
            }
            if (R === ",") {
              m.push(g), g = null, T = E + 1;
              continue;
            }
            throw new o({ expressionText: _, message: "illegal character", character: R, position: E });
          }
          return T !== null && L(), v !== null && A(), m.push(g), new f(_, y, m);
        }
        function b(_) {
          var y, m, g = [], T = null, v = 0;
          for (y = 0; y < _.length; y += 1) {
            if (m = _.charAt(y), v !== null) {
              if (m === "}")
                throw new o({ templateText: _, message: "unopened brace closed", position: y });
              m === "{" && (v < y && g.push(new d(_.substring(v, y))), v = null, T = y);
              continue;
            }
            if (T !== null) {
              if (m === "{")
                throw new o({ templateText: _, message: "brace already opened", position: y });
              if (m === "}") {
                if (T + 1 === y)
                  throw new o({ templateText: _, message: "empty braces", position: T });
                try {
                  g.push(p(_.substring(T + 1, y)));
                } catch (E) {
                  throw E.prototype === o.prototype ? new o({ templateText: _, message: E.options.message, position: T + E.options.position, details: E.options }) : E;
                }
                T = null, v = y + 1;
              }
              continue;
            }
            throw new Error("reached unreachable code");
          }
          if (T !== null)
            throw new o({ templateText: _, message: "unclosed brace", position: T });
          return v < _.length && g.push(new d(_.substr(v))), new h(_, g);
        }
        return b;
      }(), f = function() {
        function p(R) {
          return JSON && JSON.stringify ? JSON.stringify(R) : R;
        }
        function b(R) {
          if (!s(R))
            return !0;
          if (a.isString(R))
            return R === "";
          if (a.isNumber(R) || a.isBoolean(R))
            return !1;
          if (a.isArray(R))
            return R.length === 0;
          for (var L in R)
            if (R.hasOwnProperty(L))
              return !1;
          return !0;
        }
        function _(R) {
          var L = [], A;
          for (A in R)
            R.hasOwnProperty(A) && L.push({ name: A, value: R[A] });
          return L;
        }
        function y(R, L, A) {
          this.templateText = R, this.operator = L, this.varspecs = A;
        }
        y.prototype.toString = function() {
          return this.templateText;
        };
        function m(R, L, A) {
          var w = "";
          if (A = A.toString(), L.named) {
            if (w += i.encodeLiteral(R.varname), A === "")
              return w += L.ifEmpty, w;
            w += "=";
          }
          return R.maxLength !== null && (A = A.substr(0, R.maxLength)), w += L.encode(A), w;
        }
        function g(R) {
          return s(R.value);
        }
        function T(R, L, A) {
          var w = [], S = "";
          if (L.named) {
            if (S += i.encodeLiteral(R.varname), b(A))
              return S += L.ifEmpty, S;
            S += "=";
          }
          return a.isArray(A) ? (w = A, w = a.filter(w, s), w = a.map(w, L.encode), S += a.join(w, ",")) : (w = _(A), w = a.filter(w, g), w = a.map(w, function(O) {
            return L.encode(O.name) + "," + L.encode(O.value);
          }), S += a.join(w, ",")), S;
        }
        function v(R, L, A) {
          var w = a.isArray(A), S = [];
          return w ? (S = A, S = a.filter(S, s), S = a.map(S, function(O) {
            var x = i.encodeLiteral(R.varname);
            return b(O) ? x += L.ifEmpty : x += "=" + L.encode(O), x;
          })) : (S = _(A), S = a.filter(S, g), S = a.map(S, function(O) {
            var x = i.encodeLiteral(O.name);
            return b(O.value) ? x += L.ifEmpty : x += "=" + L.encode(O.value), x;
          })), a.join(S, L.separator);
        }
        function E(R, L) {
          var A = [], w = "";
          return a.isArray(L) ? (A = L, A = a.filter(A, s), A = a.map(A, R.encode), w += a.join(A, R.separator)) : (A = _(L), A = a.filter(A, function(S) {
            return s(S.value);
          }), A = a.map(A, function(S) {
            return R.encode(S.name) + "=" + R.encode(S.value);
          }), w += a.join(A, R.separator)), w;
        }
        return y.prototype.expand = function(R) {
          var L = [], A, w, S, O = this.operator;
          for (A = 0; A < this.varspecs.length; A += 1)
            if (w = this.varspecs[A], S = R[w.varname], S != null)
              if (w.exploded, a.isArray(S), typeof S == "string" || typeof S == "number" || typeof S == "boolean")
                L.push(m(w, O, S));
              else {
                if (w.maxLength && s(S))
                  throw new Error("Prefix modifiers are not applicable to variables that have composite values. You tried to expand " + this + " with " + p(S));
                w.exploded ? s(S) && (O.named ? L.push(v(w, O, S)) : L.push(E(O, S))) : (O.named || !b(S)) && L.push(T(w, O, S));
              }
          return L.length === 0 ? "" : O.first + a.join(L, O.separator);
        }, y;
      }(), h = function() {
        function p(b, _) {
          this.templateText = b, this.expressions = _, a.deepFreeze(this);
        }
        return p.prototype.toString = function() {
          return this.templateText;
        }, p.prototype.expand = function(b) {
          var _, y = "";
          for (_ = 0; _ < this.expressions.length; _ += 1)
            y += this.expressions[_].expand(b);
          return y;
        }, p.parse = l, p.UriTemplateError = o, p;
      }();
      r(h);
    })(
      function(r) {
        u.exports = r;
      }
    );
  }(_E)), _E.exports;
}
var ED;
function Aoe() {
  if (ED) return k1;
  ED = 1, Object.defineProperty(k1, "__esModule", { value: !0 }), k1.ActorRdfMetadataExtractHydraControls = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e(), o = Soe();
  let a = class oS extends u.ActorRdfMetadataExtract {
    constructor(e) {
      super(e), this.parsedUriTemplateCache = {};
    }
    async test(e) {
      return (0, r.passTestVoid)();
    }
    /**
     * Collect all Hydra page links from the given Hydra properties object.
     * @param pageUrl The page URL in which the Hydra properties are defined.
     * @param hydraProperties The collected Hydra properties.
     * @return The Hydra links
     */
    getLinks(e, n) {
      return Object.fromEntries(oS.LINK_TYPES.map((i) => {
        const c = n[i] || n[`${i}Page`], s = c && c[e];
        return [i, s && s.length > 0 ? [s[0]] : []];
      }));
    }
    /**
     * Parse a URI template, or retrieve it from a cache.
     * @param {string} template A URI template string.
     * @return {} A parsed URI template object.
     */
    parseUriTemplateCached(e) {
      const n = this.parsedUriTemplateCache[e];
      return n || (this.parsedUriTemplateCache[e] = (0, o.parse)(e));
    }
    /**
     * Collect all search forms from the given Hydra properties object.
     * @param hydraProperties The collected Hydra properties.
     * @return The search forms.
     */
    getSearchForms(e) {
      const n = e.search, i = [];
      if (n)
        for (const c in n)
          for (const s of n[c]) {
            const d = (e.template || {})[s] || [];
            if (d.length !== 1)
              throw new Error(`Expected 1 hydra:template for ${s}`);
            const l = d[0], f = this.parseUriTemplateCached(l), h = Object.fromEntries(((e.mapping || {})[s] || []).map((b) => {
              const _ = ((e.variable || {})[b] || [])[0], y = ((e.property || {})[b] || [])[0];
              if (!_)
                throw new Error(`Expected a hydra:variable for ${b}`);
              if (!y)
                throw new Error(`Expected a hydra:property for ${b}`);
              return [y, _];
            })), p = (b) => f.expand(Object.fromEntries(Object.keys(b).map((_) => [h[_], b[_]])));
            i.push({ dataset: c, template: l, mappings: h, getUri: p });
          }
      return { values: i };
    }
    /**
     * Collect all hydra properties from a given metadata stream
     * in a nice convenient nested hash (property / subject / objects).
     * @param {RDF.Stream} metadata
     * @return The collected Hydra properties.
     */
    getHydraProperties(e) {
      return new Promise((n, i) => {
        e.on("error", i);
        const c = {};
        e.on("data", (s) => {
          if (s.predicate.value.startsWith(oS.HYDRA)) {
            const d = s.predicate.value.slice(oS.HYDRA.length), l = c[d] || (c[d] = {});
            (l[s.subject.value] || (l[s.subject.value] = [])).push(s.object.value);
          }
        }), e.on("end", () => n(c));
      });
    }
    async run(e) {
      const n = {}, i = await this.getHydraProperties(e.metadata);
      return Object.assign(n, this.getLinks(e.url, i)), n.searchForms = this.getSearchForms(i), { metadata: n };
    }
  };
  return k1.ActorRdfMetadataExtractHydraControls = a, a.HYDRA = "http://www.w3.org/ns/hydra/core#", a.LINK_TYPES = ["first", "next", "previous", "last"], k1;
}
var OD;
function Eoe() {
  return OD || (OD = 1, function(u) {
    var r = Ho && Ho.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ho && Ho.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Aoe(), u);
  }(Ho)), Ho;
}
var zo = {}, J1 = {}, xD;
function Ooe() {
  if (xD) return J1;
  xD = 1, Object.defineProperty(J1, "__esModule", { value: !0 }), J1.ActorRdfMetadataExtractHydraCount = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    run(t) {
      return new Promise((e, n) => {
        t.metadata.on("error", n), t.metadata.on("data", (i) => {
          this.predicates.includes(i.predicate.value) && e({
            metadata: {
              cardinality: {
                type: "estimate",
                value: Number.parseInt(i.object.value, 10),
                dataset: i.subject.value
              }
            }
          });
        }), t.metadata.on("end", () => {
          e({ metadata: { cardinality: { type: "estimate", value: 0 } } });
        });
      });
    }
  };
  return J1.ActorRdfMetadataExtractHydraCount = o, J1;
}
var ID;
function xoe() {
  return ID || (ID = 1, function(u) {
    var r = zo && zo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zo && zo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ooe(), u);
  }(zo)), zo;
}
var ko = {}, K1 = {}, RD;
function Ioe() {
  if (RD) return K1;
  RD = 1, Object.defineProperty(K1, "__esModule", { value: !0 }), K1.ActorRdfMetadataExtractHydraPagesize = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return new Promise((e, n) => {
        t.metadata.on("error", n), t.metadata.on("data", (i) => {
          this.predicates.includes(i.predicate.value) && e({ metadata: { pageSize: Number.parseInt(i.object.value, 10) } });
        }), t.metadata.on("end", () => {
          e({ metadata: {} });
        });
      });
    }
  };
  return K1.ActorRdfMetadataExtractHydraPagesize = o, K1;
}
var FD;
function Roe() {
  return FD || (FD = 1, function(u) {
    var r = ko && ko.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ko && ko.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ioe(), u);
  }(ko)), ko;
}
var Xo = {}, W1 = {}, ND;
function Foe() {
  if (ND) return W1;
  ND = 1, Object.defineProperty(W1, "__esModule", { value: !0 }), W1.ActorRdfMetadataExtractRequestTime = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      return { metadata: { requestTime: t.requestTime } };
    }
  };
  return W1.ActorRdfMetadataExtractRequestTime = o, W1;
}
var PD;
function Noe() {
  return PD || (PD = 1, function(u) {
    var r = Xo && Xo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xo && Xo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Foe(), u);
  }(Xo)), Xo;
}
var Jo = {}, Y1 = {}, DD;
function Poe() {
  if (DD) return Y1;
  DD = 1, Object.defineProperty(Y1, "__esModule", { value: !0 }), Y1.ActorRdfMetadataExtractAllowHttpMethods = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      var n, i;
      const e = {};
      return (n = t.headers) != null && n.get("allow") && (e.allowHttpMethods = (i = t.headers.get("allow")) == null ? void 0 : i.split(/, */u)), { metadata: e };
    }
  };
  return Y1.ActorRdfMetadataExtractAllowHttpMethods = o, Y1;
}
var LD;
function Doe() {
  return LD || (LD = 1, function(u) {
    var r = Jo && Jo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Jo && Jo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Poe(), u);
  }(Jo)), Jo;
}
var Ko = {}, Z1 = {}, jD;
function Loe() {
  if (jD) return Z1;
  jD = 1, Object.defineProperty(Z1, "__esModule", { value: !0 }), Z1.ActorRdfMetadataExtractPutAccepted = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      var n, i;
      const e = {};
      return (n = t.headers) != null && n.get("accept-put") && (e.putAccepted = (i = t.headers.get("accept-put")) == null ? void 0 : i.split(/, */u)), { metadata: e };
    }
  };
  return Z1.ActorRdfMetadataExtractPutAccepted = o, Z1;
}
var MD;
function joe() {
  return MD || (MD = 1, function(u) {
    var r = Ko && Ko.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ko && Ko.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Loe(), u);
  }(Ko)), Ko;
}
var Wo = {}, eb = {}, CD;
function Moe() {
  if (CD) return eb;
  CD = 1, Object.defineProperty(eb, "__esModule", { value: !0 }), eb.ActorRdfMetadataExtractPatchSparqlUpdate = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfMetadataExtract {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTestVoid)();
    }
    async run(t) {
      var n, i, c, s;
      const e = {};
      return (((i = (n = t.headers) == null ? void 0 : n.get("accept-patch")) == null ? void 0 : i.includes("application/sparql-update")) ?? ((s = (c = t.headers) == null ? void 0 : c.get("ms-author-via")) == null ? void 0 : s.includes("SPARQL"))) && (e.patchSparqlUpdate = !0), { metadata: e };
    }
  };
  return eb.ActorRdfMetadataExtractPatchSparqlUpdate = o, eb;
}
var qD;
function Coe() {
  return qD || (qD = 1, function(u) {
    var r = Wo && Wo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Wo && Wo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Moe(), u);
  }(Wo)), Wo;
}
var Yo = {}, tb = {}, BD;
function qoe() {
  if (BD) return tb;
  BD = 1, Object.defineProperty(tb, "__esModule", { value: !0 }), tb.ActorRdfMetadataExtractSparqlService = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e(), o = Tr();
  let a = class extends u.ActorRdfMetadataExtract {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      return new Promise((n, i) => {
        e.metadata.on("error", i);
        const c = /* @__PURE__ */ new Set([e.url]), s = {}, d = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set();
        e.metadata.on("data", (h) => {
          if (h.predicate.value === "http://rdfs.org/ns/void#subset" && h.object.value === e.url)
            c.add(h.subject.value);
          else if (h.subject.value === s.defaultDataset || h.subject.termType === "BlankNode" || c.has(h.subject.value))
            switch (h.predicate.value) {
              case "http://www.w3.org/ns/sparql-service-description#endpoint":
                s.sparqlService = h.object.termType === "Literal" ? (0, o.resolve)(h.object.value, e.url) : h.object.value, this.inferHttpsEndpoint && e.url.startsWith("https") && !h.object.value.startsWith("https") && (s.sparqlService = s.sparqlService.replace(/^http:/u, "https:"));
                break;
              case "http://www.w3.org/ns/sparql-service-description#defaultDataset":
                s.defaultDataset = h.object.value;
                break;
              case "http://www.w3.org/ns/sparql-service-description#defaultGraph":
                s.defaultGraph = h.object.value;
                break;
              case "http://www.w3.org/ns/sparql-service-description#inputFormat":
                d.add(h.object.value);
                break;
              case "http://www.w3.org/ns/sparql-service-description#resultFormat":
                l.add(h.object.value);
                break;
              case "http://www.w3.org/ns/sparql-service-description#supportedLanguage":
                f.add(h.object.value);
                break;
              case "http://www.w3.org/ns/sparql-service-description#feature":
                h.object.value === "http://www.w3.org/ns/sparql-service-description#UnionDefaultGraph" ? s.unionDefaultGraph = !0 : h.object.value === "http://www.w3.org/ns/sparql-service-description#BasicFederatedQuery" && (s.basicFederatedQuery = !0);
                break;
            }
        }), e.metadata.on("end", () => {
          n({ metadata: {
            ...s,
            ...d.size > 0 ? { inputFormats: [...d.values()] } : {},
            ...l.size > 0 ? { resultFormats: [...l.values()] } : {},
            ...f.size > 0 ? { supportedLanguages: [...f.values()] } : {}
          } });
        });
      });
    }
  };
  return tb.ActorRdfMetadataExtractSparqlService = a, tb;
}
var $D;
function Boe() {
  return $D || ($D = 1, function(u) {
    var r = Yo && Yo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Yo && Yo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qoe(), u);
  }(Yo)), Yo;
}
var Zo = {}, rb = {}, gE = {}, UD;
function VW() {
  return UD || (UD = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.VOID_CLASS_PARTITION = u.VOID_PROPERTY_PARTITION = u.VOID_DISTINCT_SUBJECTS = u.VOID_DISTINCT_OBJECTS = u.VOID_URI_REGEX_PATTERN = u.VOID_URI_SPACE = u.VOID_VOCABULARY = u.VOID_PROPERTY = u.VOID_CLASS = u.VOID_ENTITIES = u.VOID_TRIPLES = u.VOID_CLASSES = u.VOID_DATASET = u.VOID = u.SD_GRAPH = u.SD_FEATURE = u.SD_UNION_DEFAULT_GRAPH = u.SD_DEFAULT_GRAPH = u.SD_DEFAULT_DATASET = u.SD = u.RDF_TYPE = void 0, u.RDF_TYPE = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", u.SD = "http://www.w3.org/ns/sparql-service-description#", u.SD_DEFAULT_DATASET = `${u.SD}defaultDataset`, u.SD_DEFAULT_GRAPH = `${u.SD}defaultGraph`, u.SD_UNION_DEFAULT_GRAPH = `${u.SD}UnionDefaultGraph`, u.SD_FEATURE = `${u.SD}feature`, u.SD_GRAPH = `${u.SD}Graph`, u.VOID = "http://rdfs.org/ns/void#", u.VOID_DATASET = `${u.VOID}Dataset`, u.VOID_CLASSES = `${u.VOID}classes`, u.VOID_TRIPLES = `${u.VOID}triples`, u.VOID_ENTITIES = `${u.VOID}entities`, u.VOID_CLASS = `${u.VOID}class`, u.VOID_PROPERTY = `${u.VOID}property`, u.VOID_VOCABULARY = `${u.VOID}vocabulary`, u.VOID_URI_SPACE = `${u.VOID}uriSpace`, u.VOID_URI_REGEX_PATTERN = `${u.VOID}uriRegexPattern`, u.VOID_DISTINCT_OBJECTS = `${u.VOID}distinctSubjects`, u.VOID_DISTINCT_SUBJECTS = `${u.VOID}distinctObjects`, u.VOID_PROPERTY_PARTITION = `${u.VOID}propertyPartition`, u.VOID_CLASS_PARTITION = `${u.VOID}classPartition`;
  }(gE)), gE;
}
var ur = {}, VD;
function $oe() {
  if (VD) return ur;
  VD = 1, Object.defineProperty(ur, "__esModule", { value: !0 }), ur.getClassPartitionEntities = ur.getPredicateTriples = ur.getPredicateSubjects = ur.getPredicateObjects = ur.getDistinctSubjects = ur.getDistinctObjects = ur.estimatePatternCardinalityRaw = ur.matchPatternVocabularies = ur.matchPatternResourceUris = ur.estimatePatternCardinality = void 0;
  const u = /* @__PURE__ */ VW();
  function r(l, f) {
    const h = { type: "exact", value: 0 };
    if (a(l, f) && o(l, f)) {
      const p = t(l, f);
      p > 0 && (h.value = p, h.type = "estimate");
    }
    return h;
  }
  ur.estimatePatternCardinality = r;
  function o(l, f) {
    return !l.uriRegexPattern || f.subject.termType !== "NamedNode" || l.uriRegexPattern.test(f.subject.value) || f.object.termType !== "NamedNode" || l.uriRegexPattern.test(f.object.value);
  }
  ur.matchPatternResourceUris = o;
  function a(l, f) {
    return l.vocabularies !== void 0 && f.predicate.termType === "NamedNode" ? l.vocabularies.some((h) => f.predicate.value.startsWith(h)) : !0;
  }
  ur.matchPatternVocabularies = a;
  function t(l, f) {
    if (f.subject.termType === "Variable" && f.predicate.termType === "NamedNode" && f.predicate.value === u.RDF_TYPE && (f.object.termType === "NamedNode" || f.object.termType === "BlankNode"))
      return d(l, f.object);
    if (f.subject.termType === "Variable" && f.predicate.termType === "Variable" && f.object.termType === "Variable")
      return l.triples;
    if ((f.subject.termType === "NamedNode" || f.subject.termType === "BlankNode") && f.predicate.termType === "Variable" && (f.object.termType === "Variable" || f.object.termType === "Literal")) {
      const h = n(l);
      if (h > 0)
        return l.triples / h;
    }
    if (f.subject.termType === "Variable" && f.predicate.termType === "NamedNode" && (f.object.termType === "Variable" || f.object.termType === "Literal"))
      return s(l, f.predicate);
    if (f.subject.termType === "Variable" && f.predicate.termType === "Variable" && (f.object.termType === "NamedNode" || f.object.termType === "BlankNode" || f.object.termType === "Literal")) {
      const h = e(l);
      if (h > 0)
        return l.triples / h;
    }
    if ((f.subject.termType === "NamedNode" || f.subject.termType === "BlankNode") && f.predicate.termType === "NamedNode" && (f.object.termType === "Variable" || f.object.termType === "Literal")) {
      const h = s(l, f.predicate), p = c(l, f.predicate);
      return p > 0 ? h / p : h;
    }
    if ((f.subject.termType === "NamedNode" || f.subject.termType === "BlankNode") && f.predicate.termType === "Variable" && (f.object.termType === "NamedNode" || f.object.termType === "BlankNode")) {
      const h = n(l), p = e(l);
      if (h > 0 && p > 0)
        return l.triples / (h * p);
    }
    if (f.subject.termType === "Variable" && f.predicate.termType === "NamedNode" && (f.object.termType === "NamedNode" || f.object.termType === "BlankNode")) {
      const h = s(l, f.predicate), p = i(l, f.predicate);
      return p > 0 ? h / p : h;
    }
    if ((f.subject.termType === "NamedNode" || f.subject.termType === "BlankNode") && f.predicate.termType === "NamedNode" && (f.object.termType === "NamedNode" || f.object.termType === "BlankNode")) {
      const h = s(l, f.predicate), p = c(l, f.predicate), b = i(l, f.predicate);
      return p > 0 && b > 0 ? h / (p * b) : h;
    }
    return l.triples;
  }
  ur.estimatePatternCardinalityRaw = t;
  function e(l) {
    return l.distinctObjects ?? l.entities ?? l.triples;
  }
  ur.getDistinctObjects = e;
  function n(l) {
    return l.distinctSubjects ?? l.entities ?? l.triples;
  }
  ur.getDistinctSubjects = n;
  function i(l, f) {
    if (l.propertyPartitions) {
      const h = l.propertyPartitions[f.value];
      return (h == null ? void 0 : h.distinctObjects) ?? (h == null ? void 0 : h.triples) ?? 0;
    }
    return l.triples;
  }
  ur.getPredicateObjects = i;
  function c(l, f) {
    if (l.propertyPartitions) {
      const h = l.propertyPartitions[f.value];
      return (h == null ? void 0 : h.distinctSubjects) ?? (h == null ? void 0 : h.triples) ?? 0;
    }
    return l.triples;
  }
  ur.getPredicateSubjects = c;
  function s(l, f) {
    var h;
    return l.propertyPartitions ? ((h = l.propertyPartitions[f.value]) == null ? void 0 : h.triples) ?? 0 : l.triples;
  }
  ur.getPredicateTriples = s;
  function d(l, f) {
    var h;
    return l.classPartitions ? ((h = l.classPartitions[f.value]) == null ? void 0 : h.entities) ?? 0 : l.entities !== void 0 && l.classes ? l.entities / l.classes : l.triples;
  }
  return ur.getClassPartitionEntities = d, ur;
}
var QD;
function Uoe() {
  if (QD) return rb;
  QD = 1, Object.defineProperty(rb, "__esModule", { value: !0 }), rb.ActorRdfMetadataExtractVoid = void 0;
  const u = /* @__PURE__ */ Sa(), r = /* @__PURE__ */ _e(), o = ft(), a = /* @__PURE__ */ VW(), t = /* @__PURE__ */ $oe();
  let e = class extends u.ActorRdfMetadataExtract {
    constructor(i) {
      super(i);
    }
    async test(i) {
      return (0, r.passTestVoid)();
    }
    async run(i) {
      return new Promise((c, s) => {
        const d = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), f = {}, h = {}, p = {}, b = {}, _ = {}, y = {}, m = {}, g = {}, T = {}, v = {}, E = {};
        let R, L, A = !1;
        i.metadata.on("error", s).on("data", (w) => {
          switch (w.predicate.value) {
            case a.RDF_TYPE:
              (w.object.value === a.SD_GRAPH || w.object.value === a.VOID_DATASET) && d.add(w.subject.value);
              break;
            case a.VOID_TRIPLES:
              f[w.subject.value] = Number.parseInt(w.object.value, 10);
              break;
            case a.VOID_ENTITIES:
              h[w.subject.value] = Number.parseInt(w.object.value, 10);
              break;
            case a.VOID_CLASSES:
              b[w.subject.value] = Number.parseInt(w.object.value, 10);
              break;
            case a.VOID_CLASS:
              E[w.subject.value] = w.object.value;
              break;
            case a.VOID_PROPERTY:
              T[w.subject.value] = w.object.value;
              break;
            case a.VOID_DISTINCT_OBJECTS:
              _[w.subject.value] = Number.parseInt(w.object.value, 10);
              break;
            case a.VOID_DISTINCT_SUBJECTS:
              y[w.subject.value] = Number.parseInt(w.object.value, 10);
              break;
            case a.VOID_VOCABULARY:
              p[w.subject.value] ? p[w.subject.value].push(w.object.value) : p[w.subject.value] = [w.object.value];
              break;
            case a.VOID_URI_SPACE:
              m[w.subject.value] || (m[w.subject.value] = new RegExp(`^${w.object.value}`, "u"));
              break;
            case a.VOID_URI_REGEX_PATTERN:
              m[w.subject.value] = new RegExp(w.object.value, "u");
              break;
            case a.VOID_PROPERTY_PARTITION:
              l.add(w.object.value), g[w.subject.value] ? g[w.subject.value].push(w.object.value) : g[w.subject.value] = [w.object.value];
              break;
            case a.VOID_CLASS_PARTITION:
              l.add(w.object.value), v[w.subject.value] ? v[w.subject.value].push(w.object.value) : v[w.subject.value] = [w.object.value];
              break;
            case a.SD_DEFAULT_DATASET:
              R = w.object.value;
              break;
            case a.SD_DEFAULT_GRAPH:
              L = w.object.value;
              break;
            case a.SD_FEATURE:
              w.object.value === a.SD_UNION_DEFAULT_GRAPH && (A = !0);
              break;
          }
        }).on("end", () => {
          var x;
          const w = [], S = (F) => {
            const j = {};
            for (const q of g[F]) {
              const Q = T[q];
              Q && (j[Q] = {
                distinctObjects: _[q],
                distinctSubjects: y[q],
                triples: f[q]
              });
            }
            return j;
          }, O = (F) => {
            const j = {};
            for (const q of v[F]) {
              const Q = E[q];
              Q && (j[Q] = {
                entities: h[q],
                propertyPartitions: g[q] ? S(q) : void 0
              });
            }
            return j;
          };
          R && l.add(R), A && L && l.add(L), R && L && p[R] && (p[L] = [
            ...p[L] ?? [],
            ...p[R]
          ]);
          for (const F of l)
            d.delete(F);
          for (const F of d)
            if (f[F]) {
              const j = {
                entities: h[F],
                identifier: F,
                classes: b[F] ?? ((x = v[F]) == null ? void 0 : x.length) ?? 0,
                classPartitions: v[F] ? O(F) : void 0,
                distinctObjects: _[F],
                distinctSubjects: y[F],
                propertyPartitions: g[F] ? S(F) : void 0,
                triples: f[F],
                uriRegexPattern: m[F],
                vocabularies: p[F]
              };
              w.push({
                uri: F,
                source: i.url,
                getCardinality: (q) => {
                  if (q.type === o.Algebra.types.PATTERN)
                    return { ...(0, t.estimatePatternCardinality)(j, q), dataset: F };
                }
              });
            }
          c({ metadata: w.length > 0 ? { datasets: w } : {} });
        });
      });
    }
  };
  return rb.ActorRdfMetadataExtractVoid = e, rb;
}
var HD;
function Voe() {
  return HD || (HD = 1, function(u) {
    var r = Zo && Zo.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zo && Zo.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Uoe(), u);
  }(Zo)), Zo;
}
var es = {}, nb = {}, ts = {}, ib = {}, GD;
function Qoe() {
  if (GD) return ib;
  GD = 1, Object.defineProperty(ib, "__esModule", { value: !0 }), ib.ActorRdfParse = void 0;
  const u = /* @__PURE__ */ ph();
  let r = class extends u.ActorAbstractMediaTyped {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(a) {
      super(a);
    }
  };
  return ib.ActorRdfParse = r, ib;
}
var ab = {}, zD;
function Hoe() {
  if (zD) return ab;
  zD = 1, Object.defineProperty(ab, "__esModule", { value: !0 }), ab.ActorRdfParseFixedMediaTypes = void 0;
  const u = /* @__PURE__ */ ph(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorAbstractMediaTypedFixed {
    /* eslint-disable max-len */
    /**
     * TODO: rm this (and eslint-disable) once we remove the abstract media typed actor
     * @param args -
     *   \ @defaultNested {<cbrp:components/ActorRdfParse.jsonld#ActorRdfParse_default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}} busFailMessage
     */
    constructor(t) {
      super(t);
    }
    /* eslint-enable max-len */
    async testHandleChecked(t) {
      return (0, r.passTestVoid)();
    }
  };
  return ab.ActorRdfParseFixedMediaTypes = o, ab;
}
var kD;
function yh() {
  return kD || (kD = 1, function(u) {
    var r = ts && ts.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ts && ts.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Qoe(), u), o(/* @__PURE__ */ Hoe(), u);
  }(ts)), ts;
}
var Goe = qi();
const ub = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", ob = "http://www.w3.org/2001/XMLSchema#", f6 = "http://www.w3.org/2000/10/swap/", qr = {
  xsd: {
    decimal: `${ob}decimal`,
    boolean: `${ob}boolean`,
    double: `${ob}double`,
    integer: `${ob}integer`,
    string: `${ob}string`
  },
  rdf: {
    type: `${ub}type`,
    nil: `${ub}nil`,
    first: `${ub}first`,
    rest: `${ub}rest`,
    langString: `${ub}langString`
  },
  owl: {
    sameAs: "http://www.w3.org/2002/07/owl#sameAs"
  },
  r: {
    forSome: `${f6}reify#forSome`,
    forAll: `${f6}reify#forAll`
  },
  log: {
    implies: `${f6}log#implies`,
    isImpliedBy: `${f6}log#isImpliedBy`
  }
}, { xsd: h6 } = qr, zoe = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g, XD = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  n: `
`,
  r: "\r",
  t: "	",
  f: "\f",
  b: "\b",
  _: "_",
  "~": "~",
  ".": ".",
  "-": "-",
  "!": "!",
  $: "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "*": "*",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%"
}, koe = /[\x00-\x20<>\\"\{\}\|\^\`]/, Xoe = {
  _iri: !0,
  _unescapedIri: !0,
  _simpleQuotedString: !0,
  _langcode: !0,
  _blank: !0,
  _newline: !0,
  _comment: !0,
  _whitespace: !0,
  _endOfFile: !0
}, Joe = /$0^/;
class P8 {
  constructor(r) {
    if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/, this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/, this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i, this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/, this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/, this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/, this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/, this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/, this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/, this._keyword = /^@[a-z]+(?=[\s#<:])/i, this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i, this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/, this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/, this._comment = /#([^\n\r]*)/, this._whitespace = /^[ \t]+/, this._endOfFile = /^(?:#[^\n\r]*)?$/, r = r || {}, this._isImpliedBy = r.isImpliedBy, this._lineMode = !!r.lineMode) {
      this._n3Mode = !1;
      for (const o in this)
        !(o in Xoe) && this[o] instanceof RegExp && (this[o] = Joe);
    } else
      this._n3Mode = r.n3 !== !1;
    this.comments = !!r.comments, this._literalClosingPos = 0;
  }
  // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
  _tokenizeToEnd(r, o) {
    let a = this._input, t = a.length;
    for (; ; ) {
      let i, c;
      for (; i = this._newline.exec(a); )
        this.comments && (c = this._comment.exec(i[0])) && e("comment", c[1], "", this._line, i[0].length), a = a.substr(i[0].length, a.length), t = a.length, this._line++;
      if (!i && (i = this._whitespace.exec(a)) && (a = a.substr(i[0].length, a.length)), this._endOfFile.test(a))
        return o && (this.comments && (c = this._comment.exec(a)) && e("comment", c[1], "", this._line, a.length), a = null, e("eof", "", "", this._line, 0)), this._input = a;
      const s = this._line, d = a[0];
      let l = "", f = "", h = "", p = null, b = 0, _ = !1;
      switch (d) {
        case "^":
          if (a.length < 3)
            break;
          if (a[1] === "^") {
            if (this._previousMarker = "^^", a = a.substr(2), a[0] !== "<") {
              _ = !0;
              break;
            }
          } else {
            this._n3Mode && (b = 1, l = "^");
            break;
          }
        // Fall through in case the type is an IRI
        case "<":
          if (p = this._unescapedIri.exec(a))
            l = "IRI", f = p[1];
          else if (p = this._iri.exec(a)) {
            if (f = this._unescape(p[1]), f === null || koe.test(f))
              return n(this);
            l = "IRI";
          } else a.length > 1 && a[1] === "<" ? (l = "<<", b = 2) : this._n3Mode && a.length > 1 && a[1] === "=" && (b = 2, this._isImpliedBy ? (l = "abbreviation", f = "<") : (l = "inverse", f = ">"));
          break;
        case ">":
          a.length > 1 && a[1] === ">" && (l = ">>", b = 2);
          break;
        case "_":
          ((p = this._blank.exec(a)) || o && (p = this._blank.exec(`${a} `))) && (l = "blank", h = "_", f = p[1]);
          break;
        case '"':
          if (p = this._simpleQuotedString.exec(a))
            f = p[1];
          else if ({ value: f, matchLength: b } = this._parseLiteral(a), f === null)
            return n(this);
          (p !== null || b !== 0) && (l = "literal", this._literalClosingPos = 0);
          break;
        case "'":
          if (!this._lineMode) {
            if (p = this._simpleApostropheString.exec(a))
              f = p[1];
            else if ({ value: f, matchLength: b } = this._parseLiteral(a), f === null)
              return n(this);
            (p !== null || b !== 0) && (l = "literal", this._literalClosingPos = 0);
          }
          break;
        case "?":
          this._n3Mode && (p = this._variable.exec(a)) && (l = "var", f = p[0]);
          break;
        case "@":
          this._previousMarker === "literal" && (p = this._langcode.exec(a)) ? (l = "langcode", f = p[1]) : (p = this._keyword.exec(a)) && (l = p[0]);
          break;
        case ".":
          if (a.length === 1 ? o : a[1] < "0" || a[1] > "9") {
            l = ".", b = 1;
            break;
          }
        // Fall through to numerical case (could be a decimal dot)
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "+":
        case "-":
          (p = this._number.exec(a) || o && (p = this._number.exec(`${a} `))) && (l = "literal", f = p[0], h = typeof p[1] == "string" ? h6.double : typeof p[2] == "string" ? h6.decimal : h6.integer);
          break;
        case "B":
        case "b":
        case "p":
        case "P":
        case "G":
        case "g":
          (p = this._sparqlKeyword.exec(a)) ? l = p[0].toUpperCase() : _ = !0;
          break;
        case "f":
        case "t":
          (p = this._boolean.exec(a)) ? (l = "literal", f = p[0], h = h6.boolean) : _ = !0;
          break;
        case "a":
          (p = this._shortPredicates.exec(a)) ? (l = "abbreviation", f = "a") : _ = !0;
          break;
        case "=":
          this._n3Mode && a.length > 1 && (l = "abbreviation", a[1] !== ">" ? (b = 1, f = "=") : (b = 2, f = ">"));
          break;
        case "!":
          if (!this._n3Mode)
            break;
        case ",":
        case ";":
        case "[":
        case "]":
        case "(":
        case ")":
        case "}":
          this._lineMode || (b = 1, l = d);
          break;
        case "{":
          !this._lineMode && a.length >= 2 && (a[1] === "|" ? (l = "{|", b = 2) : (l = d, b = 1));
          break;
        case "|":
          a.length >= 2 && a[1] === "}" && (l = "|}", b = 2);
          break;
        default:
          _ = !0;
      }
      if (_ && ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (p = this._prefix.exec(a)) ? (l = "prefix", f = p[1] || "") : ((p = this._prefixed.exec(a)) || o && (p = this._prefixed.exec(`${a} `))) && (l = "prefixed", h = p[1] || "", f = this._unescape(p[2]))), this._previousMarker === "^^")
        switch (l) {
          case "prefixed":
            l = "type";
            break;
          case "IRI":
            l = "typeIRI";
            break;
          default:
            l = "";
        }
      if (!l)
        return o || !/^'''|^"""/.test(a) && /\n|\r/.test(a) ? n(this) : this._input = a;
      const y = b || p[0].length, m = e(l, f, h, s, y);
      this.previousToken = m, this._previousMarker = l, a = a.substr(y, a.length);
    }
    function e(i, c, s, d, l) {
      const f = a ? t - a.length : t, h = f + l, p = { type: i, value: c, prefix: s, line: d, start: f, end: h };
      return r(null, p), p;
    }
    function n(i) {
      r(i._syntaxError(/^\S*/.exec(a)[0]));
    }
  }
  // ### `_unescape` replaces N3 escape codes by their corresponding characters
  _unescape(r) {
    let o = !1;
    const a = r.replace(zoe, (t, e, n, i) => {
      if (typeof e == "string")
        return String.fromCharCode(Number.parseInt(e, 16));
      if (typeof n == "string") {
        let c = Number.parseInt(n, 16);
        return c <= 65535 ? String.fromCharCode(Number.parseInt(n, 16)) : String.fromCharCode(55296 + ((c -= 65536) >> 10), 56320 + (c & 1023));
      }
      return i in XD ? XD[i] : (o = !0, "");
    });
    return o ? null : a;
  }
  // ### `_parseLiteral` parses a literal into an unescaped value
  _parseLiteral(r) {
    if (r.length >= 3) {
      const o = r.match(/^(?:"""|"|'''|'|)/)[0], a = o.length;
      let t = Math.max(this._literalClosingPos, a);
      for (; (t = r.indexOf(o, t)) > 0; ) {
        let e = 0;
        for (; r[t - e - 1] === "\\"; )
          e++;
        if (e % 2 === 0) {
          const n = r.substring(a, t), i = n.split(/\r\n|\r|\n/).length - 1, c = t + a;
          if (a === 1 && i !== 0 || a === 3 && this._lineMode)
            break;
          return this._line += i, { value: this._unescape(n), matchLength: c };
        }
        t++;
      }
      this._literalClosingPos = r.length - a + 1;
    }
    return { value: "", matchLength: 0 };
  }
  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError(r) {
    this._input = null;
    const o = new Error(`Unexpected "${r}" on line ${this._line}.`);
    return o.context = {
      token: void 0,
      line: this._line,
      previousToken: this.previousToken
    }, o;
  }
  // ### Strips off any starting UTF BOM mark.
  _readStartingBom(r) {
    return r.startsWith("\uFEFF") ? r.substr(1) : r;
  }
  // ## Public methods
  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize(r, o) {
    if (this._line = 1, typeof r == "string")
      if (this._input = this._readStartingBom(r), typeof o == "function")
        queueMicrotask(() => this._tokenizeToEnd(o, !0));
      else {
        const a = [];
        let t;
        if (this._tokenizeToEnd((e, n) => e ? t = e : a.push(n), !0), t) throw t;
        return a;
      }
    else
      this._pendingBuffer = null, typeof r.setEncoding == "function" && r.setEncoding("utf8"), r.on("data", (a) => {
        this._input !== null && a.length !== 0 && (this._pendingBuffer && (a = Goe.Buffer.concat([this._pendingBuffer, a]), this._pendingBuffer = null), a[a.length - 1] & 128 ? this._pendingBuffer = a : (typeof this._input > "u" ? this._input = this._readStartingBom(typeof a == "string" ? a : a.toString()) : this._input += a, this._tokenizeToEnd(o, !1)));
      }), r.on("end", () => {
        typeof this._input == "string" && this._tokenizeToEnd(o, !0);
      }), r.on("error", o);
  }
}
const { rdf: Koe, xsd: Hf } = qr;
let _h, Woe = 0;
const vi = {
  namedNode: HW,
  blankNode: GW,
  variable: kW,
  literal: zW,
  defaultGraph: Yoe,
  quad: dx,
  triple: dx,
  fromTerm: vT,
  fromQuad: XW
};
class Rn {
  constructor(r) {
    this.id = r;
  }
  // ### The value of this term
  get value() {
    return this.id;
  }
  // ### Returns whether this object represents the same term as the other
  equals(r) {
    return r instanceof Rn ? this.id === r.id : !!r && this.termType === r.termType && this.value === r.value;
  }
  // ### Implement hashCode for Immutable.js, since we implement `equals`
  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
  hashCode() {
    return 0;
  }
  // ### Returns a plain object representation of this term
  toJSON() {
    return {
      termType: this.termType,
      value: this.value
    };
  }
}
let t4 = class extends Rn {
  // ### The term type of this term
  get termType() {
    return "NamedNode";
  }
}, $0 = class QW extends Rn {
  // ### The term type of this term
  get termType() {
    return "Literal";
  }
  // ### The text value of this literal
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }
  // ### The language of this literal
  get language() {
    const r = this.id;
    let o = r.lastIndexOf('"') + 1;
    return o < r.length && r[o++] === "@" ? r.substr(o).toLowerCase() : "";
  }
  // ### The datatype IRI of this literal
  get datatype() {
    return new t4(this.datatypeString);
  }
  // ### The datatype string of this literal
  get datatypeString() {
    const r = this.id, o = r.lastIndexOf('"') + 1, a = o < r.length ? r[o] : "";
    return a === "^" ? r.substr(o + 2) : (
      // If "@" follows, return rdf:langString; xsd:string otherwise
      a !== "@" ? Hf.string : Koe.langString
    );
  }
  // ### Returns whether this object represents the same term as the other
  equals(r) {
    return r instanceof QW ? this.id === r.id : !!r && !!r.datatype && this.termType === r.termType && this.value === r.value && this.language === r.language && this.datatype.value === r.datatype.value;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value,
      language: this.language,
      datatype: { termType: "NamedNode", value: this.datatypeString }
    };
  }
}, D8 = class extends Rn {
  constructor(r) {
    super(`_:${r}`);
  }
  // ### The term type of this term
  get termType() {
    return "BlankNode";
  }
  // ### The name of this blank node
  get value() {
    return this.id.substr(2);
  }
}, L8 = class extends Rn {
  constructor(r) {
    super(`?${r}`);
  }
  // ### The term type of this term
  get termType() {
    return "Variable";
  }
  // ### The name of this variable
  get value() {
    return this.id.substr(1);
  }
}, j8 = class extends Rn {
  constructor() {
    return super(""), _h || this;
  }
  // ### The term type of this term
  get termType() {
    return "DefaultGraph";
  }
  // ### Returns whether this object represents the same term as the other
  equals(r) {
    return this === r || !!r && this.termType === r.termType;
  }
};
_h = new j8();
function kf(u, r, o) {
  if (r = r || vi, !u)
    return r.defaultGraph();
  switch (u[0]) {
    case "?":
      return r.variable(u.substr(1));
    case "_":
      return r.blankNode(u.substr(2));
    case '"':
      if (r === vi)
        return new $0(u);
      if (u[u.length - 1] === '"')
        return r.literal(u.substr(1, u.length - 2));
      const a = u.lastIndexOf('"', u.length - 1);
      return r.literal(
        u.substr(1, a - 1),
        u[a + 1] === "@" ? u.substr(a + 2) : r.namedNode(u.substr(a + 3))
      );
    case "[":
      u = JSON.parse(u);
      break;
    default:
      if (!o || !Array.isArray(u))
        return r.namedNode(u);
  }
  return r.quad(
    kf(u[0], r, !0),
    kf(u[1], r, !0),
    kf(u[2], r, !0),
    u[3] && kf(u[3], r, !0)
  );
}
function Qa(u, r) {
  if (typeof u == "string")
    return u;
  if (u instanceof Rn && u.termType !== "Quad")
    return u.id;
  if (!u)
    return _h.id;
  switch (u.termType) {
    case "NamedNode":
      return u.value;
    case "BlankNode":
      return `_:${u.value}`;
    case "Variable":
      return `?${u.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return `"${u.value}"${u.language ? `@${u.language}` : u.datatype && u.datatype.value !== Hf.string ? `^^${u.datatype.value}` : ""}`;
    case "Quad":
      const o = [
        Qa(u.subject, !0),
        Qa(u.predicate, !0),
        Qa(u.object, !0)
      ];
      return u.graph && u.graph.termType !== "DefaultGraph" && o.push(Qa(u.graph, !0)), r ? o : JSON.stringify(o);
    default:
      throw new Error(`Unexpected termType: ${u.termType}`);
  }
}
let Z0 = class extends Rn {
  constructor(r, o, a, t) {
    super(""), this._subject = r, this._predicate = o, this._object = a, this._graph = t || _h;
  }
  // ### The term type of this term
  get termType() {
    return "Quad";
  }
  get subject() {
    return this._subject;
  }
  get predicate() {
    return this._predicate;
  }
  get object() {
    return this._object;
  }
  get graph() {
    return this._graph;
  }
  // ### Returns a plain object representation of this quad
  toJSON() {
    return {
      termType: this.termType,
      subject: this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object: this._object.toJSON(),
      graph: this._graph.toJSON()
    };
  }
  // ### Returns whether this object represents the same quad as the other
  equals(r) {
    return !!r && this._subject.equals(r.subject) && this._predicate.equals(r.predicate) && this._object.equals(r.object) && this._graph.equals(r.graph);
  }
};
function HW(u) {
  return new t4(u);
}
function GW(u) {
  return new D8(u || `n3-${Woe++}`);
}
function zW(u, r) {
  if (typeof r == "string")
    return new $0(`"${u}"@${r.toLowerCase()}`);
  let o = r ? r.value : "";
  return o === "" && (typeof u == "boolean" ? o = Hf.boolean : typeof u == "number" && (Number.isFinite(u) ? o = Number.isInteger(u) ? Hf.integer : Hf.double : (o = Hf.double, Number.isNaN(u) || (u = u > 0 ? "INF" : "-INF")))), o === "" || o === Hf.string ? new $0(`"${u}"`) : new $0(`"${u}"^^${o}`);
}
function kW(u) {
  return new L8(u);
}
function Yoe() {
  return _h;
}
function dx(u, r, o, a) {
  return new Z0(u, r, o, a);
}
function vT(u) {
  if (u instanceof Rn)
    return u;
  switch (u.termType) {
    case "NamedNode":
      return HW(u.value);
    case "BlankNode":
      return GW(u.value);
    case "Variable":
      return kW(u.value);
    case "DefaultGraph":
      return _h;
    case "Literal":
      return zW(u.value, u.language || u.datatype);
    case "Quad":
      return XW(u);
    default:
      throw new Error(`Unexpected termType: ${u.termType}`);
  }
}
function XW(u) {
  if (u instanceof Z0)
    return u;
  if (u.termType !== "Quad")
    throw new Error(`Unexpected termType: ${u.termType}`);
  return dx(vT(u.subject), vT(u.predicate), vT(u.object), vT(u.graph));
}
let JD = 0;
class r4 {
  constructor(r) {
    this._contextStack = [], this._graph = null, r = r || {}, this._setBase(r.baseIRI), r.factory && JW(this, r.factory);
    const o = typeof r.format == "string" ? r.format.match(/\w*$/)[0].toLowerCase() : "", a = /turtle/.test(o), t = /trig/.test(o), e = /triple/.test(o), n = /quad/.test(o), i = this._n3Mode = /n3/.test(o), c = e || n;
    (this._supportsNamedGraphs = !(a || i)) || (this._readPredicateOrNamedGraph = this._readPredicate), this._supportsQuads = !(a || t || e || i), this._isImpliedBy = r.isImpliedBy, this._supportsRDFStar = o === "" || /star|\*$/.test(o), c && (this._resolveRelativeIRI = (s) => null), this._blankNodePrefix = typeof r.blankNodePrefix != "string" ? "" : r.blankNodePrefix.replace(/^(?!_:)/, "_:"), this._lexer = r.lexer || new P8({ lineMode: c, n3: i, isImpliedBy: this._isImpliedBy }), this._explicitQuantifiers = !!r.explicitQuantifiers;
  }
  // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification
  static _resetBlankNodePrefix() {
    JD = 0;
  }
  // ## Private methods
  // ### `_setBase` sets the base IRI to resolve relative IRIs
  _setBase(r) {
    if (!r)
      this._base = "", this._basePath = "";
    else {
      const o = r.indexOf("#");
      o >= 0 && (r = r.substr(0, o)), this._base = r, this._basePath = r.indexOf("/") < 0 ? r : r.replace(/[^\/?]*(?:\?.*)?$/, ""), r = r.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i), this._baseRoot = r[0], this._baseScheme = r[1];
    }
  }
  // ### `_saveContext` stores the current parsing context
  // when entering a new scope (list, blank node, formula)
  _saveContext(r, o, a, t, e) {
    const n = this._n3Mode;
    this._contextStack.push({
      type: r,
      subject: a,
      predicate: t,
      object: e,
      graph: o,
      inverse: n ? this._inversePredicate : !1,
      blankPrefix: n ? this._prefixes._ : "",
      quantified: n ? this._quantified : null
    }), n && (this._inversePredicate = !1, this._prefixes._ = this._graph ? `${this._graph.value}.` : ".", this._quantified = Object.create(this._quantified));
  }
  // ### `_restoreContext` restores the parent context
  // when leaving a scope (list, blank node, formula)
  _restoreContext(r, o) {
    const a = this._contextStack.pop();
    if (!a || a.type !== r)
      return this._error(`Unexpected ${o.type}`, o);
    this._subject = a.subject, this._predicate = a.predicate, this._object = a.object, this._graph = a.graph, this._n3Mode && (this._inversePredicate = a.inverse, this._prefixes._ = a.blankPrefix, this._quantified = a.quantified);
  }
  // ### `_readInTopContext` reads a token when in the top context
  _readInTopContext(r) {
    switch (r.type) {
      // If an EOF token arrives in the top context, signal that we're done
      case "eof":
        return this._graph !== null ? this._error("Unclosed graph", r) : (delete this._prefixes._, this._callback(null, null, this._prefixes));
      // It could be a prefix declaration
      case "PREFIX":
        this._sparqlStyle = !0;
      case "@prefix":
        return this._readPrefix;
      // It could be a base declaration
      case "BASE":
        this._sparqlStyle = !0;
      case "@base":
        return this._readBaseIRI;
      // It could be a graph
      case "{":
        if (this._supportsNamedGraphs)
          return this._graph = "", this._subject = null, this._readSubject;
      case "GRAPH":
        if (this._supportsNamedGraphs)
          return this._readNamedGraphLabel;
      // Otherwise, the next token must be a subject
      default:
        return this._readSubject(r);
    }
  }
  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
  _readEntity(r, o) {
    let a;
    switch (r.type) {
      // Read a relative or absolute IRI
      case "IRI":
      case "typeIRI":
        const t = this._resolveIRI(r.value);
        if (t === null)
          return this._error("Invalid IRI", r);
        a = this._factory.namedNode(t);
        break;
      // Read a prefixed name
      case "type":
      case "prefixed":
        const e = this._prefixes[r.prefix];
        if (e === void 0)
          return this._error(`Undefined prefix "${r.prefix}:"`, r);
        a = this._factory.namedNode(e + r.value);
        break;
      // Read a blank node
      case "blank":
        a = this._factory.blankNode(this._prefixes[r.prefix] + r.value);
        break;
      // Read a variable
      case "var":
        a = this._factory.variable(r.value.substr(1));
        break;
      // Everything else is not an entity
      default:
        return this._error(`Expected entity but got ${r.type}`, r);
    }
    return !o && this._n3Mode && a.id in this._quantified && (a = this._quantified[a.id]), a;
  }
  // ### `_readSubject` reads a quad's subject
  _readSubject(r) {
    switch (this._predicate = null, r.type) {
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject = this._factory.blankNode(),
          null,
          null
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this.RDF_NIL, null, null), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._graph = this._factory.blankNode(),
          null,
          null
        ), this._readSubject) : this._error("Unexpected graph", r);
      case "}":
        return this._readPunctuation(r);
      case "@forSome":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORSOME, this._quantifier = "blankNode", this._readQuantifierList) : this._error('Unexpected "@forSome"', r);
      case "@forAll":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORALL, this._quantifier = "variable", this._readQuantifierList) : this._error('Unexpected "@forAll"', r);
      case "literal":
        if (!this._n3Mode)
          return this._error("Unexpected literal", r);
        if (r.prefix.length === 0)
          return this._literalValue = r.value, this._completeSubjectLiteral;
        this._subject = this._factory.literal(r.value, this._factory.namedNode(r.prefix));
        break;
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF-star syntax", r);
      default:
        if ((this._subject = this._readEntity(r)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._readPredicateOrNamedGraph);
    }
    return this._readPredicateOrNamedGraph;
  }
  // ### `_readPredicate` reads a quad's predicate
  _readPredicate(r) {
    const o = r.type;
    switch (o) {
      case "inverse":
        this._inversePredicate = !0;
      case "abbreviation":
        this._predicate = this.ABBREVIATIONS[r.value];
        break;
      case ".":
      case "]":
      case "}":
        return this._predicate === null ? this._error(`Unexpected ${o}`, r) : (this._subject = null, o === "]" ? this._readBlankNodeTail(r) : this._readPunctuation(r));
      case ";":
        return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", r);
      case "[":
        if (this._n3Mode)
          return this._saveContext(
            "blank",
            this._graph,
            this._subject,
            this._subject = this._factory.blankNode(),
            null
          ), this._readBlankNodeHead;
      case "blank":
        if (!this._n3Mode)
          return this._error("Disallowed blank node as predicate", r);
      default:
        if ((this._predicate = this._readEntity(r)) === void 0)
          return;
    }
    return this._readObject;
  }
  // ### `_readObject` reads a quad's object
  _readObject(r) {
    switch (r.type) {
      case "literal":
        if (r.prefix.length === 0)
          return this._literalValue = r.value, this._readDataTypeOrLang;
        this._object = this._factory.literal(r.value, this._factory.namedNode(r.prefix));
        break;
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject,
          this._predicate,
          this._subject = this._factory.blankNode()
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._factory.blankNode()
        ), this._readSubject) : this._error("Unexpected graph", r);
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF-star syntax", r);
      default:
        if ((this._object = this._readEntity(r)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._getContextEndReader());
    }
    return this._getContextEndReader();
  }
  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
  _readPredicateOrNamedGraph(r) {
    return r.type === "{" ? this._readGraph(r) : this._readPredicate(r);
  }
  // ### `_readGraph` reads a graph
  _readGraph(r) {
    return r.type !== "{" ? this._error(`Expected graph but got ${r.type}`, r) : (this._graph = this._subject, this._subject = null, this._readSubject);
  }
  // ### `_readBlankNodeHead` reads the head of a blank node
  _readBlankNodeHead(r) {
    return r.type === "]" ? (this._subject = null, this._readBlankNodeTail(r)) : (this._predicate = null, this._readPredicate(r));
  }
  // ### `_readBlankNodeTail` reads the end of a blank node
  _readBlankNodeTail(r) {
    if (r.type !== "]")
      return this._readBlankNodePunctuation(r);
    this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph);
    const o = this._predicate === null;
    return this._restoreContext("blank", r), this._object !== null ? this._getContextEndReader() : this._predicate !== null ? this._readObject : o ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
  }
  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
  _readPredicateAfterBlank(r) {
    switch (r.type) {
      case ".":
      case "}":
        return this._subject = null, this._readPunctuation(r);
      default:
        return this._readPredicate(r);
    }
  }
  // ### `_readListItem` reads items from a list
  _readListItem(r) {
    let o = null, a = null, t = this._readListItem;
    const e = this._subject, n = this._contextStack, i = n[n.length - 1];
    switch (r.type) {
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          a = this._factory.blankNode(),
          this.RDF_FIRST,
          this._subject = o = this._factory.blankNode()
        ), t = this._readBlankNodeHead;
        break;
      case "(":
        this._saveContext(
          "list",
          this._graph,
          a = this._factory.blankNode(),
          this.RDF_FIRST,
          this.RDF_NIL
        ), this._subject = null;
        break;
      case ")":
        if (this._restoreContext("list", r), n.length !== 0 && n[n.length - 1].type === "list" && this._emit(this._subject, this._predicate, this._object, this._graph), this._predicate === null) {
          if (t = this._readPredicate, this._subject === this.RDF_NIL)
            return t;
        } else if (t = this._getContextEndReader(), this._object === this.RDF_NIL)
          return t;
        a = this.RDF_NIL;
        break;
      case "literal":
        r.prefix.length === 0 ? (this._literalValue = r.value, t = this._readListItemDataTypeOrLang) : (o = this._factory.literal(r.value, this._factory.namedNode(r.prefix)), t = this._getContextEndReader());
        break;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._factory.blankNode()
        ), this._readSubject) : this._error("Unexpected graph", r);
      default:
        if ((o = this._readEntity(r)) === void 0)
          return;
    }
    if (a === null && (this._subject = a = this._factory.blankNode()), e === null ? i.predicate === null ? i.subject = a : i.object = a : this._emit(e, this.RDF_REST, a, this._graph), o !== null) {
      if (this._n3Mode && (r.type === "IRI" || r.type === "prefixed"))
        return this._saveContext("item", this._graph, a, this.RDF_FIRST, o), this._subject = o, this._predicate = null, this._getPathReader(this._readListItem);
      this._emit(a, this.RDF_FIRST, o, this._graph);
    }
    return t;
  }
  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
  _readDataTypeOrLang(r) {
    return this._completeObjectLiteral(r, !1);
  }
  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
  _readListItemDataTypeOrLang(r) {
    return this._completeObjectLiteral(r, !0);
  }
  // ### `_completeLiteral` completes a literal with an optional datatype or language
  _completeLiteral(r) {
    let o = this._factory.literal(this._literalValue);
    switch (r.type) {
      // Create a datatyped literal
      case "type":
      case "typeIRI":
        const a = this._readEntity(r);
        if (a === void 0) return;
        o = this._factory.literal(this._literalValue, a), r = null;
        break;
      // Create a language-tagged string
      case "langcode":
        o = this._factory.literal(this._literalValue, r.value), r = null;
        break;
    }
    return { token: r, literal: o };
  }
  // Completes a literal in subject position
  _completeSubjectLiteral(r) {
    return this._subject = this._completeLiteral(r).literal, this._readPredicateOrNamedGraph;
  }
  // Completes a literal in object position
  _completeObjectLiteral(r, o) {
    const a = this._completeLiteral(r);
    if (a)
      return this._object = a.literal, o && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph), a.token === null ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(), this._readCallback(a.token));
  }
  // ### `_readFormulaTail` reads the end of a formula
  _readFormulaTail(r) {
    return r.type !== "}" ? this._readPunctuation(r) : (this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph), this._restoreContext("formula", r), this._object === null ? this._readPredicate : this._getContextEndReader());
  }
  // ### `_readPunctuation` reads punctuation between quads or quad parts
  _readPunctuation(r) {
    let o, a = this._graph;
    const t = this._subject, e = this._inversePredicate;
    switch (r.type) {
      // A closing brace ends a graph
      case "}":
        if (this._graph === null)
          return this._error("Unexpected graph closing", r);
        if (this._n3Mode)
          return this._readFormulaTail(r);
        this._graph = null;
      // A dot just ends the statement, without sharing anything with the next
      case ".":
        this._subject = null, o = this._contextStack.length ? this._readSubject : this._readInTopContext, e && (this._inversePredicate = !1);
        break;
      // Semicolon means the subject is shared; predicate and object are different
      case ";":
        o = this._readPredicate;
        break;
      // Comma means both the subject and predicate are shared; the object is different
      case ",":
        o = this._readObject;
        break;
      // {| means that the current triple is annotated with predicate-object pairs.
      case "{|":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF-star syntax", r);
        const n = this._predicate, i = this._object;
        this._subject = this._factory.quad(t, n, i, this.DEFAULTGRAPH), o = this._readPredicate;
        break;
      // |} means that the current quoted triple in annotation syntax is finalized.
      case "|}":
        if (this._subject.termType !== "Quad")
          return this._error("Unexpected asserted triple closing", r);
        this._subject = null, o = this._readPunctuation;
        break;
      default:
        if (this._supportsQuads && this._graph === null && (a = this._readEntity(r)) !== void 0) {
          o = this._readQuadPunctuation;
          break;
        }
        return this._error(`Expected punctuation to follow "${this._object.id}"`, r);
    }
    if (t !== null) {
      const n = this._predicate, i = this._object;
      e ? this._emit(i, n, t, a) : this._emit(t, n, i, a);
    }
    return o;
  }
  // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation(r) {
    let o;
    switch (r.type) {
      // Semicolon means the subject is shared; predicate and object are different
      case ";":
        o = this._readPredicate;
        break;
      // Comma means both the subject and predicate are shared; the object is different
      case ",":
        o = this._readObject;
        break;
      default:
        return this._error(`Expected punctuation to follow "${this._object.id}"`, r);
    }
    return this._emit(this._subject, this._predicate, this._object, this._graph), o;
  }
  // ### `_readQuadPunctuation` reads punctuation after a quad
  _readQuadPunctuation(r) {
    return r.type !== "." ? this._error("Expected dot to follow quad", r) : this._readInTopContext;
  }
  // ### `_readPrefix` reads the prefix of a prefix declaration
  _readPrefix(r) {
    return r.type !== "prefix" ? this._error("Expected prefix to follow @prefix", r) : (this._prefix = r.value, this._readPrefixIRI);
  }
  // ### `_readPrefixIRI` reads the IRI of a prefix declaration
  _readPrefixIRI(r) {
    if (r.type !== "IRI")
      return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, r);
    const o = this._readEntity(r);
    return this._prefixes[this._prefix] = o.value, this._prefixCallback(this._prefix, o), this._readDeclarationPunctuation;
  }
  // ### `_readBaseIRI` reads the IRI of a base declaration
  _readBaseIRI(r) {
    const o = r.type === "IRI" && this._resolveIRI(r.value);
    return o ? (this._setBase(o), this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", r);
  }
  // ### `_readNamedGraphLabel` reads the label of a named graph
  _readNamedGraphLabel(r) {
    switch (r.type) {
      case "IRI":
      case "blank":
      case "prefixed":
        return this._readSubject(r), this._readGraph;
      case "[":
        return this._readNamedGraphBlankLabel;
      default:
        return this._error("Invalid graph label", r);
    }
  }
  // ### `_readNamedGraphLabel` reads a blank node label of a named graph
  _readNamedGraphBlankLabel(r) {
    return r.type !== "]" ? this._error("Invalid graph label", r) : (this._subject = this._factory.blankNode(), this._readGraph);
  }
  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
  _readDeclarationPunctuation(r) {
    return this._sparqlStyle ? (this._sparqlStyle = !1, this._readInTopContext(r)) : r.type !== "." ? this._error("Expected declaration to end with a dot", r) : this._readInTopContext;
  }
  // Reads a list of quantified symbols from a @forSome or @forAll statement
  _readQuantifierList(r) {
    let o;
    switch (r.type) {
      case "IRI":
      case "prefixed":
        if ((o = this._readEntity(r, !0)) !== void 0)
          break;
      default:
        return this._error(`Unexpected ${r.type}`, r);
    }
    return this._explicitQuantifiers ? (this._subject === null ? this._emit(
      this._graph || this.DEFAULTGRAPH,
      this._predicate,
      this._subject = this._factory.blankNode(),
      this.QUANTIFIERS_GRAPH
    ) : this._emit(
      this._subject,
      this.RDF_REST,
      this._subject = this._factory.blankNode(),
      this.QUANTIFIERS_GRAPH
    ), this._emit(this._subject, this.RDF_FIRST, o, this.QUANTIFIERS_GRAPH)) : this._quantified[o.id] = this._factory[this._quantifier](this._factory.blankNode().value), this._readQuantifierPunctuation;
  }
  // Reads punctuation from a @forSome or @forAll statement
  _readQuantifierPunctuation(r) {
    return r.type === "," ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH), this._subject = null), this._readCallback = this._getContextEndReader(), this._readCallback(r));
  }
  // ### `_getPathReader` reads a potential path and then resumes with the given function
  _getPathReader(r) {
    return this._afterPath = r, this._readPath;
  }
  // ### `_readPath` reads a potential path
  _readPath(r) {
    switch (r.type) {
      // Forward path
      case "!":
        return this._readForwardPath;
      // Backward path
      case "^":
        return this._readBackwardPath;
      // Not a path; resume reading where we left off
      default:
        const o = this._contextStack, a = o.length && o[o.length - 1];
        if (a && a.type === "item") {
          const t = this._subject;
          this._restoreContext("item", r), this._emit(this._subject, this.RDF_FIRST, t, this._graph);
        }
        return this._afterPath(r);
    }
  }
  // ### `_readForwardPath` reads a '!' path
  _readForwardPath(r) {
    let o, a;
    const t = this._factory.blankNode();
    if ((a = this._readEntity(r)) !== void 0)
      return this._predicate === null ? (o = this._subject, this._subject = t) : (o = this._object, this._object = t), this._emit(o, a, t, this._graph), this._readPath;
  }
  // ### `_readBackwardPath` reads a '^' path
  _readBackwardPath(r) {
    const o = this._factory.blankNode();
    let a, t;
    if ((a = this._readEntity(r)) !== void 0)
      return this._predicate === null ? (t = this._subject, this._subject = o) : (t = this._object, this._object = o), this._emit(o, a, t, this._graph), this._readPath;
  }
  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF-star quad or the end of a nested RDF-star triple
  _readRDFStarTailOrGraph(r) {
    return r.type !== ">>" ? this._supportsQuads && this._graph === null && (this._graph = this._readEntity(r)) !== void 0 ? this._readRDFStarTail : this._error(`Expected >> to follow "${this._object.id}"`, r) : this._readRDFStarTail(r);
  }
  // ### `_readRDFStarTail` reads the end of a nested RDF-star triple
  _readRDFStarTail(r) {
    if (r.type !== ">>")
      return this._error(`Expected >> but got ${r.type}`, r);
    const o = this._factory.quad(
      this._subject,
      this._predicate,
      this._object,
      this._graph || this.DEFAULTGRAPH
    );
    return this._restoreContext("<<", r), this._subject === null ? (this._subject = o, this._readPredicate) : (this._object = o, this._getContextEndReader());
  }
  // ### `_getContextEndReader` gets the next reader function at the end of a context
  _getContextEndReader() {
    const r = this._contextStack;
    if (!r.length)
      return this._readPunctuation;
    switch (r[r.length - 1].type) {
      case "blank":
        return this._readBlankNodeTail;
      case "list":
        return this._readListItem;
      case "formula":
        return this._readFormulaTail;
      case "<<":
        return this._readRDFStarTailOrGraph;
    }
  }
  // ### `_emit` sends a quad through the callback
  _emit(r, o, a, t) {
    this._callback(null, this._factory.quad(r, o, a, t || this.DEFAULTGRAPH));
  }
  // ### `_error` emits an error message through the callback
  _error(r, o) {
    const a = new Error(`${r} on line ${o.line}.`);
    a.context = {
      token: o,
      line: o.line,
      previousToken: this._lexer.previousToken
    }, this._callback(a), this._callback = p6;
  }
  // ### `_resolveIRI` resolves an IRI against the base path
  _resolveIRI(r) {
    return /^[a-z][a-z0-9+.-]*:/i.test(r) ? r : this._resolveRelativeIRI(r);
  }
  // ### `_resolveRelativeIRI` resolves an IRI against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative
  _resolveRelativeIRI(r) {
    if (!r.length)
      return this._base;
    switch (r[0]) {
      // Resolve relative fragment IRIs against the base IRI
      case "#":
        return this._base + r;
      // Resolve relative query string IRIs by replacing the query string
      case "?":
        return this._base.replace(/(?:\?.*)?$/, r);
      // Resolve root-relative IRIs at the root of the base IRI
      case "/":
        return (r[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(r);
      // Resolve all other IRIs at the base IRI's path
      default:
        return /^[^/:]*:/.test(r) ? null : this._removeDotSegments(this._basePath + r);
    }
  }
  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
  _removeDotSegments(r) {
    if (!/(^|\/)\.\.?($|[/#?])/.test(r))
      return r;
    const o = r.length;
    let a = "", t = -1, e = -1, n = 0, i = "/";
    for (; t < o; ) {
      switch (i) {
        // The path starts with the first slash after the authority
        case ":":
          if (e < 0 && r[++t] === "/" && r[++t] === "/")
            for (; (e = t + 1) < o && r[e] !== "/"; )
              t = e;
          break;
        // Don't modify a query string or fragment
        case "?":
        case "#":
          t = o;
          break;
        // Handle '/.' or '/..' path segments
        case "/":
          if (r[t + 1] === ".")
            switch (i = r[++t + 1], i) {
              // Remove a '/.' segment
              case "/":
                a += r.substring(n, t - 1), n = t + 1;
                break;
              // Remove a trailing '/.' segment
              case void 0:
              case "?":
              case "#":
                return a + r.substring(n, t) + r.substr(t + 1);
              // Remove a '/..' segment
              case ".":
                if (i = r[++t + 1], i === void 0 || i === "/" || i === "?" || i === "#") {
                  if (a += r.substring(n, t - 2), (n = a.lastIndexOf("/")) >= e && (a = a.substr(0, n)), i !== "/")
                    return `${a}/${r.substr(t + 1)}`;
                  n = t + 1;
                }
            }
      }
      i = r[++t];
    }
    return a + r.substring(n);
  }
  // ## Public methods
  // ### `parse` parses the N3 input and emits each parsed quad through the onQuad callback.
  parse(r, o, a) {
    let t, e, n;
    if (o && (o.onQuad || o.onPrefix || o.onComment) ? (t = o.onQuad, e = o.onPrefix, n = o.onComment) : (t = o, e = a), this._readCallback = this._readInTopContext, this._sparqlStyle = !1, this._prefixes = /* @__PURE__ */ Object.create(null), this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${JD++}_`, this._prefixCallback = e || p6, this._inversePredicate = !1, this._quantified = /* @__PURE__ */ Object.create(null), !t) {
      const c = [];
      let s;
      if (this._callback = (d, l) => {
        d ? s = d : l && c.push(l);
      }, this._lexer.tokenize(r).every((d) => this._readCallback = this._readCallback(d)), s) throw s;
      return c;
    }
    let i = (c, s) => {
      c !== null ? (this._callback(c), this._callback = p6) : this._readCallback && (this._readCallback = this._readCallback(s));
    };
    n && (this._lexer.comments = !0, i = (c, s) => {
      c !== null ? (this._callback(c), this._callback = p6) : this._readCallback && (s.type === "comment" ? n(s.value) : this._readCallback = this._readCallback(s));
    }), this._callback = t, this._lexer.tokenize(r, i);
  }
}
function p6() {
}
function JW(u, r) {
  u._factory = r, u.DEFAULTGRAPH = r.defaultGraph(), u.RDF_FIRST = r.namedNode(qr.rdf.first), u.RDF_REST = r.namedNode(qr.rdf.rest), u.RDF_NIL = r.namedNode(qr.rdf.nil), u.N3_FORALL = r.namedNode(qr.r.forAll), u.N3_FORSOME = r.namedNode(qr.r.forSome), u.ABBREVIATIONS = {
    a: r.namedNode(qr.rdf.type),
    "=": r.namedNode(qr.owl.sameAs),
    ">": r.namedNode(qr.log.implies),
    "<": r.namedNode(qr.log.isImpliedBy)
  }, u.QUANTIFIERS_GRAPH = r.namedNode("urn:n3:quantifiers");
}
JW(r4.prototype, vi);
function Zoe(u) {
  return !!u && u.termType === "NamedNode";
}
function ese(u) {
  return !!u && u.termType === "BlankNode";
}
function tse(u) {
  return !!u && u.termType === "Literal";
}
function rse(u) {
  return !!u && u.termType === "Variable";
}
function nse(u) {
  return !!u && u.termType === "Quad";
}
function WT(u) {
  return !!u && u.termType === "DefaultGraph";
}
function ise(u) {
  return WT(u.graph);
}
function ase(u, r) {
  return KW({ "": u.value || u }, r)("");
}
function KW(u, r) {
  const o = /* @__PURE__ */ Object.create(null);
  for (const t in u)
    a(t, u[t]);
  r = r || vi;
  function a(t, e) {
    if (typeof e == "string") {
      const n = /* @__PURE__ */ Object.create(null);
      o[t] = (i) => n[i] || (n[i] = r.namedNode(e + i));
    } else if (!(t in o))
      throw new Error(`Unknown prefix: ${t}`);
    return o[t];
  }
  return a;
}
const WW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  inDefaultGraph: ise,
  isBlankNode: ese,
  isDefaultGraph: WT,
  isLiteral: tse,
  isNamedNode: Zoe,
  isQuad: nse,
  isVariable: rse,
  prefix: ase,
  prefixes: KW
}, Symbol.toStringTag, { value: "Module" }));
function sS(u) {
  return u.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
}
const use = /^:?[^:?#]*(?:[?#]|$)|^file:|^[^:]*:\/*[^?#]+?\/(?:\.\.?(?:\/|$)|\/)/i, ose = /^(?:(?:[^/?#]{3,}|\.?[^/?#.]\.?)(?:\/[^/?#]{3,}|\.?[^/?#.]\.?)*\/?)?(?:[?#]|$)/, KD = "./", sse = "../", mE = "?", WD = "#";
class xw {
  constructor(r) {
    this.base = r, this._baseLength = 0, this._baseMatcher = null, this._pathReplacements = new Array(r.length + 1);
  }
  static supports(r) {
    return !use.test(r);
  }
  _getBaseMatcher() {
    if (this._baseMatcher)
      return this._baseMatcher;
    if (!xw.supports(this.base))
      return this._baseMatcher = /.^/;
    const r = /^[^:]*:\/*/.exec(this.base)[0], o = ["^", sS(r)], a = [], t = [], e = /[^/?#]*([/?#])/y;
    let n, i = 0, c = 0, s = e.lastIndex = r.length;
    for (; !i && !c && (n = e.exec(this.base)); )
      n[1] === WD ? c = e.lastIndex - 1 : (o.push(sS(n[0]), "(?:"), a.push(")?"), n[1] !== mE ? t.push(s = e.lastIndex) : (i = s = e.lastIndex, c = this.base.indexOf(WD, i), this._pathReplacements[i] = mE));
    for (let d = 0; d < t.length; d++)
      this._pathReplacements[t[d]] = sse.repeat(t.length - d - 1);
    return this._pathReplacements[t[t.length - 1]] = KD, this._baseLength = c > 0 ? c : this.base.length, o.push(
      sS(this.base.substring(s, this._baseLength)),
      i ? "(?:#|$)" : "(?:[?#]|$)"
    ), this._baseMatcher = new RegExp([...o, ...a].join(""));
  }
  toRelative(r) {
    const o = this._getBaseMatcher().exec(r);
    if (!o)
      return r;
    const a = o[0].length;
    if (a === this._baseLength && a === r.length)
      return "";
    const t = this._pathReplacements[a];
    if (t) {
      const e = r.substring(a);
      return t !== mE && !ose.test(e) ? r : t === KD && /^[^?#]/.test(e) ? e : t + e;
    }
    return r.substring(a - 1);
  }
}
const sb = vi.defaultGraph(), { rdf: cse, xsd: v0 } = qr, YD = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/, ZD = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g, dse = {
  "\\": "\\\\",
  '"': '\\"',
  "	": "\\t",
  "\n": "\\n",
  "\r": "\\r",
  "\b": "\\b",
  "\f": "\\f"
};
class cb extends Rn {
  // Pretty-printed nodes are not equal to any other node
  // (e.g., [] does not equal [])
  equals(r) {
    return r === this;
  }
}
class Iw {
  constructor(r, o) {
    if (this._prefixRegex = /$0^/, r && typeof r.write != "function" && (o = r, r = null), o = o || {}, this._lists = o.lists, r)
      this._outputStream = r, this._endStream = o.end === void 0 ? !0 : !!o.end;
    else {
      let a = "";
      this._outputStream = {
        write(t, e, n) {
          a += t, n && n();
        },
        end: (t) => {
          t && t(null, a);
        }
      }, this._endStream = !0;
    }
    this._subject = null, /triple|quad/i.test(o.format) ? (this._lineMode = !0, this._writeQuad = this._writeQuadLine) : (this._lineMode = !1, this._graph = sb, this._prefixIRIs = /* @__PURE__ */ Object.create(null), o.prefixes && this.addPrefixes(o.prefixes), o.baseIRI && (this._baseIri = new xw(o.baseIRI)));
  }
  // ## Private methods
  // ### Whether the current graph is the default graph
  get _inDefaultGraph() {
    return sb.equals(this._graph);
  }
  // ### `_write` writes the argument to the output stream
  _write(r, o) {
    this._outputStream.write(r, "utf8", o);
  }
  // ### `_writeQuad` writes the quad to the output stream
  _writeQuad(r, o, a, t, e) {
    try {
      t.equals(this._graph) || (this._write((this._subject === null ? "" : this._inDefaultGraph ? `.
` : `
}
`) + (sb.equals(t) ? "" : `${this._encodeIriOrBlank(t)} {
`)), this._graph = t, this._subject = null), r.equals(this._subject) ? o.equals(this._predicate) ? this._write(`, ${this._encodeObject(a)}`, e) : this._write(`;
    ${this._encodePredicate(this._predicate = o)} ${this._encodeObject(a)}`, e) : this._write(`${(this._subject === null ? "" : `.
`) + this._encodeSubject(this._subject = r)} ${this._encodePredicate(this._predicate = o)} ${this._encodeObject(a)}`, e);
    } catch (n) {
      e && e(n);
    }
  }
  // ### `_writeQuadLine` writes the quad to the output stream as a single line
  _writeQuadLine(r, o, a, t, e) {
    delete this._prefixMatch, this._write(this.quadToString(r, o, a, t), e);
  }
  // ### `quadToString` serializes a quad as a string
  quadToString(r, o, a, t) {
    return `${this._encodeSubject(r)} ${this._encodeIriOrBlank(o)} ${this._encodeObject(a)}${t && t.value ? ` ${this._encodeIriOrBlank(t)} .
` : ` .
`}`;
  }
  // ### `quadsToString` serializes an array of quads as a string
  quadsToString(r) {
    let o = "";
    for (const a of r)
      o += this.quadToString(a.subject, a.predicate, a.object, a.graph);
    return o;
  }
  // ### `_encodeSubject` represents a subject
  _encodeSubject(r) {
    return r.termType === "Quad" ? this._encodeQuad(r) : this._encodeIriOrBlank(r);
  }
  // ### `_encodeIriOrBlank` represents an IRI or blank node
  _encodeIriOrBlank(r) {
    if (r.termType !== "NamedNode")
      return this._lists && r.value in this._lists && (r = this.list(this._lists[r.value])), "id" in r ? r.id : `_:${r.value}`;
    let o = r.value;
    this._baseIri && (o = this._baseIri.toRelative(o)), YD.test(o) && (o = o.replace(ZD, e7));
    const a = this._prefixRegex.exec(o);
    return a ? a[1] ? this._prefixIRIs[a[1]] + a[2] : o : `<${o}>`;
  }
  // ### `_encodeLiteral` represents a literal
  _encodeLiteral(r) {
    let o = r.value;
    if (YD.test(o) && (o = o.replace(ZD, e7)), r.language)
      return `"${o}"@${r.language}`;
    if (this._lineMode) {
      if (r.datatype.value === v0.string)
        return `"${o}"`;
    } else
      switch (r.datatype.value) {
        case v0.string:
          return `"${o}"`;
        case v0.boolean:
          if (o === "true" || o === "false")
            return o;
          break;
        case v0.integer:
          if (/^[+-]?\d+$/.test(o))
            return o;
          break;
        case v0.decimal:
          if (/^[+-]?\d*\.\d+$/.test(o))
            return o;
          break;
        case v0.double:
          if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(o))
            return o;
          break;
      }
    return `"${o}"^^${this._encodeIriOrBlank(r.datatype)}`;
  }
  // ### `_encodePredicate` represents a predicate
  _encodePredicate(r) {
    return r.value === cse.type ? "a" : this._encodeIriOrBlank(r);
  }
  // ### `_encodeObject` represents an object
  _encodeObject(r) {
    switch (r.termType) {
      case "Quad":
        return this._encodeQuad(r);
      case "Literal":
        return this._encodeLiteral(r);
      default:
        return this._encodeIriOrBlank(r);
    }
  }
  // ### `_encodeQuad` encodes an RDF-star quad
  _encodeQuad({ subject: r, predicate: o, object: a, graph: t }) {
    return `<<${this._encodeSubject(r)} ${this._encodePredicate(o)} ${this._encodeObject(a)}${WT(t) ? "" : ` ${this._encodeIriOrBlank(t)}`}>>`;
  }
  // ### `_blockedWrite` replaces `_write` after the writer has been closed
  _blockedWrite() {
    throw new Error("Cannot write because the writer has been closed.");
  }
  // ### `addQuad` adds the quad to the output stream
  addQuad(r, o, a, t, e) {
    a === void 0 ? this._writeQuad(r.subject, r.predicate, r.object, r.graph, o) : typeof t == "function" ? this._writeQuad(r, o, a, sb, t) : this._writeQuad(r, o, a, t || sb, e);
  }
  // ### `addQuads` adds the quads to the output stream
  addQuads(r) {
    for (let o = 0; o < r.length; o++)
      this.addQuad(r[o]);
  }
  // ### `addPrefix` adds the prefix to the output stream
  addPrefix(r, o, a) {
    const t = {};
    t[r] = o, this.addPrefixes(t, a);
  }
  // ### `addPrefixes` adds the prefixes to the output stream
  addPrefixes(r, o) {
    if (!this._prefixIRIs)
      return o && o();
    let a = !1;
    for (let t in r) {
      let e = r[t];
      typeof e != "string" && (e = e.value), a = !0, this._subject !== null && (this._write(this._inDefaultGraph ? `.
` : `
}
`), this._subject = null, this._graph = ""), this._prefixIRIs[e] = t += ":", this._write(`@prefix ${t} <${e}>.
`);
    }
    if (a) {
      let t = "", e = "";
      for (const n in this._prefixIRIs)
        t += t ? `|${n}` : n, e += (e ? "|" : "") + this._prefixIRIs[n];
      t = sS(t), this._prefixRegex = new RegExp(`^(?:${e})[^/]*$|^(${t})([_a-zA-Z0-9][\\-_a-zA-Z0-9]*)$`);
    }
    this._write(a ? `
` : "", o);
  }
  // ### `blank` creates a blank node with the given content
  blank(r, o) {
    let a = r, t, e;
    switch (r === void 0 ? a = [] : r.termType ? a = [{ predicate: r, object: o }] : "length" in r || (a = [r]), e = a.length) {
      // Generate an empty blank node
      case 0:
        return new cb("[]");
      // Generate a non-nested one-triple blank node
      case 1:
        if (t = a[0], !(t.object instanceof cb))
          return new cb(`[ ${this._encodePredicate(t.predicate)} ${this._encodeObject(t.object)} ]`);
      // Generate a multi-triple or nested blank node
      default:
        let n = "[";
        for (let i = 0; i < e; i++)
          t = a[i], t.predicate.equals(r) ? n += `, ${this._encodeObject(t.object)}` : (n += `${(i ? `;
  ` : `
  `) + this._encodePredicate(t.predicate)} ${this._encodeObject(t.object)}`, r = t.predicate);
        return new cb(`${n}
]`);
    }
  }
  // ### `list` creates a list node with the given content
  list(r) {
    const o = r && r.length || 0, a = new Array(o);
    for (let t = 0; t < o; t++)
      a[t] = this._encodeObject(r[t]);
    return new cb(`(${a.join(" ")})`);
  }
  // ### `end` signals the end of the output stream
  end(r) {
    this._subject !== null && (this._write(this._inDefaultGraph ? `.
` : `
}
`), this._subject = null), this._write = this._blockedWrite;
    let o = r && ((a, t) => {
      o = null, r(a, t);
    });
    if (this._endStream)
      try {
        return this._outputStream.end(o);
      } catch {
      }
    o && o();
  }
}
function e7(u) {
  let r = dse[u];
  return r === void 0 && (u.length === 1 ? (r = u.charCodeAt(0).toString(16), r = "\\u0000".substr(0, 6 - r.length) + r) : (r = ((u.charCodeAt(0) - 55296) * 1024 + u.charCodeAt(1) + 9216).toString(16), r = "\\U00000000".substr(0, 10 - r.length) + r)), r;
}
var n4 = Bt();
const vE = Symbol("iter");
function NT(u, r, o = 4) {
  if (o === 0)
    return Object.assign(u, r);
  for (const a in r)
    u[a] = NT(u[a] || /* @__PURE__ */ Object.create(null), r[a], o - 1);
  return u;
}
function YW(u, r, o = 4) {
  let a = !1;
  for (const t in u)
    if (t in r) {
      const e = o === 0 ? null : YW(u[t], r[t], o - 1);
      if (e !== !1)
        a = a || /* @__PURE__ */ Object.create(null), a[t] = e;
      else if (o === 3)
        return !1;
    }
  return a;
}
function ZW(u, r, o = 4) {
  let a = !1;
  for (const t in u)
    if (!(t in r))
      a = a || /* @__PURE__ */ Object.create(null), a[t] = o === 0 ? null : NT({}, u[t], o - 1);
    else if (o !== 0) {
      const e = ZW(u[t], r[t], o - 1);
      if (e !== !1)
        a = a || /* @__PURE__ */ Object.create(null), a[t] = e;
      else if (o === 3)
        return !1;
    }
  return a;
}
class M8 {
  constructor(r = {}) {
    this._id = 1, this._ids = /* @__PURE__ */ Object.create(null), this._ids[""] = 1, this._entities = /* @__PURE__ */ Object.create(null), this._entities[1] = "", this._blankNodeIndex = 0, this._factory = r.factory || vi;
  }
  _termFromId(r) {
    if (r[0] === ".") {
      const o = this._entities, a = r.split(".");
      return this._factory.quad(
        this._termFromId(o[a[1]]),
        this._termFromId(o[a[2]]),
        this._termFromId(o[a[3]]),
        a[4] && this._termFromId(o[a[4]])
      );
    }
    return kf(r, this._factory);
  }
  _termToNumericId(r) {
    if (r.termType === "Quad") {
      const o = this._termToNumericId(r.subject), a = this._termToNumericId(r.predicate), t = this._termToNumericId(r.object);
      let e;
      return o && a && t && (WT(r.graph) || (e = this._termToNumericId(r.graph))) && this._ids[e ? `.${o}.${a}.${t}.${e}` : `.${o}.${a}.${t}`];
    }
    return this._ids[Qa(r)];
  }
  _termToNewNumericId(r) {
    const o = r && r.termType === "Quad" ? `.${this._termToNewNumericId(r.subject)}.${this._termToNewNumericId(r.predicate)}.${this._termToNewNumericId(r.object)}${WT(r.graph) ? "" : `.${this._termToNewNumericId(r.graph)}`}` : Qa(r);
    return this._ids[o] || (this._ids[this._entities[++this._id] = o] = this._id);
  }
  createBlankNode(r) {
    let o, a;
    if (r)
      for (o = r = `_:${r}`, a = 1; this._ids[o]; )
        o = r + a++;
    else
      do
        o = `_:b${this._blankNodeIndex++}`;
      while (this._ids[o]);
    return this._ids[o] = ++this._id, this._entities[this._id] = o, this._factory.blankNode(o.substr(2));
  }
}
class Gr {
  constructor(r, o) {
    this._size = 0, this._graphs = /* @__PURE__ */ Object.create(null), !o && r && !r[0] && typeof r.match != "function" && (o = r, r = null), o = o || {}, this._factory = o.factory || vi, this._entityIndex = o.entityIndex || new M8({ factory: this._factory }), this._entities = this._entityIndex._entities, this._termFromId = this._entityIndex._termFromId.bind(this._entityIndex), this._termToNumericId = this._entityIndex._termToNumericId.bind(this._entityIndex), this._termToNewNumericId = this._entityIndex._termToNewNumericId.bind(this._entityIndex), r && this.addAll(r);
  }
  // ## Public properties
  // ### `size` returns the number of quads in the store
  get size() {
    let r = this._size;
    if (r !== null)
      return r;
    r = 0;
    const o = this._graphs;
    let a, t;
    for (const e in o)
      for (const n in a = o[e].subjects)
        for (const i in t = a[n])
          r += Object.keys(t[i]).length;
    return this._size = r;
  }
  // ## Private methods
  // ### `_addToIndex` adds a quad to a three-layered index.
  // Returns if the index has changed, if the entry did not already exist.
  _addToIndex(r, o, a, t) {
    const e = r[o] || (r[o] = {}), n = e[a] || (e[a] = {}), i = t in n;
    return i || (n[t] = null), !i;
  }
  // ### `_removeFromIndex` removes a quad from a three-layered index
  _removeFromIndex(r, o, a, t) {
    const e = r[o], n = e[a];
    delete n[t];
    for (const i in n) return;
    delete e[a];
    for (const i in e) return;
    delete r[o];
  }
  // ### `_findInIndex` finds a set of quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  // `name0`, `name1`, and `name2` are the names of the keys at each level,
  // used when reconstructing the resulting quad
  // (for instance: _subject_, _predicate_, and _object_).
  // Finally, `graphId` will be the graph of the created quads.
  *_findInIndex(r, o, a, t, e, n, i, c) {
    let s, d, l;
    const f = this._entities, h = this._termFromId(f[c]), p = { subject: null, predicate: null, object: null };
    o && ((s = r, r = {})[o] = s[o]);
    for (const b in r)
      if (d = r[b]) {
        p[e] = this._termFromId(f[b]), a && ((s = d, d = {})[a] = s[a]);
        for (const _ in d)
          if (l = d[_]) {
            p[n] = this._termFromId(f[_]);
            const y = t ? t in l ? [t] : [] : Object.keys(l);
            for (let m = 0; m < y.length; m++)
              p[i] = this._termFromId(f[y[m]]), yield this._factory.quad(p.subject, p.predicate, p.object, h);
          }
      }
  }
  // ### `_loop` executes the callback on all keys of index 0
  _loop(r, o) {
    for (const a in r)
      o(a);
  }
  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0
  _loopByKey0(r, o, a) {
    let t, e;
    if (t = r[o])
      for (e in t)
        a(e);
  }
  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0
  _loopByKey1(r, o, a) {
    let t, e;
    for (t in r)
      e = r[t], e[o] && a(t);
  }
  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2
  _loopBy2Keys(r, o, a, t) {
    let e, n, i;
    if ((e = r[o]) && (n = e[a]))
      for (i in n)
        t(i);
  }
  // ### `_countInIndex` counts matching quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  _countInIndex(r, o, a, t) {
    let e = 0, n, i, c;
    o && ((n = r, r = {})[o] = n[o]);
    for (const s in r)
      if (i = r[s]) {
        a && ((n = i, i = {})[a] = n[a]);
        for (const d in i)
          (c = i[d]) && (t ? t in c && e++ : e += Object.keys(c).length);
      }
    return e;
  }
  // ### `_getGraphs` returns an array with the given graph,
  // or all graphs if the argument is null or undefined.
  _getGraphs(r) {
    return r = r === "" ? 1 : r && (this._termToNumericId(r) || -1), typeof r != "number" ? this._graphs : { [r]: this._graphs[r] };
  }
  // ### `_uniqueEntities` returns a function that accepts an entity ID
  // and passes the corresponding entity to callback if it hasn't occurred before.
  _uniqueEntities(r) {
    const o = /* @__PURE__ */ Object.create(null);
    return (a) => {
      a in o || (o[a] = !0, r(this._termFromId(this._entities[a], this._factory)));
    };
  }
  // ## Public methods
  // ### `add` adds the specified quad to the dataset.
  // Returns the dataset instance it was called on.
  // Existing quads, as defined in Quad.equals, will be ignored.
  add(r) {
    return this.addQuad(r), this;
  }
  // ### `addQuad` adds a new quad to the store.
  // Returns if the quad index has changed, if the quad did not already exist.
  addQuad(r, o, a, t) {
    o || (t = r.graph, a = r.object, o = r.predicate, r = r.subject), t = t ? this._termToNewNumericId(t) : 1;
    let e = this._graphs[t];
    return e || (e = this._graphs[t] = { subjects: {}, predicates: {}, objects: {} }, Object.freeze(e)), r = this._termToNewNumericId(r), o = this._termToNewNumericId(o), a = this._termToNewNumericId(a), this._addToIndex(e.subjects, r, o, a) ? (this._addToIndex(e.predicates, o, a, r), this._addToIndex(e.objects, a, r, o), this._size = null, !0) : !1;
  }
  // ### `addQuads` adds multiple quads to the store
  addQuads(r) {
    for (let o = 0; o < r.length; o++)
      this.addQuad(r[o]);
  }
  // ### `delete` removes the specified quad from the dataset.
  // Returns the dataset instance it was called on.
  delete(r) {
    return this.removeQuad(r), this;
  }
  // ### `has` determines whether a dataset includes a certain quad or quad pattern.
  has(r, o, a, t) {
    return r && r.subject && ({ subject: r, predicate: o, object: a, graph: t } = r), !this.readQuads(r, o, a, t).next().done;
  }
  // ### `import` adds a stream of quads to the store
  import(r) {
    return r.on("data", (o) => {
      this.addQuad(o);
    }), r;
  }
  // ### `removeQuad` removes a quad from the store if it exists
  removeQuad(r, o, a, t) {
    o || ({ subject: r, predicate: o, object: a, graph: t } = r), t = t ? this._termToNumericId(t) : 1;
    const e = this._graphs;
    let n, i, c;
    if (!(r = r && this._termToNumericId(r)) || !(o = o && this._termToNumericId(o)) || !(a = a && this._termToNumericId(a)) || !(n = e[t]) || !(i = n.subjects[r]) || !(c = i[o]) || !(a in c))
      return !1;
    this._removeFromIndex(n.subjects, r, o, a), this._removeFromIndex(n.predicates, o, a, r), this._removeFromIndex(n.objects, a, r, o), this._size !== null && this._size--;
    for (r in n.subjects) return !0;
    return delete e[t], !0;
  }
  // ### `removeQuads` removes multiple quads from the store
  removeQuads(r) {
    for (let o = 0; o < r.length; o++)
      this.removeQuad(r[o]);
  }
  // ### `remove` removes a stream of quads from the store
  remove(r) {
    return r.on("data", (o) => {
      this.removeQuad(o);
    }), r;
  }
  // ### `removeMatches` removes all matching quads from the store
  // Setting any field to `undefined` or `null` indicates a wildcard.
  removeMatches(r, o, a, t) {
    const e = new n4.Readable({ objectMode: !0 }), n = this.readQuads(r, o, a, t);
    return e._read = (i) => {
      for (; --i >= 0; ) {
        const { done: c, value: s } = n.next();
        if (c) {
          e.push(null);
          return;
        }
        e.push(s);
      }
    }, this.remove(e);
  }
  // ### `deleteGraph` removes all triples with the given graph from the store
  deleteGraph(r) {
    return this.removeMatches(null, null, null, r);
  }
  // ### `getQuads` returns an array of quads matching a pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  getQuads(r, o, a, t) {
    return [...this.readQuads(r, o, a, t)];
  }
  /**
   * `readQuads` returns a generator of quads matching a pattern.
   * Setting any field to `undefined` or `null` indicates a wildcard.
   * @deprecated Use `match` instead.
   */
  *readQuads(r, o, a, t) {
    const e = this._getGraphs(t);
    let n, i, c, s;
    if (!(r && !(i = this._termToNumericId(r)) || o && !(c = this._termToNumericId(o)) || a && !(s = this._termToNumericId(a))))
      for (const d in e)
        (n = e[d]) && (i ? s ? yield* this._findInIndex(
          n.objects,
          s,
          i,
          c,
          "object",
          "subject",
          "predicate",
          d
        ) : yield* this._findInIndex(
          n.subjects,
          i,
          c,
          null,
          "subject",
          "predicate",
          "object",
          d
        ) : c ? yield* this._findInIndex(
          n.predicates,
          c,
          s,
          null,
          "predicate",
          "object",
          "subject",
          d
        ) : s ? yield* this._findInIndex(
          n.objects,
          s,
          null,
          null,
          "object",
          "subject",
          "predicate",
          d
        ) : yield* this._findInIndex(
          n.subjects,
          null,
          null,
          null,
          "subject",
          "predicate",
          "object",
          d
        ));
  }
  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.
  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.
  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.
  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  // For backwards compatibility, the object return also implements the Readable stream interface.
  match(r, o, a, t) {
    return new Ua(this, r, o, a, t, { entityIndex: this._entityIndex });
  }
  // ### `countQuads` returns the number of quads matching a pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  countQuads(r, o, a, t) {
    const e = this._getGraphs(t);
    let n = 0, i, c, s, d;
    if (r && !(c = this._termToNumericId(r)) || o && !(s = this._termToNumericId(o)) || a && !(d = this._termToNumericId(a)))
      return 0;
    for (const l in e)
      (i = e[l]) && (r ? a ? n += this._countInIndex(i.objects, d, c, s) : n += this._countInIndex(i.subjects, c, s, d) : o ? n += this._countInIndex(i.predicates, s, d, c) : n += this._countInIndex(i.objects, d, c, s));
    return n;
  }
  // ### `forEach` executes the callback on all quads.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  forEach(r, o, a, t, e) {
    this.some((n) => (r(n, this), !1), o, a, t, e);
  }
  // ### `every` executes the callback on all quads,
  // and returns `true` if it returns truthy for all them.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  every(r, o, a, t, e) {
    return !this.some((n) => !r(n, this), o, a, t, e);
  }
  // ### `some` executes the callback on all quads,
  // and returns `true` if it returns truthy for any of them.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  some(r, o, a, t, e) {
    for (const n of this.readQuads(o, a, t, e))
      if (r(n, this))
        return !0;
    return !1;
  }
  // ### `getSubjects` returns all subjects that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  getSubjects(r, o, a) {
    const t = [];
    return this.forSubjects((e) => {
      t.push(e);
    }, r, o, a), t;
  }
  // ### `forSubjects` executes the callback on all subjects that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  forSubjects(r, o, a, t) {
    const e = this._getGraphs(t);
    let n, i, c;
    if (r = this._uniqueEntities(r), !(o && !(i = this._termToNumericId(o)) || a && !(c = this._termToNumericId(a))))
      for (t in e)
        (n = e[t]) && (i ? c ? this._loopBy2Keys(n.predicates, i, c, r) : this._loopByKey1(n.subjects, i, r) : c ? this._loopByKey0(n.objects, c, r) : this._loop(n.subjects, r));
  }
  // ### `getPredicates` returns all predicates that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  getPredicates(r, o, a) {
    const t = [];
    return this.forPredicates((e) => {
      t.push(e);
    }, r, o, a), t;
  }
  // ### `forPredicates` executes the callback on all predicates that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  forPredicates(r, o, a, t) {
    const e = this._getGraphs(t);
    let n, i, c;
    if (r = this._uniqueEntities(r), !(o && !(i = this._termToNumericId(o)) || a && !(c = this._termToNumericId(a))))
      for (t in e)
        (n = e[t]) && (i ? c ? this._loopBy2Keys(n.objects, c, i, r) : this._loopByKey0(n.subjects, i, r) : c ? this._loopByKey1(n.predicates, c, r) : this._loop(n.predicates, r));
  }
  // ### `getObjects` returns all objects that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  getObjects(r, o, a) {
    const t = [];
    return this.forObjects((e) => {
      t.push(e);
    }, r, o, a), t;
  }
  // ### `forObjects` executes the callback on all objects that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  forObjects(r, o, a, t) {
    const e = this._getGraphs(t);
    let n, i, c;
    if (r = this._uniqueEntities(r), !(o && !(i = this._termToNumericId(o)) || a && !(c = this._termToNumericId(a))))
      for (t in e)
        (n = e[t]) && (i ? c ? this._loopBy2Keys(n.subjects, i, c, r) : this._loopByKey1(n.objects, i, r) : c ? this._loopByKey0(n.predicates, c, r) : this._loop(n.objects, r));
  }
  // ### `getGraphs` returns all graphs that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  getGraphs(r, o, a) {
    const t = [];
    return this.forGraphs((e) => {
      t.push(e);
    }, r, o, a), t;
  }
  // ### `forGraphs` executes the callback on all graphs that match the pattern.
  // Setting any field to `undefined` or `null` indicates a wildcard.
  forGraphs(r, o, a, t) {
    for (const e in this._graphs)
      this.some((n) => (r(n.graph), !0), o, a, t, this._termFromId(this._entities[e]));
  }
  // ### `createBlankNode` creates a new blank node, returning its name
  createBlankNode(r) {
    return this._entityIndex.createBlankNode(r);
  }
  // ### `extractLists` finds and removes all list triples
  // and returns the items per list.
  extractLists({ remove: r = !1, ignoreErrors: o = !1 } = {}) {
    const a = {}, t = o ? () => !0 : (i, c) => {
      throw new Error(`${i.value} ${c}`);
    }, e = this.getQuads(null, qr.rdf.rest, qr.rdf.nil, null), n = r ? [...e] : [];
    return e.forEach((i) => {
      const c = [];
      let s = !1, d, l;
      const f = i.graph;
      let h = i.subject;
      for (; h && !s; ) {
        const p = this.getQuads(null, null, h, null), b = this.getQuads(h, null, null, null);
        let _, y = null, m = null, g = null;
        for (let T = 0; T < b.length && !s; T++)
          _ = b[T], _.graph.equals(f) ? d ? s = t(h, "has non-list arcs out") : _.predicate.value === qr.rdf.first ? y ? s = t(h, "has multiple rdf:first arcs") : n.push(y = _) : _.predicate.value === qr.rdf.rest ? m ? s = t(h, "has multiple rdf:rest arcs") : n.push(m = _) : p.length ? s = t(h, "can't be subject and object") : (d = _, l = "subject") : s = t(h, "not confined to single graph");
        for (let T = 0; T < p.length && !s; ++T)
          _ = p[T], d ? s = t(h, "can't have coreferences") : _.predicate.value === qr.rdf.rest ? g ? s = t(h, "has incoming rdf:rest arcs") : g = _ : (d = _, l = "object");
        y ? c.unshift(y.object) : s = t(h, "has no list head"), h = g && g.subject;
      }
      s ? r = !1 : d && (a[d[l].value] = c);
    }), r && this.removeQuads(n), a;
  }
  /**
   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if
   * the given dataset is a subset of, i.e., is contained within, the current dataset.
   *
   * Blank Nodes will be normalized.
   */
  addAll(r) {
    if (r instanceof Ua && (r = r.filtered), Array.isArray(r))
      this.addQuads(r);
    else if (r instanceof Gr && r._entityIndex === this._entityIndex)
      r._size !== 0 && (this._graphs = NT(this._graphs, r._graphs), this._size = null);
    else
      for (const o of r)
        this.add(o);
    return this;
  }
  /**
   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if
   * the given dataset is a subset of, i.e., is contained within, the current dataset.
   *
   * Blank Nodes will be normalized.
   */
  contains(r) {
    if (r instanceof Ua && (r = r.filtered), r === this)
      return !0;
    if (!(r instanceof Gr) || this._entityIndex !== r._entityIndex)
      return r.every((s) => this.has(s));
    const o = this._graphs, a = r._graphs;
    let t, e, n, i, c;
    for (const s in a) {
      if (!(t = o[s])) return !1;
      t = t.subjects;
      for (const d in e = a[s].subjects) {
        if (!(n = t[d])) return !1;
        for (const l in i = e[d]) {
          if (!(c = n[l])) return !1;
          for (const f in i[l])
            if (!(f in c)) return !1;
        }
      }
    }
    return !0;
  }
  /**
   * This method removes the quads in the current dataset that match the given arguments.
   *
   * The logic described in {@link https://rdf.js.org/dataset-spec/#quad-matching|Quad Matching} is applied for each
   * quad in this dataset, to select the quads which will be deleted.
   *
   * @param subject   The optional exact subject to match.
   * @param predicate The optional exact predicate to match.
   * @param object    The optional exact object to match.
   * @param graph     The optional exact graph to match.
   */
  deleteMatches(r, o, a, t) {
    for (const e of this.match(r, o, a, t))
      this.removeQuad(e);
    return this;
  }
  /**
   * Returns a new dataset that contains all quads from the current dataset that are not included in the given dataset.
   */
  difference(r) {
    if (r && r instanceof Ua && (r = r.filtered), r === this)
      return new Gr({ entityIndex: this._entityIndex });
    if (r instanceof Gr && r._entityIndex === this._entityIndex) {
      const o = new Gr({ entityIndex: this._entityIndex }), a = ZW(this._graphs, r._graphs);
      return a && (o._graphs = a, o._size = null), o;
    }
    return this.filter((o) => !r.has(o));
  }
  /**
   * Returns true if the current dataset contains the same graph structure as the given dataset.
   *
   * Blank Nodes will be normalized.
   */
  equals(r) {
    return r instanceof Ua && (r = r.filtered), r === this || this.size === r.size && this.contains(r);
  }
  /**
   * Creates a new dataset with all the quads that pass the test implemented by the provided `iteratee`.
   *
   * This method is aligned with Array.prototype.filter() in ECMAScript-262.
   */
  filter(r) {
    const o = new Gr({ entityIndex: this._entityIndex });
    for (const a of this)
      r(a, this) && o.add(a);
    return o;
  }
  /**
   * Returns a new dataset containing all quads from the current dataset that are also included in the given dataset.
   */
  intersection(r) {
    if (r instanceof Ua && (r = r.filtered), r === this) {
      const o = new Gr({ entityIndex: this._entityIndex });
      return o._graphs = NT(/* @__PURE__ */ Object.create(null), this._graphs), o._size = this._size, o;
    } else if (r instanceof Gr && this._entityIndex === r._entityIndex) {
      const o = new Gr({ entityIndex: this._entityIndex }), a = YW(r._graphs, this._graphs);
      return a && (o._graphs = a, o._size = null), o;
    }
    return this.filter((o) => r.has(o));
  }
  /**
   * Returns a new dataset containing all quads returned by applying `iteratee` to each quad in the current dataset.
   */
  map(r) {
    const o = new Gr({ entityIndex: this._entityIndex });
    for (const a of this)
      o.add(r(a, this));
    return o;
  }
  /**
   * This method calls the `iteratee` method on each `quad` of the `Dataset`. The first time the `iteratee` method
   * is called, the `accumulator` value is the `initialValue`, or, if not given, equals the first quad of the `Dataset`.
   * The return value of each call to the `iteratee` method is used as the `accumulator` value for the next call.
   *
   * This method returns the return value of the last `iteratee` call.
   *
   * This method is aligned with `Array.prototype.reduce()` in ECMAScript-262.
   */
  reduce(r, o) {
    const a = this.readQuads();
    let t = o === void 0 ? a.next().value : o;
    for (const e of a)
      t = r(t, e, this);
    return t;
  }
  /**
   * Returns the set of quads within the dataset as a host-language-native sequence, for example an `Array` in
   * ECMAScript-262.
   *
   * Since a `Dataset` is an unordered set, the order of the quads within the returned sequence is arbitrary.
   */
  toArray() {
    return this.getQuads();
  }
  /**
   * Returns an N-Quads string representation of the dataset, preprocessed with the
   * {@link https://json-ld.github.io/normalization/spec/|RDF Dataset Normalization} algorithm.
   */
  toCanonical() {
    throw new Error("not implemented");
  }
  /**
   * Returns a stream that contains all quads of the dataset.
   */
  toStream() {
    return this.match();
  }
  /**
   * Returns an N-Quads string representation of the dataset.
   *
   * No prior normalization is required, therefore the results for the same quads may vary depending on the `Dataset`
   * implementation.
   */
  toString() {
    return new Iw().quadsToString(this);
  }
  /**
   * Returns a new `Dataset` that is a concatenation of this dataset and the quads given as an argument.
   */
  union(r) {
    const o = new Gr({ entityIndex: this._entityIndex });
    return o._graphs = NT(/* @__PURE__ */ Object.create(null), this._graphs), o._size = this._size, o.addAll(r), o;
  }
  // ### Store is an iterable.
  // Can be used where iterables are expected: for...of loops, array spread operator,
  // `yield*`, and destructuring assignment (order is not guaranteed).
  *[Symbol.iterator]() {
    yield* this.readQuads();
  }
}
function Ri(u, r, o = 0) {
  const a = r[o];
  if (a && !(a in u))
    return !1;
  let t = !1;
  for (const e in a ? { [a]: u[a] } : u) {
    const n = o === 2 ? null : Ri(u[e], r, o + 1);
    n !== !1 && (t = t || /* @__PURE__ */ Object.create(null), t[e] = n);
  }
  return t;
}
class Ua extends n4.Readable {
  constructor(r, o, a, t, e, n) {
    super({ objectMode: !0 }), Object.assign(this, { n3Store: r, subject: o, predicate: a, object: t, graph: e, options: n });
  }
  get filtered() {
    if (!this._filtered) {
      const { n3Store: r, graph: o, object: a, predicate: t, subject: e } = this, n = this._filtered = new Gr({ factory: r._factory, entityIndex: this.options.entityIndex });
      let i, c, s;
      if (e && !(i = n._termToNumericId(e)) || t && !(c = n._termToNumericId(t)) || a && !(s = n._termToNumericId(a)))
        return n;
      const d = r._getGraphs(o);
      for (const l in d) {
        let f, h, p, b;
        (b = d[l]) && (!i && c ? (h = Ri(b.predicates, [c, s, i])) && (f = Ri(b.subjects, [i, c, s]), p = Ri(b.objects, [s, i, c])) : s ? (p = Ri(b.objects, [s, i, c])) && (f = Ri(b.subjects, [i, c, s]), h = Ri(b.predicates, [c, s, i])) : (f = Ri(b.subjects, [i, c, s])) && (h = Ri(b.predicates, [c, s, i]), p = Ri(b.objects, [s, i, c])), f && (n._graphs[l] = { subjects: f, predicates: h, objects: p }));
      }
      n._size = null;
    }
    return this._filtered;
  }
  get size() {
    return this.filtered.size;
  }
  _read(r) {
    r > 0 && !this[vE] && (this[vE] = this[Symbol.iterator]());
    const o = this[vE];
    for (; --r >= 0; ) {
      const { done: a, value: t } = o.next();
      if (a) {
        this.push(null);
        return;
      }
      this.push(t);
    }
  }
  addAll(r) {
    return this.filtered.addAll(r);
  }
  contains(r) {
    return this.filtered.contains(r);
  }
  deleteMatches(r, o, a, t) {
    return this.filtered.deleteMatches(r, o, a, t);
  }
  difference(r) {
    return this.filtered.difference(r);
  }
  equals(r) {
    return this.filtered.equals(r);
  }
  every(r, o, a, t, e) {
    return this.filtered.every(r, o, a, t, e);
  }
  filter(r) {
    return this.filtered.filter(r);
  }
  forEach(r, o, a, t, e) {
    return this.filtered.forEach(r, o, a, t, e);
  }
  import(r) {
    return this.filtered.import(r);
  }
  intersection(r) {
    return this.filtered.intersection(r);
  }
  map(r) {
    return this.filtered.map(r);
  }
  some(r, o, a, t, e) {
    return this.filtered.some(r, o, a, t, e);
  }
  toCanonical() {
    return this.filtered.toCanonical();
  }
  toStream() {
    return this._filtered ? this._filtered.toStream() : this.n3Store.match(this.subject, this.predicate, this.object, this.graph);
  }
  union(r) {
    return this._filtered ? this._filtered.union(r) : this.n3Store.match(this.subject, this.predicate, this.object, this.graph).addAll(r);
  }
  toArray() {
    return this._filtered ? this._filtered.toArray() : this.n3Store.getQuads(this.subject, this.predicate, this.object, this.graph);
  }
  reduce(r, o) {
    return this.filtered.reduce(r, o);
  }
  toString() {
    return new Iw().quadsToString(this);
  }
  add(r) {
    return this.filtered.add(r);
  }
  delete(r) {
    return this.filtered.delete(r);
  }
  has(r) {
    return this.filtered.has(r);
  }
  match(r, o, a, t) {
    return new Ua(this.filtered, r, o, a, t, this.options);
  }
  *[Symbol.iterator]() {
    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
  }
}
class eY {
  dataset(r) {
    return new Gr(r);
  }
}
function tY(u) {
  const r = [];
  for (const { subject: o, object: a } of u.match(null, vi.namedNode("http://www.w3.org/2000/10/swap/log#implies"), null, vi.defaultGraph())) {
    const t = [...u.match(null, null, null, o)], e = [...u.match(null, null, null, a)];
    r.push({ premise: t, conclusion: e });
  }
  return r;
}
class rY {
  constructor(r) {
    this._store = r;
  }
  _add(r, o, a, t, e) {
    this._store._addToIndex(t.subjects, r, o, a) && (this._store._addToIndex(t.predicates, o, a, r), this._store._addToIndex(t.objects, a, r, o), e());
  }
  // eslint-disable-next-line no-warning-comments
  _evaluatePremise(r, o, a, t = 0) {
    let e, n, i, c, s;
    const [d, l, f] = r.premise[t].value, h = o[r.premise[t].content], p = !(i = d.value);
    for (i in p ? h : { [i]: h[i] })
      if (c = h[i]) {
        p && (d.value = Number(i)), e = !(i = l.value);
        for (i in e ? c : { [i]: c[i] })
          if (s = c[i]) {
            e && (l.value = Number(i)), n = !(i = f.value);
            for (i in n ? s : { [i]: s[i] })
              n && (f.value = Number(i)), t === r.premise.length - 1 ? r.conclusion.forEach((b) => {
                this._add(b.subject.value, b.predicate.value, b.object.value, o, () => {
                  a(b);
                });
              }) : this._evaluatePremise(r, o, a, t + 1);
            n && (f.value = null);
          }
        e && (l.value = null);
      }
    p && (d.value = null);
  }
  _evaluateRules(r, o, a) {
    for (let t = 0; t < r.length; t++)
      this._evaluatePremise(r[t], o, a);
  }
  // A naive reasoning algorithm where rules are just applied by repeatedly applying rules
  // until no more evaluations are made
  _reasonGraphNaive(r, o) {
    const a = [];
    function t(i) {
      i.next && i.next.forEach((c) => {
        a.push([i.subject.value, i.predicate.value, i.object.value, c]);
      });
    }
    const e = (i) => {
      i.forEach((c) => {
        this._add(c.subject.value, c.predicate.value, c.object.value, o, () => {
          t(c);
        });
      });
    };
    this._evaluateRules(r, o, t);
    let n;
    for (; (n = a.pop()) !== void 0; ) {
      const [i, c, s, d] = n, l = d.basePremise.subject.value;
      l || (d.basePremise.subject.value = i);
      const f = d.basePremise.predicate.value;
      f || (d.basePremise.predicate.value = c);
      const h = d.basePremise.object.value;
      h || (d.basePremise.object.value = s), d.premise.length === 0 ? e(d.conclusion) : this._evaluatePremise(d, o, t), l || (d.basePremise.subject.value = null), f || (d.basePremise.predicate.value = null), h || (d.basePremise.object.value = null);
    }
  }
  _createRule({ premise: r, conclusion: o }) {
    const a = {}, t = (n) => n.termType === "Variable" ? (
      // If the term is a variable, then create an empty object that values can be placed into
      a[n.value] = a[n.value] || {}
    ) : (
      // If the term is not a variable, then set the ID value
      { value: this._store._termToNewNumericId(n) }
    ), e = (n) => ({ subject: t(n.subject), predicate: t(n.predicate), object: t(n.object) });
    return {
      premise: r.map((n) => e(n)),
      conclusion: o.map((n) => e(n)),
      variables: Object.values(a)
    };
  }
  reason(r) {
    Array.isArray(r) || (r = tY(r)), r = r.map((a) => this._createRule(a));
    for (const a of r)
      for (const t of r)
        for (let e = 0; e < t.premise.length; e++) {
          const n = t.premise[e];
          for (const i of a.conclusion) {
            if (TE(n.subject, i.subject) && TE(n.predicate, i.predicate) && TE(n.object, i.object)) {
              const c = /* @__PURE__ */ new Set(), s = [];
              n.subject.value = n.subject.value || 1, n.object.value = n.object.value || 1, n.predicate.value = n.predicate.value || 1;
              for (let d = 0; d < t.premise.length; d++)
                d !== e && s.push(t7(t.premise[d], c));
              (i.next = i.next || []).push({
                premise: s,
                conclusion: t.conclusion,
                // This is a single premise of the form { subject, predicate, object },
                // which we can use to instantiate the rule using the new data that was emitted
                basePremise: n
              });
            }
            t.variables.forEach((c) => {
              c.value = null;
            });
          }
        }
    for (const a of r) {
      const t = /* @__PURE__ */ new Set();
      a.premise = a.premise.map((e) => t7(e, t));
    }
    const o = this._store._getGraphs();
    for (const a in o)
      this._reasonGraphNaive(r, o[a]);
    this._store._size = null;
  }
}
function t7({ subject: u, predicate: r, object: o }, a) {
  const t = u.value || a.has(u) || (a.add(u), !1), e = r.value || a.has(r) || (a.add(r), !1), n = o.value || a.has(o) || (a.add(o), !1);
  return !t && e ? { content: "predicates", value: [r, o, u] } : n ? { content: "objects", value: [o, u, r] } : { content: "subjects", value: [u, r, o] };
}
function TE(u, r) {
  return u.value === null && (u.value = r.value), u.value === r.value;
}
class nY extends n4.Transform {
  constructor(r) {
    super({ decodeStrings: !0 }), this._readableState.objectMode = !0;
    const o = new r4(r);
    let a, t;
    const e = {
      // Handle quads by pushing them down the pipeline
      onQuad: (n, i) => {
        n && this.emit("error", n) || i && this.push(i);
      },
      // Emit prefixes through the `prefix` event
      onPrefix: (n, i) => {
        this.emit("prefix", n, i);
      }
    };
    r && r.comments && (e.onComment = (n) => {
      this.emit("comment", n);
    }), o.parse({
      on: (n, i) => {
        switch (n) {
          case "data":
            a = i;
            break;
          case "end":
            t = i;
            break;
        }
      }
    }, e), this._transform = (n, i, c) => {
      a(n), c();
    }, this._flush = (n) => {
      t(), n();
    };
  }
  // ### Parses a stream of strings
  import(r) {
    return r.on("data", (o) => {
      this.write(o);
    }), r.on("end", () => {
      this.end();
    }), r.on("error", (o) => {
      this.emit("error", o);
    }), this;
  }
}
class iY extends n4.Transform {
  constructor(r) {
    super({ encoding: "utf8", writableObjectMode: !0 });
    const o = this._writer = new Iw({
      write: (a, t, e) => {
        this.push(a), e && e();
      },
      end: (a) => {
        this.push(null), a && a();
      }
    }, r);
    this._transform = (a, t, e) => {
      o.addQuad(a, e);
    }, this._flush = (a) => {
      o.end(a);
    };
  }
  // ### Serializes a stream of quads
  import(r) {
    return r.on("data", (o) => {
      this.write(o);
    }), r.on("end", () => {
      this.end();
    }), r.on("error", (o) => {
      this.emit("error", o);
    }), r.on("prefix", (o, a) => {
      this._writer.addPrefix(o, a);
    }), this;
  }
}
const lse = {
  Lexer: P8,
  Parser: r4,
  Writer: Iw,
  Store: Gr,
  StoreFactory: eY,
  EntityIndex: M8,
  StreamParser: nY,
  StreamWriter: iY,
  Util: WW,
  Reasoner: rY,
  BaseIRI: xw,
  DataFactory: vi,
  Term: Rn,
  NamedNode: t4,
  Literal: $0,
  BlankNode: D8,
  Variable: L8,
  DefaultGraph: j8,
  Quad: Z0,
  Triple: Z0,
  termFromId: kf,
  termToId: Qa
}, fse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseIRI: xw,
  BlankNode: D8,
  DataFactory: vi,
  DefaultGraph: j8,
  EntityIndex: M8,
  Lexer: P8,
  Literal: $0,
  NamedNode: t4,
  Parser: r4,
  Quad: Z0,
  Reasoner: rY,
  Store: Gr,
  StoreFactory: eY,
  StreamParser: nY,
  StreamWriter: iY,
  Term: Rn,
  Triple: Z0,
  Util: WW,
  Variable: L8,
  Writer: Iw,
  default: lse,
  getRulesFromDataset: tY,
  termFromId: kf,
  termToId: Qa
}, Symbol.toStringTag, { value: "Module" })), iu = /* @__PURE__ */ jx(fse);
var r7;
function hse() {
  if (r7) return nb;
  r7 = 1, Object.defineProperty(nb, "__esModule", { value: !0 }), nb.ActorRdfParseN3 = void 0;
  const u = /* @__PURE__ */ yh(), r = /* @__PURE__ */ Be(), o = iu;
  let a = class extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/n-quads": 1.0,
     *       "application/trig": 0.95,
     *       "application/n-triples": 0.8,
     *       "text/turtle": 0.6,
     *       "text/n3": 0.35
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/n-quads": "http://www.w3.org/ns/formats/N-Quads",
     *       "application/trig": "http://www.w3.org/ns/formats/TriG",
     *       "application/n-triples": "http://www.w3.org/ns/formats/N-Triples",
     *       "text/turtle": "http://www.w3.org/ns/formats/Turtle",
     *       "text/n3": "http://www.w3.org/ns/formats/N3"
     *     }} mediaTypeFormats
     */
    constructor(e) {
      super(e);
    }
    async runHandle(e, n, i) {
      var d;
      const c = e.context.getSafe(r.KeysInitQuery.dataFactory);
      e.data.on("error", (l) => s.emit("error", l));
      const s = e.data.pipe(new o.StreamParser({
        factory: c,
        baseIRI: (d = e.metadata) == null ? void 0 : d.baseIRI,
        // Enable RDF-star-mode on all formats, except N3, where this is not supported.
        format: n.endsWith("n3") ? n : `${n}*`
      }));
      return {
        data: s,
        metadata: {
          triples: n === "text/turtle" || n === "application/n-triples" || n === "text/n3"
        }
      };
    }
  };
  return nb.ActorRdfParseN3 = a, nb;
}
var n7;
function pse() {
  return n7 || (n7 = 1, function(u) {
    var r = es && es.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = es && es.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hse(), u);
  }(es)), es;
}
var rs = {}, db = {}, ns = {}, is = {}, as = {}, wE = {}, i7;
function bse() {
  return i7 || (i7 = 1, function(u) {
    /**
     * Character classes and associated utilities for the 5th edition of XML 1.0.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(u, "__esModule", { value: !0 }), u.CHAR = `	
\r -í¿î-ï¿½ð-ô¿¿`, u.S = ` 	\r
`, u.NAME_START_CHAR = ":A-Z_a-zÃ-ÃÃ-Ã¶Ã¸-Ë¿Í°-Í½Í¿-á¿¿âââ°-ââ°-â¿¯ã-í¿ï¤-ï·ï·°-ï¿½ð-ó¯¿¿", u.NAME_CHAR = "-" + u.NAME_START_CHAR + ".0-9Â·Ì-Í¯â¿-â", u.CHAR_RE = new RegExp("^[" + u.CHAR + "]$", "u"), u.S_RE = new RegExp("^[" + u.S + "]+$", "u"), u.NAME_START_CHAR_RE = new RegExp("^[" + u.NAME_START_CHAR + "]$", "u"), u.NAME_CHAR_RE = new RegExp("^[" + u.NAME_CHAR + "]$", "u"), u.NAME_RE = new RegExp("^[" + u.NAME_START_CHAR + "][" + u.NAME_CHAR + "]*$", "u"), u.NMTOKEN_RE = new RegExp("^[" + u.NAME_CHAR + "]+$", "u");
    var r = 9, o = 10, a = 13, t = 32;
    u.S_LIST = [t, o, a, r];
    function e(s) {
      return s >= t && s <= 55295 || s === o || s === a || s === r || s >= 57344 && s <= 65533 || s >= 65536 && s <= 1114111;
    }
    u.isChar = e;
    function n(s) {
      return s === t || s === o || s === a || s === r;
    }
    u.isS = n;
    function i(s) {
      return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s === 58 || s === 95 || s === 8204 || s === 8205 || s >= 192 && s <= 214 || s >= 216 && s <= 246 || s >= 248 && s <= 767 || s >= 880 && s <= 893 || s >= 895 && s <= 8191 || s >= 8304 && s <= 8591 || s >= 11264 && s <= 12271 || s >= 12289 && s <= 55295 || s >= 63744 && s <= 64975 || s >= 65008 && s <= 65533 || s >= 65536 && s <= 983039;
    }
    u.isNameStartChar = i;
    function c(s) {
      return i(s) || s >= 48 && s <= 57 || s === 45 || s === 46 || s === 183 || s >= 768 && s <= 879 || s >= 8255 && s <= 8256;
    }
    u.isNameChar = c;
  }(wE)), wE;
}
var SE = {}, a7;
function yse() {
  return a7 || (a7 = 1, function(u) {
    /**
     * Character classes and associated utilities for the 2nd edition of XML 1.1.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(u, "__esModule", { value: !0 }), u.CHAR = "-í¿î-ï¿½ð-ô¿¿", u.RESTRICTED_CHAR = "-\b\v\f--ÂÂ-Â", u.S = ` 	\r
`, u.NAME_START_CHAR = ":A-Z_a-zÃ-ÃÃ-Ã¶Ã¸-Ë¿Í°-Í½Í¿-á¿¿âââ°-ââ°-â¿¯ã-í¿ï¤-ï·ï·°-ï¿½ð-ó¯¿¿", u.NAME_CHAR = "-" + u.NAME_START_CHAR + ".0-9Â·Ì-Í¯â¿-â", u.CHAR_RE = new RegExp("^[" + u.CHAR + "]$", "u"), u.RESTRICTED_CHAR_RE = new RegExp("^[" + u.RESTRICTED_CHAR + "]$", "u"), u.S_RE = new RegExp("^[" + u.S + "]+$", "u"), u.NAME_START_CHAR_RE = new RegExp("^[" + u.NAME_START_CHAR + "]$", "u"), u.NAME_CHAR_RE = new RegExp("^[" + u.NAME_CHAR + "]$", "u"), u.NAME_RE = new RegExp("^[" + u.NAME_START_CHAR + "][" + u.NAME_CHAR + "]*$", "u"), u.NMTOKEN_RE = new RegExp("^[" + u.NAME_CHAR + "]+$", "u");
    var r = 9, o = 10, a = 13, t = 32;
    u.S_LIST = [t, o, a, r];
    function e(l) {
      return l >= 1 && l <= 55295 || l >= 57344 && l <= 65533 || l >= 65536 && l <= 1114111;
    }
    u.isChar = e;
    function n(l) {
      return l >= 1 && l <= 8 || l === 11 || l === 12 || l >= 14 && l <= 31 || l >= 127 && l <= 132 || l >= 134 && l <= 159;
    }
    u.isRestrictedChar = n;
    function i(l) {
      return l === 9 || l === 10 || l === 13 || l > 31 && l < 127 || l === 133 || l > 159 && l <= 55295 || l >= 57344 && l <= 65533 || l >= 65536 && l <= 1114111;
    }
    u.isCharAndNotRestricted = i;
    function c(l) {
      return l === t || l === o || l === a || l === r;
    }
    u.isS = c;
    function s(l) {
      return l >= 65 && l <= 90 || l >= 97 && l <= 122 || l === 58 || l === 95 || l === 8204 || l === 8205 || l >= 192 && l <= 214 || l >= 216 && l <= 246 || l >= 248 && l <= 767 || l >= 880 && l <= 893 || l >= 895 && l <= 8191 || l >= 8304 && l <= 8591 || l >= 11264 && l <= 12271 || l >= 12289 && l <= 55295 || l >= 63744 && l <= 64975 || l >= 65008 && l <= 65533 || l >= 65536 && l <= 983039;
    }
    u.isNameStartChar = s;
    function d(l) {
      return s(l) || l >= 48 && l <= 57 || l === 45 || l === 46 || l === 183 || l >= 768 && l <= 879 || l >= 8255 && l <= 8256;
    }
    u.isNameChar = d;
  }(SE)), SE;
}
var AE = {}, u7;
function _se() {
  return u7 || (u7 = 1, function(u) {
    /**
     * Character class utilities for XML NS 1.0 edition 3.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(u, "__esModule", { value: !0 }), u.NC_NAME_START_CHAR = "A-Z_a-zÃ-ÃÃ-Ã¶Ã¸-Ë¿Í°-Í½Í¿-á¿¿â-ââ°-ââ°-â¿¯ã-í¿ï¤-ï·ï·°-ï¿½ð-ó¯¿¿", u.NC_NAME_CHAR = "-" + u.NC_NAME_START_CHAR + ".0-9Â·Ì-Í¯â¿-â", u.NC_NAME_START_CHAR_RE = new RegExp("^[" + u.NC_NAME_START_CHAR + "]$", "u"), u.NC_NAME_CHAR_RE = new RegExp("^[" + u.NC_NAME_CHAR + "]$", "u"), u.NC_NAME_RE = new RegExp("^[" + u.NC_NAME_START_CHAR + "][" + u.NC_NAME_CHAR + "]*$", "u");
    function r(a) {
      return a >= 65 && a <= 90 || a === 95 || a >= 97 && a <= 122 || a >= 192 && a <= 214 || a >= 216 && a <= 246 || a >= 248 && a <= 767 || a >= 880 && a <= 893 || a >= 895 && a <= 8191 || a >= 8204 && a <= 8205 || a >= 8304 && a <= 8591 || a >= 11264 && a <= 12271 || a >= 12289 && a <= 55295 || a >= 63744 && a <= 64975 || a >= 65008 && a <= 65533 || a >= 65536 && a <= 983039;
    }
    u.isNCNameStartChar = r;
    function o(a) {
      return r(a) || a === 45 || a === 46 || a >= 48 && a <= 57 || a === 183 || a >= 768 && a <= 879 || a >= 8255 && a <= 8256;
    }
    u.isNCNameChar = o;
  }(AE)), AE;
}
var o7;
function aY() {
  if (o7) return as;
  o7 = 1, Object.defineProperty(as, "__esModule", { value: !0 }), as.SaxesParser = as.EVENTS = void 0;
  const u = bse(), r = yse(), o = _se();
  var a = u.isS, t = u.isChar, e = u.isNameStartChar, n = u.isNameChar, i = u.S_LIST, c = u.NAME_RE, s = r.isChar, d = o.isNCNameStartChar, l = o.isNCNameChar, f = o.NC_NAME_RE;
  const h = "http://www.w3.org/XML/1998/namespace", p = "http://www.w3.org/2000/xmlns/", b = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
    __proto__: null,
    xml: h,
    xmlns: p
  }, _ = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
    __proto__: null,
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  }, y = -1, m = -2, g = 0, T = 1, v = 2, E = 3, R = 4, L = 5, A = 6, w = 7, S = 8, O = 9, x = 10, F = 11, j = 12, q = 13, Q = 14, G = 15, K = 16, U = 17, ae = 18, ye = 19, pe = 20, ee = 21, Te = 22, we = 23, Oe = 24, be = 25, he = 26, V = 27, N = 28, M = 29, I = 30, P = 31, B = 32, z = 33, H = 34, J = 35, k = 36, W = 37, le = 38, fe = 39, me = 40, Ne = 41, xe = 42, ue = 43, $ = 44, D = 9, C = 10, X = 13, te = 32, de = 33, oe = 34, De = 38, Ve = 39, qe = 45, Ke = 47, Y = 59, Ee = 60, Ie = 61, Ue = 62, Le = 63, tt = 91, it = 93, Ye = 133, ht = 8232, ne = (ze) => ze === oe || ze === Ve, ie = [oe, Ve], je = [...ie, tt, Ue], $e = [...ie, Ee, it], He = [Ie, Le, ...i], At = [...i, Ue, De, Ee];
  function Qe(ze, se, ge) {
    switch (se) {
      case "xml":
        ge !== h && ze.fail(`xml prefix must be bound to ${h}.`);
        break;
      case "xmlns":
        ge !== p && ze.fail(`xmlns prefix must be bound to ${p}.`);
        break;
    }
    switch (ge) {
      case p:
        ze.fail(se === "" ? `the default namespace may not be set to ${ge}.` : `may not assign a prefix (even "xmlns") to the URI ${p}.`);
        break;
      case h:
        switch (se) {
          case "xml":
            break;
          case "":
            ze.fail(`the default namespace may not be set to ${ge}.`);
            break;
          default:
            ze.fail("may not assign the xml namespace to another prefix.");
        }
        break;
    }
  }
  function bt(ze, se) {
    for (const ge of Object.keys(se))
      Qe(ze, ge, se[ge]);
  }
  const Ge = (ze) => f.test(ze), Je = (ze) => c.test(ze), rt = 0, Et = 1, ot = 2;
  as.EVENTS = [
    "xmldecl",
    "text",
    "processinginstruction",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "cdata",
    "error",
    "end",
    "ready"
  ];
  const Xe = {
    xmldecl: "xmldeclHandler",
    text: "textHandler",
    processinginstruction: "piHandler",
    doctype: "doctypeHandler",
    comment: "commentHandler",
    opentagstart: "openTagStartHandler",
    attribute: "attributeHandler",
    opentag: "openTagHandler",
    closetag: "closeTagHandler",
    cdata: "cdataHandler",
    error: "errorHandler",
    end: "endHandler",
    ready: "readyHandler"
  };
  class Ur {
    /**
     * Indicates whether or not the parser is closed. If ``true``, wait for
     * the ``ready`` event to write again.
     */
    get closed() {
      return this._closed;
    }
    /**
     * @param opt The parser options.
     */
    constructor(se) {
      this.opt = se ?? {}, this.fragmentOpt = !!this.opt.fragment;
      const ge = this.xmlnsOpt = !!this.opt.xmlns;
      if (this.trackPosition = this.opt.position !== !1, this.fileName = this.opt.fileName, ge) {
        this.nameStartCheck = d, this.nameCheck = l, this.isName = Ge, this.processAttribs = this.processAttribsNS, this.pushAttrib = this.pushAttribNS, this.ns = Object.assign({ __proto__: null }, b);
        const Se = this.opt.additionalNamespaces;
        Se != null && (bt(this, Se), Object.assign(this.ns, Se));
      } else
        this.nameStartCheck = e, this.nameCheck = n, this.isName = Je, this.processAttribs = this.processAttribsPlain, this.pushAttrib = this.pushAttribPlain;
      this.stateTable = [
        /* eslint-disable @typescript-eslint/unbound-method */
        this.sBegin,
        this.sBeginWhitespace,
        this.sDoctype,
        this.sDoctypeQuote,
        this.sDTD,
        this.sDTDQuoted,
        this.sDTDOpenWaka,
        this.sDTDOpenWakaBang,
        this.sDTDComment,
        this.sDTDCommentEnding,
        this.sDTDCommentEnded,
        this.sDTDPI,
        this.sDTDPIEnding,
        this.sText,
        this.sEntity,
        this.sOpenWaka,
        this.sOpenWakaBang,
        this.sComment,
        this.sCommentEnding,
        this.sCommentEnded,
        this.sCData,
        this.sCDataEnding,
        this.sCDataEnding2,
        this.sPIFirstChar,
        this.sPIRest,
        this.sPIBody,
        this.sPIEnding,
        this.sXMLDeclNameStart,
        this.sXMLDeclName,
        this.sXMLDeclEq,
        this.sXMLDeclValueStart,
        this.sXMLDeclValue,
        this.sXMLDeclSeparator,
        this.sXMLDeclEnding,
        this.sOpenTag,
        this.sOpenTagSlash,
        this.sAttrib,
        this.sAttribName,
        this.sAttribNameSawWhite,
        this.sAttribValue,
        this.sAttribValueQuoted,
        this.sAttribValueClosed,
        this.sAttribValueUnquoted,
        this.sCloseTag,
        this.sCloseTagSawWhite
        /* eslint-enable @typescript-eslint/unbound-method */
      ], this._init();
    }
    _init() {
      var se;
      this.openWakaBang = "", this.text = "", this.name = "", this.piTarget = "", this.entity = "", this.q = null, this.tags = [], this.tag = null, this.topNS = null, this.chunk = "", this.chunkPosition = 0, this.i = 0, this.prevI = 0, this.carriedFromPrevious = void 0, this.forbiddenState = rt, this.attribList = [];
      const { fragmentOpt: ge } = this;
      this.state = ge ? q : g, this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = ge, this.xmlDeclPossible = !ge, this.xmlDeclExpects = ["version"], this.entityReturnState = void 0;
      let { defaultXMLVersion: Se } = this.opt;
      if (Se === void 0) {
        if (this.opt.forceXMLVersion === !0)
          throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
        Se = "1.0";
      }
      this.setXMLVersion(Se), this.positionAtNewLine = 0, this.doctype = !1, this._closed = !1, this.xmlDecl = {
        version: void 0,
        encoding: void 0,
        standalone: void 0
      }, this.line = 1, this.column = 0, this.ENTITIES = Object.create(_), (se = this.readyHandler) === null || se === void 0 || se.call(this);
    }
    /**
     * The stream position the parser is currently looking at. This field is
     * zero-based.
     *
     * This field is not based on counting Unicode characters but is to be
     * interpreted as a plain index into a JavaScript string.
     */
    get position() {
      return this.chunkPosition + this.i;
    }
    /**
     * The column number of the next character to be read by the parser.  *
     * This field is zero-based. (The first column in a line is 0.)
     *
     * This field reports the index at which the next character would be in the
     * line if the line were represented as a JavaScript string.  Note that this
     * *can* be different to a count based on the number of *Unicode characters*
     * due to how JavaScript handles astral plane characters.
     *
     * See [[column]] for a number that corresponds to a count of Unicode
     * characters.
     */
    get columnIndex() {
      return this.position - this.positionAtNewLine;
    }
    /**
     * Set an event listener on an event. The parser supports one handler per
     * event type. If you try to set an event handler over an existing handler,
     * the old handler is silently overwritten.
     *
     * @param name The event to listen to.
     *
     * @param handler The handler to set.
     */
    on(se, ge) {
      this[Xe[se]] = ge;
    }
    /**
     * Unset an event handler.
     *
     * @parma name The event to stop listening to.
     */
    off(se) {
      this[Xe[se]] = void 0;
    }
    /**
     * Make an error object. The error object will have a message that contains
     * the ``fileName`` option passed at the creation of the parser. If position
     * tracking was turned on, it will also have line and column number
     * information.
     *
     * @param message The message describing the error to report.
     *
     * @returns An error object with a properly formatted message.
     */
    makeError(se) {
      var ge;
      let Se = (ge = this.fileName) !== null && ge !== void 0 ? ge : "";
      return this.trackPosition && (Se.length > 0 && (Se += ":"), Se += `${this.line}:${this.column}`), Se.length > 0 && (Se += ": "), new Error(Se + se);
    }
    /**
     * Report a parsing error. This method is made public so that client code may
     * check for issues that are outside the scope of this project and can report
     * errors.
     *
     * @param message The error to report.
     *
     * @returns this
     */
    fail(se) {
      const ge = this.makeError(se), Se = this.errorHandler;
      if (Se === void 0)
        throw ge;
      return Se(ge), this;
    }
    /**
     * Write a XML data to the parser.
     *
     * @param chunk The XML data to write.
     *
     * @returns this
     */
    // We do need object for the type here. Yes, it often causes problems
    // but not in this case.
    write(se) {
      if (this.closed)
        return this.fail("cannot write after close; assign an onready handler.");
      let ge = !1;
      se === null ? (ge = !0, se = "") : typeof se == "object" && (se = se.toString()), this.carriedFromPrevious !== void 0 && (se = `${this.carriedFromPrevious}${se}`, this.carriedFromPrevious = void 0);
      let Se = se.length;
      const Ze = se.charCodeAt(Se - 1);
      !ge && // A trailing CR or surrogate must be carried over to the next
      // chunk.
      (Ze === X || Ze >= 55296 && Ze <= 56319) && (this.carriedFromPrevious = se[Se - 1], Se--, se = se.slice(0, Se));
      const { stateTable: et } = this;
      for (this.chunk = se, this.i = 0; this.i < Se; )
        et[this.state].call(this);
      return this.chunkPosition += Se, ge ? this.end() : this;
    }
    /**
     * Close the current stream. Perform final well-formedness checks and reset
     * the parser tstate.
     *
     * @returns this
     */
    close() {
      return this.write(null);
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.0.
     *
     * @returns The character read.
     */
    getCode10() {
      const { chunk: se, i: ge } = this;
      if (this.prevI = ge, this.i = ge + 1, ge >= se.length)
        return y;
      const Se = se.charCodeAt(ge);
      if (this.column++, Se < 55296) {
        if (Se >= te || Se === D)
          return Se;
        switch (Se) {
          case C:
            return this.line++, this.column = 0, this.positionAtNewLine = this.position, C;
          case X:
            return se.charCodeAt(ge + 1) === C && (this.i = ge + 2), this.line++, this.column = 0, this.positionAtNewLine = this.position, m;
          default:
            return this.fail("disallowed character."), Se;
        }
      }
      if (Se > 56319)
        return Se >= 57344 && Se <= 65533 || this.fail("disallowed character."), Se;
      const Ze = 65536 + (Se - 55296) * 1024 + (se.charCodeAt(ge + 1) - 56320);
      return this.i = ge + 2, Ze > 1114111 && this.fail("disallowed character."), Ze;
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.1.
     *
     * @returns {number} The character read.
     */
    getCode11() {
      const { chunk: se, i: ge } = this;
      if (this.prevI = ge, this.i = ge + 1, ge >= se.length)
        return y;
      const Se = se.charCodeAt(ge);
      if (this.column++, Se < 55296) {
        if (Se > 31 && Se < 127 || Se > 159 && Se !== ht || Se === D)
          return Se;
        switch (Se) {
          case C:
            return this.line++, this.column = 0, this.positionAtNewLine = this.position, C;
          case X: {
            const et = se.charCodeAt(ge + 1);
            (et === C || et === Ye) && (this.i = ge + 2);
          }
          /* yes, fall through */
          case Ye:
          // 0x85
          case ht:
            return this.line++, this.column = 0, this.positionAtNewLine = this.position, m;
          default:
            return this.fail("disallowed character."), Se;
        }
      }
      if (Se > 56319)
        return Se >= 57344 && Se <= 65533 || this.fail("disallowed character."), Se;
      const Ze = 65536 + (Se - 55296) * 1024 + (se.charCodeAt(ge + 1) - 56320);
      return this.i = ge + 2, Ze > 1114111 && this.fail("disallowed character."), Ze;
    }
    /**
     * Like ``getCode`` but with the return value normalized so that ``NL`` is
     * returned for ``NL_LIKE``.
     */
    getCodeNorm() {
      const se = this.getCode();
      return se === m ? C : se;
    }
    unget() {
      this.i = this.prevI, this.column--;
    }
    /**
     * Capture characters into a buffer until encountering one of a set of
     * characters.
     *
     * @param chars An array of codepoints. Encountering a character in the array
     * ends the capture. (``chars`` may safely contain ``NL``.)
     *
     * @return The character code that made the capture end, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    captureTo(se) {
      let { i: ge } = this;
      const { chunk: Se } = this;
      for (; ; ) {
        const Ze = this.getCode(), et = Ze === m, Tt = et ? C : Ze;
        if (Tt === y || se.includes(Tt))
          return this.text += Se.slice(ge, this.prevI), Tt;
        et && (this.text += `${Se.slice(ge, this.prevI)}
`, ge = this.i);
      }
    }
    /**
     * Capture characters into a buffer until encountering a character.
     *
     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
     *
     * @return ``true`` if we ran into the character. Otherwise, we ran into the
     * end of the current chunk.
     */
    captureToChar(se) {
      let { i: ge } = this;
      const { chunk: Se } = this;
      for (; ; ) {
        let Ze = this.getCode();
        switch (Ze) {
          case m:
            this.text += `${Se.slice(ge, this.prevI)}
`, ge = this.i, Ze = C;
            break;
          case y:
            return this.text += Se.slice(ge), !1;
        }
        if (Ze === se)
          return this.text += Se.slice(ge, this.prevI), !0;
      }
    }
    /**
     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
     * this parser.
     *
     * @return The character code that made the test fail, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    captureNameChars() {
      const { chunk: se, i: ge } = this;
      for (; ; ) {
        const Se = this.getCode();
        if (Se === y)
          return this.name += se.slice(ge), y;
        if (!n(Se))
          return this.name += se.slice(ge, this.prevI), Se === m ? C : Se;
      }
    }
    /**
     * Skip white spaces.
     *
     * @return The character that ended the skip, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    skipSpaces() {
      for (; ; ) {
        const se = this.getCodeNorm();
        if (se === y || !a(se))
          return se;
      }
    }
    setXMLVersion(se) {
      this.currentXMLVersion = se, se === "1.0" ? (this.isChar = t, this.getCode = this.getCode10) : (this.isChar = s, this.getCode = this.getCode11);
    }
    // STATE ENGINE METHODS
    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
    // to be sure never to come back to this state later.
    sBegin() {
      this.chunk.charCodeAt(0) === 65279 && (this.i++, this.column++), this.state = T;
    }
    sBeginWhitespace() {
      const se = this.i, ge = this.skipSpaces();
      switch (this.prevI !== se && (this.xmlDeclPossible = !1), ge) {
        case Ee:
          if (this.state = G, this.text.length !== 0)
            throw new Error("no-empty text at start");
          break;
        case y:
          break;
        default:
          this.unget(), this.state = q, this.xmlDeclPossible = !1;
      }
    }
    sDoctype() {
      var se;
      const ge = this.captureTo(je);
      switch (ge) {
        case Ue: {
          (se = this.doctypeHandler) === null || se === void 0 || se.call(this, this.text), this.text = "", this.state = q, this.doctype = !0;
          break;
        }
        case y:
          break;
        default:
          this.text += String.fromCodePoint(ge), ge === tt ? this.state = R : ne(ge) && (this.state = E, this.q = ge);
      }
    }
    sDoctypeQuote() {
      const se = this.q;
      this.captureToChar(se) && (this.text += String.fromCodePoint(se), this.q = null, this.state = v);
    }
    sDTD() {
      const se = this.captureTo($e);
      se !== y && (this.text += String.fromCodePoint(se), se === it ? this.state = v : se === Ee ? this.state = A : ne(se) && (this.state = L, this.q = se));
    }
    sDTDQuoted() {
      const se = this.q;
      this.captureToChar(se) && (this.text += String.fromCodePoint(se), this.state = R, this.q = null);
    }
    sDTDOpenWaka() {
      const se = this.getCodeNorm();
      switch (this.text += String.fromCodePoint(se), se) {
        case de:
          this.state = w, this.openWakaBang = "";
          break;
        case Le:
          this.state = F;
          break;
        default:
          this.state = R;
      }
    }
    sDTDOpenWakaBang() {
      const se = String.fromCodePoint(this.getCodeNorm()), ge = this.openWakaBang += se;
      this.text += se, ge !== "-" && (this.state = ge === "--" ? S : R, this.openWakaBang = "");
    }
    sDTDComment() {
      this.captureToChar(qe) && (this.text += "-", this.state = O);
    }
    sDTDCommentEnding() {
      const se = this.getCodeNorm();
      this.text += String.fromCodePoint(se), this.state = se === qe ? x : S;
    }
    sDTDCommentEnded() {
      const se = this.getCodeNorm();
      this.text += String.fromCodePoint(se), se === Ue ? this.state = R : (this.fail("malformed comment."), this.state = S);
    }
    sDTDPI() {
      this.captureToChar(Le) && (this.text += "?", this.state = j);
    }
    sDTDPIEnding() {
      const se = this.getCodeNorm();
      this.text += String.fromCodePoint(se), se === Ue && (this.state = R);
    }
    sText() {
      this.tags.length !== 0 ? this.handleTextInRoot() : this.handleTextOutsideRoot();
    }
    sEntity() {
      let { i: se } = this;
      const { chunk: ge } = this;
      e:
        for (; ; )
          switch (this.getCode()) {
            case m:
              this.entity += `${ge.slice(se, this.prevI)}
`, se = this.i;
              break;
            case Y: {
              const { entityReturnState: Se } = this, Ze = this.entity + ge.slice(se, this.prevI);
              this.state = Se;
              let et;
              Ze === "" ? (this.fail("empty entity name."), et = "&;") : (et = this.parseEntity(Ze), this.entity = ""), (Se !== q || this.textHandler !== void 0) && (this.text += et);
              break e;
            }
            case y:
              this.entity += ge.slice(se);
              break e;
          }
    }
    sOpenWaka() {
      const se = this.getCode();
      if (e(se))
        this.state = H, this.unget(), this.xmlDeclPossible = !1;
      else
        switch (se) {
          case Ke:
            this.state = ue, this.xmlDeclPossible = !1;
            break;
          case de:
            this.state = K, this.openWakaBang = "", this.xmlDeclPossible = !1;
            break;
          case Le:
            this.state = we;
            break;
          default:
            this.fail("disallowed character in tag name"), this.state = q, this.xmlDeclPossible = !1;
        }
    }
    sOpenWakaBang() {
      switch (this.openWakaBang += String.fromCodePoint(this.getCodeNorm()), this.openWakaBang) {
        case "[CDATA[":
          !this.sawRoot && !this.reportedTextBeforeRoot && (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = !0), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = !0), this.state = pe, this.openWakaBang = "";
          break;
        case "--":
          this.state = U, this.openWakaBang = "";
          break;
        case "DOCTYPE":
          this.state = v, (this.doctype || this.sawRoot) && this.fail("inappropriately located doctype declaration."), this.openWakaBang = "";
          break;
        default:
          this.openWakaBang.length >= 7 && this.fail("incorrect syntax.");
      }
    }
    sComment() {
      this.captureToChar(qe) && (this.state = ae);
    }
    sCommentEnding() {
      var se;
      const ge = this.getCodeNorm();
      ge === qe ? (this.state = ye, (se = this.commentHandler) === null || se === void 0 || se.call(this, this.text), this.text = "") : (this.text += `-${String.fromCodePoint(ge)}`, this.state = U);
    }
    sCommentEnded() {
      const se = this.getCodeNorm();
      se !== Ue ? (this.fail("malformed comment."), this.text += `--${String.fromCodePoint(se)}`, this.state = U) : this.state = q;
    }
    sCData() {
      this.captureToChar(it) && (this.state = ee);
    }
    sCDataEnding() {
      const se = this.getCodeNorm();
      se === it ? this.state = Te : (this.text += `]${String.fromCodePoint(se)}`, this.state = pe);
    }
    sCDataEnding2() {
      var se;
      const ge = this.getCodeNorm();
      switch (ge) {
        case Ue: {
          (se = this.cdataHandler) === null || se === void 0 || se.call(this, this.text), this.text = "", this.state = q;
          break;
        }
        case it:
          this.text += "]";
          break;
        default:
          this.text += `]]${String.fromCodePoint(ge)}`, this.state = pe;
      }
    }
    // We need this separate state to check the first character fo the pi target
    // with this.nameStartCheck which allows less characters than this.nameCheck.
    sPIFirstChar() {
      const se = this.getCodeNorm();
      this.nameStartCheck(se) ? (this.piTarget += String.fromCodePoint(se), this.state = Oe) : se === Le || a(se) ? (this.fail("processing instruction without a target."), this.state = se === Le ? he : be) : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(se), this.state = Oe);
    }
    sPIRest() {
      const { chunk: se, i: ge } = this;
      for (; ; ) {
        const Se = this.getCodeNorm();
        if (Se === y) {
          this.piTarget += se.slice(ge);
          return;
        }
        if (!this.nameCheck(Se)) {
          this.piTarget += se.slice(ge, this.prevI);
          const Ze = Se === Le;
          Ze || a(Se) ? this.piTarget === "xml" ? (this.xmlDeclPossible || this.fail("an XML declaration must be at the start of the document."), this.state = Ze ? z : V) : this.state = Ze ? he : be : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(Se));
          break;
        }
      }
    }
    sPIBody() {
      if (this.text.length === 0) {
        const se = this.getCodeNorm();
        se === Le ? this.state = he : a(se) || (this.text = String.fromCodePoint(se));
      } else this.captureToChar(Le) && (this.state = he);
    }
    sPIEnding() {
      var se;
      const ge = this.getCodeNorm();
      if (ge === Ue) {
        const { piTarget: Se } = this;
        Se.toLowerCase() === "xml" && this.fail("the XML declaration must appear at the start of the document."), (se = this.piHandler) === null || se === void 0 || se.call(this, {
          target: Se,
          body: this.text
        }), this.piTarget = this.text = "", this.state = q;
      } else ge === Le ? this.text += "?" : (this.text += `?${String.fromCodePoint(ge)}`, this.state = be);
      this.xmlDeclPossible = !1;
    }
    sXMLDeclNameStart() {
      const se = this.skipSpaces();
      if (se === Le) {
        this.state = z;
        return;
      }
      se !== y && (this.state = N, this.name = String.fromCodePoint(se));
    }
    sXMLDeclName() {
      const se = this.captureTo(He);
      if (se === Le) {
        this.state = z, this.name += this.text, this.text = "", this.fail("XML declaration is incomplete.");
        return;
      }
      if (a(se) || se === Ie) {
        if (this.name += this.text, this.text = "", !this.xmlDeclExpects.includes(this.name))
          switch (this.name.length) {
            case 0:
              this.fail("did not expect any more name/value pairs.");
              break;
            case 1:
              this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
              break;
            default:
              this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
          }
        this.state = se === Ie ? I : M;
      }
    }
    sXMLDeclEq() {
      const se = this.getCodeNorm();
      if (se === Le) {
        this.state = z, this.fail("XML declaration is incomplete.");
        return;
      }
      a(se) || (se !== Ie && this.fail("value required."), this.state = I);
    }
    sXMLDeclValueStart() {
      const se = this.getCodeNorm();
      if (se === Le) {
        this.state = z, this.fail("XML declaration is incomplete.");
        return;
      }
      a(se) || (ne(se) ? this.q = se : (this.fail("value must be quoted."), this.q = te), this.state = P);
    }
    sXMLDeclValue() {
      const se = this.captureTo([this.q, Le]);
      if (se === Le) {
        this.state = z, this.text = "", this.fail("XML declaration is incomplete.");
        return;
      }
      if (se === y)
        return;
      const ge = this.text;
      switch (this.text = "", this.name) {
        case "version": {
          this.xmlDeclExpects = ["encoding", "standalone"];
          const Se = ge;
          this.xmlDecl.version = Se, /^1\.[0-9]+$/.test(Se) ? this.opt.forceXMLVersion || this.setXMLVersion(Se) : this.fail("version number must match /^1\\.[0-9]+$/.");
          break;
        }
        case "encoding":
          /^[A-Za-z][A-Za-z0-9._-]*$/.test(ge) || this.fail("encoding value must match 	/^[A-Za-z0-9][A-Za-z0-9._-]*$/."), this.xmlDeclExpects = ["standalone"], this.xmlDecl.encoding = ge;
          break;
        case "standalone":
          ge !== "yes" && ge !== "no" && this.fail('standalone value must match "yes" or "no".'), this.xmlDeclExpects = [], this.xmlDecl.standalone = ge;
          break;
      }
      this.name = "", this.state = B;
    }
    sXMLDeclSeparator() {
      const se = this.getCodeNorm();
      if (se === Le) {
        this.state = z;
        return;
      }
      a(se) || (this.fail("whitespace required."), this.unget()), this.state = V;
    }
    sXMLDeclEnding() {
      var se;
      this.getCodeNorm() === Ue ? (this.piTarget !== "xml" ? this.fail("processing instructions are not allowed before root.") : this.name !== "version" && this.xmlDeclExpects.includes("version") && this.fail("XML declaration must contain a version."), (se = this.xmldeclHandler) === null || se === void 0 || se.call(this, this.xmlDecl), this.name = "", this.piTarget = this.text = "", this.state = q) : this.fail("The character ? is disallowed anywhere in XML declarations."), this.xmlDeclPossible = !1;
    }
    sOpenTag() {
      var se;
      const ge = this.captureNameChars();
      if (ge === y)
        return;
      const Se = this.tag = {
        name: this.name,
        attributes: /* @__PURE__ */ Object.create(null)
      };
      switch (this.name = "", this.xmlnsOpt && (this.topNS = Se.ns = /* @__PURE__ */ Object.create(null)), (se = this.openTagStartHandler) === null || se === void 0 || se.call(this, Se), this.sawRoot = !0, !this.fragmentOpt && this.closedRoot && this.fail("documents may contain only one root."), ge) {
        case Ue:
          this.openTag();
          break;
        case Ke:
          this.state = J;
          break;
        default:
          a(ge) || this.fail("disallowed character in tag name."), this.state = k;
      }
    }
    sOpenTagSlash() {
      this.getCode() === Ue ? this.openSelfClosingTag() : (this.fail("forward-slash in opening tag not followed by >."), this.state = k);
    }
    sAttrib() {
      const se = this.skipSpaces();
      se !== y && (e(se) ? (this.unget(), this.state = W) : se === Ue ? this.openTag() : se === Ke ? this.state = J : this.fail("disallowed character in attribute name."));
    }
    sAttribName() {
      const se = this.captureNameChars();
      se === Ie ? this.state = fe : a(se) ? this.state = le : se === Ue ? (this.fail("attribute without value."), this.pushAttrib(this.name, this.name), this.name = this.text = "", this.openTag()) : se !== y && this.fail("disallowed character in attribute name.");
    }
    sAttribNameSawWhite() {
      const se = this.skipSpaces();
      switch (se) {
        case y:
          return;
        case Ie:
          this.state = fe;
          break;
        default:
          this.fail("attribute without value."), this.text = "", this.name = "", se === Ue ? this.openTag() : e(se) ? (this.unget(), this.state = W) : (this.fail("disallowed character in attribute name."), this.state = k);
      }
    }
    sAttribValue() {
      const se = this.getCodeNorm();
      ne(se) ? (this.q = se, this.state = me) : a(se) || (this.fail("unquoted attribute value."), this.state = xe, this.unget());
    }
    sAttribValueQuoted() {
      const { q: se, chunk: ge } = this;
      let { i: Se } = this;
      for (; ; )
        switch (this.getCode()) {
          case se:
            this.pushAttrib(this.name, this.text + ge.slice(Se, this.prevI)), this.name = this.text = "", this.q = null, this.state = Ne;
            return;
          case De:
            this.text += ge.slice(Se, this.prevI), this.state = Q, this.entityReturnState = me;
            return;
          case C:
          case m:
          case D:
            this.text += `${ge.slice(Se, this.prevI)} `, Se = this.i;
            break;
          case Ee:
            this.text += ge.slice(Se, this.prevI), this.fail("disallowed character.");
            return;
          case y:
            this.text += ge.slice(Se);
            return;
        }
    }
    sAttribValueClosed() {
      const se = this.getCodeNorm();
      a(se) ? this.state = k : se === Ue ? this.openTag() : se === Ke ? this.state = J : e(se) ? (this.fail("no whitespace between attributes."), this.unget(), this.state = W) : this.fail("disallowed character in attribute name.");
    }
    sAttribValueUnquoted() {
      const se = this.captureTo(At);
      switch (se) {
        case De:
          this.state = Q, this.entityReturnState = xe;
          break;
        case Ee:
          this.fail("disallowed character.");
          break;
        case y:
          break;
        default:
          this.text.includes("]]>") && this.fail('the string "]]>" is disallowed in char data.'), this.pushAttrib(this.name, this.text), this.name = this.text = "", se === Ue ? this.openTag() : this.state = k;
      }
    }
    sCloseTag() {
      const se = this.captureNameChars();
      se === Ue ? this.closeTag() : a(se) ? this.state = $ : se !== y && this.fail("disallowed character in closing tag.");
    }
    sCloseTagSawWhite() {
      switch (this.skipSpaces()) {
        case Ue:
          this.closeTag();
          break;
        case y:
          break;
        default:
          this.fail("disallowed character in closing tag.");
      }
    }
    // END OF STATE ENGINE METHODS
    handleTextInRoot() {
      let { i: se, forbiddenState: ge } = this;
      const { chunk: Se, textHandler: Ze } = this;
      e:
        for (; ; )
          switch (this.getCode()) {
            case Ee: {
              if (this.state = G, Ze !== void 0) {
                const { text: et } = this, Tt = Se.slice(se, this.prevI);
                et.length !== 0 ? (Ze(et + Tt), this.text = "") : Tt.length !== 0 && Ze(Tt);
              }
              ge = rt;
              break e;
            }
            case De:
              this.state = Q, this.entityReturnState = q, Ze !== void 0 && (this.text += Se.slice(se, this.prevI)), ge = rt;
              break e;
            case it:
              switch (ge) {
                case rt:
                  ge = Et;
                  break;
                case Et:
                  ge = ot;
                  break;
                case ot:
                  break;
                default:
                  throw new Error("impossible state");
              }
              break;
            case Ue:
              ge === ot && this.fail('the string "]]>" is disallowed in char data.'), ge = rt;
              break;
            case m:
              Ze !== void 0 && (this.text += `${Se.slice(se, this.prevI)}
`), se = this.i, ge = rt;
              break;
            case y:
              Ze !== void 0 && (this.text += Se.slice(se));
              break e;
            default:
              ge = rt;
          }
      this.forbiddenState = ge;
    }
    handleTextOutsideRoot() {
      let { i: se } = this;
      const { chunk: ge, textHandler: Se } = this;
      let Ze = !1;
      e:
        for (; ; ) {
          const et = this.getCode();
          switch (et) {
            case Ee: {
              if (this.state = G, Se !== void 0) {
                const { text: Tt } = this, ar = ge.slice(se, this.prevI);
                Tt.length !== 0 ? (Se(Tt + ar), this.text = "") : ar.length !== 0 && Se(ar);
              }
              break e;
            }
            case De:
              this.state = Q, this.entityReturnState = q, Se !== void 0 && (this.text += ge.slice(se, this.prevI)), Ze = !0;
              break e;
            case m:
              Se !== void 0 && (this.text += `${ge.slice(se, this.prevI)}
`), se = this.i;
              break;
            case y:
              Se !== void 0 && (this.text += ge.slice(se));
              break e;
            default:
              a(et) || (Ze = !0);
          }
        }
      Ze && (!this.sawRoot && !this.reportedTextBeforeRoot && (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = !0), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = !0));
    }
    pushAttribNS(se, ge) {
      var Se;
      const { prefix: Ze, local: et } = this.qname(se), Tt = { name: se, prefix: Ze, local: et, value: ge };
      if (this.attribList.push(Tt), (Se = this.attributeHandler) === null || Se === void 0 || Se.call(this, Tt), Ze === "xmlns") {
        const ar = ge.trim();
        this.currentXMLVersion === "1.0" && ar === "" && this.fail("invalid attempt to undefine prefix in XML 1.0"), this.topNS[et] = ar, Qe(this, et, ar);
      } else if (se === "xmlns") {
        const ar = ge.trim();
        this.topNS[""] = ar, Qe(this, "", ar);
      }
    }
    pushAttribPlain(se, ge) {
      var Se;
      const Ze = { name: se, value: ge };
      this.attribList.push(Ze), (Se = this.attributeHandler) === null || Se === void 0 || Se.call(this, Ze);
    }
    /**
     * End parsing. This performs final well-formedness checks and resets the
     * parser to a clean state.
     *
     * @returns this
     */
    end() {
      var se, ge;
      this.sawRoot || this.fail("document must contain a root element.");
      const { tags: Se } = this;
      for (; Se.length > 0; ) {
        const et = Se.pop();
        this.fail(`unclosed tag: ${et.name}`);
      }
      this.state !== g && this.state !== q && this.fail("unexpected end.");
      const { text: Ze } = this;
      return Ze.length !== 0 && ((se = this.textHandler) === null || se === void 0 || se.call(this, Ze), this.text = ""), this._closed = !0, (ge = this.endHandler) === null || ge === void 0 || ge.call(this), this._init(), this;
    }
    /**
     * Resolve a namespace prefix.
     *
     * @param prefix The prefix to resolve.
     *
     * @returns The namespace URI or ``undefined`` if the prefix is not defined.
     */
    resolve(se) {
      var ge, Se;
      let Ze = this.topNS[se];
      if (Ze !== void 0)
        return Ze;
      const { tags: et } = this;
      for (let Tt = et.length - 1; Tt >= 0; Tt--)
        if (Ze = et[Tt].ns[se], Ze !== void 0)
          return Ze;
      return Ze = this.ns[se], Ze !== void 0 ? Ze : (Se = (ge = this.opt).resolvePrefix) === null || Se === void 0 ? void 0 : Se.call(ge, se);
    }
    /**
     * Parse a qname into its prefix and local name parts.
     *
     * @param name The name to parse
     *
     * @returns
     */
    qname(se) {
      const ge = se.indexOf(":");
      if (ge === -1)
        return { prefix: "", local: se };
      const Se = se.slice(ge + 1), Ze = se.slice(0, ge);
      return (Ze === "" || Se === "" || Se.includes(":")) && this.fail(`malformed name: ${se}.`), { prefix: Ze, local: Se };
    }
    processAttribsNS() {
      var se;
      const { attribList: ge } = this, Se = this.tag;
      {
        const { prefix: Tt, local: ar } = this.qname(Se.name);
        Se.prefix = Tt, Se.local = ar;
        const kt = Se.uri = (se = this.resolve(Tt)) !== null && se !== void 0 ? se : "";
        Tt !== "" && (Tt === "xmlns" && this.fail('tags may not have "xmlns" as prefix.'), kt === "" && (this.fail(`unbound namespace prefix: ${JSON.stringify(Tt)}.`), Se.uri = Tt));
      }
      if (ge.length === 0)
        return;
      const { attributes: Ze } = Se, et = /* @__PURE__ */ new Set();
      for (const Tt of ge) {
        const { name: ar, prefix: kt, local: Ui } = Tt;
        let yn, Kt;
        kt === "" ? (yn = ar === "xmlns" ? p : "", Kt = ar) : (yn = this.resolve(kt), yn === void 0 && (this.fail(`unbound namespace prefix: ${JSON.stringify(kt)}.`), yn = kt), Kt = `{${yn}}${Ui}`), et.has(Kt) && this.fail(`duplicate attribute: ${Kt}.`), et.add(Kt), Tt.uri = yn, Ze[ar] = Tt;
      }
      this.attribList = [];
    }
    processAttribsPlain() {
      const { attribList: se } = this, ge = this.tag.attributes;
      for (const { name: Se, value: Ze } of se)
        ge[Se] !== void 0 && this.fail(`duplicate attribute: ${Se}.`), ge[Se] = Ze;
      this.attribList = [];
    }
    /**
     * Handle a complete open tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onopentag``.
     */
    openTag() {
      var se;
      this.processAttribs();
      const { tags: ge } = this, Se = this.tag;
      Se.isSelfClosing = !1, (se = this.openTagHandler) === null || se === void 0 || se.call(this, Se), ge.push(Se), this.state = q, this.name = "";
    }
    /**
     * Handle a complete self-closing tag. This parser code calls this once it has
     * seen the whole tag. This method checks for well-formeness and then emits
     * ``onopentag`` and ``onclosetag``.
     */
    openSelfClosingTag() {
      var se, ge, Se;
      this.processAttribs();
      const { tags: Ze } = this, et = this.tag;
      et.isSelfClosing = !0, (se = this.openTagHandler) === null || se === void 0 || se.call(this, et), (ge = this.closeTagHandler) === null || ge === void 0 || ge.call(this, et), (this.tag = (Se = Ze[Ze.length - 1]) !== null && Se !== void 0 ? Se : null) === null && (this.closedRoot = !0), this.state = q, this.name = "";
    }
    /**
     * Handle a complete close tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onclosetag``.
     */
    closeTag() {
      const { tags: se, name: ge } = this;
      if (this.state = q, this.name = "", ge === "") {
        this.fail("weird empty close tag."), this.text += "</>";
        return;
      }
      const Se = this.closeTagHandler;
      let Ze = se.length;
      for (; Ze-- > 0; ) {
        const et = this.tag = se.pop();
        if (this.topNS = et.ns, Se == null || Se(et), et.name === ge)
          break;
        this.fail("unexpected close tag.");
      }
      Ze === 0 ? this.closedRoot = !0 : Ze < 0 && (this.fail(`unmatched closing tag: ${ge}.`), this.text += `</${ge}>`);
    }
    /**
     * Resolves an entity. Makes any necessary well-formedness checks.
     *
     * @param entity The entity to resolve.
     *
     * @returns The parsed entity.
     */
    parseEntity(se) {
      if (se[0] !== "#") {
        const Se = this.ENTITIES[se];
        return Se !== void 0 ? Se : (this.fail(this.isName(se) ? "undefined entity." : "disallowed character in entity name."), `&${se};`);
      }
      let ge = NaN;
      return se[1] === "x" && /^#x[0-9a-f]+$/i.test(se) ? ge = parseInt(se.slice(2), 16) : /^#[0-9]+$/.test(se) && (ge = parseInt(se.slice(1), 10)), this.isChar(ge) ? String.fromCodePoint(ge) : (this.fail("malformed character entity."), `&${se};`);
    }
  }
  return as.SaxesParser = Ur, as;
}
var lb = {}, s7;
function gse() {
  if (s7) return lb;
  s7 = 1, Object.defineProperty(lb, "__esModule", { value: !0 }), lb.ParseError = void 0;
  let u = class extends Error {
    constructor(o, a) {
      const t = o.saxParser;
      super(o.trackPosition ? `Line ${t.line} column ${t.column + 1}: ${a}` : a);
    }
  };
  return lb.ParseError = u, lb;
}
var us = {}, EE = {}, c7;
function mse() {
  return c7 || (c7 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.validateIri = u.IriValidationStrategy = void 0;
    function r() {
      const i = "[!$&'()*+,;=]", c = "%[a-fA-F0-9]{2}", s = "([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])", d = `${s}\\.${s}\\.${s}\\.${s}`, l = "[a-fA-F0-9]{1,4}", f = `(${l}:${l}|${d})`, h = `((${l}:){6}${f}|::(${l}:){5}${f}|(${l})?::(${l}:){4}${f}|((${l}:){0,1}${l})?::(${l}:){3}${f}|((${l}:){0,2}${l})?::(${l}:){2}${f}|((${l}:){0,3}${l})?::${l}:${f}|((${l}:){0,4}${l})?::${f}|((${l}:){0,5}${l})?::${l}|((${l}:){0,6}${l})?::)`, p = `v[a-fA-F0-9]+\\.(${i}|${i}|":)+`, b = `\\[(${h}|${p})\\]`, _ = "[0-9]*", y = "[a-zA-Z][a-zA-Z0-9+\\-.]*", g = "[î-ï£¿ó°-ó¿¿½ô-ô¿½]", E = "[a-zA-Z0-9\\-._~Â -í¿ï¤-ï·ï·°-ï¿¯ð-ð¿½ð -ð¯¿½ð°-ð¿¿½ñ-ñ¿½ñ-ñ¿½ñ -ñ¯¿½ñ°-ñ¿¿½ò-ò¿½ò-ò¿½ò -ò¯¿½ò°-ò¿¿½ó-ó¿½ó-ó¿½ó¡-ó¯¿½]", R = `(${E}|${c}|${i}|[:@])*`, L = `(${R}|[\\/?])*`, A = `(${R}|${g}|[\\/?])*`, w = `(${R})+`, S = `(${R})*`, O = "", x = `${w}(\\/${S})*`, F = `\\/(${w}(\\/${S})*)?`, j = `(\\/${S})*`, q = `(${E}|${c}|${i})*`, Q = `(${b}|${d}|${q})`, U = `(\\/\\/${`(${`(${E}|${c}|${i}|:)*`}@)?${Q}(:${_})?`}${j}|${F}|${x}|${O})`, ae = `^${y}:${U}(\\?${A})?(#${L})?$`;
      return new RegExp(ae, "u");
    }
    const o = r(), a = /^[A-Za-z][\d+-.A-Za-z]*:[^\u0000-\u0020"<>\\^`{|}]*$/u;
    var t;
    (function(n) {
      n.Strict = "strict", n.Pragmatic = "pragmatic", n.None = "none";
    })(t = u.IriValidationStrategy || (u.IriValidationStrategy = {}));
    function e(n, i = t.Strict) {
      switch (i) {
        case t.Strict:
          return o.test(n) ? void 0 : new Error(`Invalid IRI according to RFC 3987: '${n}'`);
        case t.Pragmatic:
          return a.test(n) ? void 0 : new Error(`Invalid IRI according to RDF Turtle: '${n}'`);
        case t.None:
          return;
        default:
          return new Error(`Not supported validation strategy "${i}"`);
      }
    }
    u.validateIri = e;
  }(EE)), EE;
}
var d7;
function vse() {
  return d7 || (d7 = 1, function(u) {
    var r = us && us.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = us && us.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(mse(), u);
  }(us)), us;
}
var l7;
function Tse() {
  if (l7) return is;
  l7 = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.ParseType = is.RdfXmlParser = void 0;
  const u = Tr(), r = aY(), o = Bt(), a = /* @__PURE__ */ gse(), t = Or(), e = vse();
  let n = class or extends o.Transform {
    constructor(s) {
      super({ readableObjectMode: !0 }), this.activeTagStack = [], this.nodeIds = {}, s && (Object.assign(this, s), this.options = s), this.dataFactory || (this.dataFactory = new t.DataFactory()), this.baseIRI || (this.baseIRI = ""), this.defaultGraph || (this.defaultGraph = this.dataFactory.defaultGraph()), this.validateUri !== !1 && (this.validateUri = !0), this.iriValidationStrategy || (this.iriValidationStrategy = this.validateUri ? e.IriValidationStrategy.Pragmatic : e.IriValidationStrategy.None), this.saxParser = new r.SaxesParser({ xmlns: !0, position: this.trackPosition }), this.attachSaxListeners();
    }
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {RDF.Stream} A quad stream.
     */
    import(s) {
      const d = new o.PassThrough({ readableObjectMode: !0 });
      s.on("error", (f) => l.emit("error", f)), s.on("data", (f) => d.push(f)), s.on("end", () => d.push(null));
      const l = d.pipe(new or(this.options));
      return l;
    }
    _transform(s, d, l) {
      try {
        this.saxParser.write(s);
      } catch (f) {
        return l(f);
      }
      l();
    }
    /**
     * Create a new parse error instance.
     * @param {string} message An error message.
     * @return {Error} An error instance.
     */
    newParseError(s) {
      return new a.ParseError(this, s);
    }
    /**
     * Convert the given value to a IRI by taking into account the baseIRI.
     *
     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.
     *
     * @param {string} value The value to convert to an IRI.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} an IRI.
     */
    valueToUri(s, d) {
      return this.uriToNamedNode((0, u.resolve)(s, d.baseIRI));
    }
    /**
     * Convert the given value URI string to a named node.
     *
     * This throw an error if the URI is invalid.
     *
     * @param {string} uri A URI string.
     * @return {NamedNode} a named node.
     */
    uriToNamedNode(s) {
      const d = (0, e.validateIri)(s, this.iriValidationStrategy);
      if (d instanceof Error)
        throw this.newParseError(d.message);
      return this.dataFactory.namedNode(s);
    }
    /**
     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName
     * If it is invalid, an error will thrown emitted.
     * @param {string} value A value.
     */
    validateNcname(s) {
      if (!or.NCNAME_MATCHER.test(s))
        throw this.newParseError(`Not a valid NCName: ${s}`);
    }
    attachSaxListeners() {
      this.saxParser.on("error", (s) => this.emit("error", s)), this.saxParser.on("opentag", this.onTag.bind(this)), this.saxParser.on("text", this.onText.bind(this)), this.saxParser.on("cdata", this.onText.bind(this)), this.saxParser.on("closetag", this.onCloseTag.bind(this)), this.saxParser.on("doctype", this.onDoctype.bind(this));
    }
    /**
     * Handle the given tag.
     * @param {SaxesTagNS} tag A SAX tag.
     */
    onTag(s) {
      const d = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
      let l = i.RESOURCE;
      if (d && (d.hadChildren = !0, l = d.childrenParseType), d && d.childrenStringTags) {
        const h = s.name;
        let p = "";
        for (const m in s.attributes)
          p += ` ${m}="${s.attributes[m].value}"`;
        const _ = `<${`${h}${p}`}>`;
        d.childrenStringTags.push(_);
        const y = { childrenStringTags: d.childrenStringTags };
        y.childrenStringEmitClosingTag = `</${h}>`, this.activeTagStack.push(y);
        return;
      }
      const f = {};
      d ? (f.language = d.language, f.baseIRI = d.baseIRI) : f.baseIRI = this.baseIRI, this.activeTagStack.push(f), l === i.RESOURCE ? this.onTagResource(s, f, d, !d) : this.onTagProperty(s, f, d);
    }
    /**
     * Handle the given node element in resource-mode.
     * @param {SaxesTagNS} tag A SAX tag.
     * @param {IActiveTag} activeTag The currently active tag.
     * @param {IActiveTag} parentTag The parent tag or null.
     * @param {boolean} rootTag If we are currently processing the root tag.
     */
    onTagResource(s, d, l, f) {
      d.childrenParseType = i.PROPERTY;
      let h = !0;
      if (s.uri === or.RDF) {
        if (!f && or.FORBIDDEN_NODE_ELEMENTS.indexOf(s.local) >= 0)
          throw this.newParseError(`Illegal node element name: ${s.local}`);
        switch (s.local) {
          case "RDF":
            d.childrenParseType = i.RESOURCE;
          case "Description":
            h = !1;
        }
      }
      const p = [], b = [];
      let _ = null, y = !1, m = !1, g = null;
      for (const T in s.attributes) {
        const v = s.attributes[T];
        if (l && v.uri === or.RDF)
          switch (v.local) {
            case "about":
              if (_)
                throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${v.value} and ${_} where found.`);
              _ = v.value;
              continue;
            case "ID":
              if (_)
                throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${v.value} and ${_} where found.`);
              this.validateNcname(v.value), _ = "#" + v.value, y = !0;
              continue;
            case "nodeID":
              if (_)
                throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${v.value} and ${_} where found.`);
              this.validateNcname(v.value), _ = v.value, m = !0;
              continue;
            case "bagID":
              throw this.newParseError("rdf:bagID is not supported.");
            case "type":
              g = v.value;
              continue;
            case "aboutEach":
              throw this.newParseError("rdf:aboutEach is not supported.");
            case "aboutEachPrefix":
              throw this.newParseError("rdf:aboutEachPrefix is not supported.");
            case "li":
              throw this.newParseError("rdf:li on node elements are not supported.");
          }
        else if (v.uri === or.XML) {
          if (v.local === "lang") {
            d.language = v.value === "" ? null : v.value.toLowerCase();
            continue;
          } else if (v.local === "base") {
            d.baseIRI = (0, u.resolve)(v.value, d.baseIRI);
            continue;
          }
        }
        v.prefix !== "xml" && v.prefix !== "xmlns" && (v.prefix !== "" || v.local !== "xmlns") && v.uri && (p.push(this.uriToNamedNode(v.uri + v.local)), b.push(v.value));
      }
      if (_ !== null && (d.subject = m ? this.dataFactory.blankNode(_) : this.valueToUri(_, d), y && this.claimNodeId(d.subject)), d.subject || (d.subject = this.dataFactory.blankNode()), h) {
        const T = this.uriToNamedNode(s.uri + s.local);
        this.emitTriple(d.subject, this.dataFactory.namedNode(or.RDF + "type"), T, l ? l.reifiedStatementId : null);
      }
      if (l) {
        if (l.predicate)
          if (l.childrenCollectionSubject) {
            const T = this.dataFactory.blankNode();
            this.emitTriple(l.childrenCollectionSubject, l.childrenCollectionPredicate, T, l.reifiedStatementId), this.emitTriple(T, this.dataFactory.namedNode(or.RDF + "first"), d.subject, d.reifiedStatementId), l.childrenCollectionSubject = T, l.childrenCollectionPredicate = this.dataFactory.namedNode(or.RDF + "rest");
          } else {
            this.emitTriple(l.subject, l.predicate, d.subject, l.reifiedStatementId);
            for (let T = 0; T < l.predicateSubPredicates.length; T++)
              this.emitTriple(d.subject, l.predicateSubPredicates[T], l.predicateSubObjects[T], null);
            l.predicateSubPredicates = [], l.predicateSubObjects = [], l.predicateEmitted = !0;
          }
        for (let T = 0; T < p.length; T++) {
          const v = this.dataFactory.literal(b[T], d.datatype || d.language);
          this.emitTriple(d.subject, p[T], v, l.reifiedStatementId);
        }
        g && this.emitTriple(d.subject, this.dataFactory.namedNode(or.RDF + "type"), this.uriToNamedNode(g), null);
      }
    }
    /**
     * Handle the given property element in property-mode.
     * @param {SaxesTagNS} tag A SAX tag.
     * @param {IActiveTag} activeTag The currently active tag.
     * @param {IActiveTag} parentTag The parent tag or null.
     */
    onTagProperty(s, d, l) {
      if (d.childrenParseType = i.RESOURCE, d.subject = l.subject, s.uri === or.RDF && s.local === "li" ? (l.listItemCounter || (l.listItemCounter = 1), d.predicate = this.uriToNamedNode(s.uri + "_" + l.listItemCounter++)) : d.predicate = this.uriToNamedNode(s.uri + s.local), s.uri === or.RDF && or.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(s.local) >= 0)
        throw this.newParseError(`Illegal property element name: ${s.local}`);
      d.predicateSubPredicates = [], d.predicateSubObjects = [];
      let f = !1, h = !1, p = null, b = !0;
      const _ = [], y = [];
      for (const m in s.attributes) {
        const g = s.attributes[m];
        if (g.uri === or.RDF)
          switch (g.local) {
            case "resource":
              if (p)
                throw this.newParseError(`Found both rdf:resource (${g.value}) and rdf:nodeID (${p}).`);
              if (f)
                throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${g.value})`);
              d.hadChildren = !0, p = g.value, b = !1;
              continue;
            case "datatype":
              if (h)
                throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${g.value}).`);
              if (f)
                throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${g.value})`);
              d.datatype = this.valueToUri(g.value, d);
              continue;
            case "nodeID":
              if (h)
                throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${g.value}).`);
              if (d.hadChildren)
                throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${g.value}).`);
              if (f)
                throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${g.value})`);
              this.validateNcname(g.value), d.hadChildren = !0, p = g.value, b = !0;
              continue;
            case "bagID":
              throw this.newParseError("rdf:bagID is not supported.");
            case "parseType":
              if (h)
                throw this.newParseError("rdf:parseType is not allowed when non-rdf:* property attributes are present");
              if (d.datatype)
                throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${d.datatype.value})`);
              if (p)
                throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${p})`);
              if (g.value === "Resource") {
                f = !0, d.childrenParseType = i.PROPERTY;
                const T = this.dataFactory.blankNode();
                this.emitTriple(d.subject, d.predicate, T, d.reifiedStatementId), d.subject = T, d.predicate = null;
              } else g.value === "Collection" ? (f = !0, d.hadChildren = !0, d.childrenCollectionSubject = d.subject, d.childrenCollectionPredicate = d.predicate, b = !1) : g.value === "Literal" && (f = !0, d.childrenTagsToString = !0, d.childrenStringTags = []);
              continue;
            case "ID":
              this.validateNcname(g.value), d.reifiedStatementId = this.valueToUri("#" + g.value, d), this.claimNodeId(d.reifiedStatementId);
              continue;
          }
        else if (g.uri === or.XML && g.local === "lang") {
          d.language = g.value === "" ? null : g.value.toLowerCase();
          continue;
        }
        if (g.prefix !== "xml" && g.prefix !== "xmlns" && (g.prefix !== "" || g.local !== "xmlns") && g.uri) {
          if (f || d.datatype)
            throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${g.value}`);
          d.hadChildren = !0, h = !0, _.push(this.uriToNamedNode(g.uri + g.local)), y.push(this.dataFactory.literal(g.value, d.datatype || d.language));
        }
      }
      if (p !== null) {
        const m = d.subject;
        d.subject = b ? this.dataFactory.blankNode(p) : this.valueToUri(p, d), this.emitTriple(m, d.predicate, d.subject, d.reifiedStatementId);
        for (let g = 0; g < _.length; g++)
          this.emitTriple(d.subject, _[g], y[g], null);
        d.predicateEmitted = !0;
      } else b && (d.predicateSubPredicates = _, d.predicateSubObjects = y, d.predicateEmitted = !1);
    }
    /**
     * Emit the given triple to the stream.
     * @param {Term} subject A subject term.
     * @param {Term} predicate A predicate term.
     * @param {Term} object An object term.
     * @param {Term} statementId An optional resource that identifies the triple.
     *                           If truthy, then the given triple will also be emitted reified.
     */
    emitTriple(s, d, l, f) {
      this.push(this.dataFactory.quad(s, d, l, this.defaultGraph)), f && (this.push(this.dataFactory.quad(f, this.dataFactory.namedNode(or.RDF + "type"), this.dataFactory.namedNode(or.RDF + "Statement"), this.defaultGraph)), this.push(this.dataFactory.quad(f, this.dataFactory.namedNode(or.RDF + "subject"), s, this.defaultGraph)), this.push(this.dataFactory.quad(f, this.dataFactory.namedNode(or.RDF + "predicate"), d, this.defaultGraph)), this.push(this.dataFactory.quad(f, this.dataFactory.namedNode(or.RDF + "object"), l, this.defaultGraph)));
    }
    /**
     * Register the given term as a node ID.
     * If one was already registered, this will emit an error.
     *
     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.
     * @param {Term} term An RDF term.
     */
    claimNodeId(s) {
      if (!this.allowDuplicateRdfIds) {
        if (this.nodeIds[s.value])
          throw this.newParseError(`Found multiple occurrences of rdf:ID='${s.value}'.`);
        this.nodeIds[s.value] = !0;
      }
    }
    /**
     * Handle the given text string.
     * @param {string} text A parsed text string.
     */
    onText(s) {
      const d = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
      d && (d.childrenStringTags ? d.childrenStringTags.push(s) : d.predicate && (d.text = s));
    }
    /**
     * Handle the closing of the last tag.
     */
    onCloseTag() {
      const s = this.activeTagStack.pop();
      if (s.childrenStringEmitClosingTag && s.childrenStringTags.push(s.childrenStringEmitClosingTag), s.childrenTagsToString && (s.datatype = this.dataFactory.namedNode(or.RDF + "XMLLiteral"), s.text = s.childrenStringTags.join(""), s.hadChildren = !1), s.childrenCollectionSubject)
        this.emitTriple(s.childrenCollectionSubject, s.childrenCollectionPredicate, this.dataFactory.namedNode(or.RDF + "nil"), s.reifiedStatementId);
      else if (s.predicate) {
        if (!s.hadChildren && s.childrenParseType !== i.PROPERTY)
          this.emitTriple(s.subject, s.predicate, this.dataFactory.literal(s.text || "", s.datatype || s.language), s.reifiedStatementId);
        else if (!s.predicateEmitted) {
          const d = this.dataFactory.blankNode();
          this.emitTriple(s.subject, s.predicate, d, s.reifiedStatementId);
          for (let l = 0; l < s.predicateSubPredicates.length; l++)
            this.emitTriple(d, s.predicateSubPredicates[l], s.predicateSubObjects[l], null);
        }
      }
    }
    /**
     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.
     * @param {string} doctype The read doctype.
     */
    onDoctype(s) {
      s.replace(/<!ENTITY\s+([^\s]+)\s+["']([^"']+)["']\s*>/g, (d, l, f) => (this.saxParser.ENTITIES[l] = f, ""));
    }
  };
  is.RdfXmlParser = n, n.MIME_TYPE = "application/rdf+xml", n.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", n.XML = "http://www.w3.org/XML/1998/namespace", n.FORBIDDEN_NODE_ELEMENTS = [
    "RDF",
    "ID",
    "about",
    "bagID",
    "parseType",
    "resource",
    "nodeID",
    "li",
    "aboutEach",
    "aboutEachPrefix"
  ], n.FORBIDDEN_PROPERTY_ELEMENTS = [
    "Description",
    "RDF",
    "ID",
    "about",
    "bagID",
    "parseType",
    "resource",
    "nodeID",
    "aboutEach",
    "aboutEachPrefix"
  ], n.NCNAME_MATCHER = /^([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_])([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_\-.0-9#xB7\u{0300}-\u{036F}\u{203F}-\u{2040}])*$/u;
  var i;
  return function(c) {
    c[c.RESOURCE = 0] = "RESOURCE", c[c.PROPERTY = 1] = "PROPERTY";
  }(i || (is.ParseType = i = {})), is;
}
var f7;
function wse() {
  return f7 || (f7 = 1, function(u) {
    var r = ns && ns.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ns && ns.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Tse(), u);
  }(ns)), ns;
}
var h7;
function Sse() {
  if (h7) return db;
  h7 = 1, Object.defineProperty(db, "__esModule", { value: !0 }), db.ActorRdfParseRdfXml = void 0;
  const u = /* @__PURE__ */ yh(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ wse();
  let a = class extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/rdf+xml": 1.0
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/rdf+xml": "http://www.w3.org/ns/formats/RDF_XML"
     *     }} mediaTypeFormats
     */
    constructor(e) {
      super(e);
    }
    async runHandle(e) {
      var c;
      const n = e.context.getSafe(r.KeysInitQuery.dataFactory);
      e.data.on("error", (s) => i.emit("error", s));
      const i = e.data.pipe(new o.RdfXmlParser({
        dataFactory: n,
        baseIRI: (c = e.metadata) == null ? void 0 : c.baseIRI
      }));
      return {
        data: i,
        metadata: { triples: !0 }
      };
    }
  };
  return db.ActorRdfParseRdfXml = a, db;
}
var p7;
function Ase() {
  return p7 || (p7 = 1, function(u) {
    var r = rs && rs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = rs && rs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Sse(), u);
  }(rs)), rs;
}
var os = {}, fb = {}, ss = {}, OE = {}, b7;
function Ese() {
  return b7 || (b7 = 1, Object.defineProperty(OE, "__esModule", { value: !0 })), OE;
}
var xE = {}, y7;
function Ose() {
  return y7 || (y7 = 1, Object.defineProperty(xE, "__esModule", { value: !0 })), xE;
}
var IE = {}, _7;
function xse() {
  return _7 || (_7 = 1, Object.defineProperty(IE, "__esModule", { value: !0 })), IE;
}
var hb = {}, ei = {}, ti = {}, RE = {}, ri = {}, b6 = {}, g7;
function Ise() {
  return g7 || (g7 = 1, Object.defineProperty(b6, "__esModule", { value: !0 }), b6.default = new Uint16Array(
    // prettier-ignore
    'áµ<ÃÄ±ÊÒÕ»×ÙµÛÞ¢ßà à©àªà¶¡à¹­à¼à¼¦áá¨á¡ááááá¥\0\0\0\0\0\0á«áá¦á°á·á½¾â â°âââ»ââ ¤â¤â´â¹â¿ããºã¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à EMabcfglmnoprstu\\bfmsÂÂÂÂÂÂ¦Â³Â¹ÃÃligè»ÃäPè»&ä¦cuteè»Ãäreve;äÄiyx}rcè»Ãä;är;ìðraveè»Ãäpha;äacr;äd;æ©ÄgpÂÂ¡on;äf;ìð¸plyFunction;æ¡ingè»ÃäÄcsÂ¾Ãr;ìðign;æildeè»Ãämlè»ÃäÐaceforsuÃ¥Ã»Ã¾ÄÄÄ¢Ä§ÄªÄcrÃªÃ²kslash;æÅ¶Ã¶Ã¸;æ«§ed;æy;äÆcrtÄÄÄause;æµnoullis;æ¬a;är;ìðpf;ìð¹eve;äcÃ²Ämpeq;æÜHOacdefhilorsuÅÅÅÆÆÆ¢ÆµÆ·ÆºÇÈÉ³É¸É¾cy;ä§PYè»Â©ä©ÆcpyÅÅ¢Åºute;äÄ;iÅ§Å¨ætalDifferentialD;æleys;æ­ÈaeioÆÆÆÆron;ädilè»Ãärc;änint;æ°ot;äÄdnÆ§Æ­illa;ä¸terDot;ä·Ã²Å¿i;ä§rcleÈDMPTÇÇÇÇot;æinus;ælus;æimes;æoÄcsÇ¢Ç¸kwiseContourIntegral;æ²eCurlyÄDQÈÈoubleQuote;æuote;æÈlnpuÈÈ¨ÉÉonÄ;eÈ¥È¦æ·;æ©´ÆgitÈ¯È¶Èºruent;æ¡nt;æ¯ourIntegral;æ®ÄfrÉÉ;æoduct;ænterClockwiseContourIntegral;æ³oss;æ¨¯cr;ìðpÄ;CÊÊæap;æÖDJSZacefiosÊ Ê¬Ê°Ê´Ê¸ËËË¡Ë¦Ì³ÒÄ;oÅ¹Ê¥trahd;æ¤cy;äcy;äcy;äÆgrsÊ¿ËËger;æ¡r;æ¡hv;æ«¤ÄayËËron;ä;älÄ;tËËæa;är;ìðÄafË«Ì§ÄcmË°Ì¢riticalÈADGTÌÌÌÌcute;ä´oÅ´ÌÌ;äbleAcute;ärave;ä ilde;äond;æferentialD;æÑ°Ì½\0\0\0ÍÍ\0Ðf;ìð»Æ;DEÍÍÍä¨ot;æqual;æbleÌCDLRUVÍ£Í²ÎÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»ÍnArrow;æÄeoÎÎ¤ftÆARTÎÎÎ¡rrow;æightArrow;æeÃ¥ËngÄLRÎ«ÏeftÄARÎ³Î¹rrow;æ¸ightArrow;æºightArrow;æ¹ightÄATÏÏrrow;æee;æ¨pÉÏ©\0\0Ï¯rrow;æownArrow;æerticalBar;æ¥nÌABLRTaÐÐªÐ°ÑÑ¿Í¼rrowÆ;BUÐÐÐ¢æar;æ¤pArrow;æµreve;äeftËÐº\0Ñ\0ÑightVector;æ¥eeVector;æ¥ectorÄ;BÑÑæ½ar;æ¥ightÇÑ§\0Ñ±eeVector;æ¥ectorÄ;BÑºÑ»æar;æ¥eeÄ;AÒÒæ¤rrow;æ§ÄctÒÒr;ìðrok;äà NTacdfglmopqstuxÒ½ÓÓÓÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶ÕÕÕ Õ¥G;äHè»Ãäcuteè»ÃäÆaiyÓÓÓron;ärcè»Ãä;ä­ot;är;ìðraveè»Ãäement;æÄapÓºÓ¾cr;ätyÉÔ\0\0ÔmallSquare;æ»erySmallSquare;æ«ÄgpÔ¦Ôªon;äf;ìð¼silon;äuÄaiÔ¼ÕlÄ;TÕÕæ©µilde;ælibrium;æÄciÕÕr;æ°m;æ©³a;ämlè»ÃäÄipÕªÕ¯sts;æonentialE;æÊcfiosÖÖÖÖ²×y;ä¤r;ìðlledÉÖ\0\0Ö£mallSquare;æ¼erySmallSquare;æªÍ°Öº\0Ö¿\0\0×f;ìð½All;æriertrf;æ±cÃ²×ØJTabcdfgorst×¨×¬×¯×ºØØØØØØ£Ù¬Ù²cy;äè»>ä¾mmaÄ;d×·×¸ä;äreve;äÆeiyØØØdil;ä¢rc;ä;äot;ä r;ìð;æpf;ìð¾eaterÌEFGLSTØµÙÙÙÙÙ¦qualÄ;LØ¾Ø¿æ¥ess;æullEqual;æ§reater;æª¢ess;æ·lantEqual;æ©¾ilde;æ³cr;ìð¢;æ«ÐAacfiosuÚÚÚÚÚÚªÚ¾ÛRDcy;äªÄctÚÚek;ä;äirc;ä¤r;ælbertSpace;æÇ°Ú¯\0Ú²f;æizontalLine;æÄctÛÛÃ²Ú©rok;ä¦mpÅÛÛownHumÃ°Ä¯qual;æÜEJOacdfgmnostuÛºÛ¾ÜÜÜÜÜÜ¡Ü¨ÝÝ¸ÞÞÞcy;älig;ä²cy;äcuteè»ÃäÄiyÜÜrcè»Ãä;äot;ä°r;æraveè»ÃäÆ;apÜ Ü¯Ü¿ÄcgÜ´Ü·r;äªinaryI;ælieÃ³ÏÇ´Ý\0Ý¢Ä;eÝÝæ¬ÄgrÝÝral;æ«section;æisibleÄCTÝ¬Ý²omma;æ£imes;æ¢ÆgptÝ¿ÞÞon;ä®f;ìða;äcr;æilde;ä¨Ç«Þ\0Þcy;älè»ÃäÊcfosuÞ¬Þ·Þ¼ßßÄiyÞ±Þµrc;ä´;är;ìðpf;ìðÇ£ß\0ßr;ìð¥rcy;äkcy;äÎHJacfosß¤ß¨ß¬ß±ß½à à cy;ä¥cy;äppa;äÄeyß¶ß»dil;ä¶;är;ìðpf;ìðcr;ìð¦ÖJTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§à§à¨·à©cy;äè»<ä¼Êcmnprà ·à ¼à¡à¡à¡ute;ä¹bda;äg;æªlacetrf;ær;æÆaeyà¡à¡à¡¡ron;ä½dil;ä»;äÄfsà¡¨à¥°tÔACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥Îà¥ªÄnrà¢à¢gleBracket;æ¨rowÆ;BRà¢à¢à¢æar;æ¤ightArrow;æeiling;æoÇµà¢·\0à£bleBracket;æ¦nÇà£\0à£eeVector;æ¥¡ectorÄ;Bà£à£æar;æ¥loor;æightÄAVà£¯à£µrrow;æector;æ¥Äerà¤à¤eÆ;AVà¤à¤à¤æ£rrow;æ¤ector;æ¥iangleÆ;BEà¤¤à¤¥à¤©æ²ar;æ§qual;æ´pÆDTVà¤·à¥à¥ownVector;æ¥eeVector;æ¥ ectorÄ;Bà¥à¥æ¿ar;æ¥ectorÄ;Bà¥¥à¥¦æ¼ar;æ¥ightÃ¡ÎsÌEFGLSTà¥¾à¦à¦à¦à¦¢à¦­qualGreater;æullEqual;æ¦reater;æ¶ess;æª¡lantEqual;æ©½ilde;æ²r;ìðÄ;eà¦½à¦¾æftarrow;æidot;ä¿Ænpwà§à¨à¨gÈLRlrà§à§·à¨à¨eftÄARà§¦à§¬rrow;æµightArrow;æ·ightArrow;æ¶eftÄarÎ³à¨ightÃ¡Î¿ightÃ¡Ïf;ìðerÄLRà¨¢à¨¬eftArrow;æightArrow;æÆchtà¨¾à©à©Ã²à¡;æ°rok;ä;æªÐacefiosuà©à©à© à©·à©¼àªàªàªp;æ¤y;äÄdlà©¥à©¯iumSpace;ælintrf;æ³r;ìðnusPlus;æpf;ìðcÃ²à©¶;äÒJacefostuàª£àª§àª­à«à¬à¬à¶à¶à¶cy;äcute;äÆaeyàª´àª¹àª¾ron;ädil;ä;äÆgswà«à«°à¬ativeÆMTVà«à«à«¨ediumSpace;æhiÄcnà«¦à«Ã«à«eryThiÃ®à«tedÄGLà«¸à¬reaterGreateÃ²Ù³essLesÃ³à©Line;är;ìðÈBnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä f;æÚ;CDEGHLNPRSTVà­à­à­ªà­¼à®¡à¯«à°à±à²à²¦à³àµ¡à¶æ«¬Äouà­à­¤ngruent;æ¢pCap;æ­oubleVerticalBar;æ¦Ælqxà®à®à®ement;æualÄ;Tà®à®æ ilde;ìâÌ¸ists;æreaterÎ;EFGLSTà®¶à®·à®½à¯à¯à¯à¯¥æ¯qual;æ±ullEqual;ìâ§Ì¸reater;ìâ«Ì¸ess;æ¹lantEqual;ìâ©¾Ì¸ilde;æµumpÅà¯²à¯½ownHump;ìâÌ¸qual;ìâÌ¸eÄfsà°à°§tTriangleÆ;BEà°à°à°¡æªar;ìâ§Ì¸qual;æ¬sÌ;EGLSTà°µà°¶à°¼à±à±à±æ®qual;æ°reater;æ¸ess;ìâªÌ¸lantEqual;ìâ©½Ì¸ilde;æ´estedÄGLà±¨à±¹reaterGreater;ìâª¢Ì¸essLess;ìâª¡Ì¸recedesÆ;ESà²à²à²æqual;ìâª¯Ì¸lantEqual;æ Äeià²«à²¹verseElement;æghtTriangleÆ;BEà³à³à³æ«ar;ìâ§Ì¸qual;æ­Äquà³à´uareSuÄbpà³¨à³¹setÄ;Eà³°à³³ìâÌ¸qual;æ¢ersetÄ;Eà´à´ìâÌ¸qual;æ£Æbcpà´à´¤àµsetÄ;Eà´à´ìââqual;æceedsÈ;ESTà´²à´³à´»àµæqual;ìâª°Ì¸lantEqual;æ¡ilde;ìâ¿Ì¸ersetÄ;Eàµàµìââqual;æildeÈ;EFTàµ®àµ¯àµµàµ¿æqual;æullEqual;æilde;æerticalBar;æ¤cr;ìð©ildeè»Ãä;äÜEacdfgmoprstuvà¶½à·à·à·à·à· à·§à·¼à¸à¸ à¸¢à¸²à¸¿à¹lig;äcuteè»ÃäÄiyà·à·rcè»Ãä;äblac;är;ìðraveè»ÃäÆaeià·®à·²à·¶cr;äga;ä©cron;äpf;ìðenCurlyÄDQà¸à¸oubleQuote;æuote;æ;æ©Äclà¸§à¸¬r;ìðªashè»ÃäiÅ¬à¸·à¸¼deè»Ãäes;æ¨·mlè»ÃäerÄBPà¹à¹ Äarà¹à¹r;æ¾acÄekà¹à¹;æet;æ´arenthesis;æÒacfhilorsà¹¿àºàºàºàºàºàºàº°à»¼rtialD;æy;är;ìði;ä¦;ä usMinus;ä±Äipàº¢àº­ncareplanÃ¥Úf;æÈ;eioàº¹àººà» à»¤æª»cedesÈ;ESTà»à»à»à»æºqual;æª¯lantEqual;æ¼ilde;æ¾me;æ³Ädpà»©à»®uct;æortionÄ;aÈ¥à»¹l;æÄcià¼à¼r;ìð«;ä¨ÈUfosà¼à¼à¼à¼OTè»"ä¢r;ìðpf;æcr;ìð¬ØBEacefhiorsuà¼¾à½à½à½ à½³à¾§à¾ªà¾­áá©á´á¾arr;æ¤Gè»Â®ä®Æcnrà½à½à½ute;äg;æ«rÄ;tà½à½æ l;æ¤Æaeyà½§à½¬à½±ron;ädil;ä;ä Ä;và½¸à½¹æerseÄEUà¾à¾Älqà¾à¾ement;æuilibrium;æpEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtÐACDFTUVaà¿à¿«à¿³á¢á¨ááÏÄnrà¿à¿gleBracket;æ©rowÆ;BLà¿à¿à¿¡æar;æ¥eftArrow;æeiling;æoÇµà¿¹\0ábleBracket;æ§nÇá\0áeeVector;æ¥ectorÄ;Bááæar;æ¥loor;æÄerá­áeÆ;AVáµá¶á¼æ¢rrow;æ¦ector;æ¥iangleÆ;BEáááæ³ar;æ§qual;æµpÆDTVá£á®á¸ownVector;æ¥eeVector;æ¥ectorÄ;Bááæ¾ar;æ¥ectorÄ;Bááæar;æ¥Äpuááf;ændImplies;æ¥°ightarrow;æÄchá¹á¼r;æ;æ±leDelayed;æ§´ÚHOacfhimoqstuá¤á±á·á½ááááá¡á§áµá»á¿ÄCcá©á®Hcy;ä©y;ä¨FTcy;ä¬cute;äÊ;aeiyáááááæª¼ron;ä dil;ärc;ä;ä¡r;ìðortÈDLRUáªá´á¾áownArrowÂ»ÐeftArrowÂ»à¢ightArrowÂ»à¿pArrow;ægma;ä£allCircle;æpf;ìðÉ²á­\0\0á°t;æareÈ;ISUá»á¼áá¯æ¡ntersection;æuÄbpáásetÄ;Eááæqual;æersetÄ;Eá¨á©æqual;ænion;æcr;ìð®ar;æÈbcmpááááÄ;sááæetÄ;Eááqual;æÄchá áeedsÈ;ESTá­á®á´á¿æ»qual;æª°lantEqual;æ½ilde;æ¿ThÃ¡à¾;æÆ;esááá£ærsetÄ;Eááæqual;æetÂ»áÖHRSacfhiorsá¾ááááá±á¶ááááORNè»ÃäADE;æ¢ÄHcáácy;äy;ä¦Äbuáá;ä;ä¤Æaeyá¥áªá¯ron;ä¤dil;ä¢;ä¢r;ìðÄeiá»áÇ²á\0áefore;æ´a;äÄcnáákSpace;ìââSpace;ældeÈ;EFTá«á¬á²á¼æ¼qual;æullEqual;æilde;æpf;ìðipleDot;æÄctáár;ìð¯rok;ä¦à«¡á·ááá¦\0á¬á±\0\0\0\0\0á¸á½á·á\0á¿áááÄcrá»áuteè»ÃärÄ;oááæcir;æ¥rÇ£á\0áy;äve;ä¬Äiyáá£rcè»Ãä;ä£blac;ä°r;ìðraveè»Ãäacr;äªÄdiáá©erÄBPááÄaráár;äacÄekáá;æet;æµarenthesis;æonÄ;Pá°á±ælus;æÄgpá»á¿on;ä²f;ìðÐADETadpsáá®á¸áÏ¨ááá³rrowÆ;BDáá á¤ar;æ¤ownArrow;æownArrow;æquilibrium;æ¥®eeÄ;Aááæ¥rrow;æ¥ownÃ¡Ï³erÄLRáá¨eftArrow;æightArrow;æiÄ;lá¹áºäon;ä¥ing;ä®cr;ìð°ilde;ä¨mlè»ÃäÒDbcdefosvá§á¬á°á³á¾ááááash;æ«ar;æ««y;äashÄ;lá»á¼æ©;æ«¦Äeráá;æÆbtyáááºar;æÄ;iáácalÈBLSTá¡á¥áªá´ar;æ£ine;ä¼eparator;æilde;æThinSpace;ær;ìðpf;ìðcr;ìð±dash;æªÊcefosá§á¬á±á¶á¼irc;ä´dge;ær;ìðpf;ìðcr;ìð²Èfiosáááár;ìð;äpf;ìðcr;ìð³ÒAIUacfosuá±áµá¹á½ááááá cy;ä¯cy;äcy;ä®cuteè»ÃäÄiyáárc;ä¶;ä«r;ìðpf;ìðcr;ìð´ml;ä¸ÐHacdefosáµá¹á¿áááá á¤cy;äcute;ä¹Äayááron;ä½;äot;ä»Ç²á\0áoWidtÃ¨à«a;är;æ¨pf;æ¤cr;ìðµà¯¡ááá\0á°á¶á¿\0\0\0\0ááá«áá­\0ááá²á¹\0á¾cuteè»Ã¡ä¡reve;äÌ;Ediuyááá¡á£á¨á­æ¾;ìâ¾Ì³;æ¿rcè»Ã¢ä¢teè»Â´Ì;ä°ligè»Ã¦ä¦Ä;rÂ²áº;ìðraveè»Ã ä ÄepááÄfpáásym;æµÃ¨áha;ä±ÄapácÄclá¤á§r;äg;æ¨¿É¤á°\0\0áÊ;adsváºá»á¿ááæ§nd;æ©;æ©lope;æ©;æ©Î;elmrszááááá¿ááæ ;æ¦¤eÂ»ásdÄ;aá¥á¦æ¡Ñ¡á°á²á´á¶á¸áºá¼á¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ;vááæbÄ;dááæ¾;æ¦Äptááh;æ¢Â»Â¹arr;æ¼Ägpá£á§on;äf;ìðÎ;Eaeiopáá»á½áááá;æ©°cir;æ©¯;æd;æs;ä§roxÄ;eááÃ±áingè»Ã¥ä¥Æctyá¡á¦á¨r;ìð¶;äªmpÄ;eáá¯Ã±Êildeè»Ã£ä£mlè»Ã¤ä¤ÄciááoninÃ´É²nt;æ¨à Nabcdefiklnoprsuá­á±á°á¼ááá¸á½á á¦á ¹á¡áá¤½á¥á¥°ot;æ«­Äcrá¶ákÈcepsááááong;æpsilon;ä¶rime;æµimÄ;eááæ½q;æÅ¶á¢á¦ee;æ½edÄ;gá¬á­æeÂ»á­rkÄ;táá·brk;æ¶Äoyáá;ä±quo;æÊcmprtááá¡á¤á¨ausÄ;eÄÄptyv;æ¦°sÃ©ánoÃµÄÆahwá¯á±á³;ä²;æ¶een;æ¬r;ìðgÎcostuvwááá³ááááÆaiuáááÃ°Ý rc;æ¯pÂ»á±Ædptá¤á¨á­ot;æ¨lus;æ¨imes;æ¨É±á¹\0\0á¾cup;æ¨ar;æriangleÄduááown;æ½p;æ³plus;æ¨eÃ¥áÃ¥á­arow;æ¤Æakoá­á ¦á µÄcná²á £kÆlstáºÖ«á ozenge;æ§«riangleÈ;dlrá á á á æ´own;æ¾eft;æight;æ¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ;æ4;æck;æÄeoá ¾á¡Ä;qá¡á¡ì=â¥uiv;ìâ¡â¥t;æÈptwxá¡á¡á¡§á¡¬f;ìðÄ;táá¡£omÂ»átie;æØDHUVbdhmptuvá¢á¢á¢ªá¢»á£á£á£¬á£¿á¤á¤á¤á¤¡ÈLRlrá¢á¢á¢á¢;æ;æ;æ;æÊ;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ;æ¦;æ©;æ¤;æ§ÈLRlrá¢³á¢µá¢·á¢¹;æ;æ;æ;æÎ;HLRhlrá£á£á£á£á£á£á£æ;æ¬;æ£;æ ;æ«;æ¢;æox;æ§ÈLRlrá£¤á£¦á£¨á£ª;æ;æ;æ;æÊ;DUduÚ½á£·á£¹á£»á£½;æ¥;æ¨;æ¬;æ´inus;ælus;æimes;æ ÈLRlrá¤á¤á¤á¤;æ;æ;æ;æÎ;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ;æª;æ¡;æ;æ¼;æ¤;æÄevÄ£á¥barè»Â¦ä¦Èceioá¥á¥á¥á¥ r;ìð·mi;æmÄ;eáálÆ;bhá¥¨á¥©á¥«ä;æ§sub;æÅ¬á¥´á¥¾lÄ;eá¥¹á¥ºæ¢tÂ»á¥ºpÆ;EeÄ¯á¦á¦;æª®Ä;qÛÛà³¡á¦§\0á§¨á¨á¨á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­\0á¯½\0á°Æcprá¦­á¦²á§ute;äÌ;abcdsá¦¿á§á§á§á§á§æ©nd;æ©rcup;æ©Äauá§á§p;æ©p;æ©ot;æ©;ìâ©ï¸Äeoá§¢á§¥t;æÃ®ÚÈaeiuá§°á§»á¨á¨Ç°á§µ\0á§¸s;æ©on;ädilè»Ã§ä§rc;äpsÄ;sá¨á¨æ©m;æ©ot;äÆdmná¨á¨ á¨¦ilè»Â¸Æ­ptyv;æ¦²tèÂ¢;eá¨­á¨®ä¢rÃ¤Æ²r;ìð Æceiá¨½á©á©y;äckÄ;má©á©æarkÂ»á©;ärÎ;Ecefmsá©á© á©¢á©«áª¤áªªáª®æ;æ§Æ;elá©©á©ªá©­äq;æeÉ¡á©´\0\0áªrrowÄlrá©¼áªeft;æºight;æ»ÊRSacdáªáªáªáªáªÂ»à½;æst;æirc;æash;ænint;æ¨id;æ«¯cir;æ§ubsÄ;uáª»áª¼æ£itÂ»áª¼Ë¬á«á«á«º\0á¬onÄ;eá«á«äºÄ;qÃÃÉ­á«\0\0á«¢aÄ;tá«á«ä¬;äÆ;flá«¨á«©á««æÃ®á eÄmxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬Ä;dá»á¬ot;æ©­nÃ´ÉÆfryá¬á¬á¬;ìðoÃ¤ÉèÂ©;sÅá¬r;æÄaoá¬¥á¬©rr;æµss;æÄcuá¬²á¬·r;ìð¸Äbpá¬¼á­Ä;eá­á­æ«;æ«Ä;eá­á­æ«;æ«dot;æ¯Îdelprvwá­ á­¬á­·á®á®¬á¯á¯¹arrÄlrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æc;æarrÄ;pá­¿á®æ¶;æ¤½Ì;bcdosá®á®á®á®¡á®¥á®¨æªrcap;æ©Äauá®á®p;æ©p;æ©ot;ær;æ©;ìâªï¸Èalrvá®µá®¿á¯á¯£rrÄ;má®¼á®½æ·;æ¤¼yÆevwá¯á¯á¯qÉ°á¯\0\0á¯reÃ£á­³uÃ£á­µee;æedge;æenè»Â¤ä¤earrowÄlrá¯®á¯³eftÂ»á®ightÂ»á®½eÃ¤á¯Äciá°á°oninÃ´Ç·nt;æ±lcty;æ­à¦AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²á²á²¬á²·á³»á³¿á´áµ»á¶á¶«á¶»á·á·rÃ²Îar;æ¥¥Èglrsá±á±á±á±ger;æ eth;æ¸Ã²á³hÄ;vá±á±æÂ»à¤Å«á±¡á±§arow;æ¤aÃ£ÌÄayá±®á±³ron;ä;ä´Æ;aoÌ²á±¼á²ÄgrÊ¿á²r;ætseq;æ©·Æglmá²á²á²è»Â°ä°ta;ä´ptyv;æ¦±Äirá²£á²¨sht;æ¥¿;ìð¡arÄlrá²³á²µÂ»à£Â»áÊaegsvá³Í¸á³á³á³ mÆ;osÌ¦á³á³ndÄ;sÌ¦á³uit;æ¦amma;äin;æ²Æ;ioá³§á³¨á³¸ä·deèÃ·;oá³§á³°ntimes;ænÃ¸á³·cy;äcÉ¯á´\0\0á´rn;æop;æÊlptuwá´á´á´¢áµáµlar;ä¤f;ìðÊ;empsÌá´­á´·á´½áµqÄ;dÍá´³ot;æinus;æ¸lus;æquare;æ¡blebarwedgÃ¥ÃºnÆadhá®áµáµ§ownarrowÃ³á²arpoonÄlráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶karoÃ·à½É¯á¶\0\0á¶rn;æop;æÆcotá¶á¶£á¶¦Äryá¶á¶¡;ìð¹;äl;æ§¶rok;äÄdrá¶°á¶´ot;æ±iÄ;fá¶ºá æ¿Äahá·á·rÃ²Ð©aÃ²à¾¦angle;æ¦¦Äciá·á·y;ägrarr;æ¿à¤Dacdefglmnopqrstuxá¸á¸á¸á¸¸Õ¸á¸¼á¹á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½á½á½ÄDoá¸á´´oÃ´á²Äcsá¸á¸uteè»Ã©ä©ter;æ©®Èaioyá¸¢á¸§á¸±á¸¶ron;ärÄ;cá¸­á¸®æè»Ãªäªlon;æ;äot;äÄDrá¹á¹ot;æ;ìð¢Æ;rsá¹á¹á¹æªaveè»Ã¨ä¨Ä;dá¹á¹æªot;æªÈ;ilsá¹ªá¹«á¹²á¹´æªnters;æ§;æÄ;dá¹¹á¹ºæªot;æªÆapsáºáºáºcr;ätyÆ;sváºáºáºæetÂ»áºpÄ1;áºáº¤Ä³áº¡áº£;æ;ææÄgsáºªáº¬;äp;æÄgpáº´áº¸on;äf;ìðÆalsá»á»á»rÄ;sá»á»æl;æ§£us;æ©±iÆ;lvá»á»á»äµonÂ»á»;äµÈcsuvá»ªá»³á¼á¼£Äioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕantÄglá¼á¼trÂ»á¹essÂ»á¹ºÆaeiá¼á¼á¼ls;ä½st;ævÄ;DÈµá¼ D;æ©¸parsl;æ§¥ÄDaá¼¯á¼³ot;ærr;æ¥±Æcdiá¼¾á½á»¸r;æ¯oÃ´ÍÄahá½á½;ä·è»Ã°ä°Ämrá½á½lè»Ã«ä«o;æ¬Æcipá½¡á½¤á½§l;ä¡sÃ´Õ®Äeoá½¬á½´ctatioÃ®ÕnentialÃ¥Õ¹à§¡á¾\0á¾\0á¾¡á¾§\0\0á¿á¿\0á¿\0á¿¦á¿ªâ\0ââllingdotseÃ±á¹y;ämale;æÆilrá¾­á¾³á¿lig;èï¬É©á¾¹\0\0á¾½g;èï¬ig;èï¬;ìð£lig;èï¬lig;ìfjÆaltá¿á¿á¿¡t;æ­ig;èï¬ns;æ±of;äÇ°á¿®\0á¿³f;ìðÄakÖ¿á¿·Ä;vá¿¼á¿½æ;æ«artint;æ¨ÄaoââÄcsââÎ±ââ°â¸ââ\0âÎ²â¢â¥â§âªâ¬\0â®è»Â½ä½;æè»Â¼ä¼;æ;æ;æÆ³â´\0â¶;æ;æÊ´â¾â\0\0âè»Â¾ä¾;æ;æ5;æÆ¶â\0â;æ;æ8;æl;æwn;æ¢cr;ìð»à¢Eabcdefgijlnorstvââââ¥â°â´â°âµâºâ¿âââ¸Ìâ¾ââÄ;lÙâ;æªÆcmpâââute;äµmaÄ;dâá³ä³;æªreve;äÄiyâªâ®rc;ä;ä³ot;ä¡È;lqsØ¾Ùâ½âÆ;qsØ¾ÙâlanÃ´Ù¥È;cdlÙ¥âââ¥c;æª©otÄ;oââæªÄ;lâ¢â£æª;æªÄ;eâªâ­ìâï¸s;æªr;ìð¤Ä;gÙ³Ømel;æ·cy;äÈ;EajÙâââ;æª;æª¥;æª¤ÈEaesâââ©â´;æ©pÄ;pâ£â¤æªroxÂ»â¤Ä;qâ®â¯æªÄ;qâ®âim;æ§pf;ìðÄciââr;æmÆ;elÙ«ââ;æª;æªè>;cdlqr×®â âªâ®â³â¹Äciâ¥â§;æª§r;æ©ºot;æPar;æ¦uest;æ©¼ÊadelsââªâÙâÇ°â\0âproÃ¸âr;æ¥¸qÄlqØ¿âlesÃ³âiÃ­Ù«Äenâ£â­rtneqq;ìâ©ï¸ÃâªÔAabcefkosyâââ±âµâºâââ¯â¨â½rÃ²Î ÈilmrâââârsÃ°áfÂ»â¤ilÃ´Ú©Ädrâ â¤cy;äÆ;cwà£´â«â¯ir;æ¥;æ­ar;æirc;ä¥ÆalrââârtsÄ;uââæ¥itÂ»âlip;æ¦con;æ¹r;ìð¥sÄewâ£â©arow;æ¤¥arow;æ¤¦Êamoprâºâ¾âââ£rr;æ¿tht;æ»kÄlrââeftarrow;æ©ightarrow;æªf;ìðbar;æÆcltâ¯â´â¸r;ìð½asÃ¨â´rok;ä§Äbpââull;æhenÂ»á±à«¡â£\0âª\0â¸ââ\0ââ³\0\0â¸â¢â§â¢â¿\0ââªâ´cuteè»Ã­ä­Æ;iyÝ±â°âµrcè»Ã®ä®;ä¸Äcxâ¼â¿y;äµclè»Â¡ä¡ÄfrÎâ;ìð¦raveè»Ã¬ä¬È;inoÜ¾ââ©â®Äinâ¢â¦nt;æ¨t;æ­fin;æ§ta;æ©lig;ä³Æaopâ¾ââÆcgtâââr;ä«ÆelpÜââinÃ¥ÞarÃ´Ü h;ä±f;æ·ed;äµÊ;cfotÓ´â¬â±â½âare;æinÄ;tâ¸â¹æie;æ§doÃ´âÊ;celpÝââââ¡al;æºÄgrââerÃ³á£Ã£âarhk;æ¨rod;æ¨¼Ècgptâ¯â²â¶â»y;äon;ä¯f;ìða;ä¹uestè»Â¿ä¿Äciââr;ìð¾nÊ;EdsvÓ´âââ¡Ó³;æ¹ot;æµÄ;vâ¦â§æ´;æ³Ä;iÝ·â®lde;ä©Ç«â¸\0â¼cy;älè»Ã¯ä¯Ìcfmosuââââ¡â§âµÄiyâârc;äµ;ä¹r;ìð§ath;ä·pf;ìðÇ£â¬\0â±r;ìð¿rcy;äkcy;äÐacfghjosâââ¢â§â­â±âµâ»ppaÄ;vââäº;ä°Äeyââ dil;ä·;äºr;ìð¨reen;ä¸cy;äcy;äpf;ìðcr;ìðà®ABEHabcdefghjlmnoprstuvâ°ââââââ½âââââ¥â¹â½ââ²âââ¨âââ â Æartâ·âºâ¼rÃ²à§Ã²Îail;æ¤arr;æ¤Ä;gà¦â;æªar;æ¥¢à¥£â¥\0âª\0â±\0\0\0\0\0âµâº\0âââ\0â¹ute;äºmptyv;æ¦´raÃ®à¡bda;ä»gÆ;dlà¢ââ;æ¦Ã¥à¢;æªuoè»Â«ä«rÐ;bfhlpstà¢ââ¦â©â«â®â±âµÄ;fà¢â£s;æ¤s;æ¤Ã«âp;æ«l;æ¤¹im;æ¥³l;æ¢Æ;aeâ¿ââæª«il;æ¤Ä;sââæª­;ìâª­ï¸Æabrââârr;æ¤rk;æ²Äakâ¢â¬cÄekâ¨âª;ä»;äÄesâ±â³;æ¦lÄduâ¹â»;æ¦;æ¦Èaeuyââââron;ä¾Ädiââil;ä¼Ã¬à¢°Ã¢â©;ä»Ècqrsâ£â¦â­â½a;æ¤¶uoÄ;rà¸áÄduâ²â·har;æ¥§shar;æ¥h;æ²Ê;fgqsââà¦â³â¿æ¤tÊahlrtââ¤â·ââ¨rrowÄ;tà¢â¡aÃ©â¶arpoonÄduâ¯â´ownÂ»ÑpÂ»à¥¦eftarrows;æightÆahsââârrowÄ;sà£´à¢§arpoonÃ³à¾quigarroÃ·â°hreetimes;æÆ;qsâà¦âºlanÃ´à¦¬Ê;cdgsà¦¬ââââ¨c;æª¨otÄ;oââæ©¿Ä;rââæª;æªÄ;eâ¢â¥ìâï¸s;æªÊadegsâ³â¹â½ââpproÃ¸âot;æqÄgqââÃ´à¦gtÃ²âÃ´à¦iÃ­à¦²Æilrâà£¡âsht;æ¥¼;ìð©Ä;Eà¦â£;æªÅ¡â©â¶rÄduâ²â®Ä;là¥¥â³;æ¥ªlk;æcy;äÊ;achtà©âââârÃ²âorneÃ²á´ard;æ¥«ri;æºÄioââ¤dot;äustÄ;aâ¬â­æ°cheÂ»â­ÈEaesâ»â½ââ;æ¨pÄ;pââæªroxÂ»âÄ;qââæªÄ;qââ»im;æ¦Ðabnoptwzâ©â´â·ââ¯âââÄnrâ®â±g;æ¬r;æ½rÃ«à£gÆlmrâ¿ââeftÄarà§¦âightÃ¡à§²apsto;æ¼ightÃ¡à§½parrowÄlrâ¥â©efÃ´â­ight;æ¬Æaflâ¶â¹â½r;æ¦;ìðus;æ¨­imes;æ¨´Å¡ââst;æÃ¡áÆ;efââá ængeÂ»âarÄ;lâ¤â¥ä¨t;æ¦Êachmtâ³â¶â¼âârÃ²à¢¨orneÃ²á¶arÄ;dà¾â;æ¥­;æri;æ¿Ìachiqtââà©â¢â®â»quo;æ¹r;ìðmÆ;egà¦²âªâ¬;æª;æªÄbuâªâ³oÄ;rà¸â¹;ærok;äè<;cdhilqrà «ââ¹ââ â¥âªâ°Äciââ;æª¦r;æ©¹reÃ¥â²mes;æarr;æ¥¶uest;æ©»ÄPiâµâ¹ar;æ¦Æ;efâ à¤­á ærÄduâ â shar;æ¥har;æ¥¦Äenâ â ¡rtneqq;ìâ¨ï¸Ãâ ÜDacdefhilnopsuâ¡â¡â¢â¢â¢â¢ â¢¥â¢¨â£â£¢â£¤àªâ£³â¤Dot;æºÈclprâ¡â¡â¡£â¡½rè»Â¯ä¯Äetâ¡â¡;æÄ;eâ¡â¡æ seÂ»â¡Ä;sá»â¡¨toÈ;dluá»â¡³â¡·â¡»owÃ®ÒefÃ´à¤Ã°áker;æ®Äoyâ¢â¢mma;æ¨©;ä¼ash;æasuredangleÂ»á¦r;ìðªo;æ§Æcdnâ¢¯â¢´â£roè»ÂµäµÈ;acdá¤â¢½â£â£sÃ´á§ir;æ«°otè»Â·ÆµusÆ;bdâ£á¤â£æÄ;uá´¼â£;æ¨ªÅ£â£â£¡p;æ«Ã²âÃ°àªÄdpâ£©â£®els;æ§f;ìðÄctâ£¸â£½r;ìðposÂ»áÆ;lmâ¤â¤â¤ä¼timap;æ¸à°GLRVabcdefghijlmoprstuvwâ¥â¥â¥¾â¦â¦â§â§©â¨â¨â©â©âªâªâª¤âª¨â¬â¬â­â­¿â®®â°´â±§â±¼â³©Ägtâ¥â¥;ìâÌ¸Ä;vâ¥à¯ìâ«âÆeltâ¥â¥²â¥¶ftÄarâ¥¡â¥§rrow;æightarrow;æ;ìâÌ¸Ä;vâ¥»à±ìâªâightarrow;æÄDdâ¦â¦ash;æ¯ash;æ®Êbcnptâ¦£â¦§â¦¬â¦±â§laÂ»Ëute;äg;ìâ âÊ;Eiopà¶â¦¼â§â§â§;ìâ©°Ì¸d;ìâÌ¸s;äroÃ¸à¶urÄ;aâ§â§æ®lÄ;sâ§à¬¸Ç³â§\0â§£pè»Â à¬·mpÄ;eà¯¹à°Êaeouyâ§´â§¾â¨â¨â¨Ç°â§¹\0â§»;æ©on;ädil;ängÄ;dàµ¾â¨ot;ìâ©­Ì¸p;æ©;ä½ash;æÎ;Aadqsxà®â¨©â¨­â¨»â©â©â©rr;ærÄhrâ¨³â¨¶k;æ¤¤Ä;oá²á°ot;ìâÌ¸uiÃ¶à­£Äeiâ©â©ar;æ¤¨Ã­à®istÄ;sà® à®r;ìð«ÈEestà¯â©¦â©¹â©¼Æ;qsà®¼â©­à¯¡Æ;qsà®¼à¯â©´lanÃ´à¯¢iÃ­à¯ªÄ;rà®¶âªÂ»à®·ÆAapâªâªâªrÃ²â¥±rr;æ®ar;æ«²Æ;svà¾âªà¾Ä;dâª¡âª¢æ¼;æºcy;äÎAEadestâª·âªºâª¾â«â«â«¶â«¹rÃ²â¥¦;ìâ¦Ì¸rr;ær;æ¥È;fqsà°»â«â«£â«¯tÄarâ«â«rroÃ·â«ightarroÃ·âªÆ;qsà°»âªºâ«ªlanÃ´à±Ä;sà±â«´Â»à°¶iÃ­à±Ä;rà°µâ«¾iÄ;eà°à°¥iÃ¤à¶Äptâ¬â¬f;ìðèÂ¬;inâ¬â¬â¬¶ä¬nÈ;Edvà®â¬¤â¬¨â¬®;ìâ¹Ì¸ot;ìâµÌ¸Ç¡à®â¬³â¬µ;æ·;æ¶iÄ;và²¸â¬¼Ç¡à²¸â­â­;æ¾;æ½Æaorâ­â­£â­©rÈ;astà­»â­â­â­lleÃ¬à­»l;ìâ«½â¥;ìâÌ¸lint;æ¨Æ;ceà²â­°â­³uÃ¥à²¥Ä;cà²â­¸Ä;eà²â­½Ã±à²ÈAaitâ®â®â®â®§rÃ²â¦rrÆ;cwâ®â®â®æ;ìâ¤³Ì¸;ìâÌ¸ghtarrowÂ»â®riÄ;eà³à³Îchimpquâ®½â¯â¯â¬à­¸â¯¤â¯¯È;cerà´²â¯à´·â¯uÃ¥àµ;ìðortÉ­â¬\0\0â¯arÃ¡â­mÄ;eàµ®â¯Ä;qàµ´àµ³suÄbpâ¯«â¯­Ã¥à³¸Ã¥à´Æbcpâ¯¶â°â°È;Eesâ¯¿â°à´¢â°æ;ìâ«Ì¸etÄ;eà´â°qÄ;qà´£â°cÄ;eà´²â°Ã±à´¸È;Eesâ°¢â°£àµâ°§æ;ìâ«Ì¸etÄ;eàµâ°®qÄ;qàµ â°£Ègilrâ°½â°¿â±â±Ã¬à¯ldeè»Ã±ä±Ã§à±iangleÄlrâ±â±eftÄ;eà°â±Ã±à°¦ightÄ;eà³â±¥Ã±à³Ä;mâ±¬â±­ä½Æ;esâ±´â±µâ±¹ä£ro;æp;æÒDHadgilrsâ²â²â²â²â²£â²°â²¶â³â³£ash;æ­arr;æ¤p;ìââash;æ¬Äetâ²¨â²¬;ìâ¥â;ì>ânfin;æ§ÆAetâ²½â³â³rr;æ¤;ìâ¤âÄ;râ³â³ì<âie;ìâ´âÄAtâ³â³rr;æ¤rie;ìâµâim;ìâ¼âÆAanâ³°â³´â´rr;ærÄhrâ³ºâ³½k;æ¤£Ä;oá§á¥ear;æ¤§ááª\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµâµ âµ¥âµ²â¶á¬\0\0â¶â¶«\0â·â·\0â·â¸â¸«â¸¾â¹Äcsâ´±áªuteè»Ã³ä³Äiyâ´¼âµrÄ;cáªâµè»Ã´ä´;ä¾Êabiosáª âµâµÇâµlac;äv;æ¨¸old;æ¦¼lig;äÄcrâµ©âµ­ir;æ¦¿;ìð¬Í¯âµ¹\0\0âµ¼\0â¶n;äaveè»Ã²ä²;æ§Äbmâ¶à·´ar;æ¦µÈacitâ¶â¶â¶¥â¶¨rÃ²áªÄirâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹;æ§Æaeiâ¶±â¶µâ¶¹cr;äga;äÆcdnâ·â·Çron;ä¿;æ¦¶pf;ìð Æaelâ·â·Çr;æ¦·rp;æ¦¹Î;adiosvâ·ªâ·«â·®â¸â¸â¸â¸æ¨rÃ²áªÈ;efmâ··â·¸â¸â¸æ©rÄ;oâ·¾â·¿æ´fÂ»â·¿è»Âªäªè»Âºäºgof;æ¶r;æ©lope;æ©;æ©Æcloâ¸â¸¡â¸§Ã²â¸ashè»Ã¸ä¸l;æiÅ¬â¸¯â¸´deè»ÃµäµesÄ;aÇâ¸ºs;æ¨¶mlè»Ã¶ä¶bar;æ½à«¡â¹\0â¹½\0âºâº\0âº¢âº¹\0\0â»àº\0â¼\0\0â¼«â¾¼\0â¿rÈ;astÐâ¹§â¹²àºèÂ¶;lâ¹­â¹®ä¶leÃ¬ÐÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊcimptâºâºâºá¡¥âºnt;ä¥od;ä®il;æ°enk;æ±r;ìð­Æimoâº¨âº°âº´Ä;vâº­âº®ä;ämaÃ´à©¶ne;æÆ;tvâº¿â»â»ächforkÂ»á¿½;äÄauâ»â»nÄckâ»â»kÄ;hâ´â»;æÃ¶â´sÒ;abcdemstâ»³â»´á¤â»¹â»½â¼â¼â¼â¼ä«cir;æ¨£ir;æ¨¢Äouáµâ¼;æ¨¥;æ©²nè»Â±àºim;æ¨¦wo;æ¨§Æipuâ¼â¼ â¼¥ntint;æ¨f;ìð¡ndè»Â£ä£Ô;Eaceinosuà»â¼¿â½â½â½â¾â¾â¾â½¾â¾¶;æª³p;æª·uÃ¥à»Ä;cà»â½Ì;acensà»â½â½â½¦â½¨â½¾pproÃ¸â½urlyeÃ±à»Ã±à»Æaesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ¨iÃ­à»meÄ;sâ¾àº®æ²ÆEasâ½¸â¾â½ºÃ°â½µÆdfpà»¬â¾â¾¯Æalsâ¾ â¾¥â¾ªlar;æ®ine;æurf;æÄ;tà»»â¾´Ã¯à»»rel;æ°Äciâ¿â¿r;ìð;äncsp;æÌfiopsuâ¿â¢â¿â¿¥â¿«â¿±r;ìð®pf;ìð¢rime;æcr;ìðÆaeoâ¿¸ããtÄeiâ¿¾ãrnionÃ³Ú°nt;æ¨stÄ;eããä¿Ã±á¼Ã´à¼àªABHabcdefhilmnoprstuxããããã ãã«ãã¢ã²ãããã¤ã©ãã®ã²ãã°ã·ÆartãããrÃ²á³Ã²Ïail;æ¤arÃ²á±¥ar;æ¥¤Îcdenqrtã¨ãµã¸ã¿ãããÄeuã­ã±;ìâ½Ì±te;äiÃ£á®mptyv;æ¦³gÈ;delà¿ããã;æ¦;æ¦¥Ã¥à¿uoè»Â»ä»rÖ;abcfhlpstwà¿ã¬ã¯ã·ã¹ã¼ã¾ããããp;æ¥µÄ;fà¿ ã´s;æ¤ ;æ¤³s;æ¤Ã«âÃ°â®l;æ¥im;æ¥´l;æ£;æÄaiããil;æ¤oÄ;nããæ¶alÃ³à¼Æabrã§ãªã®rÃ²á¥rk;æ³Äakã³ã½cÄekã¹ã»;ä½;äÄesãã;æ¦lÄduãã;æ¦;æ¦Èaeuyããã§ã©ron;äÄdiã¡ã¥il;äÃ¬à¿²Ã¢ãº;äÈclqsã´ã·ã½ãa;æ¤·dhar;æ¥©uoÄ;rÈÈh;æ³Æacgããà½lÈ;ipsà½¸ããánÃ¥á»arÃ´à¾©t;æ­Æilrã©á£ã®sht;æ¥½;ìð¯Äaoã·ãrÄduã½ã¿Â»Ñ»Ä;láã;æ¥¬Ä;vããä;ä±Ægnsãã¹ã¼htÌahlrstã¤ã°ããã¤ã®rrowÄ;tà¿ã­aÃ©ãarpoonÄduã»ã¿owÃ®ã¾pÂ»áeftÄahããrrowÃ³à¿ªarpoonÃ³Õightarrows;æquigarroÃ·ãhreetimes;æg;äingdotseÃ±á¼²ÆahmãããrÃ²à¿ªaÃ²Õ;æoustÄ;aããæ±cheÂ»ãmid;æ«®Èabptã²ã½ããÄnrã·ãºg;æ­r;æ¾rÃ«áÆaflãããr;æ¦;ìð£us;æ¨®imes;æ¨µÄapãã§rÄ;gã£ã¤ä©t;æ¦olint;æ¨arÃ²ã£Èachqã»ãá¼ãquo;æºr;ìðÄbuã»ãoÄ;rÈÈÆhirããã reÃ¥ã¸mes;æiÈ;eflãªáá ¡ã«æ¹tri;æ§luhar;æ¥¨;æàµ¡ãããã¬ã¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ããã­ã±ãã±\0ã\0\0ã³cute;äquÃ¯âºÔ;Eaceinpsyá­ã³ãµã¿ããããã¦ã©;æª´Ç°ãº\0ã¼;æª¸on;ä¡uÃ¥á¾Ä;dá³ãil;ärc;äÆEasããã;æª¶p;æªºim;æ©olint;æ¨iÃ­á;äotÆ;beã´áµãµæ;æ©¦ÎAacmstxãããããã£ã­rr;ærÄhrããÃ«â¨Ä;oà¨¶à¨´tè»Â§ä§i;ä»war;æ¤©mÄinã©Ã°nuÃ³Ã±t;æ¶rÄ;oã¶âìð°Èacoyãããã rp;æ¯Ähyããcy;ä;ärtÉ­ã\0\0ãiÃ¤á¤araÃ¬â¹¯è»Â­ä­Ägmã¨ã´maÆ;fvã±ã²ã²ä;äÐ;deglnprá«ãããããã¡ã¦ot;æ©ªÄ;qá±á°Ä;Eããæª;æª Ä;Eããæª;æªe;ælus;æ¨¤arr;æ¥²arÃ²á½Èaeitã¸ãããÄlsã½ãlsetmÃ©ãªhp;æ¨³parsl;æ§¤Ädlá£ãe;æ£Ä;eããæªªÄ;sã¢ã£æª¬;ìâª¬ï¸Æflpã®ã³ãtcy;äÄ;bã¸ã¹ä¯Ä;aã¾ã¿æ§r;æ¿f;ìð¤aÄdrãÐesÄ;uããæ itÂ»ãÆcsuã ã¹ãÄauã¥ã¯pÄ;sáã«;ìâï¸pÄ;sá´ãµ;ìâï¸uÄbpã¿ãÆ;esááãetÄ;eáãÃ±áÆ;esá¨á­ãetÄ;eá¨ãÃ±á®Æ;afá»ã¦Ö°rÅ¥ã«Ö±Â»á¼arÃ²áÈcemtã¹ã¾ããr;ìðtmÃ®Ã±iÃ¬ãarÃ¦á¾ÄarããrÄ;fãá¿æÄanãã­ightÄepã£ãªpsiloÃ®á» hÃ©âº¯sÂ»â¡Êbcmnpã»ãáããÒ;Edemnprsãããããã£ã¬ã±ã¶æ;æ«ot;æª½Ä;dáãot;æ«ult;æ«ÄEeã¨ãª;æ«;ælus;æª¿arr;æ¥¹Æeiuã½ããtÆ;enãããqÄ;qáãeqÄ;qã«ã¨m;æ«Äbpãã;æ«;æ«cÌ;acensá­ã¬ã²ã¹ã»ã¦pproÃ¸ãºurlyeÃ±á¾Ã±á³ÆaesãããpproÃ¸ãqÃ±ãg;æªÚ123;Edehlmnpsã©ã¬ã¯áã²ã´ãããããã¨ã­è»Â¹ä¹è»Â²ä²è»Â³ä³;æ«Äosã¹ã¼t;æª¾ub;æ«Ä;dá¢ãot;æ«sÄouããl;æb;æ«arr;æ¥»ult;æ«ÄEeã¤ã¦;æ«;ælus;æ«Æeiuã´ããtÆ;enáã¼ãqÄ;qá¢ã²eqÄ;qã§ã¤m;æ«Äbpãã;æ«;æ«ÆAanãã ã­rr;ærÄhrã¦ã¨Ã«â®Ä;oà¨«à¨©war;æ¤ªligè»Ãäà¯¡ããã áã³ã¹\0ã¾ã\0\0\0\0\0ãã\0ãã¬\0\0\0ãÉ²ã\0\0ãget;æ;ärÃ«à¹Æaeyã¦ã«ã°ron;ä¥dil;ä£;älrec;ær;ìð±Èeikoãããµã¼Ç²ã\0ãeÄ4fááaÆ;svãããä¸ym;äÄcnã¢ã²kÄasã¨ã®pproÃ¸áimÂ»á¬sÃ°áÄasãºã®Ã°árnè»Ã¾ä¾Ç¬Ìãâ§esèÃ;bdãããäÄ;aá¤ãr;æ¨±;æ¨°Æepsã¡ã£ãÃ¡â©È;bcfÒã¬ã°ã´ot;æ¶ir;æ«±Ä;oã¹ã¼ìð¥rk;æ«Ã¡ã¢rime;æ´Æaipããã¤dÃ¥áÎadempstã¡ããããããngleÊ;dlqrã°ã±ã¶ããæµownÂ»á¶»eftÄ;eâ ã¾Ã±à¤®;æightÄ;eãªãÃ±áot;æ¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æchtã²ã½ãÄryã·ã»;ìð;äcy;ärok;ä§ÄioããxÃ´á·headÄlrãã eftarroÃ·à¡ightarrowÂ»à½à¤AHabcdfghlmoprstuwãããã¤ã°ã¼ã ã ã £ã ´ã¡ã¡ã¡«ã¢©ã£ã£ã£ªã£¶rÃ²Ï­ar;æ¥£Äcrãã¢uteè»ÃºäºÃ²árÇ£ãª\0ã­y;äve;ä­Äiyãµãºrcè»Ã»ä»;äÆabhã ã ã rÃ²á­lac;ä±aÃ²áÄirã ã sht;æ¥¾;ìð²raveè»Ã¹ä¹Å¡ã §ã ±rÄlrã ¬ã ®Â»à¥Â»álk;æÄctã ¹ã¡É¯ã ¿\0\0ã¡rnÄ;eã¡ã¡ærÂ»ã¡op;æri;æ¸Äalã¡ã¡cr;ä«è»Â¨ÍÄgpã¡¢ã¡¦on;ä³f;ìð¦Ìadhlsuáã¡¸ã¡½á²ã¢ã¢ ownÃ¡á³arpoonÄlrã¢ã¢efÃ´ã ­ighÃ´ã ¯iÆ;hlã¢ã¢ã¢äÂ»áºonÂ»ã¢parrows;æÆcitã¢°ã£ã£É¯ã¢¶\0\0ã£rnÄ;eã¢¼ã¢½ærÂ»ã¢½op;æng;ä¯ri;æ¹cr;ìðÆdirã£ã£ã£¢ot;æ°lde;ä©iÄ;fã°ã£¨Â»á Äamã£¯ã£²rÃ²ã¢¨lè»Ã¼ä¼angle;æ¦§ÞABDacdeflnoprszã¤ã¤ã¤©ã¤­ã¦µã¦¸ã¦½ã§ã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Änrã¤²ã¤·grt;æ¦Îeknprstã£ã¥ã¥ã¥ã¥ã¥¤ã¦appÃ¡âothinÃ§áºÆhirã«â»ã¥opÃ´â¾µÄ;há·ã¥¢Ã¯ãÄiuã¥©ã¥­gmÃ¡ã³Äbpã¥²ã¦setneqÄ;qã¥½ã¦ìâï¸;ìâ«ï¸setneqÄ;qã¦ã¦ìâï¸;ìâ«ï¸Ährã¦ã¦etÃ¡ãiangleÄlrã¦ªã¦¯eftÂ»à¤¥ightÂ»áy;ä²ashÂ»á¶Æelrã§ã§ã§Æ;beâ·ªã§ã§ar;æ»q;ælip;æ®Äbtã§á¨aÃ²á©r;ìð³trÃ©ã¦®suÄbpã§¯ã§±Â»à´Â»àµpf;ìð§roÃ°à»»trÃ©ã¦´Äcuã¨ã¨r;ìðÄbpã¨ã¨nÄEeã¦ã¨Â»ã¥¾nÄEeã¦ã¨Â»ã¦igzag;æ¦Îcefoprsã¨¶ã¨»ã©ã©ã©ã©¡ã©ªirc;äµÄdiã©ã©Äbgã©ã©ar;æ©eÄ;qáºã©;æerp;ær;ìð´pf;ìð¨Ä;eá¹ã©¦atÃ¨á¹cr;ìðà«£áãª\0ãª\0ãªãª\0\0ãªãª¨ãª«ãª¯\0\0ã«ã«\0ã«áátrÃ©ár;ìðµÄAaãªãªrÃ²ÏrÃ²à§¶;ä¾ÄAaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âis;æ»Ædptá¤ãªµãª¾Äflãªºá©;ìð©imÃ¥á²ÄAaã«ã«rÃ²ÏrÃ²à¨Äcqã«á¸r;ìðÄptáã«rÃ©áÐacefiosuã«°ã«½ã¬ã¬ã¬ã¬ã¬ã¬¡cÄuyã«¶ã«»teè»Ã½ä½;äÄiyã¬ã¬rc;ä·;änè»Â¥ä¥r;ìð¶cy;äpf;ìðªcr;ìðÄcmã¬¦ã¬©y;älè»Ã¿ä¿Ôacdefhioswã­ã­ã­ã­ã­¤ã­©ã­­ã­´ã­ºã®cute;äºÄayã­ã­ron;ä¾;ä·ot;ä¼Äetã­ã­¡trÃ¦áa;ä¶r;ìð·cy;ä¶grarr;æpf;ìð«cr;ìðÄjnã®ã®;æj;æ'.split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), b6;
}
var y6 = {}, m7;
function Rse() {
  return m7 || (m7 = 1, Object.defineProperty(y6, "__esModule", { value: !0 }), y6.default = new Uint16Array(
    // prettier-ignore
    "Èaglq	\x1BÉ­\0\0p;ä¦os;ä§t;ä¾t;ä¼uot;ä¢".split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), y6;
}
var FE = {}, v7;
function T7() {
  return v7 || (v7 = 1, function(u) {
    var r;
    Object.defineProperty(u, "__esModule", { value: !0 }), u.replaceCodePoint = u.fromCodePoint = void 0;
    var o = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    u.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (r = String.fromCodePoint) !== null && r !== void 0 ? r : function(e) {
      var n = "";
      return e > 65535 && (e -= 65536, n += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), n += String.fromCharCode(e), n;
    };
    function a(e) {
      var n;
      return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (n = o.get(e)) !== null && n !== void 0 ? n : e;
    }
    u.replaceCodePoint = a;
    function t(e) {
      return (0, u.fromCodePoint)(a(e));
    }
    u.default = t;
  }(FE)), FE;
}
var w7;
function uY() {
  return w7 || (w7 = 1, function(u) {
    var r = ri && ri.__createBinding || (Object.create ? function(S, O, x, F) {
      F === void 0 && (F = x);
      var j = Object.getOwnPropertyDescriptor(O, x);
      (!j || ("get" in j ? !O.__esModule : j.writable || j.configurable)) && (j = { enumerable: !0, get: function() {
        return O[x];
      } }), Object.defineProperty(S, F, j);
    } : function(S, O, x, F) {
      F === void 0 && (F = x), S[F] = O[x];
    }), o = ri && ri.__setModuleDefault || (Object.create ? function(S, O) {
      Object.defineProperty(S, "default", { enumerable: !0, value: O });
    } : function(S, O) {
      S.default = O;
    }), a = ri && ri.__importStar || function(S) {
      if (S && S.__esModule) return S;
      var O = {};
      if (S != null) for (var x in S) x !== "default" && Object.prototype.hasOwnProperty.call(S, x) && r(O, S, x);
      return o(O, S), O;
    }, t = ri && ri.__importDefault || function(S) {
      return S && S.__esModule ? S : { default: S };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.decodeXML = u.decodeHTMLStrict = u.decodeHTMLAttribute = u.decodeHTML = u.determineBranch = u.EntityDecoder = u.DecodingMode = u.BinTrieFlags = u.fromCodePoint = u.replaceCodePoint = u.decodeCodePoint = u.xmlDecodeTree = u.htmlDecodeTree = void 0;
    var e = t(/* @__PURE__ */ Ise());
    u.htmlDecodeTree = e.default;
    var n = t(/* @__PURE__ */ Rse());
    u.xmlDecodeTree = n.default;
    var i = a(/* @__PURE__ */ T7());
    u.decodeCodePoint = i.default;
    var c = /* @__PURE__ */ T7();
    Object.defineProperty(u, "replaceCodePoint", { enumerable: !0, get: function() {
      return c.replaceCodePoint;
    } }), Object.defineProperty(u, "fromCodePoint", { enumerable: !0, get: function() {
      return c.fromCodePoint;
    } });
    var s;
    (function(S) {
      S[S.NUM = 35] = "NUM", S[S.SEMI = 59] = "SEMI", S[S.EQUALS = 61] = "EQUALS", S[S.ZERO = 48] = "ZERO", S[S.NINE = 57] = "NINE", S[S.LOWER_A = 97] = "LOWER_A", S[S.LOWER_F = 102] = "LOWER_F", S[S.LOWER_X = 120] = "LOWER_X", S[S.LOWER_Z = 122] = "LOWER_Z", S[S.UPPER_A = 65] = "UPPER_A", S[S.UPPER_F = 70] = "UPPER_F", S[S.UPPER_Z = 90] = "UPPER_Z";
    })(s || (s = {}));
    var d = 32, l;
    (function(S) {
      S[S.VALUE_LENGTH = 49152] = "VALUE_LENGTH", S[S.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", S[S.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(l = u.BinTrieFlags || (u.BinTrieFlags = {}));
    function f(S) {
      return S >= s.ZERO && S <= s.NINE;
    }
    function h(S) {
      return S >= s.UPPER_A && S <= s.UPPER_F || S >= s.LOWER_A && S <= s.LOWER_F;
    }
    function p(S) {
      return S >= s.UPPER_A && S <= s.UPPER_Z || S >= s.LOWER_A && S <= s.LOWER_Z || f(S);
    }
    function b(S) {
      return S === s.EQUALS || p(S);
    }
    var _;
    (function(S) {
      S[S.EntityStart = 0] = "EntityStart", S[S.NumericStart = 1] = "NumericStart", S[S.NumericDecimal = 2] = "NumericDecimal", S[S.NumericHex = 3] = "NumericHex", S[S.NamedEntity = 4] = "NamedEntity";
    })(_ || (_ = {}));
    var y;
    (function(S) {
      S[S.Legacy = 0] = "Legacy", S[S.Strict = 1] = "Strict", S[S.Attribute = 2] = "Attribute";
    })(y = u.DecodingMode || (u.DecodingMode = {}));
    var m = (
      /** @class */
      function() {
        function S(O, x, F) {
          this.decodeTree = O, this.emitCodePoint = x, this.errors = F, this.state = _.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = y.Strict;
        }
        return S.prototype.startEntity = function(O) {
          this.decodeMode = O, this.state = _.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, S.prototype.write = function(O, x) {
          switch (this.state) {
            case _.EntityStart:
              return O.charCodeAt(x) === s.NUM ? (this.state = _.NumericStart, this.consumed += 1, this.stateNumericStart(O, x + 1)) : (this.state = _.NamedEntity, this.stateNamedEntity(O, x));
            case _.NumericStart:
              return this.stateNumericStart(O, x);
            case _.NumericDecimal:
              return this.stateNumericDecimal(O, x);
            case _.NumericHex:
              return this.stateNumericHex(O, x);
            case _.NamedEntity:
              return this.stateNamedEntity(O, x);
          }
        }, S.prototype.stateNumericStart = function(O, x) {
          return x >= O.length ? -1 : (O.charCodeAt(x) | d) === s.LOWER_X ? (this.state = _.NumericHex, this.consumed += 1, this.stateNumericHex(O, x + 1)) : (this.state = _.NumericDecimal, this.stateNumericDecimal(O, x));
        }, S.prototype.addToNumericResult = function(O, x, F, j) {
          if (x !== F) {
            var q = F - x;
            this.result = this.result * Math.pow(j, q) + parseInt(O.substr(x, q), j), this.consumed += q;
          }
        }, S.prototype.stateNumericHex = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j) || h(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 16), this.emitNumericEntity(j, 3);
          }
          return this.addToNumericResult(O, F, x, 16), -1;
        }, S.prototype.stateNumericDecimal = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 10), this.emitNumericEntity(j, 2);
          }
          return this.addToNumericResult(O, F, x, 10), -1;
        }, S.prototype.emitNumericEntity = function(O, x) {
          var F;
          if (this.consumed <= x)
            return (F = this.errors) === null || F === void 0 || F.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (O === s.SEMI)
            this.consumed += 1;
          else if (this.decodeMode === y.Strict)
            return 0;
          return this.emitCodePoint((0, i.replaceCodePoint)(this.result), this.consumed), this.errors && (O !== s.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, S.prototype.stateNamedEntity = function(O, x) {
          for (var F = this.decodeTree, j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14; x < O.length; x++, this.excess++) {
            var Q = O.charCodeAt(x);
            if (this.treeIndex = T(F, j, this.treeIndex + Math.max(1, q), Q), this.treeIndex < 0)
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === y.Attribute && // We shouldn't have consumed any characters after the entity,
              (q === 0 || // And there should be no invalid characters.
              b(Q)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14, q !== 0) {
              if (Q === s.SEMI)
                return this.emitNamedEntityData(this.treeIndex, q, this.consumed + this.excess);
              this.decodeMode !== y.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, S.prototype.emitNotTerminatedNamedEntity = function() {
          var O, x = this, F = x.result, j = x.decodeTree, q = (j[F] & l.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(F, q, this.consumed), (O = this.errors) === null || O === void 0 || O.missingSemicolonAfterCharacterReference(), this.consumed;
        }, S.prototype.emitNamedEntityData = function(O, x, F) {
          var j = this.decodeTree;
          return this.emitCodePoint(x === 1 ? j[O] & ~l.VALUE_LENGTH : j[O + 1], F), x === 3 && this.emitCodePoint(j[O + 2], F), F;
        }, S.prototype.end = function() {
          var O;
          switch (this.state) {
            case _.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== y.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            // Otherwise, emit a numeric entity if we have one.
            case _.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case _.NumericHex:
              return this.emitNumericEntity(0, 3);
            case _.NumericStart:
              return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case _.EntityStart:
              return 0;
          }
        }, S;
      }()
    );
    u.EntityDecoder = m;
    function g(S) {
      var O = "", x = new m(S, function(F) {
        return O += (0, i.fromCodePoint)(F);
      });
      return function(j, q) {
        for (var Q = 0, G = 0; (G = j.indexOf("&", G)) >= 0; ) {
          O += j.slice(Q, G), x.startEntity(q);
          var K = x.write(
            j,
            // Skip the "&"
            G + 1
          );
          if (K < 0) {
            Q = G + x.end();
            break;
          }
          Q = G + K, G = K === 0 ? Q + 1 : Q;
        }
        var U = O + j.slice(Q);
        return O = "", U;
      };
    }
    function T(S, O, x, F) {
      var j = (O & l.BRANCH_LENGTH) >> 7, q = O & l.JUMP_TABLE;
      if (j === 0)
        return q !== 0 && F === q ? x : -1;
      if (q) {
        var Q = F - q;
        return Q < 0 || Q >= j ? -1 : S[x + Q] - 1;
      }
      for (var G = x, K = G + j - 1; G <= K; ) {
        var U = G + K >>> 1, ae = S[U];
        if (ae < F)
          G = U + 1;
        else if (ae > F)
          K = U - 1;
        else
          return S[U + j];
      }
      return -1;
    }
    u.determineBranch = T;
    var v = g(e.default), E = g(n.default);
    function R(S, O) {
      return O === void 0 && (O = y.Legacy), v(S, O);
    }
    u.decodeHTML = R;
    function L(S) {
      return v(S, y.Attribute);
    }
    u.decodeHTMLAttribute = L;
    function A(S) {
      return v(S, y.Strict);
    }
    u.decodeHTMLStrict = A;
    function w(S) {
      return E(S, y.Strict);
    }
    u.decodeXML = w;
  }(ri)), ri;
}
var S7;
function oY() {
  return S7 || (S7 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.QuoteType = void 0;
    var r = /* @__PURE__ */ uY(), o;
    (function(f) {
      f[f.Tab = 9] = "Tab", f[f.NewLine = 10] = "NewLine", f[f.FormFeed = 12] = "FormFeed", f[f.CarriageReturn = 13] = "CarriageReturn", f[f.Space = 32] = "Space", f[f.ExclamationMark = 33] = "ExclamationMark", f[f.Number = 35] = "Number", f[f.Amp = 38] = "Amp", f[f.SingleQuote = 39] = "SingleQuote", f[f.DoubleQuote = 34] = "DoubleQuote", f[f.Dash = 45] = "Dash", f[f.Slash = 47] = "Slash", f[f.Zero = 48] = "Zero", f[f.Nine = 57] = "Nine", f[f.Semi = 59] = "Semi", f[f.Lt = 60] = "Lt", f[f.Eq = 61] = "Eq", f[f.Gt = 62] = "Gt", f[f.Questionmark = 63] = "Questionmark", f[f.UpperA = 65] = "UpperA", f[f.LowerA = 97] = "LowerA", f[f.UpperF = 70] = "UpperF", f[f.LowerF = 102] = "LowerF", f[f.UpperZ = 90] = "UpperZ", f[f.LowerZ = 122] = "LowerZ", f[f.LowerX = 120] = "LowerX", f[f.OpeningSquareBracket = 91] = "OpeningSquareBracket";
    })(o || (o = {}));
    var a;
    (function(f) {
      f[f.Text = 1] = "Text", f[f.BeforeTagName = 2] = "BeforeTagName", f[f.InTagName = 3] = "InTagName", f[f.InSelfClosingTag = 4] = "InSelfClosingTag", f[f.BeforeClosingTagName = 5] = "BeforeClosingTagName", f[f.InClosingTagName = 6] = "InClosingTagName", f[f.AfterClosingTagName = 7] = "AfterClosingTagName", f[f.BeforeAttributeName = 8] = "BeforeAttributeName", f[f.InAttributeName = 9] = "InAttributeName", f[f.AfterAttributeName = 10] = "AfterAttributeName", f[f.BeforeAttributeValue = 11] = "BeforeAttributeValue", f[f.InAttributeValueDq = 12] = "InAttributeValueDq", f[f.InAttributeValueSq = 13] = "InAttributeValueSq", f[f.InAttributeValueNq = 14] = "InAttributeValueNq", f[f.BeforeDeclaration = 15] = "BeforeDeclaration", f[f.InDeclaration = 16] = "InDeclaration", f[f.InProcessingInstruction = 17] = "InProcessingInstruction", f[f.BeforeComment = 18] = "BeforeComment", f[f.CDATASequence = 19] = "CDATASequence", f[f.InSpecialComment = 20] = "InSpecialComment", f[f.InCommentLike = 21] = "InCommentLike", f[f.BeforeSpecialS = 22] = "BeforeSpecialS", f[f.SpecialStartSequence = 23] = "SpecialStartSequence", f[f.InSpecialTag = 24] = "InSpecialTag", f[f.BeforeEntity = 25] = "BeforeEntity", f[f.BeforeNumericEntity = 26] = "BeforeNumericEntity", f[f.InNamedEntity = 27] = "InNamedEntity", f[f.InNumericEntity = 28] = "InNumericEntity", f[f.InHexEntity = 29] = "InHexEntity";
    })(a || (a = {}));
    function t(f) {
      return f === o.Space || f === o.NewLine || f === o.Tab || f === o.FormFeed || f === o.CarriageReturn;
    }
    function e(f) {
      return f === o.Slash || f === o.Gt || t(f);
    }
    function n(f) {
      return f >= o.Zero && f <= o.Nine;
    }
    function i(f) {
      return f >= o.LowerA && f <= o.LowerZ || f >= o.UpperA && f <= o.UpperZ;
    }
    function c(f) {
      return f >= o.UpperA && f <= o.UpperF || f >= o.LowerA && f <= o.LowerF;
    }
    var s;
    (function(f) {
      f[f.NoValue = 0] = "NoValue", f[f.Unquoted = 1] = "Unquoted", f[f.Single = 2] = "Single", f[f.Double = 3] = "Double";
    })(s = u.QuoteType || (u.QuoteType = {}));
    var d = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    }, l = (
      /** @class */
      function() {
        function f(h, p) {
          var b = h.xmlMode, _ = b === void 0 ? !1 : b, y = h.decodeEntities, m = y === void 0 ? !0 : y;
          this.cbs = p, this.state = a.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = a.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = _, this.decodeEntities = m, this.entityTrie = _ ? r.xmlDecodeTree : r.htmlDecodeTree;
        }
        return f.prototype.reset = function() {
          this.state = a.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = a.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
        }, f.prototype.write = function(h) {
          this.offset += this.buffer.length, this.buffer = h, this.parse();
        }, f.prototype.end = function() {
          this.running && this.finish();
        }, f.prototype.pause = function() {
          this.running = !1;
        }, f.prototype.resume = function() {
          this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
        }, f.prototype.getIndex = function() {
          return this.index;
        }, f.prototype.getSectionStart = function() {
          return this.sectionStart;
        }, f.prototype.stateText = function(h) {
          h === o.Lt || !this.decodeEntities && this.fastForwardTo(o.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = a.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && h === o.Amp && (this.state = a.BeforeEntity);
        }, f.prototype.stateSpecialStartSequence = function(h) {
          var p = this.sequenceIndex === this.currentSequence.length, b = p ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            e(h)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (h | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!b)
            this.isSpecial = !1;
          else if (!p) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0, this.state = a.InTagName, this.stateInTagName(h);
        }, f.prototype.stateInSpecialTag = function(h) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (h === o.Gt || t(h)) {
              var p = this.index - this.currentSequence.length;
              if (this.sectionStart < p) {
                var b = this.index;
                this.index = p, this.cbs.ontext(this.sectionStart, p), this.index = b;
              }
              this.isSpecial = !1, this.sectionStart = p + 2, this.stateInClosingTagName(h);
              return;
            }
            this.sequenceIndex = 0;
          }
          (h | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === d.TitleEnd ? this.decodeEntities && h === o.Amp && (this.state = a.BeforeEntity) : this.fastForwardTo(o.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(h === o.Lt);
        }, f.prototype.stateCDATASequence = function(h) {
          h === d.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === d.Cdata.length && (this.state = a.InCommentLike, this.currentSequence = d.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = a.InDeclaration, this.stateInDeclaration(h));
        }, f.prototype.fastForwardTo = function(h) {
          for (; ++this.index < this.buffer.length + this.offset; )
            if (this.buffer.charCodeAt(this.index - this.offset) === h)
              return !0;
          return this.index = this.buffer.length + this.offset - 1, !1;
        }, f.prototype.stateInCommentLike = function(h) {
          h === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === d.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = a.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : h !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }, f.prototype.isTagStartChar = function(h) {
          return this.xmlMode ? !e(h) : i(h);
        }, f.prototype.startSpecial = function(h, p) {
          this.isSpecial = !0, this.currentSequence = h, this.sequenceIndex = p, this.state = a.SpecialStartSequence;
        }, f.prototype.stateBeforeTagName = function(h) {
          if (h === o.ExclamationMark)
            this.state = a.BeforeDeclaration, this.sectionStart = this.index + 1;
          else if (h === o.Questionmark)
            this.state = a.InProcessingInstruction, this.sectionStart = this.index + 1;
          else if (this.isTagStartChar(h)) {
            var p = h | 32;
            this.sectionStart = this.index, !this.xmlMode && p === d.TitleEnd[2] ? this.startSpecial(d.TitleEnd, 3) : this.state = !this.xmlMode && p === d.ScriptEnd[2] ? a.BeforeSpecialS : a.InTagName;
          } else h === o.Slash ? this.state = a.BeforeClosingTagName : (this.state = a.Text, this.stateText(h));
        }, f.prototype.stateInTagName = function(h) {
          e(h) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h));
        }, f.prototype.stateBeforeClosingTagName = function(h) {
          t(h) || (h === o.Gt ? this.state = a.Text : (this.state = this.isTagStartChar(h) ? a.InClosingTagName : a.InSpecialComment, this.sectionStart = this.index));
        }, f.prototype.stateInClosingTagName = function(h) {
          (h === o.Gt || t(h)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.AfterClosingTagName, this.stateAfterClosingTagName(h));
        }, f.prototype.stateAfterClosingTagName = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.state = a.Text, this.baseState = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeAttributeName = function(h) {
          h === o.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = a.InSpecialTag, this.sequenceIndex = 0) : this.state = a.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : h === o.Slash ? this.state = a.InSelfClosingTag : t(h) || (this.state = a.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateInSelfClosingTag = function(h) {
          h === o.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = a.Text, this.baseState = a.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : t(h) || (this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h));
        }, f.prototype.stateInAttributeName = function(h) {
          (h === o.Eq || e(h)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.AfterAttributeName, this.stateAfterAttributeName(h));
        }, f.prototype.stateAfterAttributeName = function(h) {
          h === o.Eq ? this.state = a.BeforeAttributeValue : h === o.Slash || h === o.Gt ? (this.cbs.onattribend(s.NoValue, this.index), this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h)) : t(h) || (this.cbs.onattribend(s.NoValue, this.index), this.state = a.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateBeforeAttributeValue = function(h) {
          h === o.DoubleQuote ? (this.state = a.InAttributeValueDq, this.sectionStart = this.index + 1) : h === o.SingleQuote ? (this.state = a.InAttributeValueSq, this.sectionStart = this.index + 1) : t(h) || (this.sectionStart = this.index, this.state = a.InAttributeValueNq, this.stateInAttributeValueNoQuotes(h));
        }, f.prototype.handleInAttributeValue = function(h, p) {
          h === p || !this.decodeEntities && this.fastForwardTo(p) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(p === o.DoubleQuote ? s.Double : s.Single, this.index), this.state = a.BeforeAttributeName) : this.decodeEntities && h === o.Amp && (this.baseState = this.state, this.state = a.BeforeEntity);
        }, f.prototype.stateInAttributeValueDoubleQuotes = function(h) {
          this.handleInAttributeValue(h, o.DoubleQuote);
        }, f.prototype.stateInAttributeValueSingleQuotes = function(h) {
          this.handleInAttributeValue(h, o.SingleQuote);
        }, f.prototype.stateInAttributeValueNoQuotes = function(h) {
          t(h) || h === o.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(s.Unquoted, this.index), this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h)) : this.decodeEntities && h === o.Amp && (this.baseState = this.state, this.state = a.BeforeEntity);
        }, f.prototype.stateBeforeDeclaration = function(h) {
          h === o.OpeningSquareBracket ? (this.state = a.CDATASequence, this.sequenceIndex = 0) : this.state = h === o.Dash ? a.BeforeComment : a.InDeclaration;
        }, f.prototype.stateInDeclaration = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateInProcessingInstruction = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeComment = function(h) {
          h === o.Dash ? (this.state = a.InCommentLike, this.currentSequence = d.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = a.InDeclaration;
        }, f.prototype.stateInSpecialComment = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeSpecialS = function(h) {
          var p = h | 32;
          p === d.ScriptEnd[3] ? this.startSpecial(d.ScriptEnd, 4) : p === d.StyleEnd[3] ? this.startSpecial(d.StyleEnd, 4) : (this.state = a.InTagName, this.stateInTagName(h));
        }, f.prototype.stateBeforeEntity = function(h) {
          this.entityExcess = 1, this.entityResult = 0, h === o.Number ? this.state = a.BeforeNumericEntity : h === o.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = a.InNamedEntity, this.stateInNamedEntity(h));
        }, f.prototype.stateInNamedEntity = function(h) {
          if (this.entityExcess += 1, this.trieIndex = (0, r.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, h), this.trieIndex < 0) {
            this.emitNamedEntity(), this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var p = this.trieCurrent & r.BinTrieFlags.VALUE_LENGTH;
          if (p) {
            var b = (p >> 14) - 1;
            if (!this.allowLegacyEntity() && h !== o.Semi)
              this.trieIndex += b;
            else {
              var _ = this.index - this.entityExcess + 1;
              _ > this.sectionStart && this.emitPartial(this.sectionStart, _), this.entityResult = this.trieIndex, this.trieIndex += b, this.entityExcess = 0, this.sectionStart = this.index + 1, b === 0 && this.emitNamedEntity();
            }
          }
        }, f.prototype.emitNamedEntity = function() {
          if (this.state = this.baseState, this.entityResult !== 0) {
            var h = (this.entityTrie[this.entityResult] & r.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (h) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~r.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        }, f.prototype.stateBeforeNumericEntity = function(h) {
          (h | 32) === o.LowerX ? (this.entityExcess++, this.state = a.InHexEntity) : (this.state = a.InNumericEntity, this.stateInNumericEntity(h));
        }, f.prototype.emitNumericEntity = function(h) {
          var p = this.index - this.entityExcess - 1, b = p + 2 + +(this.state === a.InHexEntity);
          b !== this.index && (p > this.sectionStart && this.emitPartial(this.sectionStart, p), this.sectionStart = this.index + Number(h), this.emitCodePoint((0, r.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
        }, f.prototype.stateInNumericEntity = function(h) {
          h === o.Semi ? this.emitNumericEntity(!0) : n(h) ? (this.entityResult = this.entityResult * 10 + (h - o.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.stateInHexEntity = function(h) {
          h === o.Semi ? this.emitNumericEntity(!0) : n(h) ? (this.entityResult = this.entityResult * 16 + (h - o.Zero), this.entityExcess++) : c(h) ? (this.entityResult = this.entityResult * 16 + ((h | 32) - o.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === a.Text || this.baseState === a.InSpecialTag);
        }, f.prototype.cleanup = function() {
          this.running && this.sectionStart !== this.index && (this.state === a.Text || this.state === a.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === a.InAttributeValueDq || this.state === a.InAttributeValueSq || this.state === a.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
        }, f.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        }, f.prototype.parse = function() {
          for (; this.shouldContinue(); ) {
            var h = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case a.Text: {
                this.stateText(h);
                break;
              }
              case a.SpecialStartSequence: {
                this.stateSpecialStartSequence(h);
                break;
              }
              case a.InSpecialTag: {
                this.stateInSpecialTag(h);
                break;
              }
              case a.CDATASequence: {
                this.stateCDATASequence(h);
                break;
              }
              case a.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(h);
                break;
              }
              case a.InAttributeName: {
                this.stateInAttributeName(h);
                break;
              }
              case a.InCommentLike: {
                this.stateInCommentLike(h);
                break;
              }
              case a.InSpecialComment: {
                this.stateInSpecialComment(h);
                break;
              }
              case a.BeforeAttributeName: {
                this.stateBeforeAttributeName(h);
                break;
              }
              case a.InTagName: {
                this.stateInTagName(h);
                break;
              }
              case a.InClosingTagName: {
                this.stateInClosingTagName(h);
                break;
              }
              case a.BeforeTagName: {
                this.stateBeforeTagName(h);
                break;
              }
              case a.AfterAttributeName: {
                this.stateAfterAttributeName(h);
                break;
              }
              case a.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(h);
                break;
              }
              case a.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(h);
                break;
              }
              case a.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(h);
                break;
              }
              case a.AfterClosingTagName: {
                this.stateAfterClosingTagName(h);
                break;
              }
              case a.BeforeSpecialS: {
                this.stateBeforeSpecialS(h);
                break;
              }
              case a.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(h);
                break;
              }
              case a.InSelfClosingTag: {
                this.stateInSelfClosingTag(h);
                break;
              }
              case a.InDeclaration: {
                this.stateInDeclaration(h);
                break;
              }
              case a.BeforeDeclaration: {
                this.stateBeforeDeclaration(h);
                break;
              }
              case a.BeforeComment: {
                this.stateBeforeComment(h);
                break;
              }
              case a.InProcessingInstruction: {
                this.stateInProcessingInstruction(h);
                break;
              }
              case a.InNamedEntity: {
                this.stateInNamedEntity(h);
                break;
              }
              case a.BeforeEntity: {
                this.stateBeforeEntity(h);
                break;
              }
              case a.InHexEntity: {
                this.stateInHexEntity(h);
                break;
              }
              case a.InNumericEntity: {
                this.stateInNumericEntity(h);
                break;
              }
              default:
                this.stateBeforeNumericEntity(h);
            }
            this.index++;
          }
          this.cleanup();
        }, f.prototype.finish = function() {
          this.state === a.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
        }, f.prototype.handleTrailingData = function() {
          var h = this.buffer.length + this.offset;
          this.state === a.InCommentLike ? this.currentSequence === d.CdataEnd ? this.cbs.oncdata(this.sectionStart, h, 0) : this.cbs.oncomment(this.sectionStart, h, 0) : this.state === a.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === a.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === a.InTagName || this.state === a.BeforeAttributeName || this.state === a.BeforeAttributeValue || this.state === a.AfterAttributeName || this.state === a.InAttributeName || this.state === a.InAttributeValueSq || this.state === a.InAttributeValueDq || this.state === a.InAttributeValueNq || this.state === a.InClosingTagName || this.cbs.ontext(this.sectionStart, h);
        }, f.prototype.emitPartial = function(h, p) {
          this.baseState !== a.Text && this.baseState !== a.InSpecialTag ? this.cbs.onattribdata(h, p) : this.cbs.ontext(h, p);
        }, f.prototype.emitCodePoint = function(h) {
          this.baseState !== a.Text && this.baseState !== a.InSpecialTag ? this.cbs.onattribentity(h) : this.cbs.ontextentity(h);
        }, f;
      }()
    );
    u.default = l;
  }(RE)), RE;
}
var A7;
function E7() {
  if (A7) return ti;
  A7 = 1;
  var u = ti && ti.__createBinding || (Object.create ? function(_, y, m, g) {
    g === void 0 && (g = m);
    var T = Object.getOwnPropertyDescriptor(y, m);
    (!T || ("get" in T ? !y.__esModule : T.writable || T.configurable)) && (T = { enumerable: !0, get: function() {
      return y[m];
    } }), Object.defineProperty(_, g, T);
  } : function(_, y, m, g) {
    g === void 0 && (g = m), _[g] = y[m];
  }), r = ti && ti.__setModuleDefault || (Object.create ? function(_, y) {
    Object.defineProperty(_, "default", { enumerable: !0, value: y });
  } : function(_, y) {
    _.default = y;
  }), o = ti && ti.__importStar || function(_) {
    if (_ && _.__esModule) return _;
    var y = {};
    if (_ != null) for (var m in _) m !== "default" && Object.prototype.hasOwnProperty.call(_, m) && u(y, _, m);
    return r(y, _), y;
  };
  Object.defineProperty(ti, "__esModule", { value: !0 }), ti.Parser = void 0;
  var a = o(/* @__PURE__ */ oY()), t = /* @__PURE__ */ uY(), e = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), n = /* @__PURE__ */ new Set(["p"]), i = /* @__PURE__ */ new Set(["thead", "tbody"]), c = /* @__PURE__ */ new Set(["dd", "dt"]), s = /* @__PURE__ */ new Set(["rt", "rp"]), d = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", n],
    ["h1", n],
    ["h2", n],
    ["h3", n],
    ["h4", n],
    ["h5", n],
    ["h6", n],
    ["select", e],
    ["input", e],
    ["output", e],
    ["button", e],
    ["datalist", e],
    ["textarea", e],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", c],
    ["dt", c],
    ["address", n],
    ["article", n],
    ["aside", n],
    ["blockquote", n],
    ["details", n],
    ["div", n],
    ["dl", n],
    ["fieldset", n],
    ["figcaption", n],
    ["figure", n],
    ["footer", n],
    ["form", n],
    ["header", n],
    ["hr", n],
    ["main", n],
    ["nav", n],
    ["ol", n],
    ["pre", n],
    ["section", n],
    ["table", n],
    ["ul", n],
    ["rt", s],
    ["rp", s],
    ["tbody", i],
    ["tfoot", i]
  ]), l = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), f = /* @__PURE__ */ new Set(["math", "svg"]), h = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]), p = /\s|\//, b = (
    /** @class */
    function() {
      function _(y, m) {
        m === void 0 && (m = {});
        var g, T, v, E, R;
        this.options = m, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = y ?? {}, this.lowerCaseTagNames = (g = m.lowerCaseTags) !== null && g !== void 0 ? g : !m.xmlMode, this.lowerCaseAttributeNames = (T = m.lowerCaseAttributeNames) !== null && T !== void 0 ? T : !m.xmlMode, this.tokenizer = new ((v = m.Tokenizer) !== null && v !== void 0 ? v : a.default)(this.options, this), (R = (E = this.cbs).onparserinit) === null || R === void 0 || R.call(E, this);
      }
      return _.prototype.ontext = function(y, m) {
        var g, T, v = this.getSlice(y, m);
        this.endIndex = m - 1, (T = (g = this.cbs).ontext) === null || T === void 0 || T.call(g, v), this.startIndex = m;
      }, _.prototype.ontextentity = function(y) {
        var m, g, T = this.tokenizer.getSectionStart();
        this.endIndex = T - 1, (g = (m = this.cbs).ontext) === null || g === void 0 || g.call(m, (0, t.fromCodePoint)(y)), this.startIndex = T;
      }, _.prototype.isVoidElement = function(y) {
        return !this.options.xmlMode && l.has(y);
      }, _.prototype.onopentagname = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        this.lowerCaseTagNames && (g = g.toLowerCase()), this.emitOpenTag(g);
      }, _.prototype.emitOpenTag = function(y) {
        var m, g, T, v;
        this.openTagStart = this.startIndex, this.tagname = y;
        var E = !this.options.xmlMode && d.get(y);
        if (E)
          for (; this.stack.length > 0 && E.has(this.stack[this.stack.length - 1]); ) {
            var R = this.stack.pop();
            (g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, R, !0);
          }
        this.isVoidElement(y) || (this.stack.push(y), f.has(y) ? this.foreignContext.push(!0) : h.has(y) && this.foreignContext.push(!1)), (v = (T = this.cbs).onopentagname) === null || v === void 0 || v.call(T, y), this.cbs.onopentag && (this.attribs = {});
      }, _.prototype.endOpenTag = function(y) {
        var m, g;
        this.startIndex = this.openTagStart, this.attribs && ((g = (m = this.cbs).onopentag) === null || g === void 0 || g.call(m, this.tagname, this.attribs, y), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
      }, _.prototype.onopentagend = function(y) {
        this.endIndex = y, this.endOpenTag(!1), this.startIndex = y + 1;
      }, _.prototype.onclosetag = function(y, m) {
        var g, T, v, E, R, L;
        this.endIndex = m;
        var A = this.getSlice(y, m);
        if (this.lowerCaseTagNames && (A = A.toLowerCase()), (f.has(A) || h.has(A)) && this.foreignContext.pop(), this.isVoidElement(A))
          !this.options.xmlMode && A === "br" && ((T = (g = this.cbs).onopentagname) === null || T === void 0 || T.call(g, "br"), (E = (v = this.cbs).onopentag) === null || E === void 0 || E.call(v, "br", {}, !0), (L = (R = this.cbs).onclosetag) === null || L === void 0 || L.call(R, "br", !1));
        else {
          var w = this.stack.lastIndexOf(A);
          if (w !== -1)
            if (this.cbs.onclosetag)
              for (var S = this.stack.length - w; S--; )
                this.cbs.onclosetag(this.stack.pop(), S !== 0);
            else
              this.stack.length = w;
          else !this.options.xmlMode && A === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
        }
        this.startIndex = m + 1;
      }, _.prototype.onselfclosingtag = function(y) {
        this.endIndex = y, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = y + 1) : this.onopentagend(y);
      }, _.prototype.closeCurrentTag = function(y) {
        var m, g, T = this.tagname;
        this.endOpenTag(y), this.stack[this.stack.length - 1] === T && ((g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, T, !y), this.stack.pop());
      }, _.prototype.onattribname = function(y, m) {
        this.startIndex = y;
        var g = this.getSlice(y, m);
        this.attribname = this.lowerCaseAttributeNames ? g.toLowerCase() : g;
      }, _.prototype.onattribdata = function(y, m) {
        this.attribvalue += this.getSlice(y, m);
      }, _.prototype.onattribentity = function(y) {
        this.attribvalue += (0, t.fromCodePoint)(y);
      }, _.prototype.onattribend = function(y, m) {
        var g, T;
        this.endIndex = m, (T = (g = this.cbs).onattribute) === null || T === void 0 || T.call(g, this.attribname, this.attribvalue, y === a.QuoteType.Double ? '"' : y === a.QuoteType.Single ? "'" : y === a.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
      }, _.prototype.getInstructionName = function(y) {
        var m = y.search(p), g = m < 0 ? y : y.substr(0, m);
        return this.lowerCaseTagNames && (g = g.toLowerCase()), g;
      }, _.prototype.ondeclaration = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        if (this.cbs.onprocessinginstruction) {
          var T = this.getInstructionName(g);
          this.cbs.onprocessinginstruction("!".concat(T), "!".concat(g));
        }
        this.startIndex = m + 1;
      }, _.prototype.onprocessinginstruction = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        if (this.cbs.onprocessinginstruction) {
          var T = this.getInstructionName(g);
          this.cbs.onprocessinginstruction("?".concat(T), "?".concat(g));
        }
        this.startIndex = m + 1;
      }, _.prototype.oncomment = function(y, m, g) {
        var T, v, E, R;
        this.endIndex = m, (v = (T = this.cbs).oncomment) === null || v === void 0 || v.call(T, this.getSlice(y, m - g)), (R = (E = this.cbs).oncommentend) === null || R === void 0 || R.call(E), this.startIndex = m + 1;
      }, _.prototype.oncdata = function(y, m, g) {
        var T, v, E, R, L, A, w, S, O, x;
        this.endIndex = m;
        var F = this.getSlice(y, m - g);
        this.options.xmlMode || this.options.recognizeCDATA ? ((v = (T = this.cbs).oncdatastart) === null || v === void 0 || v.call(T), (R = (E = this.cbs).ontext) === null || R === void 0 || R.call(E, F), (A = (L = this.cbs).oncdataend) === null || A === void 0 || A.call(L)) : ((S = (w = this.cbs).oncomment) === null || S === void 0 || S.call(w, "[CDATA[".concat(F, "]]")), (x = (O = this.cbs).oncommentend) === null || x === void 0 || x.call(O)), this.startIndex = m + 1;
      }, _.prototype.onend = function() {
        var y, m;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var g = this.stack.length; g > 0; this.cbs.onclosetag(this.stack[--g], !0))
            ;
        }
        (m = (y = this.cbs).onend) === null || m === void 0 || m.call(y);
      }, _.prototype.reset = function() {
        var y, m, g, T;
        (m = (y = this.cbs).onreset) === null || m === void 0 || m.call(y), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (T = (g = this.cbs).onparserinit) === null || T === void 0 || T.call(g, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
      }, _.prototype.parseComplete = function(y) {
        this.reset(), this.end(y);
      }, _.prototype.getSlice = function(y, m) {
        for (; y - this.bufferOffset >= this.buffers[0].length; )
          this.shiftBuffer();
        for (var g = this.buffers[0].slice(y - this.bufferOffset, m - this.bufferOffset); m - this.bufferOffset > this.buffers[0].length; )
          this.shiftBuffer(), g += this.buffers[0].slice(0, m - this.bufferOffset);
        return g;
      }, _.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
      }, _.prototype.write = function(y) {
        var m, g;
        if (this.ended) {
          (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(y), this.tokenizer.running && (this.tokenizer.write(y), this.writeIndex++);
      }, _.prototype.end = function(y) {
        var m, g;
        if (this.ended) {
          (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".end() after done!"));
          return;
        }
        y && this.write(y), this.ended = !0, this.tokenizer.end();
      }, _.prototype.pause = function() {
        this.tokenizer.pause();
      }, _.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
          this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end();
      }, _.prototype.parseChunk = function(y) {
        this.write(y);
      }, _.prototype.done = function(y) {
        this.end(y);
      }, _;
    }()
  );
  return ti.Parser = b, ti;
}
var cs = {}, NE = {}, O7;
function i0() {
  return O7 || (O7 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.Doctype = u.CDATA = u.Tag = u.Style = u.Script = u.Comment = u.Directive = u.Text = u.Root = u.isTag = u.ElementType = void 0;
    var r;
    (function(a) {
      a.Root = "root", a.Text = "text", a.Directive = "directive", a.Comment = "comment", a.Script = "script", a.Style = "style", a.Tag = "tag", a.CDATA = "cdata", a.Doctype = "doctype";
    })(r = u.ElementType || (u.ElementType = {}));
    function o(a) {
      return a.type === r.Tag || a.type === r.Script || a.type === r.Style;
    }
    u.isTag = o, u.Root = r.Root, u.Text = r.Text, u.Directive = r.Directive, u.Comment = r.Comment, u.Script = r.Script, u.Style = r.Style, u.Tag = r.Tag, u.CDATA = r.CDATA, u.Doctype = r.Doctype;
  }(NE)), NE;
}
var mt = {}, x7;
function I7() {
  if (x7) return mt;
  x7 = 1;
  var u = mt && mt.__extends || /* @__PURE__ */ function() {
    var v = function(E, R) {
      return v = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(L, A) {
        L.__proto__ = A;
      } || function(L, A) {
        for (var w in A) Object.prototype.hasOwnProperty.call(A, w) && (L[w] = A[w]);
      }, v(E, R);
    };
    return function(E, R) {
      if (typeof R != "function" && R !== null)
        throw new TypeError("Class extends value " + String(R) + " is not a constructor or null");
      v(E, R);
      function L() {
        this.constructor = E;
      }
      E.prototype = R === null ? Object.create(R) : (L.prototype = R.prototype, new L());
    };
  }(), r = mt && mt.__assign || function() {
    return r = Object.assign || function(v) {
      for (var E, R = 1, L = arguments.length; R < L; R++) {
        E = arguments[R];
        for (var A in E) Object.prototype.hasOwnProperty.call(E, A) && (v[A] = E[A]);
      }
      return v;
    }, r.apply(this, arguments);
  };
  Object.defineProperty(mt, "__esModule", { value: !0 }), mt.cloneNode = mt.hasChildren = mt.isDocument = mt.isDirective = mt.isComment = mt.isText = mt.isCDATA = mt.isTag = mt.Element = mt.Document = mt.CDATA = mt.NodeWithChildren = mt.ProcessingInstruction = mt.Comment = mt.Text = mt.DataNode = mt.Node = void 0;
  var o = /* @__PURE__ */ i0(), a = (
    /** @class */
    function() {
      function v() {
        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return Object.defineProperty(v.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.parent;
        },
        set: function(E) {
          this.parent = E;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.prev;
        },
        set: function(E) {
          this.prev = E;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.next;
        },
        set: function(E) {
          this.next = E;
        },
        enumerable: !1,
        configurable: !0
      }), v.prototype.cloneNode = function(E) {
        return E === void 0 && (E = !1), g(this, E);
      }, v;
    }()
  );
  mt.Node = a;
  var t = (
    /** @class */
    function(v) {
      u(E, v);
      function E(R) {
        var L = v.call(this) || this;
        return L.data = R, L;
      }
      return Object.defineProperty(E.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.data;
        },
        set: function(R) {
          this.data = R;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(a)
  );
  mt.DataNode = t;
  var e = (
    /** @class */
    function(v) {
      u(E, v);
      function E() {
        var R = v !== null && v.apply(this, arguments) || this;
        return R.type = o.ElementType.Text, R;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 3;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(t)
  );
  mt.Text = e;
  var n = (
    /** @class */
    function(v) {
      u(E, v);
      function E() {
        var R = v !== null && v.apply(this, arguments) || this;
        return R.type = o.ElementType.Comment, R;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 8;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(t)
  );
  mt.Comment = n;
  var i = (
    /** @class */
    function(v) {
      u(E, v);
      function E(R, L) {
        var A = v.call(this, L) || this;
        return A.name = R, A.type = o.ElementType.Directive, A;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(t)
  );
  mt.ProcessingInstruction = i;
  var c = (
    /** @class */
    function(v) {
      u(E, v);
      function E(R) {
        var L = v.call(this) || this;
        return L.children = R, L;
      }
      return Object.defineProperty(E.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function() {
          var R;
          return (R = this.children[0]) !== null && R !== void 0 ? R : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(E.prototype, "lastChild", {
        /** Last child of the node. */
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(E.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.children;
        },
        set: function(R) {
          this.children = R;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(a)
  );
  mt.NodeWithChildren = c;
  var s = (
    /** @class */
    function(v) {
      u(E, v);
      function E() {
        var R = v !== null && v.apply(this, arguments) || this;
        return R.type = o.ElementType.CDATA, R;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 4;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(c)
  );
  mt.CDATA = s;
  var d = (
    /** @class */
    function(v) {
      u(E, v);
      function E() {
        var R = v !== null && v.apply(this, arguments) || this;
        return R.type = o.ElementType.Root, R;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 9;
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(c)
  );
  mt.Document = d;
  var l = (
    /** @class */
    function(v) {
      u(E, v);
      function E(R, L, A, w) {
        A === void 0 && (A = []), w === void 0 && (w = R === "script" ? o.ElementType.Script : R === "style" ? o.ElementType.Style : o.ElementType.Tag);
        var S = v.call(this, A) || this;
        return S.name = R, S.attribs = L, S.type = w, S;
      }
      return Object.defineProperty(E.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(E.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.name;
        },
        set: function(R) {
          this.name = R;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(E.prototype, "attributes", {
        get: function() {
          var R = this;
          return Object.keys(this.attribs).map(function(L) {
            var A, w;
            return {
              name: L,
              value: R.attribs[L],
              namespace: (A = R["x-attribsNamespace"]) === null || A === void 0 ? void 0 : A[L],
              prefix: (w = R["x-attribsPrefix"]) === null || w === void 0 ? void 0 : w[L]
            };
          });
        },
        enumerable: !1,
        configurable: !0
      }), E;
    }(c)
  );
  mt.Element = l;
  function f(v) {
    return (0, o.isTag)(v);
  }
  mt.isTag = f;
  function h(v) {
    return v.type === o.ElementType.CDATA;
  }
  mt.isCDATA = h;
  function p(v) {
    return v.type === o.ElementType.Text;
  }
  mt.isText = p;
  function b(v) {
    return v.type === o.ElementType.Comment;
  }
  mt.isComment = b;
  function _(v) {
    return v.type === o.ElementType.Directive;
  }
  mt.isDirective = _;
  function y(v) {
    return v.type === o.ElementType.Root;
  }
  mt.isDocument = y;
  function m(v) {
    return Object.prototype.hasOwnProperty.call(v, "children");
  }
  mt.hasChildren = m;
  function g(v, E) {
    E === void 0 && (E = !1);
    var R;
    if (p(v))
      R = new e(v.data);
    else if (b(v))
      R = new n(v.data);
    else if (f(v)) {
      var L = E ? T(v.children) : [], A = new l(v.name, r({}, v.attribs), L);
      L.forEach(function(x) {
        return x.parent = A;
      }), v.namespace != null && (A.namespace = v.namespace), v["x-attribsNamespace"] && (A["x-attribsNamespace"] = r({}, v["x-attribsNamespace"])), v["x-attribsPrefix"] && (A["x-attribsPrefix"] = r({}, v["x-attribsPrefix"])), R = A;
    } else if (h(v)) {
      var L = E ? T(v.children) : [], w = new s(L);
      L.forEach(function(F) {
        return F.parent = w;
      }), R = w;
    } else if (y(v)) {
      var L = E ? T(v.children) : [], S = new d(L);
      L.forEach(function(F) {
        return F.parent = S;
      }), v["x-mode"] && (S["x-mode"] = v["x-mode"]), R = S;
    } else if (_(v)) {
      var O = new i(v.name, v.data);
      v["x-name"] != null && (O["x-name"] = v["x-name"], O["x-publicId"] = v["x-publicId"], O["x-systemId"] = v["x-systemId"]), R = O;
    } else
      throw new Error("Not implemented yet: ".concat(v.type));
    return R.startIndex = v.startIndex, R.endIndex = v.endIndex, v.sourceCodeLocation != null && (R.sourceCodeLocation = v.sourceCodeLocation), R;
  }
  mt.cloneNode = g;
  function T(v) {
    for (var E = v.map(function(L) {
      return g(L, !0);
    }), R = 1; R < E.length; R++)
      E[R].prev = E[R - 1], E[R - 1].next = E[R];
    return E;
  }
  return mt;
}
var R7;
function Vn() {
  return R7 || (R7 = 1, function(u) {
    var r = cs && cs.__createBinding || (Object.create ? function(i, c, s, d) {
      d === void 0 && (d = s);
      var l = Object.getOwnPropertyDescriptor(c, s);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[s];
      } }), Object.defineProperty(i, d, l);
    } : function(i, c, s, d) {
      d === void 0 && (d = s), i[d] = c[s];
    }), o = cs && cs.__exportStar || function(i, c) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(c, s) && r(c, i, s);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.DomHandler = void 0;
    var a = /* @__PURE__ */ i0(), t = /* @__PURE__ */ I7();
    o(/* @__PURE__ */ I7(), u);
    var e = {
      withStartIndices: !1,
      withEndIndices: !1,
      xmlMode: !1
    }, n = (
      /** @class */
      function() {
        function i(c, s, d) {
          this.dom = [], this.root = new t.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof s == "function" && (d = s, s = e), typeof c == "object" && (s = c, c = void 0), this.callback = c ?? null, this.options = s ?? e, this.elementCB = d ?? null;
        }
        return i.prototype.onparserinit = function(c) {
          this.parser = c;
        }, i.prototype.onreset = function() {
          this.dom = [], this.root = new t.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
        }, i.prototype.onend = function() {
          this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
        }, i.prototype.onerror = function(c) {
          this.handleCallback(c);
        }, i.prototype.onclosetag = function() {
          this.lastNode = null;
          var c = this.tagStack.pop();
          this.options.withEndIndices && (c.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(c);
        }, i.prototype.onopentag = function(c, s) {
          var d = this.options.xmlMode ? a.ElementType.Tag : void 0, l = new t.Element(c, s, void 0, d);
          this.addNode(l), this.tagStack.push(l);
        }, i.prototype.ontext = function(c) {
          var s = this.lastNode;
          if (s && s.type === a.ElementType.Text)
            s.data += c, this.options.withEndIndices && (s.endIndex = this.parser.endIndex);
          else {
            var d = new t.Text(c);
            this.addNode(d), this.lastNode = d;
          }
        }, i.prototype.oncomment = function(c) {
          if (this.lastNode && this.lastNode.type === a.ElementType.Comment) {
            this.lastNode.data += c;
            return;
          }
          var s = new t.Comment(c);
          this.addNode(s), this.lastNode = s;
        }, i.prototype.oncommentend = function() {
          this.lastNode = null;
        }, i.prototype.oncdatastart = function() {
          var c = new t.Text(""), s = new t.CDATA([c]);
          this.addNode(s), c.parent = s, this.lastNode = c;
        }, i.prototype.oncdataend = function() {
          this.lastNode = null;
        }, i.prototype.onprocessinginstruction = function(c, s) {
          var d = new t.ProcessingInstruction(c, s);
          this.addNode(d);
        }, i.prototype.handleCallback = function(c) {
          if (typeof this.callback == "function")
            this.callback(c, this.dom);
          else if (c)
            throw c;
        }, i.prototype.addNode = function(c) {
          var s = this.tagStack[this.tagStack.length - 1], d = s.children[s.children.length - 1];
          this.options.withStartIndices && (c.startIndex = this.parser.startIndex), this.options.withEndIndices && (c.endIndex = this.parser.endIndex), s.children.push(c), d && (c.prev = d, d.next = c), c.parent = s, this.lastNode = null;
        }, i;
      }()
    );
    u.DomHandler = n, u.default = n;
  }(cs)), cs;
}
var ds = {}, Oi = {}, ln = {}, PE = {}, ni = {}, _6 = {}, F7;
function Fse() {
  return F7 || (F7 = 1, Object.defineProperty(_6, "__esModule", { value: !0 }), _6.default = new Uint16Array(
    // prettier-ignore
    'áµ<ÃÄ±ÊÒÕ»×ÙµÛÞ¢ßà à©àªà¶¡à¹­à¼à¼¦áá¨á¡ááááá¥\0\0\0\0\0\0á«áá¦á°á·á½¾â â°âââ»ââ ¤â¤â´â¹â¿ããºã¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à EMabcfglmnoprstu\\bfmsÂÂÂÂÂÂ¦Â³Â¹ÃÃligè»ÃäPè»&ä¦cuteè»Ãäreve;äÄiyx}rcè»Ãä;är;ìðraveè»Ãäpha;äacr;äd;æ©ÄgpÂÂ¡on;äf;ìð¸plyFunction;æ¡ingè»ÃäÄcsÂ¾Ãr;ìðign;æildeè»Ãämlè»ÃäÐaceforsuÃ¥Ã»Ã¾ÄÄÄ¢Ä§ÄªÄcrÃªÃ²kslash;æÅ¶Ã¶Ã¸;æ«§ed;æy;äÆcrtÄÄÄause;æµnoullis;æ¬a;är;ìðpf;ìð¹eve;äcÃ²Ämpeq;æÜHOacdefhilorsuÅÅÅÆÆÆ¢ÆµÆ·ÆºÇÈÉ³É¸É¾cy;ä§PYè»Â©ä©ÆcpyÅÅ¢Åºute;äÄ;iÅ§Å¨ætalDifferentialD;æleys;æ­ÈaeioÆÆÆÆron;ädilè»Ãärc;änint;æ°ot;äÄdnÆ§Æ­illa;ä¸terDot;ä·Ã²Å¿i;ä§rcleÈDMPTÇÇÇÇot;æinus;ælus;æimes;æoÄcsÇ¢Ç¸kwiseContourIntegral;æ²eCurlyÄDQÈÈoubleQuote;æuote;æÈlnpuÈÈ¨ÉÉonÄ;eÈ¥È¦æ·;æ©´ÆgitÈ¯È¶Èºruent;æ¡nt;æ¯ourIntegral;æ®ÄfrÉÉ;æoduct;ænterClockwiseContourIntegral;æ³oss;æ¨¯cr;ìðpÄ;CÊÊæap;æÖDJSZacefiosÊ Ê¬Ê°Ê´Ê¸ËËË¡Ë¦Ì³ÒÄ;oÅ¹Ê¥trahd;æ¤cy;äcy;äcy;äÆgrsÊ¿ËËger;æ¡r;æ¡hv;æ«¤ÄayËËron;ä;älÄ;tËËæa;är;ìðÄafË«Ì§ÄcmË°Ì¢riticalÈADGTÌÌÌÌcute;ä´oÅ´ÌÌ;äbleAcute;ärave;ä ilde;äond;æferentialD;æÑ°Ì½\0\0\0ÍÍ\0Ðf;ìð»Æ;DEÍÍÍä¨ot;æqual;æbleÌCDLRUVÍ£Í²ÎÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»ÍnArrow;æÄeoÎÎ¤ftÆARTÎÎÎ¡rrow;æightArrow;æeÃ¥ËngÄLRÎ«ÏeftÄARÎ³Î¹rrow;æ¸ightArrow;æºightArrow;æ¹ightÄATÏÏrrow;æee;æ¨pÉÏ©\0\0Ï¯rrow;æownArrow;æerticalBar;æ¥nÌABLRTaÐÐªÐ°ÑÑ¿Í¼rrowÆ;BUÐÐÐ¢æar;æ¤pArrow;æµreve;äeftËÐº\0Ñ\0ÑightVector;æ¥eeVector;æ¥ectorÄ;BÑÑæ½ar;æ¥ightÇÑ§\0Ñ±eeVector;æ¥ectorÄ;BÑºÑ»æar;æ¥eeÄ;AÒÒæ¤rrow;æ§ÄctÒÒr;ìðrok;äà NTacdfglmopqstuxÒ½ÓÓÓÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶ÕÕÕ Õ¥G;äHè»Ãäcuteè»ÃäÆaiyÓÓÓron;ärcè»Ãä;ä­ot;är;ìðraveè»Ãäement;æÄapÓºÓ¾cr;ätyÉÔ\0\0ÔmallSquare;æ»erySmallSquare;æ«ÄgpÔ¦Ôªon;äf;ìð¼silon;äuÄaiÔ¼ÕlÄ;TÕÕæ©µilde;ælibrium;æÄciÕÕr;æ°m;æ©³a;ämlè»ÃäÄipÕªÕ¯sts;æonentialE;æÊcfiosÖÖÖÖ²×y;ä¤r;ìðlledÉÖ\0\0Ö£mallSquare;æ¼erySmallSquare;æªÍ°Öº\0Ö¿\0\0×f;ìð½All;æriertrf;æ±cÃ²×ØJTabcdfgorst×¨×¬×¯×ºØØØØØØ£Ù¬Ù²cy;äè»>ä¾mmaÄ;d×·×¸ä;äreve;äÆeiyØØØdil;ä¢rc;ä;äot;ä r;ìð;æpf;ìð¾eaterÌEFGLSTØµÙÙÙÙÙ¦qualÄ;LØ¾Ø¿æ¥ess;æullEqual;æ§reater;æª¢ess;æ·lantEqual;æ©¾ilde;æ³cr;ìð¢;æ«ÐAacfiosuÚÚÚÚÚÚªÚ¾ÛRDcy;äªÄctÚÚek;ä;äirc;ä¤r;ælbertSpace;æÇ°Ú¯\0Ú²f;æizontalLine;æÄctÛÛÃ²Ú©rok;ä¦mpÅÛÛownHumÃ°Ä¯qual;æÜEJOacdfgmnostuÛºÛ¾ÜÜÜÜÜÜ¡Ü¨ÝÝ¸ÞÞÞcy;älig;ä²cy;äcuteè»ÃäÄiyÜÜrcè»Ãä;äot;ä°r;æraveè»ÃäÆ;apÜ Ü¯Ü¿ÄcgÜ´Ü·r;äªinaryI;ælieÃ³ÏÇ´Ý\0Ý¢Ä;eÝÝæ¬ÄgrÝÝral;æ«section;æisibleÄCTÝ¬Ý²omma;æ£imes;æ¢ÆgptÝ¿ÞÞon;ä®f;ìða;äcr;æilde;ä¨Ç«Þ\0Þcy;älè»ÃäÊcfosuÞ¬Þ·Þ¼ßßÄiyÞ±Þµrc;ä´;är;ìðpf;ìðÇ£ß\0ßr;ìð¥rcy;äkcy;äÎHJacfosß¤ß¨ß¬ß±ß½à à cy;ä¥cy;äppa;äÄeyß¶ß»dil;ä¶;är;ìðpf;ìðcr;ìð¦ÖJTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§à§à¨·à©cy;äè»<ä¼Êcmnprà ·à ¼à¡à¡à¡ute;ä¹bda;äg;æªlacetrf;ær;æÆaeyà¡à¡à¡¡ron;ä½dil;ä»;äÄfsà¡¨à¥°tÔACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥Îà¥ªÄnrà¢à¢gleBracket;æ¨rowÆ;BRà¢à¢à¢æar;æ¤ightArrow;æeiling;æoÇµà¢·\0à£bleBracket;æ¦nÇà£\0à£eeVector;æ¥¡ectorÄ;Bà£à£æar;æ¥loor;æightÄAVà£¯à£µrrow;æector;æ¥Äerà¤à¤eÆ;AVà¤à¤à¤æ£rrow;æ¤ector;æ¥iangleÆ;BEà¤¤à¤¥à¤©æ²ar;æ§qual;æ´pÆDTVà¤·à¥à¥ownVector;æ¥eeVector;æ¥ ectorÄ;Bà¥à¥æ¿ar;æ¥ectorÄ;Bà¥¥à¥¦æ¼ar;æ¥ightÃ¡ÎsÌEFGLSTà¥¾à¦à¦à¦à¦¢à¦­qualGreater;æullEqual;æ¦reater;æ¶ess;æª¡lantEqual;æ©½ilde;æ²r;ìðÄ;eà¦½à¦¾æftarrow;æidot;ä¿Ænpwà§à¨à¨gÈLRlrà§à§·à¨à¨eftÄARà§¦à§¬rrow;æµightArrow;æ·ightArrow;æ¶eftÄarÎ³à¨ightÃ¡Î¿ightÃ¡Ïf;ìðerÄLRà¨¢à¨¬eftArrow;æightArrow;æÆchtà¨¾à©à©Ã²à¡;æ°rok;ä;æªÐacefiosuà©à©à© à©·à©¼àªàªàªp;æ¤y;äÄdlà©¥à©¯iumSpace;ælintrf;æ³r;ìðnusPlus;æpf;ìðcÃ²à©¶;äÒJacefostuàª£àª§àª­à«à¬à¬à¶à¶à¶cy;äcute;äÆaeyàª´àª¹àª¾ron;ädil;ä;äÆgswà«à«°à¬ativeÆMTVà«à«à«¨ediumSpace;æhiÄcnà«¦à«Ã«à«eryThiÃ®à«tedÄGLà«¸à¬reaterGreateÃ²Ù³essLesÃ³à©Line;är;ìðÈBnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä f;æÚ;CDEGHLNPRSTVà­à­à­ªà­¼à®¡à¯«à°à±à²à²¦à³àµ¡à¶æ«¬Äouà­à­¤ngruent;æ¢pCap;æ­oubleVerticalBar;æ¦Ælqxà®à®à®ement;æualÄ;Tà®à®æ ilde;ìâÌ¸ists;æreaterÎ;EFGLSTà®¶à®·à®½à¯à¯à¯à¯¥æ¯qual;æ±ullEqual;ìâ§Ì¸reater;ìâ«Ì¸ess;æ¹lantEqual;ìâ©¾Ì¸ilde;æµumpÅà¯²à¯½ownHump;ìâÌ¸qual;ìâÌ¸eÄfsà°à°§tTriangleÆ;BEà°à°à°¡æªar;ìâ§Ì¸qual;æ¬sÌ;EGLSTà°µà°¶à°¼à±à±à±æ®qual;æ°reater;æ¸ess;ìâªÌ¸lantEqual;ìâ©½Ì¸ilde;æ´estedÄGLà±¨à±¹reaterGreater;ìâª¢Ì¸essLess;ìâª¡Ì¸recedesÆ;ESà²à²à²æqual;ìâª¯Ì¸lantEqual;æ Äeià²«à²¹verseElement;æghtTriangleÆ;BEà³à³à³æ«ar;ìâ§Ì¸qual;æ­Äquà³à´uareSuÄbpà³¨à³¹setÄ;Eà³°à³³ìâÌ¸qual;æ¢ersetÄ;Eà´à´ìâÌ¸qual;æ£Æbcpà´à´¤àµsetÄ;Eà´à´ìââqual;æceedsÈ;ESTà´²à´³à´»àµæqual;ìâª°Ì¸lantEqual;æ¡ilde;ìâ¿Ì¸ersetÄ;Eàµàµìââqual;æildeÈ;EFTàµ®àµ¯àµµàµ¿æqual;æullEqual;æilde;æerticalBar;æ¤cr;ìð©ildeè»Ãä;äÜEacdfgmoprstuvà¶½à·à·à·à·à· à·§à·¼à¸à¸ à¸¢à¸²à¸¿à¹lig;äcuteè»ÃäÄiyà·à·rcè»Ãä;äblac;är;ìðraveè»ÃäÆaeià·®à·²à·¶cr;äga;ä©cron;äpf;ìðenCurlyÄDQà¸à¸oubleQuote;æuote;æ;æ©Äclà¸§à¸¬r;ìðªashè»ÃäiÅ¬à¸·à¸¼deè»Ãäes;æ¨·mlè»ÃäerÄBPà¹à¹ Äarà¹à¹r;æ¾acÄekà¹à¹;æet;æ´arenthesis;æÒacfhilorsà¹¿àºàºàºàºàºàºàº°à»¼rtialD;æy;är;ìði;ä¦;ä usMinus;ä±Äipàº¢àº­ncareplanÃ¥Úf;æÈ;eioàº¹àººà» à»¤æª»cedesÈ;ESTà»à»à»à»æºqual;æª¯lantEqual;æ¼ilde;æ¾me;æ³Ädpà»©à»®uct;æortionÄ;aÈ¥à»¹l;æÄcià¼à¼r;ìð«;ä¨ÈUfosà¼à¼à¼à¼OTè»"ä¢r;ìðpf;æcr;ìð¬ØBEacefhiorsuà¼¾à½à½à½ à½³à¾§à¾ªà¾­áá©á´á¾arr;æ¤Gè»Â®ä®Æcnrà½à½à½ute;äg;æ«rÄ;tà½à½æ l;æ¤Æaeyà½§à½¬à½±ron;ädil;ä;ä Ä;và½¸à½¹æerseÄEUà¾à¾Älqà¾à¾ement;æuilibrium;æpEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtÐACDFTUVaà¿à¿«à¿³á¢á¨ááÏÄnrà¿à¿gleBracket;æ©rowÆ;BLà¿à¿à¿¡æar;æ¥eftArrow;æeiling;æoÇµà¿¹\0ábleBracket;æ§nÇá\0áeeVector;æ¥ectorÄ;Bááæar;æ¥loor;æÄerá­áeÆ;AVáµá¶á¼æ¢rrow;æ¦ector;æ¥iangleÆ;BEáááæ³ar;æ§qual;æµpÆDTVá£á®á¸ownVector;æ¥eeVector;æ¥ectorÄ;Bááæ¾ar;æ¥ectorÄ;Bááæar;æ¥Äpuááf;ændImplies;æ¥°ightarrow;æÄchá¹á¼r;æ;æ±leDelayed;æ§´ÚHOacfhimoqstuá¤á±á·á½ááááá¡á§áµá»á¿ÄCcá©á®Hcy;ä©y;ä¨FTcy;ä¬cute;äÊ;aeiyáááááæª¼ron;ä dil;ärc;ä;ä¡r;ìðortÈDLRUáªá´á¾áownArrowÂ»ÐeftArrowÂ»à¢ightArrowÂ»à¿pArrow;ægma;ä£allCircle;æpf;ìðÉ²á­\0\0á°t;æareÈ;ISUá»á¼áá¯æ¡ntersection;æuÄbpáásetÄ;Eááæqual;æersetÄ;Eá¨á©æqual;ænion;æcr;ìð®ar;æÈbcmpááááÄ;sááæetÄ;Eááqual;æÄchá áeedsÈ;ESTá­á®á´á¿æ»qual;æª°lantEqual;æ½ilde;æ¿ThÃ¡à¾;æÆ;esááá£ærsetÄ;Eááæqual;æetÂ»áÖHRSacfhiorsá¾ááááá±á¶ááááORNè»ÃäADE;æ¢ÄHcáácy;äy;ä¦Äbuáá;ä;ä¤Æaeyá¥áªá¯ron;ä¤dil;ä¢;ä¢r;ìðÄeiá»áÇ²á\0áefore;æ´a;äÄcnáákSpace;ìââSpace;ældeÈ;EFTá«á¬á²á¼æ¼qual;æullEqual;æilde;æpf;ìðipleDot;æÄctáár;ìð¯rok;ä¦à«¡á·ááá¦\0á¬á±\0\0\0\0\0á¸á½á·á\0á¿áááÄcrá»áuteè»ÃärÄ;oááæcir;æ¥rÇ£á\0áy;äve;ä¬Äiyáá£rcè»Ãä;ä£blac;ä°r;ìðraveè»Ãäacr;äªÄdiáá©erÄBPááÄaráár;äacÄekáá;æet;æµarenthesis;æonÄ;Pá°á±ælus;æÄgpá»á¿on;ä²f;ìðÐADETadpsáá®á¸áÏ¨ááá³rrowÆ;BDáá á¤ar;æ¤ownArrow;æownArrow;æquilibrium;æ¥®eeÄ;Aááæ¥rrow;æ¥ownÃ¡Ï³erÄLRáá¨eftArrow;æightArrow;æiÄ;lá¹áºäon;ä¥ing;ä®cr;ìð°ilde;ä¨mlè»ÃäÒDbcdefosvá§á¬á°á³á¾ááááash;æ«ar;æ««y;äashÄ;lá»á¼æ©;æ«¦Äeráá;æÆbtyáááºar;æÄ;iáácalÈBLSTá¡á¥áªá´ar;æ£ine;ä¼eparator;æilde;æThinSpace;ær;ìðpf;ìðcr;ìð±dash;æªÊcefosá§á¬á±á¶á¼irc;ä´dge;ær;ìðpf;ìðcr;ìð²Èfiosáááár;ìð;äpf;ìðcr;ìð³ÒAIUacfosuá±áµá¹á½ááááá cy;ä¯cy;äcy;ä®cuteè»ÃäÄiyáárc;ä¶;ä«r;ìðpf;ìðcr;ìð´ml;ä¸ÐHacdefosáµá¹á¿áááá á¤cy;äcute;ä¹Äayááron;ä½;äot;ä»Ç²á\0áoWidtÃ¨à«a;är;æ¨pf;æ¤cr;ìðµà¯¡ááá\0á°á¶á¿\0\0\0\0ááá«áá­\0ááá²á¹\0á¾cuteè»Ã¡ä¡reve;äÌ;Ediuyááá¡á£á¨á­æ¾;ìâ¾Ì³;æ¿rcè»Ã¢ä¢teè»Â´Ì;ä°ligè»Ã¦ä¦Ä;rÂ²áº;ìðraveè»Ã ä ÄepááÄfpáásym;æµÃ¨áha;ä±ÄapácÄclá¤á§r;äg;æ¨¿É¤á°\0\0áÊ;adsváºá»á¿ááæ§nd;æ©;æ©lope;æ©;æ©Î;elmrszááááá¿ááæ ;æ¦¤eÂ»ásdÄ;aá¥á¦æ¡Ñ¡á°á²á´á¶á¸áºá¼á¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ;vááæbÄ;dááæ¾;æ¦Äptááh;æ¢Â»Â¹arr;æ¼Ägpá£á§on;äf;ìðÎ;Eaeiopáá»á½áááá;æ©°cir;æ©¯;æd;æs;ä§roxÄ;eááÃ±áingè»Ã¥ä¥Æctyá¡á¦á¨r;ìð¶;äªmpÄ;eáá¯Ã±Êildeè»Ã£ä£mlè»Ã¤ä¤ÄciááoninÃ´É²nt;æ¨à Nabcdefiklnoprsuá­á±á°á¼ááá¸á½á á¦á ¹á¡áá¤½á¥á¥°ot;æ«­Äcrá¶ákÈcepsááááong;æpsilon;ä¶rime;æµimÄ;eááæ½q;æÅ¶á¢á¦ee;æ½edÄ;gá¬á­æeÂ»á­rkÄ;táá·brk;æ¶Äoyáá;ä±quo;æÊcmprtááá¡á¤á¨ausÄ;eÄÄptyv;æ¦°sÃ©ánoÃµÄÆahwá¯á±á³;ä²;æ¶een;æ¬r;ìðgÎcostuvwááá³ááááÆaiuáááÃ°Ý rc;æ¯pÂ»á±Ædptá¤á¨á­ot;æ¨lus;æ¨imes;æ¨É±á¹\0\0á¾cup;æ¨ar;æriangleÄduááown;æ½p;æ³plus;æ¨eÃ¥áÃ¥á­arow;æ¤Æakoá­á ¦á µÄcná²á £kÆlstáºÖ«á ozenge;æ§«riangleÈ;dlrá á á á æ´own;æ¾eft;æight;æ¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ;æ4;æck;æÄeoá ¾á¡Ä;qá¡á¡ì=â¥uiv;ìâ¡â¥t;æÈptwxá¡á¡á¡§á¡¬f;ìðÄ;táá¡£omÂ»átie;æØDHUVbdhmptuvá¢á¢á¢ªá¢»á£á£á£¬á£¿á¤á¤á¤á¤¡ÈLRlrá¢á¢á¢á¢;æ;æ;æ;æÊ;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ;æ¦;æ©;æ¤;æ§ÈLRlrá¢³á¢µá¢·á¢¹;æ;æ;æ;æÎ;HLRhlrá£á£á£á£á£á£á£æ;æ¬;æ£;æ ;æ«;æ¢;æox;æ§ÈLRlrá£¤á£¦á£¨á£ª;æ;æ;æ;æÊ;DUduÚ½á£·á£¹á£»á£½;æ¥;æ¨;æ¬;æ´inus;ælus;æimes;æ ÈLRlrá¤á¤á¤á¤;æ;æ;æ;æÎ;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ;æª;æ¡;æ;æ¼;æ¤;æÄevÄ£á¥barè»Â¦ä¦Èceioá¥á¥á¥á¥ r;ìð·mi;æmÄ;eáálÆ;bhá¥¨á¥©á¥«ä;æ§sub;æÅ¬á¥´á¥¾lÄ;eá¥¹á¥ºæ¢tÂ»á¥ºpÆ;EeÄ¯á¦á¦;æª®Ä;qÛÛà³¡á¦§\0á§¨á¨á¨á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­\0á¯½\0á°Æcprá¦­á¦²á§ute;äÌ;abcdsá¦¿á§á§á§á§á§æ©nd;æ©rcup;æ©Äauá§á§p;æ©p;æ©ot;æ©;ìâ©ï¸Äeoá§¢á§¥t;æÃ®ÚÈaeiuá§°á§»á¨á¨Ç°á§µ\0á§¸s;æ©on;ädilè»Ã§ä§rc;äpsÄ;sá¨á¨æ©m;æ©ot;äÆdmná¨á¨ á¨¦ilè»Â¸Æ­ptyv;æ¦²tèÂ¢;eá¨­á¨®ä¢rÃ¤Æ²r;ìð Æceiá¨½á©á©y;äckÄ;má©á©æarkÂ»á©;ärÎ;Ecefmsá©á© á©¢á©«áª¤áªªáª®æ;æ§Æ;elá©©á©ªá©­äq;æeÉ¡á©´\0\0áªrrowÄlrá©¼áªeft;æºight;æ»ÊRSacdáªáªáªáªáªÂ»à½;æst;æirc;æash;ænint;æ¨id;æ«¯cir;æ§ubsÄ;uáª»áª¼æ£itÂ»áª¼Ë¬á«á«á«º\0á¬onÄ;eá«á«äºÄ;qÃÃÉ­á«\0\0á«¢aÄ;tá«á«ä¬;äÆ;flá«¨á«©á««æÃ®á eÄmxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬Ä;dá»á¬ot;æ©­nÃ´ÉÆfryá¬á¬á¬;ìðoÃ¤ÉèÂ©;sÅá¬r;æÄaoá¬¥á¬©rr;æµss;æÄcuá¬²á¬·r;ìð¸Äbpá¬¼á­Ä;eá­á­æ«;æ«Ä;eá­á­æ«;æ«dot;æ¯Îdelprvwá­ á­¬á­·á®á®¬á¯á¯¹arrÄlrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æc;æarrÄ;pá­¿á®æ¶;æ¤½Ì;bcdosá®á®á®á®¡á®¥á®¨æªrcap;æ©Äauá®á®p;æ©p;æ©ot;ær;æ©;ìâªï¸Èalrvá®µá®¿á¯á¯£rrÄ;má®¼á®½æ·;æ¤¼yÆevwá¯á¯á¯qÉ°á¯\0\0á¯reÃ£á­³uÃ£á­µee;æedge;æenè»Â¤ä¤earrowÄlrá¯®á¯³eftÂ»á®ightÂ»á®½eÃ¤á¯Äciá°á°oninÃ´Ç·nt;æ±lcty;æ­à¦AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²á²á²¬á²·á³»á³¿á´áµ»á¶á¶«á¶»á·á·rÃ²Îar;æ¥¥Èglrsá±á±á±á±ger;æ eth;æ¸Ã²á³hÄ;vá±á±æÂ»à¤Å«á±¡á±§arow;æ¤aÃ£ÌÄayá±®á±³ron;ä;ä´Æ;aoÌ²á±¼á²ÄgrÊ¿á²r;ætseq;æ©·Æglmá²á²á²è»Â°ä°ta;ä´ptyv;æ¦±Äirá²£á²¨sht;æ¥¿;ìð¡arÄlrá²³á²µÂ»à£Â»áÊaegsvá³Í¸á³á³á³ mÆ;osÌ¦á³á³ndÄ;sÌ¦á³uit;æ¦amma;äin;æ²Æ;ioá³§á³¨á³¸ä·deèÃ·;oá³§á³°ntimes;ænÃ¸á³·cy;äcÉ¯á´\0\0á´rn;æop;æÊlptuwá´á´á´¢áµáµlar;ä¤f;ìðÊ;empsÌá´­á´·á´½áµqÄ;dÍá´³ot;æinus;æ¸lus;æquare;æ¡blebarwedgÃ¥ÃºnÆadhá®áµáµ§ownarrowÃ³á²arpoonÄlráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶karoÃ·à½É¯á¶\0\0á¶rn;æop;æÆcotá¶á¶£á¶¦Äryá¶á¶¡;ìð¹;äl;æ§¶rok;äÄdrá¶°á¶´ot;æ±iÄ;fá¶ºá æ¿Äahá·á·rÃ²Ð©aÃ²à¾¦angle;æ¦¦Äciá·á·y;ägrarr;æ¿à¤Dacdefglmnopqrstuxá¸á¸á¸á¸¸Õ¸á¸¼á¹á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½á½á½ÄDoá¸á´´oÃ´á²Äcsá¸á¸uteè»Ã©ä©ter;æ©®Èaioyá¸¢á¸§á¸±á¸¶ron;ärÄ;cá¸­á¸®æè»Ãªäªlon;æ;äot;äÄDrá¹á¹ot;æ;ìð¢Æ;rsá¹á¹á¹æªaveè»Ã¨ä¨Ä;dá¹á¹æªot;æªÈ;ilsá¹ªá¹«á¹²á¹´æªnters;æ§;æÄ;dá¹¹á¹ºæªot;æªÆapsáºáºáºcr;ätyÆ;sváºáºáºæetÂ»áºpÄ1;áºáº¤Ä³áº¡áº£;æ;ææÄgsáºªáº¬;äp;æÄgpáº´áº¸on;äf;ìðÆalsá»á»á»rÄ;sá»á»æl;æ§£us;æ©±iÆ;lvá»á»á»äµonÂ»á»;äµÈcsuvá»ªá»³á¼á¼£Äioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕantÄglá¼á¼trÂ»á¹essÂ»á¹ºÆaeiá¼á¼á¼ls;ä½st;ævÄ;DÈµá¼ D;æ©¸parsl;æ§¥ÄDaá¼¯á¼³ot;ærr;æ¥±Æcdiá¼¾á½á»¸r;æ¯oÃ´ÍÄahá½á½;ä·è»Ã°ä°Ämrá½á½lè»Ã«ä«o;æ¬Æcipá½¡á½¤á½§l;ä¡sÃ´Õ®Äeoá½¬á½´ctatioÃ®ÕnentialÃ¥Õ¹à§¡á¾\0á¾\0á¾¡á¾§\0\0á¿á¿\0á¿\0á¿¦á¿ªâ\0ââllingdotseÃ±á¹y;ämale;æÆilrá¾­á¾³á¿lig;èï¬É©á¾¹\0\0á¾½g;èï¬ig;èï¬;ìð£lig;èï¬lig;ìfjÆaltá¿á¿á¿¡t;æ­ig;èï¬ns;æ±of;äÇ°á¿®\0á¿³f;ìðÄakÖ¿á¿·Ä;vá¿¼á¿½æ;æ«artint;æ¨ÄaoââÄcsââÎ±ââ°â¸ââ\0âÎ²â¢â¥â§âªâ¬\0â®è»Â½ä½;æè»Â¼ä¼;æ;æ;æÆ³â´\0â¶;æ;æÊ´â¾â\0\0âè»Â¾ä¾;æ;æ5;æÆ¶â\0â;æ;æ8;æl;æwn;æ¢cr;ìð»à¢Eabcdefgijlnorstvââââ¥â°â´â°âµâºâ¿âââ¸Ìâ¾ââÄ;lÙâ;æªÆcmpâââute;äµmaÄ;dâá³ä³;æªreve;äÄiyâªâ®rc;ä;ä³ot;ä¡È;lqsØ¾Ùâ½âÆ;qsØ¾ÙâlanÃ´Ù¥È;cdlÙ¥âââ¥c;æª©otÄ;oââæªÄ;lâ¢â£æª;æªÄ;eâªâ­ìâï¸s;æªr;ìð¤Ä;gÙ³Ømel;æ·cy;äÈ;EajÙâââ;æª;æª¥;æª¤ÈEaesâââ©â´;æ©pÄ;pâ£â¤æªroxÂ»â¤Ä;qâ®â¯æªÄ;qâ®âim;æ§pf;ìðÄciââr;æmÆ;elÙ«ââ;æª;æªè>;cdlqr×®â âªâ®â³â¹Äciâ¥â§;æª§r;æ©ºot;æPar;æ¦uest;æ©¼ÊadelsââªâÙâÇ°â\0âproÃ¸âr;æ¥¸qÄlqØ¿âlesÃ³âiÃ­Ù«Äenâ£â­rtneqq;ìâ©ï¸ÃâªÔAabcefkosyâââ±âµâºâââ¯â¨â½rÃ²Î ÈilmrâââârsÃ°áfÂ»â¤ilÃ´Ú©Ädrâ â¤cy;äÆ;cwà£´â«â¯ir;æ¥;æ­ar;æirc;ä¥ÆalrââârtsÄ;uââæ¥itÂ»âlip;æ¦con;æ¹r;ìð¥sÄewâ£â©arow;æ¤¥arow;æ¤¦Êamoprâºâ¾âââ£rr;æ¿tht;æ»kÄlrââeftarrow;æ©ightarrow;æªf;ìðbar;æÆcltâ¯â´â¸r;ìð½asÃ¨â´rok;ä§Äbpââull;æhenÂ»á±à«¡â£\0âª\0â¸ââ\0ââ³\0\0â¸â¢â§â¢â¿\0ââªâ´cuteè»Ã­ä­Æ;iyÝ±â°âµrcè»Ã®ä®;ä¸Äcxâ¼â¿y;äµclè»Â¡ä¡ÄfrÎâ;ìð¦raveè»Ã¬ä¬È;inoÜ¾ââ©â®Äinâ¢â¦nt;æ¨t;æ­fin;æ§ta;æ©lig;ä³Æaopâ¾ââÆcgtâââr;ä«ÆelpÜââinÃ¥ÞarÃ´Ü h;ä±f;æ·ed;äµÊ;cfotÓ´â¬â±â½âare;æinÄ;tâ¸â¹æie;æ§doÃ´âÊ;celpÝââââ¡al;æºÄgrââerÃ³á£Ã£âarhk;æ¨rod;æ¨¼Ècgptâ¯â²â¶â»y;äon;ä¯f;ìða;ä¹uestè»Â¿ä¿Äciââr;ìð¾nÊ;EdsvÓ´âââ¡Ó³;æ¹ot;æµÄ;vâ¦â§æ´;æ³Ä;iÝ·â®lde;ä©Ç«â¸\0â¼cy;älè»Ã¯ä¯Ìcfmosuââââ¡â§âµÄiyâârc;äµ;ä¹r;ìð§ath;ä·pf;ìðÇ£â¬\0â±r;ìð¿rcy;äkcy;äÐacfghjosâââ¢â§â­â±âµâ»ppaÄ;vââäº;ä°Äeyââ dil;ä·;äºr;ìð¨reen;ä¸cy;äcy;äpf;ìðcr;ìðà®ABEHabcdefghjlmnoprstuvâ°ââââââ½âââââ¥â¹â½ââ²âââ¨âââ â Æartâ·âºâ¼rÃ²à§Ã²Îail;æ¤arr;æ¤Ä;gà¦â;æªar;æ¥¢à¥£â¥\0âª\0â±\0\0\0\0\0âµâº\0âââ\0â¹ute;äºmptyv;æ¦´raÃ®à¡bda;ä»gÆ;dlà¢ââ;æ¦Ã¥à¢;æªuoè»Â«ä«rÐ;bfhlpstà¢ââ¦â©â«â®â±âµÄ;fà¢â£s;æ¤s;æ¤Ã«âp;æ«l;æ¤¹im;æ¥³l;æ¢Æ;aeâ¿ââæª«il;æ¤Ä;sââæª­;ìâª­ï¸Æabrââârr;æ¤rk;æ²Äakâ¢â¬cÄekâ¨âª;ä»;äÄesâ±â³;æ¦lÄduâ¹â»;æ¦;æ¦Èaeuyââââron;ä¾Ädiââil;ä¼Ã¬à¢°Ã¢â©;ä»Ècqrsâ£â¦â­â½a;æ¤¶uoÄ;rà¸áÄduâ²â·har;æ¥§shar;æ¥h;æ²Ê;fgqsââà¦â³â¿æ¤tÊahlrtââ¤â·ââ¨rrowÄ;tà¢â¡aÃ©â¶arpoonÄduâ¯â´ownÂ»ÑpÂ»à¥¦eftarrows;æightÆahsââârrowÄ;sà£´à¢§arpoonÃ³à¾quigarroÃ·â°hreetimes;æÆ;qsâà¦âºlanÃ´à¦¬Ê;cdgsà¦¬ââââ¨c;æª¨otÄ;oââæ©¿Ä;rââæª;æªÄ;eâ¢â¥ìâï¸s;æªÊadegsâ³â¹â½ââpproÃ¸âot;æqÄgqââÃ´à¦gtÃ²âÃ´à¦iÃ­à¦²Æilrâà£¡âsht;æ¥¼;ìð©Ä;Eà¦â£;æªÅ¡â©â¶rÄduâ²â®Ä;là¥¥â³;æ¥ªlk;æcy;äÊ;achtà©âââârÃ²âorneÃ²á´ard;æ¥«ri;æºÄioââ¤dot;äustÄ;aâ¬â­æ°cheÂ»â­ÈEaesâ»â½ââ;æ¨pÄ;pââæªroxÂ»âÄ;qââæªÄ;qââ»im;æ¦Ðabnoptwzâ©â´â·ââ¯âââÄnrâ®â±g;æ¬r;æ½rÃ«à£gÆlmrâ¿ââeftÄarà§¦âightÃ¡à§²apsto;æ¼ightÃ¡à§½parrowÄlrâ¥â©efÃ´â­ight;æ¬Æaflâ¶â¹â½r;æ¦;ìðus;æ¨­imes;æ¨´Å¡ââst;æÃ¡áÆ;efââá ængeÂ»âarÄ;lâ¤â¥ä¨t;æ¦Êachmtâ³â¶â¼âârÃ²à¢¨orneÃ²á¶arÄ;dà¾â;æ¥­;æri;æ¿Ìachiqtââà©â¢â®â»quo;æ¹r;ìðmÆ;egà¦²âªâ¬;æª;æªÄbuâªâ³oÄ;rà¸â¹;ærok;äè<;cdhilqrà «ââ¹ââ â¥âªâ°Äciââ;æª¦r;æ©¹reÃ¥â²mes;æarr;æ¥¶uest;æ©»ÄPiâµâ¹ar;æ¦Æ;efâ à¤­á ærÄduâ â shar;æ¥har;æ¥¦Äenâ â ¡rtneqq;ìâ¨ï¸Ãâ ÜDacdefhilnopsuâ¡â¡â¢â¢â¢â¢ â¢¥â¢¨â£â£¢â£¤àªâ£³â¤Dot;æºÈclprâ¡â¡â¡£â¡½rè»Â¯ä¯Äetâ¡â¡;æÄ;eâ¡â¡æ seÂ»â¡Ä;sá»â¡¨toÈ;dluá»â¡³â¡·â¡»owÃ®ÒefÃ´à¤Ã°áker;æ®Äoyâ¢â¢mma;æ¨©;ä¼ash;æasuredangleÂ»á¦r;ìðªo;æ§Æcdnâ¢¯â¢´â£roè»ÂµäµÈ;acdá¤â¢½â£â£sÃ´á§ir;æ«°otè»Â·ÆµusÆ;bdâ£á¤â£æÄ;uá´¼â£;æ¨ªÅ£â£â£¡p;æ«Ã²âÃ°àªÄdpâ£©â£®els;æ§f;ìðÄctâ£¸â£½r;ìðposÂ»áÆ;lmâ¤â¤â¤ä¼timap;æ¸à°GLRVabcdefghijlmoprstuvwâ¥â¥â¥¾â¦â¦â§â§©â¨â¨â©â©âªâªâª¤âª¨â¬â¬â­â­¿â®®â°´â±§â±¼â³©Ägtâ¥â¥;ìâÌ¸Ä;vâ¥à¯ìâ«âÆeltâ¥â¥²â¥¶ftÄarâ¥¡â¥§rrow;æightarrow;æ;ìâÌ¸Ä;vâ¥»à±ìâªâightarrow;æÄDdâ¦â¦ash;æ¯ash;æ®Êbcnptâ¦£â¦§â¦¬â¦±â§laÂ»Ëute;äg;ìâ âÊ;Eiopà¶â¦¼â§â§â§;ìâ©°Ì¸d;ìâÌ¸s;äroÃ¸à¶urÄ;aâ§â§æ®lÄ;sâ§à¬¸Ç³â§\0â§£pè»Â à¬·mpÄ;eà¯¹à°Êaeouyâ§´â§¾â¨â¨â¨Ç°â§¹\0â§»;æ©on;ädil;ängÄ;dàµ¾â¨ot;ìâ©­Ì¸p;æ©;ä½ash;æÎ;Aadqsxà®â¨©â¨­â¨»â©â©â©rr;ærÄhrâ¨³â¨¶k;æ¤¤Ä;oá²á°ot;ìâÌ¸uiÃ¶à­£Äeiâ©â©ar;æ¤¨Ã­à®istÄ;sà® à®r;ìð«ÈEestà¯â©¦â©¹â©¼Æ;qsà®¼â©­à¯¡Æ;qsà®¼à¯â©´lanÃ´à¯¢iÃ­à¯ªÄ;rà®¶âªÂ»à®·ÆAapâªâªâªrÃ²â¥±rr;æ®ar;æ«²Æ;svà¾âªà¾Ä;dâª¡âª¢æ¼;æºcy;äÎAEadestâª·âªºâª¾â«â«â«¶â«¹rÃ²â¥¦;ìâ¦Ì¸rr;ær;æ¥È;fqsà°»â«â«£â«¯tÄarâ«â«rroÃ·â«ightarroÃ·âªÆ;qsà°»âªºâ«ªlanÃ´à±Ä;sà±â«´Â»à°¶iÃ­à±Ä;rà°µâ«¾iÄ;eà°à°¥iÃ¤à¶Äptâ¬â¬f;ìðèÂ¬;inâ¬â¬â¬¶ä¬nÈ;Edvà®â¬¤â¬¨â¬®;ìâ¹Ì¸ot;ìâµÌ¸Ç¡à®â¬³â¬µ;æ·;æ¶iÄ;và²¸â¬¼Ç¡à²¸â­â­;æ¾;æ½Æaorâ­â­£â­©rÈ;astà­»â­â­â­lleÃ¬à­»l;ìâ«½â¥;ìâÌ¸lint;æ¨Æ;ceà²â­°â­³uÃ¥à²¥Ä;cà²â­¸Ä;eà²â­½Ã±à²ÈAaitâ®â®â®â®§rÃ²â¦rrÆ;cwâ®â®â®æ;ìâ¤³Ì¸;ìâÌ¸ghtarrowÂ»â®riÄ;eà³à³Îchimpquâ®½â¯â¯â¬à­¸â¯¤â¯¯È;cerà´²â¯à´·â¯uÃ¥àµ;ìðortÉ­â¬\0\0â¯arÃ¡â­mÄ;eàµ®â¯Ä;qàµ´àµ³suÄbpâ¯«â¯­Ã¥à³¸Ã¥à´Æbcpâ¯¶â°â°È;Eesâ¯¿â°à´¢â°æ;ìâ«Ì¸etÄ;eà´â°qÄ;qà´£â°cÄ;eà´²â°Ã±à´¸È;Eesâ°¢â°£àµâ°§æ;ìâ«Ì¸etÄ;eàµâ°®qÄ;qàµ â°£Ègilrâ°½â°¿â±â±Ã¬à¯ldeè»Ã±ä±Ã§à±iangleÄlrâ±â±eftÄ;eà°â±Ã±à°¦ightÄ;eà³â±¥Ã±à³Ä;mâ±¬â±­ä½Æ;esâ±´â±µâ±¹ä£ro;æp;æÒDHadgilrsâ²â²â²â²â²£â²°â²¶â³â³£ash;æ­arr;æ¤p;ìââash;æ¬Äetâ²¨â²¬;ìâ¥â;ì>ânfin;æ§ÆAetâ²½â³â³rr;æ¤;ìâ¤âÄ;râ³â³ì<âie;ìâ´âÄAtâ³â³rr;æ¤rie;ìâµâim;ìâ¼âÆAanâ³°â³´â´rr;ærÄhrâ³ºâ³½k;æ¤£Ä;oá§á¥ear;æ¤§ááª\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµâµ âµ¥âµ²â¶á¬\0\0â¶â¶«\0â·â·\0â·â¸â¸«â¸¾â¹Äcsâ´±áªuteè»Ã³ä³Äiyâ´¼âµrÄ;cáªâµè»Ã´ä´;ä¾Êabiosáª âµâµÇâµlac;äv;æ¨¸old;æ¦¼lig;äÄcrâµ©âµ­ir;æ¦¿;ìð¬Í¯âµ¹\0\0âµ¼\0â¶n;äaveè»Ã²ä²;æ§Äbmâ¶à·´ar;æ¦µÈacitâ¶â¶â¶¥â¶¨rÃ²áªÄirâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹;æ§Æaeiâ¶±â¶µâ¶¹cr;äga;äÆcdnâ·â·Çron;ä¿;æ¦¶pf;ìð Æaelâ·â·Çr;æ¦·rp;æ¦¹Î;adiosvâ·ªâ·«â·®â¸â¸â¸â¸æ¨rÃ²áªÈ;efmâ··â·¸â¸â¸æ©rÄ;oâ·¾â·¿æ´fÂ»â·¿è»Âªäªè»Âºäºgof;æ¶r;æ©lope;æ©;æ©Æcloâ¸â¸¡â¸§Ã²â¸ashè»Ã¸ä¸l;æiÅ¬â¸¯â¸´deè»ÃµäµesÄ;aÇâ¸ºs;æ¨¶mlè»Ã¶ä¶bar;æ½à«¡â¹\0â¹½\0âºâº\0âº¢âº¹\0\0â»àº\0â¼\0\0â¼«â¾¼\0â¿rÈ;astÐâ¹§â¹²àºèÂ¶;lâ¹­â¹®ä¶leÃ¬ÐÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊcimptâºâºâºá¡¥âºnt;ä¥od;ä®il;æ°enk;æ±r;ìð­Æimoâº¨âº°âº´Ä;vâº­âº®ä;ämaÃ´à©¶ne;æÆ;tvâº¿â»â»ächforkÂ»á¿½;äÄauâ»â»nÄckâ»â»kÄ;hâ´â»;æÃ¶â´sÒ;abcdemstâ»³â»´á¤â»¹â»½â¼â¼â¼â¼ä«cir;æ¨£ir;æ¨¢Äouáµâ¼;æ¨¥;æ©²nè»Â±àºim;æ¨¦wo;æ¨§Æipuâ¼â¼ â¼¥ntint;æ¨f;ìð¡ndè»Â£ä£Ô;Eaceinosuà»â¼¿â½â½â½â¾â¾â¾â½¾â¾¶;æª³p;æª·uÃ¥à»Ä;cà»â½Ì;acensà»â½â½â½¦â½¨â½¾pproÃ¸â½urlyeÃ±à»Ã±à»Æaesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ¨iÃ­à»meÄ;sâ¾àº®æ²ÆEasâ½¸â¾â½ºÃ°â½µÆdfpà»¬â¾â¾¯Æalsâ¾ â¾¥â¾ªlar;æ®ine;æurf;æÄ;tà»»â¾´Ã¯à»»rel;æ°Äciâ¿â¿r;ìð;äncsp;æÌfiopsuâ¿â¢â¿â¿¥â¿«â¿±r;ìð®pf;ìð¢rime;æcr;ìðÆaeoâ¿¸ããtÄeiâ¿¾ãrnionÃ³Ú°nt;æ¨stÄ;eããä¿Ã±á¼Ã´à¼àªABHabcdefhilmnoprstuxããããã ãã«ãã¢ã²ãããã¤ã©ãã®ã²ãã°ã·ÆartãããrÃ²á³Ã²Ïail;æ¤arÃ²á±¥ar;æ¥¤Îcdenqrtã¨ãµã¸ã¿ãããÄeuã­ã±;ìâ½Ì±te;äiÃ£á®mptyv;æ¦³gÈ;delà¿ããã;æ¦;æ¦¥Ã¥à¿uoè»Â»ä»rÖ;abcfhlpstwà¿ã¬ã¯ã·ã¹ã¼ã¾ããããp;æ¥µÄ;fà¿ ã´s;æ¤ ;æ¤³s;æ¤Ã«âÃ°â®l;æ¥im;æ¥´l;æ£;æÄaiããil;æ¤oÄ;nããæ¶alÃ³à¼Æabrã§ãªã®rÃ²á¥rk;æ³Äakã³ã½cÄekã¹ã»;ä½;äÄesãã;æ¦lÄduãã;æ¦;æ¦Èaeuyããã§ã©ron;äÄdiã¡ã¥il;äÃ¬à¿²Ã¢ãº;äÈclqsã´ã·ã½ãa;æ¤·dhar;æ¥©uoÄ;rÈÈh;æ³Æacgããà½lÈ;ipsà½¸ããánÃ¥á»arÃ´à¾©t;æ­Æilrã©á£ã®sht;æ¥½;ìð¯Äaoã·ãrÄduã½ã¿Â»Ñ»Ä;láã;æ¥¬Ä;vããä;ä±Ægnsãã¹ã¼htÌahlrstã¤ã°ããã¤ã®rrowÄ;tà¿ã­aÃ©ãarpoonÄduã»ã¿owÃ®ã¾pÂ»áeftÄahããrrowÃ³à¿ªarpoonÃ³Õightarrows;æquigarroÃ·ãhreetimes;æg;äingdotseÃ±á¼²ÆahmãããrÃ²à¿ªaÃ²Õ;æoustÄ;aããæ±cheÂ»ãmid;æ«®Èabptã²ã½ããÄnrã·ãºg;æ­r;æ¾rÃ«áÆaflãããr;æ¦;ìð£us;æ¨®imes;æ¨µÄapãã§rÄ;gã£ã¤ä©t;æ¦olint;æ¨arÃ²ã£Èachqã»ãá¼ãquo;æºr;ìðÄbuã»ãoÄ;rÈÈÆhirããã reÃ¥ã¸mes;æiÈ;eflãªáá ¡ã«æ¹tri;æ§luhar;æ¥¨;æàµ¡ãããã¬ã¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ããã­ã±ãã±\0ã\0\0ã³cute;äquÃ¯âºÔ;Eaceinpsyá­ã³ãµã¿ããããã¦ã©;æª´Ç°ãº\0ã¼;æª¸on;ä¡uÃ¥á¾Ä;dá³ãil;ärc;äÆEasããã;æª¶p;æªºim;æ©olint;æ¨iÃ­á;äotÆ;beã´áµãµæ;æ©¦ÎAacmstxãããããã£ã­rr;ærÄhrããÃ«â¨Ä;oà¨¶à¨´tè»Â§ä§i;ä»war;æ¤©mÄinã©Ã°nuÃ³Ã±t;æ¶rÄ;oã¶âìð°Èacoyãããã rp;æ¯Ähyããcy;ä;ärtÉ­ã\0\0ãiÃ¤á¤araÃ¬â¹¯è»Â­ä­Ägmã¨ã´maÆ;fvã±ã²ã²ä;äÐ;deglnprá«ãããããã¡ã¦ot;æ©ªÄ;qá±á°Ä;Eããæª;æª Ä;Eããæª;æªe;ælus;æ¨¤arr;æ¥²arÃ²á½Èaeitã¸ãããÄlsã½ãlsetmÃ©ãªhp;æ¨³parsl;æ§¤Ädlá£ãe;æ£Ä;eããæªªÄ;sã¢ã£æª¬;ìâª¬ï¸Æflpã®ã³ãtcy;äÄ;bã¸ã¹ä¯Ä;aã¾ã¿æ§r;æ¿f;ìð¤aÄdrãÐesÄ;uããæ itÂ»ãÆcsuã ã¹ãÄauã¥ã¯pÄ;sáã«;ìâï¸pÄ;sá´ãµ;ìâï¸uÄbpã¿ãÆ;esááãetÄ;eáãÃ±áÆ;esá¨á­ãetÄ;eá¨ãÃ±á®Æ;afá»ã¦Ö°rÅ¥ã«Ö±Â»á¼arÃ²áÈcemtã¹ã¾ããr;ìðtmÃ®Ã±iÃ¬ãarÃ¦á¾ÄarããrÄ;fãá¿æÄanãã­ightÄepã£ãªpsiloÃ®á» hÃ©âº¯sÂ»â¡Êbcmnpã»ãáããÒ;Edemnprsãããããã£ã¬ã±ã¶æ;æ«ot;æª½Ä;dáãot;æ«ult;æ«ÄEeã¨ãª;æ«;ælus;æª¿arr;æ¥¹Æeiuã½ããtÆ;enãããqÄ;qáãeqÄ;qã«ã¨m;æ«Äbpãã;æ«;æ«cÌ;acensá­ã¬ã²ã¹ã»ã¦pproÃ¸ãºurlyeÃ±á¾Ã±á³ÆaesãããpproÃ¸ãqÃ±ãg;æªÚ123;Edehlmnpsã©ã¬ã¯áã²ã´ãããããã¨ã­è»Â¹ä¹è»Â²ä²è»Â³ä³;æ«Äosã¹ã¼t;æª¾ub;æ«Ä;dá¢ãot;æ«sÄouããl;æb;æ«arr;æ¥»ult;æ«ÄEeã¤ã¦;æ«;ælus;æ«Æeiuã´ããtÆ;enáã¼ãqÄ;qá¢ã²eqÄ;qã§ã¤m;æ«Äbpãã;æ«;æ«ÆAanãã ã­rr;ærÄhrã¦ã¨Ã«â®Ä;oà¨«à¨©war;æ¤ªligè»Ãäà¯¡ããã áã³ã¹\0ã¾ã\0\0\0\0\0ãã\0ãã¬\0\0\0ãÉ²ã\0\0ãget;æ;ärÃ«à¹Æaeyã¦ã«ã°ron;ä¥dil;ä£;älrec;ær;ìð±Èeikoãããµã¼Ç²ã\0ãeÄ4fááaÆ;svãããä¸ym;äÄcnã¢ã²kÄasã¨ã®pproÃ¸áimÂ»á¬sÃ°áÄasãºã®Ã°árnè»Ã¾ä¾Ç¬Ìãâ§esèÃ;bdãããäÄ;aá¤ãr;æ¨±;æ¨°Æepsã¡ã£ãÃ¡â©È;bcfÒã¬ã°ã´ot;æ¶ir;æ«±Ä;oã¹ã¼ìð¥rk;æ«Ã¡ã¢rime;æ´Æaipããã¤dÃ¥áÎadempstã¡ããããããngleÊ;dlqrã°ã±ã¶ããæµownÂ»á¶»eftÄ;eâ ã¾Ã±à¤®;æightÄ;eãªãÃ±áot;æ¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æchtã²ã½ãÄryã·ã»;ìð;äcy;ärok;ä§ÄioããxÃ´á·headÄlrãã eftarroÃ·à¡ightarrowÂ»à½à¤AHabcdfghlmoprstuwãããã¤ã°ã¼ã ã ã £ã ´ã¡ã¡ã¡«ã¢©ã£ã£ã£ªã£¶rÃ²Ï­ar;æ¥£Äcrãã¢uteè»ÃºäºÃ²árÇ£ãª\0ã­y;äve;ä­Äiyãµãºrcè»Ã»ä»;äÆabhã ã ã rÃ²á­lac;ä±aÃ²áÄirã ã sht;æ¥¾;ìð²raveè»Ã¹ä¹Å¡ã §ã ±rÄlrã ¬ã ®Â»à¥Â»álk;æÄctã ¹ã¡É¯ã ¿\0\0ã¡rnÄ;eã¡ã¡ærÂ»ã¡op;æri;æ¸Äalã¡ã¡cr;ä«è»Â¨ÍÄgpã¡¢ã¡¦on;ä³f;ìð¦Ìadhlsuáã¡¸ã¡½á²ã¢ã¢ ownÃ¡á³arpoonÄlrã¢ã¢efÃ´ã ­ighÃ´ã ¯iÆ;hlã¢ã¢ã¢äÂ»áºonÂ»ã¢parrows;æÆcitã¢°ã£ã£É¯ã¢¶\0\0ã£rnÄ;eã¢¼ã¢½ærÂ»ã¢½op;æng;ä¯ri;æ¹cr;ìðÆdirã£ã£ã£¢ot;æ°lde;ä©iÄ;fã°ã£¨Â»á Äamã£¯ã£²rÃ²ã¢¨lè»Ã¼ä¼angle;æ¦§ÞABDacdeflnoprszã¤ã¤ã¤©ã¤­ã¦µã¦¸ã¦½ã§ã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Änrã¤²ã¤·grt;æ¦Îeknprstã£ã¥ã¥ã¥ã¥ã¥¤ã¦appÃ¡âothinÃ§áºÆhirã«â»ã¥opÃ´â¾µÄ;há·ã¥¢Ã¯ãÄiuã¥©ã¥­gmÃ¡ã³Äbpã¥²ã¦setneqÄ;qã¥½ã¦ìâï¸;ìâ«ï¸setneqÄ;qã¦ã¦ìâï¸;ìâ«ï¸Ährã¦ã¦etÃ¡ãiangleÄlrã¦ªã¦¯eftÂ»à¤¥ightÂ»áy;ä²ashÂ»á¶Æelrã§ã§ã§Æ;beâ·ªã§ã§ar;æ»q;ælip;æ®Äbtã§á¨aÃ²á©r;ìð³trÃ©ã¦®suÄbpã§¯ã§±Â»à´Â»àµpf;ìð§roÃ°à»»trÃ©ã¦´Äcuã¨ã¨r;ìðÄbpã¨ã¨nÄEeã¦ã¨Â»ã¥¾nÄEeã¦ã¨Â»ã¦igzag;æ¦Îcefoprsã¨¶ã¨»ã©ã©ã©ã©¡ã©ªirc;äµÄdiã©ã©Äbgã©ã©ar;æ©eÄ;qáºã©;æerp;ær;ìð´pf;ìð¨Ä;eá¹ã©¦atÃ¨á¹cr;ìðà«£áãª\0ãª\0ãªãª\0\0ãªãª¨ãª«ãª¯\0\0ã«ã«\0ã«áátrÃ©ár;ìðµÄAaãªãªrÃ²ÏrÃ²à§¶;ä¾ÄAaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âis;æ»Ædptá¤ãªµãª¾Äflãªºá©;ìð©imÃ¥á²ÄAaã«ã«rÃ²ÏrÃ²à¨Äcqã«á¸r;ìðÄptáã«rÃ©áÐacefiosuã«°ã«½ã¬ã¬ã¬ã¬ã¬ã¬¡cÄuyã«¶ã«»teè»Ã½ä½;äÄiyã¬ã¬rc;ä·;änè»Â¥ä¥r;ìð¶cy;äpf;ìðªcr;ìðÄcmã¬¦ã¬©y;älè»Ã¿ä¿Ôacdefhioswã­ã­ã­ã­ã­¤ã­©ã­­ã­´ã­ºã®cute;äºÄayã­ã­ron;ä¾;ä·ot;ä¼Äetã­ã­¡trÃ¦áa;ä¶r;ìð·cy;ä¶grarr;æpf;ìð«cr;ìðÄjnã®ã®;æj;æ'.split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), _6;
}
var g6 = {}, N7;
function Nse() {
  return N7 || (N7 = 1, Object.defineProperty(g6, "__esModule", { value: !0 }), g6.default = new Uint16Array(
    // prettier-ignore
    "Èaglq	\x1BÉ­\0\0p;ä¦os;ä§t;ä¾t;ä¼uot;ä¢".split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), g6;
}
var DE = {}, P7;
function D7() {
  return P7 || (P7 = 1, function(u) {
    var r;
    Object.defineProperty(u, "__esModule", { value: !0 }), u.replaceCodePoint = u.fromCodePoint = void 0;
    var o = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    u.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (r = String.fromCodePoint) !== null && r !== void 0 ? r : function(e) {
      var n = "";
      return e > 65535 && (e -= 65536, n += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), n += String.fromCharCode(e), n;
    };
    function a(e) {
      var n;
      return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (n = o.get(e)) !== null && n !== void 0 ? n : e;
    }
    u.replaceCodePoint = a;
    function t(e) {
      return (0, u.fromCodePoint)(a(e));
    }
    u.default = t;
  }(DE)), DE;
}
var L7;
function j7() {
  return L7 || (L7 = 1, function(u) {
    var r = ni && ni.__createBinding || (Object.create ? function(S, O, x, F) {
      F === void 0 && (F = x);
      var j = Object.getOwnPropertyDescriptor(O, x);
      (!j || ("get" in j ? !O.__esModule : j.writable || j.configurable)) && (j = { enumerable: !0, get: function() {
        return O[x];
      } }), Object.defineProperty(S, F, j);
    } : function(S, O, x, F) {
      F === void 0 && (F = x), S[F] = O[x];
    }), o = ni && ni.__setModuleDefault || (Object.create ? function(S, O) {
      Object.defineProperty(S, "default", { enumerable: !0, value: O });
    } : function(S, O) {
      S.default = O;
    }), a = ni && ni.__importStar || function(S) {
      if (S && S.__esModule) return S;
      var O = {};
      if (S != null) for (var x in S) x !== "default" && Object.prototype.hasOwnProperty.call(S, x) && r(O, S, x);
      return o(O, S), O;
    }, t = ni && ni.__importDefault || function(S) {
      return S && S.__esModule ? S : { default: S };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.decodeXML = u.decodeHTMLStrict = u.decodeHTMLAttribute = u.decodeHTML = u.determineBranch = u.EntityDecoder = u.DecodingMode = u.BinTrieFlags = u.fromCodePoint = u.replaceCodePoint = u.decodeCodePoint = u.xmlDecodeTree = u.htmlDecodeTree = void 0;
    var e = t(/* @__PURE__ */ Fse());
    u.htmlDecodeTree = e.default;
    var n = t(/* @__PURE__ */ Nse());
    u.xmlDecodeTree = n.default;
    var i = a(/* @__PURE__ */ D7());
    u.decodeCodePoint = i.default;
    var c = /* @__PURE__ */ D7();
    Object.defineProperty(u, "replaceCodePoint", { enumerable: !0, get: function() {
      return c.replaceCodePoint;
    } }), Object.defineProperty(u, "fromCodePoint", { enumerable: !0, get: function() {
      return c.fromCodePoint;
    } });
    var s;
    (function(S) {
      S[S.NUM = 35] = "NUM", S[S.SEMI = 59] = "SEMI", S[S.EQUALS = 61] = "EQUALS", S[S.ZERO = 48] = "ZERO", S[S.NINE = 57] = "NINE", S[S.LOWER_A = 97] = "LOWER_A", S[S.LOWER_F = 102] = "LOWER_F", S[S.LOWER_X = 120] = "LOWER_X", S[S.LOWER_Z = 122] = "LOWER_Z", S[S.UPPER_A = 65] = "UPPER_A", S[S.UPPER_F = 70] = "UPPER_F", S[S.UPPER_Z = 90] = "UPPER_Z";
    })(s || (s = {}));
    var d = 32, l;
    (function(S) {
      S[S.VALUE_LENGTH = 49152] = "VALUE_LENGTH", S[S.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", S[S.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(l = u.BinTrieFlags || (u.BinTrieFlags = {}));
    function f(S) {
      return S >= s.ZERO && S <= s.NINE;
    }
    function h(S) {
      return S >= s.UPPER_A && S <= s.UPPER_F || S >= s.LOWER_A && S <= s.LOWER_F;
    }
    function p(S) {
      return S >= s.UPPER_A && S <= s.UPPER_Z || S >= s.LOWER_A && S <= s.LOWER_Z || f(S);
    }
    function b(S) {
      return S === s.EQUALS || p(S);
    }
    var _;
    (function(S) {
      S[S.EntityStart = 0] = "EntityStart", S[S.NumericStart = 1] = "NumericStart", S[S.NumericDecimal = 2] = "NumericDecimal", S[S.NumericHex = 3] = "NumericHex", S[S.NamedEntity = 4] = "NamedEntity";
    })(_ || (_ = {}));
    var y;
    (function(S) {
      S[S.Legacy = 0] = "Legacy", S[S.Strict = 1] = "Strict", S[S.Attribute = 2] = "Attribute";
    })(y = u.DecodingMode || (u.DecodingMode = {}));
    var m = (
      /** @class */
      function() {
        function S(O, x, F) {
          this.decodeTree = O, this.emitCodePoint = x, this.errors = F, this.state = _.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = y.Strict;
        }
        return S.prototype.startEntity = function(O) {
          this.decodeMode = O, this.state = _.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, S.prototype.write = function(O, x) {
          switch (this.state) {
            case _.EntityStart:
              return O.charCodeAt(x) === s.NUM ? (this.state = _.NumericStart, this.consumed += 1, this.stateNumericStart(O, x + 1)) : (this.state = _.NamedEntity, this.stateNamedEntity(O, x));
            case _.NumericStart:
              return this.stateNumericStart(O, x);
            case _.NumericDecimal:
              return this.stateNumericDecimal(O, x);
            case _.NumericHex:
              return this.stateNumericHex(O, x);
            case _.NamedEntity:
              return this.stateNamedEntity(O, x);
          }
        }, S.prototype.stateNumericStart = function(O, x) {
          return x >= O.length ? -1 : (O.charCodeAt(x) | d) === s.LOWER_X ? (this.state = _.NumericHex, this.consumed += 1, this.stateNumericHex(O, x + 1)) : (this.state = _.NumericDecimal, this.stateNumericDecimal(O, x));
        }, S.prototype.addToNumericResult = function(O, x, F, j) {
          if (x !== F) {
            var q = F - x;
            this.result = this.result * Math.pow(j, q) + parseInt(O.substr(x, q), j), this.consumed += q;
          }
        }, S.prototype.stateNumericHex = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j) || h(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 16), this.emitNumericEntity(j, 3);
          }
          return this.addToNumericResult(O, F, x, 16), -1;
        }, S.prototype.stateNumericDecimal = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 10), this.emitNumericEntity(j, 2);
          }
          return this.addToNumericResult(O, F, x, 10), -1;
        }, S.prototype.emitNumericEntity = function(O, x) {
          var F;
          if (this.consumed <= x)
            return (F = this.errors) === null || F === void 0 || F.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (O === s.SEMI)
            this.consumed += 1;
          else if (this.decodeMode === y.Strict)
            return 0;
          return this.emitCodePoint((0, i.replaceCodePoint)(this.result), this.consumed), this.errors && (O !== s.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, S.prototype.stateNamedEntity = function(O, x) {
          for (var F = this.decodeTree, j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14; x < O.length; x++, this.excess++) {
            var Q = O.charCodeAt(x);
            if (this.treeIndex = T(F, j, this.treeIndex + Math.max(1, q), Q), this.treeIndex < 0)
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === y.Attribute && // We shouldn't have consumed any characters after the entity,
              (q === 0 || // And there should be no invalid characters.
              b(Q)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14, q !== 0) {
              if (Q === s.SEMI)
                return this.emitNamedEntityData(this.treeIndex, q, this.consumed + this.excess);
              this.decodeMode !== y.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, S.prototype.emitNotTerminatedNamedEntity = function() {
          var O, x = this, F = x.result, j = x.decodeTree, q = (j[F] & l.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(F, q, this.consumed), (O = this.errors) === null || O === void 0 || O.missingSemicolonAfterCharacterReference(), this.consumed;
        }, S.prototype.emitNamedEntityData = function(O, x, F) {
          var j = this.decodeTree;
          return this.emitCodePoint(x === 1 ? j[O] & ~l.VALUE_LENGTH : j[O + 1], F), x === 3 && this.emitCodePoint(j[O + 2], F), F;
        }, S.prototype.end = function() {
          var O;
          switch (this.state) {
            case _.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== y.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            // Otherwise, emit a numeric entity if we have one.
            case _.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case _.NumericHex:
              return this.emitNumericEntity(0, 3);
            case _.NumericStart:
              return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case _.EntityStart:
              return 0;
          }
        }, S;
      }()
    );
    u.EntityDecoder = m;
    function g(S) {
      var O = "", x = new m(S, function(F) {
        return O += (0, i.fromCodePoint)(F);
      });
      return function(j, q) {
        for (var Q = 0, G = 0; (G = j.indexOf("&", G)) >= 0; ) {
          O += j.slice(Q, G), x.startEntity(q);
          var K = x.write(
            j,
            // Skip the "&"
            G + 1
          );
          if (K < 0) {
            Q = G + x.end();
            break;
          }
          Q = G + K, G = K === 0 ? Q + 1 : Q;
        }
        var U = O + j.slice(Q);
        return O = "", U;
      };
    }
    function T(S, O, x, F) {
      var j = (O & l.BRANCH_LENGTH) >> 7, q = O & l.JUMP_TABLE;
      if (j === 0)
        return q !== 0 && F === q ? x : -1;
      if (q) {
        var Q = F - q;
        return Q < 0 || Q >= j ? -1 : S[x + Q] - 1;
      }
      for (var G = x, K = G + j - 1; G <= K; ) {
        var U = G + K >>> 1, ae = S[U];
        if (ae < F)
          G = U + 1;
        else if (ae > F)
          K = U - 1;
        else
          return S[U + j];
      }
      return -1;
    }
    u.determineBranch = T;
    var v = g(e.default), E = g(n.default);
    function R(S, O) {
      return O === void 0 && (O = y.Legacy), v(S, O);
    }
    u.decodeHTML = R;
    function L(S) {
      return v(S, y.Attribute);
    }
    u.decodeHTMLAttribute = L;
    function A(S) {
      return v(S, y.Strict);
    }
    u.decodeHTMLStrict = A;
    function w(S) {
      return E(S, y.Strict);
    }
    u.decodeXML = w;
  }(ni)), ni;
}
var Wi = {}, m6 = {}, M7;
function Pse() {
  if (M7) return m6;
  M7 = 1, Object.defineProperty(m6, "__esModule", { value: !0 });
  function u(r) {
    for (var o = 1; o < r.length; o++)
      r[o][0] += r[o - 1][0] + 1;
    return r;
  }
  return m6.default = new Map(/* @__PURE__ */ u([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ u([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ u([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ u([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])), m6;
}
var LE = {}, C7;
function lx() {
  return C7 || (C7 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.escapeText = u.escapeAttribute = u.escapeUTF8 = u.escape = u.encodeXML = u.getCodePoint = u.xmlReplacer = void 0, u.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var r = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    u.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(t, e) {
      return t.codePointAt(e);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(t, e) {
        return (t.charCodeAt(e) & 64512) === 55296 ? (t.charCodeAt(e) - 55296) * 1024 + t.charCodeAt(e + 1) - 56320 + 65536 : t.charCodeAt(e);
      }
    );
    function o(t) {
      for (var e = "", n = 0, i; (i = u.xmlReplacer.exec(t)) !== null; ) {
        var c = i.index, s = t.charCodeAt(c), d = r.get(s);
        d !== void 0 ? (e += t.substring(n, c) + d, n = c + 1) : (e += "".concat(t.substring(n, c), "&#x").concat((0, u.getCodePoint)(t, c).toString(16), ";"), n = u.xmlReplacer.lastIndex += +((s & 64512) === 55296));
      }
      return e + t.substr(n);
    }
    u.encodeXML = o, u.escape = o;
    function a(t, e) {
      return function(i) {
        for (var c, s = 0, d = ""; c = t.exec(i); )
          s !== c.index && (d += i.substring(s, c.index)), d += e.get(c[0].charCodeAt(0)), s = c.index + 1;
        return d + i.substring(s);
      };
    }
    u.escapeUTF8 = a(/[&<>'"]/g, r), u.escapeAttribute = a(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ])), u.escapeText = a(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }(LE)), LE;
}
var q7;
function B7() {
  if (q7) return Wi;
  q7 = 1;
  var u = Wi && Wi.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.encodeNonAsciiHTML = Wi.encodeHTML = void 0;
  var r = u(/* @__PURE__ */ Pse()), o = /* @__PURE__ */ lx(), a = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  function t(i) {
    return n(a, i);
  }
  Wi.encodeHTML = t;
  function e(i) {
    return n(o.xmlReplacer, i);
  }
  Wi.encodeNonAsciiHTML = e;
  function n(i, c) {
    for (var s = "", d = 0, l; (l = i.exec(c)) !== null; ) {
      var f = l.index;
      s += c.substring(d, f);
      var h = c.charCodeAt(f), p = r.default.get(h);
      if (typeof p == "object") {
        if (f + 1 < c.length) {
          var b = c.charCodeAt(f + 1), _ = typeof p.n == "number" ? p.n === b ? p.o : void 0 : p.n.get(b);
          if (_ !== void 0) {
            s += _, d = i.lastIndex += 1;
            continue;
          }
        }
        p = p.v;
      }
      if (p !== void 0)
        s += p, d = f + 1;
      else {
        var y = (0, o.getCodePoint)(c, f);
        s += "&#x".concat(y.toString(16), ";"), d = i.lastIndex += +(y !== h);
      }
    }
    return s + c.substr(d);
  }
  return Wi;
}
var $7;
function Dse() {
  return $7 || ($7 = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.decodeXMLStrict = u.decodeHTML5Strict = u.decodeHTML4Strict = u.decodeHTML5 = u.decodeHTML4 = u.decodeHTMLAttribute = u.decodeHTMLStrict = u.decodeHTML = u.decodeXML = u.DecodingMode = u.EntityDecoder = u.encodeHTML5 = u.encodeHTML4 = u.encodeNonAsciiHTML = u.encodeHTML = u.escapeText = u.escapeAttribute = u.escapeUTF8 = u.escape = u.encodeXML = u.encode = u.decodeStrict = u.decode = u.EncodingMode = u.EntityLevel = void 0;
    var r = /* @__PURE__ */ j7(), o = /* @__PURE__ */ B7(), a = /* @__PURE__ */ lx(), t;
    (function(f) {
      f[f.XML = 0] = "XML", f[f.HTML = 1] = "HTML";
    })(t = u.EntityLevel || (u.EntityLevel = {}));
    var e;
    (function(f) {
      f[f.UTF8 = 0] = "UTF8", f[f.ASCII = 1] = "ASCII", f[f.Extensive = 2] = "Extensive", f[f.Attribute = 3] = "Attribute", f[f.Text = 4] = "Text";
    })(e = u.EncodingMode || (u.EncodingMode = {}));
    function n(f, h) {
      h === void 0 && (h = t.XML);
      var p = typeof h == "number" ? h : h.level;
      if (p === t.HTML) {
        var b = typeof h == "object" ? h.mode : void 0;
        return (0, r.decodeHTML)(f, b);
      }
      return (0, r.decodeXML)(f);
    }
    u.decode = n;
    function i(f, h) {
      var p;
      h === void 0 && (h = t.XML);
      var b = typeof h == "number" ? { level: h } : h;
      return (p = b.mode) !== null && p !== void 0 || (b.mode = r.DecodingMode.Strict), n(f, b);
    }
    u.decodeStrict = i;
    function c(f, h) {
      h === void 0 && (h = t.XML);
      var p = typeof h == "number" ? { level: h } : h;
      return p.mode === e.UTF8 ? (0, a.escapeUTF8)(f) : p.mode === e.Attribute ? (0, a.escapeAttribute)(f) : p.mode === e.Text ? (0, a.escapeText)(f) : p.level === t.HTML ? p.mode === e.ASCII ? (0, o.encodeNonAsciiHTML)(f) : (0, o.encodeHTML)(f) : (0, a.encodeXML)(f);
    }
    u.encode = c;
    var s = /* @__PURE__ */ lx();
    Object.defineProperty(u, "encodeXML", { enumerable: !0, get: function() {
      return s.encodeXML;
    } }), Object.defineProperty(u, "escape", { enumerable: !0, get: function() {
      return s.escape;
    } }), Object.defineProperty(u, "escapeUTF8", { enumerable: !0, get: function() {
      return s.escapeUTF8;
    } }), Object.defineProperty(u, "escapeAttribute", { enumerable: !0, get: function() {
      return s.escapeAttribute;
    } }), Object.defineProperty(u, "escapeText", { enumerable: !0, get: function() {
      return s.escapeText;
    } });
    var d = /* @__PURE__ */ B7();
    Object.defineProperty(u, "encodeHTML", { enumerable: !0, get: function() {
      return d.encodeHTML;
    } }), Object.defineProperty(u, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
      return d.encodeNonAsciiHTML;
    } }), Object.defineProperty(u, "encodeHTML4", { enumerable: !0, get: function() {
      return d.encodeHTML;
    } }), Object.defineProperty(u, "encodeHTML5", { enumerable: !0, get: function() {
      return d.encodeHTML;
    } });
    var l = /* @__PURE__ */ j7();
    Object.defineProperty(u, "EntityDecoder", { enumerable: !0, get: function() {
      return l.EntityDecoder;
    } }), Object.defineProperty(u, "DecodingMode", { enumerable: !0, get: function() {
      return l.DecodingMode;
    } }), Object.defineProperty(u, "decodeXML", { enumerable: !0, get: function() {
      return l.decodeXML;
    } }), Object.defineProperty(u, "decodeHTML", { enumerable: !0, get: function() {
      return l.decodeHTML;
    } }), Object.defineProperty(u, "decodeHTMLStrict", { enumerable: !0, get: function() {
      return l.decodeHTMLStrict;
    } }), Object.defineProperty(u, "decodeHTMLAttribute", { enumerable: !0, get: function() {
      return l.decodeHTMLAttribute;
    } }), Object.defineProperty(u, "decodeHTML4", { enumerable: !0, get: function() {
      return l.decodeHTML;
    } }), Object.defineProperty(u, "decodeHTML5", { enumerable: !0, get: function() {
      return l.decodeHTML;
    } }), Object.defineProperty(u, "decodeHTML4Strict", { enumerable: !0, get: function() {
      return l.decodeHTMLStrict;
    } }), Object.defineProperty(u, "decodeHTML5Strict", { enumerable: !0, get: function() {
      return l.decodeHTMLStrict;
    } }), Object.defineProperty(u, "decodeXMLStrict", { enumerable: !0, get: function() {
      return l.decodeXML;
    } });
  }(PE)), PE;
}
var ls = {}, U7;
function Lse() {
  return U7 || (U7 = 1, Object.defineProperty(ls, "__esModule", { value: !0 }), ls.attributeNames = ls.elementNames = void 0, ls.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(u) {
    return [u.toLowerCase(), u];
  })), ls.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(u) {
    return [u.toLowerCase(), u];
  }))), ls;
}
var V7;
function jse() {
  if (V7) return ln;
  V7 = 1;
  var u = ln && ln.__assign || function() {
    return u = Object.assign || function(T) {
      for (var v, E = 1, R = arguments.length; E < R; E++) {
        v = arguments[E];
        for (var L in v) Object.prototype.hasOwnProperty.call(v, L) && (T[L] = v[L]);
      }
      return T;
    }, u.apply(this, arguments);
  }, r = ln && ln.__createBinding || (Object.create ? function(T, v, E, R) {
    R === void 0 && (R = E);
    var L = Object.getOwnPropertyDescriptor(v, E);
    (!L || ("get" in L ? !v.__esModule : L.writable || L.configurable)) && (L = { enumerable: !0, get: function() {
      return v[E];
    } }), Object.defineProperty(T, R, L);
  } : function(T, v, E, R) {
    R === void 0 && (R = E), T[R] = v[E];
  }), o = ln && ln.__setModuleDefault || (Object.create ? function(T, v) {
    Object.defineProperty(T, "default", { enumerable: !0, value: v });
  } : function(T, v) {
    T.default = v;
  }), a = ln && ln.__importStar || function(T) {
    if (T && T.__esModule) return T;
    var v = {};
    if (T != null) for (var E in T) E !== "default" && Object.prototype.hasOwnProperty.call(T, E) && r(v, T, E);
    return o(v, T), v;
  };
  Object.defineProperty(ln, "__esModule", { value: !0 }), ln.render = void 0;
  var t = a(/* @__PURE__ */ i0()), e = /* @__PURE__ */ Dse(), n = /* @__PURE__ */ Lse(), i = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function c(T) {
    return T.replace(/"/g, "&quot;");
  }
  function s(T, v) {
    var E;
    if (T) {
      var R = ((E = v.encodeEntities) !== null && E !== void 0 ? E : v.decodeEntities) === !1 ? c : v.xmlMode || v.encodeEntities !== "utf8" ? e.encodeXML : e.escapeAttribute;
      return Object.keys(T).map(function(L) {
        var A, w, S = (A = T[L]) !== null && A !== void 0 ? A : "";
        return v.xmlMode === "foreign" && (L = (w = n.attributeNames.get(L)) !== null && w !== void 0 ? w : L), !v.emptyAttrs && !v.xmlMode && S === "" ? L : "".concat(L, '="').concat(R(S), '"');
      }).join(" ");
    }
  }
  var d = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function l(T, v) {
    v === void 0 && (v = {});
    for (var E = ("length" in T) ? T : [T], R = "", L = 0; L < E.length; L++)
      R += f(E[L], v);
    return R;
  }
  ln.render = l, ln.default = l;
  function f(T, v) {
    switch (T.type) {
      case t.Root:
        return l(T.children, v);
      // @ts-expect-error We don't use `Doctype` yet
      case t.Doctype:
      case t.Directive:
        return _(T);
      case t.Comment:
        return g(T);
      case t.CDATA:
        return m(T);
      case t.Script:
      case t.Style:
      case t.Tag:
        return b(T, v);
      case t.Text:
        return y(T, v);
    }
  }
  var h = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]), p = /* @__PURE__ */ new Set(["svg", "math"]);
  function b(T, v) {
    var E;
    v.xmlMode === "foreign" && (T.name = (E = n.elementNames.get(T.name)) !== null && E !== void 0 ? E : T.name, T.parent && h.has(T.parent.name) && (v = u(u({}, v), { xmlMode: !1 }))), !v.xmlMode && p.has(T.name) && (v = u(u({}, v), { xmlMode: "foreign" }));
    var R = "<".concat(T.name), L = s(T.attribs, v);
    return L && (R += " ".concat(L)), T.children.length === 0 && (v.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      v.selfClosingTags !== !1
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      v.selfClosingTags && d.has(T.name)
    )) ? (v.xmlMode || (R += " "), R += "/>") : (R += ">", T.children.length > 0 && (R += l(T.children, v)), (v.xmlMode || !d.has(T.name)) && (R += "</".concat(T.name, ">"))), R;
  }
  function _(T) {
    return "<".concat(T.data, ">");
  }
  function y(T, v) {
    var E, R = T.data || "";
    return ((E = v.encodeEntities) !== null && E !== void 0 ? E : v.decodeEntities) !== !1 && !(!v.xmlMode && T.parent && i.has(T.parent.name)) && (R = v.xmlMode || v.encodeEntities !== "utf8" ? (0, e.encodeXML)(R) : (0, e.escapeText)(R)), R;
  }
  function m(T) {
    return "<![CDATA[".concat(T.children[0].data, "]]>");
  }
  function g(T) {
    return "<!--".concat(T.data, "-->");
  }
  return ln;
}
var Q7;
function sY() {
  if (Q7) return Oi;
  Q7 = 1;
  var u = Oi && Oi.__importDefault || function(s) {
    return s && s.__esModule ? s : { default: s };
  };
  Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.getOuterHTML = t, Oi.getInnerHTML = e, Oi.getText = n, Oi.textContent = i, Oi.innerText = c;
  var r = /* @__PURE__ */ Vn(), o = u(/* @__PURE__ */ jse()), a = /* @__PURE__ */ i0();
  function t(s, d) {
    return (0, o.default)(s, d);
  }
  function e(s, d) {
    return (0, r.hasChildren)(s) ? s.children.map(function(l) {
      return t(l, d);
    }).join("") : "";
  }
  function n(s) {
    return Array.isArray(s) ? s.map(n).join("") : (0, r.isTag)(s) ? s.name === "br" ? `
` : n(s.children) : (0, r.isCDATA)(s) ? n(s.children) : (0, r.isText)(s) ? s.data : "";
  }
  function i(s) {
    return Array.isArray(s) ? s.map(i).join("") : (0, r.hasChildren)(s) && !(0, r.isComment)(s) ? i(s.children) : (0, r.isText)(s) ? s.data : "";
  }
  function c(s) {
    return Array.isArray(s) ? s.map(c).join("") : (0, r.hasChildren)(s) && (s.type === a.ElementType.Tag || (0, r.isCDATA)(s)) ? c(s.children) : (0, r.isText)(s) ? s.data : "";
  }
  return Oi;
}
var ii = {}, H7;
function Mse() {
  if (H7) return ii;
  H7 = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.getChildren = r, ii.getParent = o, ii.getSiblings = a, ii.getAttributeValue = t, ii.hasAttrib = e, ii.getName = n, ii.nextElementSibling = i, ii.prevElementSibling = c;
  var u = /* @__PURE__ */ Vn();
  function r(s) {
    return (0, u.hasChildren)(s) ? s.children : [];
  }
  function o(s) {
    return s.parent || null;
  }
  function a(s) {
    var d, l, f = o(s);
    if (f != null)
      return r(f);
    for (var h = [s], p = s.prev, b = s.next; p != null; )
      h.unshift(p), d = p, p = d.prev;
    for (; b != null; )
      h.push(b), l = b, b = l.next;
    return h;
  }
  function t(s, d) {
    var l;
    return (l = s.attribs) === null || l === void 0 ? void 0 : l[d];
  }
  function e(s, d) {
    return s.attribs != null && Object.prototype.hasOwnProperty.call(s.attribs, d) && s.attribs[d] != null;
  }
  function n(s) {
    return s.name;
  }
  function i(s) {
    for (var d, l = s.next; l !== null && !(0, u.isTag)(l); )
      d = l, l = d.next;
    return l;
  }
  function c(s) {
    for (var d, l = s.prev; l !== null && !(0, u.isTag)(l); )
      d = l, l = d.prev;
    return l;
  }
  return ii;
}
var Yi = {}, G7;
function Cse() {
  if (G7) return Yi;
  G7 = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.removeElement = u, Yi.replaceElement = r, Yi.appendChild = o, Yi.append = a, Yi.prependChild = t, Yi.prepend = e;
  function u(n) {
    if (n.prev && (n.prev.next = n.next), n.next && (n.next.prev = n.prev), n.parent) {
      var i = n.parent.children, c = i.lastIndexOf(n);
      c >= 0 && i.splice(c, 1);
    }
    n.next = null, n.prev = null, n.parent = null;
  }
  function r(n, i) {
    var c = i.prev = n.prev;
    c && (c.next = i);
    var s = i.next = n.next;
    s && (s.prev = i);
    var d = i.parent = n.parent;
    if (d) {
      var l = d.children;
      l[l.lastIndexOf(n)] = i, n.parent = null;
    }
  }
  function o(n, i) {
    if (u(i), i.next = null, i.parent = n, n.children.push(i) > 1) {
      var c = n.children[n.children.length - 2];
      c.next = i, i.prev = c;
    } else
      i.prev = null;
  }
  function a(n, i) {
    u(i);
    var c = n.parent, s = n.next;
    if (i.next = s, i.prev = n, n.next = i, i.parent = c, s) {
      if (s.prev = i, c) {
        var d = c.children;
        d.splice(d.lastIndexOf(s), 0, i);
      }
    } else c && c.children.push(i);
  }
  function t(n, i) {
    if (u(i), i.parent = n, i.prev = null, n.children.unshift(i) !== 1) {
      var c = n.children[1];
      c.prev = i, i.next = c;
    } else
      i.next = null;
  }
  function e(n, i) {
    u(i);
    var c = n.parent;
    if (c) {
      var s = c.children;
      s.splice(s.indexOf(n), 0, i);
    }
    n.prev && (n.prev.next = i), i.parent = c, i.prev = n.prev, i.next = n, n.prev = i;
  }
  return Yi;
}
var Zi = {}, z7;
function cY() {
  if (z7) return Zi;
  z7 = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.filter = r, Zi.find = o, Zi.findOneChild = a, Zi.findOne = t, Zi.existsOne = e, Zi.findAll = n;
  var u = /* @__PURE__ */ Vn();
  function r(i, c, s, d) {
    return s === void 0 && (s = !0), d === void 0 && (d = 1 / 0), o(i, Array.isArray(c) ? c : [c], s, d);
  }
  function o(i, c, s, d) {
    for (var l = [], f = [Array.isArray(c) ? c : [c]], h = [0]; ; ) {
      if (h[0] >= f[0].length) {
        if (h.length === 1)
          return l;
        f.shift(), h.shift();
        continue;
      }
      var p = f[0][h[0]++];
      if (i(p) && (l.push(p), --d <= 0))
        return l;
      s && (0, u.hasChildren)(p) && p.children.length > 0 && (h.unshift(0), f.unshift(p.children));
    }
  }
  function a(i, c) {
    return c.find(i);
  }
  function t(i, c, s) {
    s === void 0 && (s = !0);
    for (var d = Array.isArray(c) ? c : [c], l = 0; l < d.length; l++) {
      var f = d[l];
      if ((0, u.isTag)(f) && i(f))
        return f;
      if (s && (0, u.hasChildren)(f) && f.children.length > 0) {
        var h = t(i, f.children, !0);
        if (h)
          return h;
      }
    }
    return null;
  }
  function e(i, c) {
    return (Array.isArray(c) ? c : [c]).some(function(s) {
      return (0, u.isTag)(s) && i(s) || (0, u.hasChildren)(s) && e(i, s.children);
    });
  }
  function n(i, c) {
    for (var s = [], d = [Array.isArray(c) ? c : [c]], l = [0]; ; ) {
      if (l[0] >= d[0].length) {
        if (d.length === 1)
          return s;
        d.shift(), l.shift();
        continue;
      }
      var f = d[0][l[0]++];
      (0, u.isTag)(f) && i(f) && s.push(f), (0, u.hasChildren)(f) && f.children.length > 0 && (l.unshift(0), d.unshift(f.children));
    }
  }
  return Zi;
}
var ea = {}, k7;
function dY() {
  if (k7) return ea;
  k7 = 1, Object.defineProperty(ea, "__esModule", { value: !0 }), ea.testElement = n, ea.getElements = i, ea.getElementById = c, ea.getElementsByTagName = s, ea.getElementsByClassName = d, ea.getElementsByTagType = l;
  var u = /* @__PURE__ */ Vn(), r = /* @__PURE__ */ cY(), o = {
    tag_name: function(f) {
      return typeof f == "function" ? function(h) {
        return (0, u.isTag)(h) && f(h.name);
      } : f === "*" ? u.isTag : function(h) {
        return (0, u.isTag)(h) && h.name === f;
      };
    },
    tag_type: function(f) {
      return typeof f == "function" ? function(h) {
        return f(h.type);
      } : function(h) {
        return h.type === f;
      };
    },
    tag_contains: function(f) {
      return typeof f == "function" ? function(h) {
        return (0, u.isText)(h) && f(h.data);
      } : function(h) {
        return (0, u.isText)(h) && h.data === f;
      };
    }
  };
  function a(f, h) {
    return typeof h == "function" ? function(p) {
      return (0, u.isTag)(p) && h(p.attribs[f]);
    } : function(p) {
      return (0, u.isTag)(p) && p.attribs[f] === h;
    };
  }
  function t(f, h) {
    return function(p) {
      return f(p) || h(p);
    };
  }
  function e(f) {
    var h = Object.keys(f).map(function(p) {
      var b = f[p];
      return Object.prototype.hasOwnProperty.call(o, p) ? o[p](b) : a(p, b);
    });
    return h.length === 0 ? null : h.reduce(t);
  }
  function n(f, h) {
    var p = e(f);
    return p ? p(h) : !0;
  }
  function i(f, h, p, b) {
    b === void 0 && (b = 1 / 0);
    var _ = e(f);
    return _ ? (0, r.filter)(_, h, p, b) : [];
  }
  function c(f, h, p) {
    return p === void 0 && (p = !0), Array.isArray(h) || (h = [h]), (0, r.findOne)(a("id", f), h, p);
  }
  function s(f, h, p, b) {
    return p === void 0 && (p = !0), b === void 0 && (b = 1 / 0), (0, r.filter)(o.tag_name(f), h, p, b);
  }
  function d(f, h, p, b) {
    return p === void 0 && (p = !0), b === void 0 && (b = 1 / 0), (0, r.filter)(a("class", f), h, p, b);
  }
  function l(f, h, p, b) {
    return p === void 0 && (p = !0), b === void 0 && (b = 1 / 0), (0, r.filter)(o.tag_type(f), h, p, b);
  }
  return ea;
}
var Fa = {}, X7;
function qse() {
  if (X7) return Fa;
  X7 = 1, Object.defineProperty(Fa, "__esModule", { value: !0 }), Fa.DocumentPosition = void 0, Fa.removeSubsets = r, Fa.compareDocumentPosition = a, Fa.uniqueSort = t;
  var u = /* @__PURE__ */ Vn();
  function r(e) {
    for (var n = e.length; --n >= 0; ) {
      var i = e[n];
      if (n > 0 && e.lastIndexOf(i, n - 1) >= 0) {
        e.splice(n, 1);
        continue;
      }
      for (var c = i.parent; c; c = c.parent)
        if (e.includes(c)) {
          e.splice(n, 1);
          break;
        }
    }
    return e;
  }
  var o;
  (function(e) {
    e[e.DISCONNECTED = 1] = "DISCONNECTED", e[e.PRECEDING = 2] = "PRECEDING", e[e.FOLLOWING = 4] = "FOLLOWING", e[e.CONTAINS = 8] = "CONTAINS", e[e.CONTAINED_BY = 16] = "CONTAINED_BY";
  })(o || (Fa.DocumentPosition = o = {}));
  function a(e, n) {
    var i = [], c = [];
    if (e === n)
      return 0;
    for (var s = (0, u.hasChildren)(e) ? e : e.parent; s; )
      i.unshift(s), s = s.parent;
    for (s = (0, u.hasChildren)(n) ? n : n.parent; s; )
      c.unshift(s), s = s.parent;
    for (var d = Math.min(i.length, c.length), l = 0; l < d && i[l] === c[l]; )
      l++;
    if (l === 0)
      return o.DISCONNECTED;
    var f = i[l - 1], h = f.children, p = i[l], b = c[l];
    return h.indexOf(p) > h.indexOf(b) ? f === n ? o.FOLLOWING | o.CONTAINED_BY : o.FOLLOWING : f === e ? o.PRECEDING | o.CONTAINS : o.PRECEDING;
  }
  function t(e) {
    return e = e.filter(function(n, i, c) {
      return !c.includes(n, i + 1);
    }), e.sort(function(n, i) {
      var c = a(n, i);
      return c & o.PRECEDING ? -1 : c & o.FOLLOWING ? 1 : 0;
    }), e;
  }
  return Fa;
}
var v6 = {}, J7;
function Bse() {
  if (J7) return v6;
  J7 = 1, Object.defineProperty(v6, "__esModule", { value: !0 }), v6.getFeed = o;
  var u = /* @__PURE__ */ sY(), r = /* @__PURE__ */ dY();
  function o(f) {
    var h = c(l, f);
    return h ? h.name === "feed" ? a(h) : t(h) : null;
  }
  function a(f) {
    var h, p = f.children, b = {
      type: "atom",
      items: (0, r.getElementsByTagName)("entry", p).map(function(m) {
        var g, T = m.children, v = { media: i(T) };
        d(v, "id", "id", T), d(v, "title", "title", T);
        var E = (g = c("link", T)) === null || g === void 0 ? void 0 : g.attribs.href;
        E && (v.link = E);
        var R = s("summary", T) || s("content", T);
        R && (v.description = R);
        var L = s("updated", T);
        return L && (v.pubDate = new Date(L)), v;
      })
    };
    d(b, "id", "id", p), d(b, "title", "title", p);
    var _ = (h = c("link", p)) === null || h === void 0 ? void 0 : h.attribs.href;
    _ && (b.link = _), d(b, "description", "subtitle", p);
    var y = s("updated", p);
    return y && (b.updated = new Date(y)), d(b, "author", "email", p, !0), b;
  }
  function t(f) {
    var h, p, b = (p = (h = c("channel", f.children)) === null || h === void 0 ? void 0 : h.children) !== null && p !== void 0 ? p : [], _ = {
      type: f.name.substr(0, 3),
      id: "",
      items: (0, r.getElementsByTagName)("item", f.children).map(function(m) {
        var g = m.children, T = { media: i(g) };
        d(T, "id", "guid", g), d(T, "title", "title", g), d(T, "link", "link", g), d(T, "description", "description", g);
        var v = s("pubDate", g) || s("dc:date", g);
        return v && (T.pubDate = new Date(v)), T;
      })
    };
    d(_, "title", "title", b), d(_, "link", "link", b), d(_, "description", "description", b);
    var y = s("lastBuildDate", b);
    return y && (_.updated = new Date(y)), d(_, "author", "managingEditor", b, !0), _;
  }
  var e = ["url", "type", "lang"], n = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function i(f) {
    return (0, r.getElementsByTagName)("media:content", f).map(function(h) {
      for (var p = h.attribs, b = {
        medium: p.medium,
        isDefault: !!p.isDefault
      }, _ = 0, y = e; _ < y.length; _++) {
        var m = y[_];
        p[m] && (b[m] = p[m]);
      }
      for (var g = 0, T = n; g < T.length; g++) {
        var m = T[g];
        p[m] && (b[m] = parseInt(p[m], 10));
      }
      return p.expression && (b.expression = p.expression), b;
    });
  }
  function c(f, h) {
    return (0, r.getElementsByTagName)(f, h, !0, 1)[0];
  }
  function s(f, h, p) {
    return p === void 0 && (p = !1), (0, u.textContent)((0, r.getElementsByTagName)(f, h, p, 1)).trim();
  }
  function d(f, h, p, b, _) {
    _ === void 0 && (_ = !1);
    var y = s(p, b, _);
    y && (f[h] = y);
  }
  function l(f) {
    return f === "rss" || f === "feed" || f === "rdf:RDF";
  }
  return v6;
}
var K7;
function pa() {
  return K7 || (K7 = 1, function(u) {
    var r = ds && ds.__createBinding || (Object.create ? function(t, e, n, i) {
      i === void 0 && (i = n);
      var c = Object.getOwnPropertyDescriptor(e, n);
      (!c || ("get" in c ? !e.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return e[n];
      } }), Object.defineProperty(t, i, c);
    } : function(t, e, n, i) {
      i === void 0 && (i = n), t[i] = e[n];
    }), o = ds && ds.__exportStar || function(t, e) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(e, n) && r(e, t, n);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.hasChildren = u.isDocument = u.isComment = u.isText = u.isCDATA = u.isTag = void 0, o(/* @__PURE__ */ sY(), u), o(/* @__PURE__ */ Mse(), u), o(/* @__PURE__ */ Cse(), u), o(/* @__PURE__ */ cY(), u), o(/* @__PURE__ */ dY(), u), o(/* @__PURE__ */ qse(), u), o(/* @__PURE__ */ Bse(), u);
    var a = /* @__PURE__ */ Vn();
    Object.defineProperty(u, "isTag", { enumerable: !0, get: function() {
      return a.isTag;
    } }), Object.defineProperty(u, "isCDATA", { enumerable: !0, get: function() {
      return a.isCDATA;
    } }), Object.defineProperty(u, "isText", { enumerable: !0, get: function() {
      return a.isText;
    } }), Object.defineProperty(u, "isComment", { enumerable: !0, get: function() {
      return a.isComment;
    } }), Object.defineProperty(u, "isDocument", { enumerable: !0, get: function() {
      return a.isDocument;
    } }), Object.defineProperty(u, "hasChildren", { enumerable: !0, get: function() {
      return a.hasChildren;
    } });
  }(ds)), ds;
}
var W7;
function $se() {
  return W7 || (W7 = 1, function(u) {
    var r = ei && ei.__createBinding || (Object.create ? function(y, m, g, T) {
      T === void 0 && (T = g);
      var v = Object.getOwnPropertyDescriptor(m, g);
      (!v || ("get" in v ? !m.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
        return m[g];
      } }), Object.defineProperty(y, T, v);
    } : function(y, m, g, T) {
      T === void 0 && (T = g), y[T] = m[g];
    }), o = ei && ei.__setModuleDefault || (Object.create ? function(y, m) {
      Object.defineProperty(y, "default", { enumerable: !0, value: m });
    } : function(y, m) {
      y.default = m;
    }), a = ei && ei.__importStar || function(y) {
      if (y && y.__esModule) return y;
      var m = {};
      if (y != null) for (var g in y) g !== "default" && Object.prototype.hasOwnProperty.call(y, g) && r(m, y, g);
      return o(m, y), m;
    }, t = ei && ei.__importDefault || function(y) {
      return y && y.__esModule ? y : { default: y };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.DomUtils = u.parseFeed = u.getFeed = u.ElementType = u.Tokenizer = u.createDomStream = u.parseDOM = u.parseDocument = u.DefaultHandler = u.DomHandler = u.Parser = void 0;
    var e = /* @__PURE__ */ E7(), n = /* @__PURE__ */ E7();
    Object.defineProperty(u, "Parser", { enumerable: !0, get: function() {
      return n.Parser;
    } });
    var i = /* @__PURE__ */ Vn(), c = /* @__PURE__ */ Vn();
    Object.defineProperty(u, "DomHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } }), Object.defineProperty(u, "DefaultHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } });
    function s(y, m) {
      var g = new i.DomHandler(void 0, m);
      return new e.Parser(g, m).end(y), g.root;
    }
    u.parseDocument = s;
    function d(y, m) {
      return s(y, m).children;
    }
    u.parseDOM = d;
    function l(y, m, g) {
      var T = new i.DomHandler(y, m, g);
      return new e.Parser(T, m);
    }
    u.createDomStream = l;
    var f = /* @__PURE__ */ oY();
    Object.defineProperty(u, "Tokenizer", { enumerable: !0, get: function() {
      return t(f).default;
    } }), u.ElementType = a(/* @__PURE__ */ i0());
    var h = /* @__PURE__ */ pa(), p = /* @__PURE__ */ pa();
    Object.defineProperty(u, "getFeed", { enumerable: !0, get: function() {
      return p.getFeed;
    } });
    var b = { xmlMode: !0 };
    function _(y, m) {
      return m === void 0 && (m = b), (0, h.getFeed)(d(y, m));
    }
    u.parseFeed = _, u.DomUtils = a(/* @__PURE__ */ pa());
  }(ei)), ei;
}
const Use = {
  "@context": { alternate: "http://www.w3.org/1999/xhtml/vocab#alternate", appendix: "http://www.w3.org/1999/xhtml/vocab#appendix", cite: "http://www.w3.org/1999/xhtml/vocab#cite", bookmark: "http://www.w3.org/1999/xhtml/vocab#bookmark", contents: "http://www.w3.org/1999/xhtml/vocab#contents", chapter: "http://www.w3.org/1999/xhtml/vocab#chapter", copyright: "http://www.w3.org/1999/xhtml/vocab#copyright", first: "http://www.w3.org/1999/xhtml/vocab#first", glossary: "http://www.w3.org/1999/xhtml/vocab#glossary", help: "http://www.w3.org/1999/xhtml/vocab#help", icon: "http://www.w3.org/1999/xhtml/vocab#icon", index: "http://www.w3.org/1999/xhtml/vocab#index", last: "http://www.w3.org/1999/xhtml/vocab#last", license: "http://www.w3.org/1999/xhtml/vocab#license", meta: "http://www.w3.org/1999/xhtml/vocab#meta", next: "http://www.w3.org/1999/xhtml/vocab#next", prev: "http://www.w3.org/1999/xhtml/vocab#prev", previous: "http://www.w3.org/1999/xhtml/vocab#previous", section: "http://www.w3.org/1999/xhtml/vocab#section", start: "http://www.w3.org/1999/xhtml/vocab#start", stylesheet: "http://www.w3.org/1999/xhtml/vocab#stylesheet", subsection: "http://www.w3.org/1999/xhtml/vocab#subsection", top: "http://www.w3.org/1999/xhtml/vocab#top", up: "http://www.w3.org/1999/xhtml/vocab#up", p3pv1: "http://www.w3.org/1999/xhtml/vocab#p3pv1" }
}, Vse = {
  "@context": { as: "https://www.w3.org/ns/activitystreams#", cat: "http://www.w3.org/ns/dcat#", cc: "http://creativecommons.org/ns#", cnt: "http://www.w3.org/2008/content#", csvw: "http://www.w3.org/ns/csvw#", ctag: "http://commontag.org/ns#", dc: "http://purl.org/dc/terms/", dc11: "http://purl.org/dc/elements/1.1/", dcat: "http://www.w3.org/ns/dcat#", dcterms: "http://purl.org/dc/terms/", dqv: "http://www.w3.org/ns/dqv#", duv: "https://www.w3.org/TR/vocab-duv#", earl: "http://www.w3.org/ns/earl#", foaf: "http://xmlns.com/foaf/0.1/", gldp: "http://www.w3.org/ns/people#", gr: "http://purl.org/goodrelations/v1#", grddl: "http://www.w3.org/2003/g/data-view#", ht: "http://www.w3.org/2006/http#", ical: "http://www.w3.org/2002/12/cal/icaltzd#", ldp: "http://www.w3.org/ns/ldp#", ma: "http://www.w3.org/ns/ma-ont#", oa: "http://www.w3.org/ns/oa#", odrl: "http://www.w3.org/ns/odrl/2/", og: "http://ogp.me/ns#", org: "http://www.w3.org/ns/org#", owl: "http://www.w3.org/2002/07/owl#", prov: "http://www.w3.org/ns/prov#", ptr: "http://www.w3.org/2009/pointers#", qb: "http://purl.org/linked-data/cube#", rev: "http://purl.org/stuff/rev#", rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#", rdfa: "http://www.w3.org/ns/rdfa#", rdfs: "http://www.w3.org/2000/01/rdf-schema#", rif: "http://www.w3.org/2007/rif#", rr: "http://www.w3.org/ns/r2rml#", schema: "http://schema.org/", sd: "http://www.w3.org/ns/sparql-service-description#", sioc: "http://rdfs.org/sioc/ns#", skos: "http://www.w3.org/2004/02/skos/core#", skosxl: "http://www.w3.org/2008/05/skos-xl#", ssn: "http://www.w3.org/ns/ssn/", sosa: "http://www.w3.org/ns/sosa/", time: "http://www.w3.org/2006/time#", v: "http://rdf.data-vocabulary.org/#", vcard: "http://www.w3.org/2006/vcard/ns#", void: "http://rdfs.org/ns/void#", wdr: "http://www.w3.org/2007/05/powder#", wdrs: "http://www.w3.org/2007/05/powder-s#", xhv: "http://www.w3.org/1999/xhtml/vocab#", xml: "http://www.w3.org/XML/1998/namespace", xsd: "http://www.w3.org/2001/XMLSchema#", describedby: "http://www.w3.org/2007/05/powder-s#describedby", license: "http://www.w3.org/1999/xhtml/vocab#license", role: "http://www.w3.org/1999/xhtml/vocab#role" }
};
var fs = {}, Y7;
function C8() {
  return Y7 || (Y7 = 1, Object.defineProperty(fs, "__esModule", { value: !0 }), fs.RDFA_CONTENTTYPES = fs.RDFA_FEATURES = void 0, fs.RDFA_FEATURES = {
    "": {
      baseTag: !0,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    core: {
      baseTag: !1,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !1,
      timeTag: !1,
      htmlDatatype: !1,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !1
    },
    html: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    },
    xhtml: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    xml: {
      baseTag: !1,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !1,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !1,
      copyRdfaPatterns: !1,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    }
  }, fs.RDFA_CONTENTTYPES = {
    // HTML
    "text/html": "html",
    // XHTML
    "application/xhtml+xml": "xhtml",
    // XML
    "application/xml": "xml",
    "text/xml": "xml",
    "image/svg+xml": "xml"
  }), fs;
}
var pb = {}, Z7;
function lY() {
  if (Z7) return pb;
  Z7 = 1, Object.defineProperty(pb, "__esModule", { value: !0 }), pb.Util = void 0;
  const u = Tr(), r = /* @__PURE__ */ C8(), o = Or();
  class a {
    constructor(e, n) {
      this.dataFactory = e || new o.DataFactory(), this.baseIRI = this.dataFactory.namedNode(n || ""), this.baseIRIDocument = this.baseIRI;
    }
    /**
     * Retrieve the prefixes of the current tag's attributes.
     * @param {{[p: string]: string}} attributes A tag's attributes.
     * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.
     * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.
     * @return {{[p: string]: string}} The new prefixes.
     */
    static parsePrefixes(e, n, i) {
      const c = {};
      if (i)
        for (const s in e)
          s.startsWith("xmlns") && (c[s.substr(6)] = e[s]);
      if (e.prefix || Object.keys(c).length > 0) {
        const s = Object.assign(Object.assign({}, n), c);
        if (e.prefix) {
          let d;
          for (; d = a.PREFIX_REGEX.exec(e.prefix); )
            s[d[1]] = d[2];
        }
        return s;
      } else
        return n;
    }
    /**
     * Expand the given term value based on the given prefixes.
     * @param {string} term A term value.
     * @param {{[p: string]: string}[]} prefixes The available prefixes.
     * @return {string} An expanded URL, or the term as-is.
     */
    static expandPrefixedTerm(e, n) {
      const i = e.indexOf(":");
      let c, s;
      if (i >= 0 && (c = e.substr(0, i), s = e.substr(i + 1)), c === "")
        return "http://www.w3.org/1999/xhtml/vocab#" + s;
      if (c) {
        const d = n.prefixesAll[c];
        if (d)
          return d + s;
      }
      if (e) {
        const d = n.prefixesAll[e.toLocaleLowerCase()];
        if (d)
          return d;
      }
      return e;
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(e) {
      return a.IRI_REGEX.test(e);
    }
    /**
     * Determine the RDFa profile from the given content type.
     * Defaults to the default RDFa profile (all features enabled) for unknown content types.
     * @param {string} contentType A content type.
     * @returns {RdfaProfile} An RDFa profile.
     */
    static contentTypeToProfile(e) {
      return r.RDFA_CONTENTTYPES[e] || "";
    }
    /**
     * Get the base IRI.
     * @param {string} baseIriValue A base IRI value.
     * @return A base IRI named node.
     */
    getBaseIRI(e) {
      let n = e;
      const i = n.indexOf("#");
      return i >= 0 && (n = n.substr(0, i)), this.dataFactory.namedNode((0, u.resolve)(n, this.baseIRI.value));
    }
    /**
     * If the term is a boolean, return the baseIRI, otherwise return the term as-is.
     * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.
     * @param {IActiveTag} activeTag An active tag.
     * @returns {Term} A term.
     */
    getResourceOrBaseIri(e, n) {
      return e === !0 ? this.getBaseIriTerm(n) : e;
    }
    /**
     * Get the active base IRI as an RDF term.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} The base IRI term.
     */
    getBaseIriTerm(e) {
      return e.localBaseIRI || this.baseIRI;
    }
    createVocabIris(e, n, i, c) {
      return e.split(/\s+/).filter((s) => s && (i || s.indexOf(":") >= 0)).map((s) => this.createIri(s, n, !0, !0, c)).filter((s) => s != null);
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */
    createLiteral(e, n) {
      if (n.interpretObjectAsTime && !n.datatype) {
        for (const i of a.TIME_REGEXES)
          if (e.match(i.regex)) {
            n.datatype = this.dataFactory.namedNode(a.XSD + i.type);
            break;
          }
      }
      return this.dataFactory.literal(e, n.datatype || n.language);
    }
    /**
     * Create a blank node.
     * @returns {BlankNode} A new blank node.
     */
    createBlankNode() {
      return this.blankNodeFactory ? this.blankNodeFactory() : this.dataFactory.blankNode();
    }
    createIri(e, n, i, c, s) {
      if (e = e || "", !c)
        return i || (e = (0, u.resolve)(e, this.getBaseIriTerm(n).value)), a.isValidIri(e) ? this.dataFactory.namedNode(e) : null;
      if (e.length > 0 && e[0] === "[" && e[e.length - 1] === "]" && (e = e.substr(1, e.length - 2), e.indexOf(":") < 0))
        return null;
      if (e.startsWith("_:"))
        return s ? this.dataFactory.blankNode(e.substr(2) || "b_identity") : null;
      if (i && n.vocab && e.indexOf(":") < 0)
        return this.dataFactory.namedNode(n.vocab + e);
      let d = a.expandPrefixedTerm(e, n);
      return i ? e !== d && (d = (0, u.resolve)(d, this.baseIRIDocument.value)) : d = (0, u.resolve)(d, this.getBaseIriTerm(n).value), a.isValidIri(d) ? this.dataFactory.namedNode(d) : null;
    }
  }
  return pb.Util = a, a.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", a.XSD = "http://www.w3.org/2001/XMLSchema#", a.RDFA = "http://www.w3.org/ns/rdfa#", a.PREFIX_REGEX = /\s*([^:\s]*)*:\s*([^\s]*)*\s*/g, a.TIME_REGEXES = [
    {
      regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
      type: "duration"
    },
    {
      regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
      type: "dateTime"
    },
    { regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/, type: "date" },
    { regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/, type: "time" },
    { regex: /^[0-9]+-[0-9][0-9]$/, type: "gYearMonth" },
    { regex: /^[0-9]+$/, type: "gYear" }
  ], a.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`]*$/, pb;
}
var eL;
function Qse() {
  if (eL) return hb;
  eL = 1, Object.defineProperty(hb, "__esModule", { value: !0 }), hb.RdfaParser = void 0;
  const u = /* @__PURE__ */ $se(), r = Bt(), o = Use, a = Vse, t = /* @__PURE__ */ C8(), e = /* @__PURE__ */ lY();
  let n = class fY extends r.Transform {
    constructor(c) {
      super({ readableObjectMode: !0 }), this.activeTagStack = [], c = c || {}, this.options = c, this.util = new e.Util(c.dataFactory, c.baseIRI), this.defaultGraph = c.defaultGraph || this.util.dataFactory.defaultGraph();
      const s = c.contentType ? e.Util.contentTypeToProfile(c.contentType) : c.profile || "";
      this.features = c.features || t.RDFA_FEATURES[s], this.htmlParseListener = c.htmlParseListener, this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null, this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null, this.parser = this.initializeParser(s === "xml"), this.activeTagStack.push({
        incompleteTriples: [],
        inlist: !1,
        language: c.language,
        listMapping: {},
        listMappingLocal: {},
        name: "",
        prefixesAll: Object.assign(Object.assign({}, a["@context"]), this.features.xhtmlInitialContext ? o["@context"] : {}),
        prefixesCustom: {},
        skipElement: !1,
        vocab: c.vocab
      });
    }
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {RDF.Stream} A quad stream.
     */
    import(c) {
      const s = new r.PassThrough({ readableObjectMode: !0 });
      c.on("error", (l) => d.emit("error", l)), c.on("data", (l) => s.push(l)), c.on("end", () => s.push(null));
      const d = s.pipe(new fY(this.options));
      return d;
    }
    _transform(c, s, d) {
      this.parser.write(c.toString()), d();
    }
    _flush(c) {
      this.parser.end(), c();
    }
    onTagOpen(c, s) {
      let d = this.activeTagStack.length - 1;
      for (; d > 0 && this.activeTagStack[d].skipElement; )
        d--;
      let l = this.activeTagStack[d];
      d !== this.activeTagStack.length - 1 && (l = Object.assign(Object.assign({}, l), { language: this.activeTagStack[this.activeTagStack.length - 1].language, prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll, prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom, vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab }));
      const f = {
        collectChildTags: l.collectChildTags,
        incompleteTriples: [],
        inlist: "inlist" in s,
        listMapping: [],
        listMappingLocal: l.listMapping,
        localBaseIRI: l.localBaseIRI,
        name: c,
        prefixesAll: null,
        prefixesCustom: null,
        skipElement: !1
      };
      if (this.activeTagStack.push(f), f.collectChildTags) {
        for (const v of Object.keys(l.prefixesCustom).sort()) {
          const E = l.prefixesCustom[v], R = v === "" ? "xmlns" : "xmlns:" + v;
          R in s || (s[R] = E);
        }
        const T = Object.keys(s).map((v) => `${v}="${s[v]}"`).join(" ");
        if (f.text = [`<${c}${T ? " " + T : ""}>`], this.features.skipHandlingXmlLiteralChildren)
          return;
      }
      let h = !0, p = !0;
      if (this.features.onlyAllowUriRelRevIfProperty && ("property" in s && "rel" in s && (h = !1, s.rel.indexOf(":") < 0 && delete s.rel), "property" in s && "rev" in s && (p = !1, s.rev.indexOf(":") < 0 && delete s.rev)), this.features.copyRdfaPatterns) {
        if (l.collectedPatternTag) {
          const T = {
            attributes: s,
            children: [],
            name: c,
            referenced: !1,
            rootPattern: !1,
            text: []
          };
          l.collectedPatternTag.children.push(T), f.collectedPatternTag = T;
          return;
        }
        if (s.typeof === "rdfa:Pattern") {
          f.collectedPatternTag = {
            attributes: s,
            children: [],
            name: c,
            parentTag: l,
            referenced: !1,
            rootPattern: !0,
            text: []
          };
          return;
        }
        if (s.property === "rdfa:copy") {
          const T = s.resource || s.href || s.src;
          this.rdfaPatterns[T] ? this.emitPatternCopy(l, this.rdfaPatterns[T], T) : (this.pendingRdfaPatternCopies[T] || (this.pendingRdfaPatternCopies[T] = []), this.pendingRdfaPatternCopies[T].push(l));
          return;
        }
      }
      this.features.baseTag && c === "base" && s.href && (this.util.baseIRI = this.util.getBaseIRI(s.href)), this.features.xmlBase && s["xml:base"] && (f.localBaseIRI = this.util.getBaseIRI(s["xml:base"])), this.features.timeTag && c === "time" && !s.datatype && (f.interpretObjectAsTime = !0);
      let b, _, y;
      if ("vocab" in s ? s.vocab ? (f.vocab = s.vocab, this.emitTriple(this.util.getBaseIriTerm(f), this.util.dataFactory.namedNode(e.Util.RDFA + "usesVocabulary"), this.util.dataFactory.namedNode(f.vocab))) : f.vocab = this.activeTagStack[0].vocab : f.vocab = l.vocab, f.prefixesCustom = e.Util.parsePrefixes(s, l.prefixesCustom, this.features.xmlnsPrefixMappings), f.prefixesAll = Object.keys(f.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, l.prefixesAll), f.prefixesCustom) : l.prefixesAll, this.features.roleAttribute && s.role) {
        const T = s.id ? this.util.createIri("#" + s.id, f, !1, !1, !1) : this.util.createBlankNode(), v = f.vocab;
        f.vocab = "http://www.w3.org/1999/xhtml/vocab#";
        for (const E of this.util.createVocabIris(s.role, f, !0, !1))
          this.emitTriple(T, this.util.dataFactory.namedNode("http://www.w3.org/1999/xhtml/vocab#role"), E);
        f.vocab = v;
      }
      "xml:lang" in s || this.features.langAttribute && "lang" in s ? f.language = s["xml:lang"] || s.lang : f.language = l.language;
      const m = this.activeTagStack.length === 2;
      if (!("rel" in s) && !("rev" in s) ? "property" in s && !("content" in s) && !("datatype" in s) ? ("about" in s ? (b = this.util.createIri(s.about, f, !1, !0, !0), f.explicitNewSubject = !!b) : m ? b = !0 : l.object && (b = l.object), "typeof" in s && ("about" in s && (y = this.util.createIri(s.about, f, !1, !0, !0)), !y && m && (y = !0), !y && "resource" in s && (y = this.util.createIri(s.resource, f, !1, !0, !0)), !y && ("href" in s || "src" in s) && (y = this.util.createIri(s.href || s.src, f, !1, !1, !0)), !y && this.isInheritSubjectInHeadBody(c) && (y = b), y || (y = this.util.createBlankNode()), _ = y)) : (("about" in s || "resource" in s) && (b = this.util.createIri(s.about || s.resource, f, !1, !0, !0), f.explicitNewSubject = !!b), !b && ("href" in s || "src" in s) && (b = this.util.createIri(s.href || s.src, f, !1, !1, !0), f.explicitNewSubject = !!b), b || (m ? b = !0 : this.isInheritSubjectInHeadBody(c) ? b = l.object : "typeof" in s ? (b = this.util.createBlankNode(), f.explicitNewSubject = !0) : l.object && (b = l.object, "property" in s || (f.skipElement = !0))), "typeof" in s && (y = b)) : ("about" in s ? (b = this.util.createIri(s.about, f, !1, !0, !0), f.explicitNewSubject = !!b, "typeof" in s && (y = b)) : m ? b = !0 : l.object && (b = l.object), "resource" in s && (_ = this.util.createIri(s.resource, f, !1, !0, !0)), _ || ("href" in s || "src" in s ? _ = this.util.createIri(s.href || s.src, f, !1, !1, !0) : "typeof" in s && !("about" in s) && !this.isInheritSubjectInHeadBody(c) && (_ = this.util.createBlankNode())), "typeof" in s && !("about" in s) && (this.isInheritSubjectInHeadBody(c) ? y = b : y = _)), y)
        for (const T of this.util.createVocabIris(s.typeof, f, !0, !0))
          this.emitTriple(this.util.getResourceOrBaseIri(y, f), this.util.dataFactory.namedNode(e.Util.RDF + "type"), T);
      if (b && (f.listMapping = {}), _) {
        if ("rel" in s && "inlist" in s)
          for (const T of this.util.createVocabIris(s.rel, f, h, !1))
            this.addListMapping(f, b, T, _);
        if (!("rel" in s && "inlist" in s)) {
          if ("rel" in s)
            for (const T of this.util.createVocabIris(s.rel, f, h, !1))
              this.emitTriple(this.util.getResourceOrBaseIri(b, f), T, this.util.getResourceOrBaseIri(_, f));
          if ("rev" in s)
            for (const T of this.util.createVocabIris(s.rev, f, p, !1))
              this.emitTriple(this.util.getResourceOrBaseIri(_, f), T, this.util.getResourceOrBaseIri(b, f));
        }
      }
      if (!_) {
        if ("rel" in s)
          if ("inlist" in s)
            for (const T of this.util.createVocabIris(s.rel, f, h, !1))
              this.addListMapping(f, b, T, null), f.incompleteTriples.push({ predicate: T, reverse: !1, list: !0 });
          else
            for (const T of this.util.createVocabIris(s.rel, f, h, !1))
              f.incompleteTriples.push({ predicate: T, reverse: !1 });
        if ("rev" in s)
          for (const T of this.util.createVocabIris(s.rev, f, p, !1))
            f.incompleteTriples.push({ predicate: T, reverse: !0 });
        f.incompleteTriples.length > 0 && (_ = this.util.createBlankNode());
      }
      if ("property" in s) {
        f.predicates = this.util.createVocabIris(s.property, f, !0, !1);
        let T;
        if ("datatype" in s ? (f.datatype = this.util.createIri(s.datatype, f, !0, !0, !1), f.datatype && (f.datatype.value === e.Util.RDF + "XMLLiteral" || this.features.htmlDatatype && f.datatype.value === e.Util.RDF + "HTML") && (f.collectChildTags = !0)) : (!("rev" in s) && !("rel" in s) && !("content" in s) && ("resource" in s && (T = this.util.createIri(s.resource, f, !1, !0, !0)), !T && "href" in s && (T = this.util.createIri(s.href, f, !1, !1, !0)), !T && "src" in s && (T = this.util.createIri(s.src, f, !1, !1, !0))), "typeof" in s && !("about" in s) && (T = y)), "content" in s) {
          const v = this.util.createLiteral(s.content, f);
          if ("inlist" in s)
            for (const E of f.predicates)
              this.addListMapping(f, b, E, v);
          else {
            const E = this.util.getResourceOrBaseIri(b, f);
            for (const R of f.predicates)
              this.emitTriple(E, R, v);
          }
          f.predicates = null;
        } else if (this.features.datetimeAttribute && "datetime" in s) {
          f.interpretObjectAsTime = !0;
          const v = this.util.createLiteral(s.datetime, f);
          if ("inlist" in s)
            for (const E of f.predicates)
              this.addListMapping(f, b, E, v);
          else {
            const E = this.util.getResourceOrBaseIri(b, f);
            for (const R of f.predicates)
              this.emitTriple(E, R, v);
          }
          f.predicates = null;
        } else if (T) {
          const v = this.util.getResourceOrBaseIri(T, f);
          if ("inlist" in s)
            for (const E of f.predicates)
              this.addListMapping(f, b, E, v);
          else {
            const E = this.util.getResourceOrBaseIri(b, f);
            for (const R of f.predicates)
              this.emitTriple(E, R, v);
          }
          f.predicates = null;
        }
      }
      let g = !1;
      if (!f.skipElement && b && l.incompleteTriples.length > 0) {
        g = !0;
        const T = this.util.getResourceOrBaseIri(l.subject, f), v = this.util.getResourceOrBaseIri(b, f);
        for (const E of l.incompleteTriples)
          if (E.reverse)
            this.emitTriple(v, E.predicate, T);
          else if (E.list) {
            let R = null;
            for (let L = this.activeTagStack.length - 1; L >= 0; L--)
              if (this.activeTagStack[L].inlist) {
                R = this.activeTagStack[L];
                break;
              }
            this.addListMapping(R, b, E.predicate, v);
          } else
            this.emitTriple(T, E.predicate, v);
      }
      !g && l.incompleteTriples.length > 0 && (f.incompleteTriples = f.incompleteTriples.concat(l.incompleteTriples)), f.subject = b || l.subject, f.object = _ || b;
    }
    onText(c) {
      const s = this.activeTagStack[this.activeTagStack.length - 1];
      if (this.features.copyRdfaPatterns && s.collectedPatternTag) {
        s.collectedPatternTag.text.push(c);
        return;
      }
      s.text || (s.text = []), s.text.push(c);
    }
    onTagClose() {
      const c = this.activeTagStack[this.activeTagStack.length - 1], s = this.activeTagStack[this.activeTagStack.length - 2];
      if (!(c.collectChildTags && s.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {
        if (this.features.copyRdfaPatterns && c.collectedPatternTag && c.collectedPatternTag.rootPattern) {
          const d = c.collectedPatternTag.attributes.resource;
          if (delete c.collectedPatternTag.attributes.resource, delete c.collectedPatternTag.attributes.typeof, this.rdfaPatterns[d] = c.collectedPatternTag, this.pendingRdfaPatternCopies[d]) {
            for (const l of this.pendingRdfaPatternCopies[d])
              this.emitPatternCopy(l, c.collectedPatternTag, d);
            delete this.pendingRdfaPatternCopies[d];
          }
          this.activeTagStack.pop();
          return;
        }
        if (c.predicates) {
          const d = this.util.getResourceOrBaseIri(c.subject, c);
          let l = c.text || [];
          c.collectChildTags && s.collectChildTags && (l = l.slice(1));
          const f = this.util.createLiteral(l.join(""), c);
          if (c.inlist)
            for (const h of c.predicates)
              this.addListMapping(c, d, h, f);
          else
            for (const h of c.predicates)
              this.emitTriple(d, h, f);
          s.predicates || (c.text = null);
        }
        if (c.object && Object.keys(c.listMapping).length > 0) {
          const d = this.util.getResourceOrBaseIri(c.object, c);
          for (const l in c.listMapping) {
            const f = this.util.dataFactory.namedNode(l), h = c.listMapping[l];
            if (h.length > 0) {
              const p = h.map(() => this.util.createBlankNode());
              for (let b = 0; b < h.length; b++) {
                const _ = this.util.getResourceOrBaseIri(h[b], c);
                this.emitTriple(p[b], this.util.dataFactory.namedNode(e.Util.RDF + "first"), _), this.emitTriple(p[b], this.util.dataFactory.namedNode(e.Util.RDF + "rest"), b < h.length - 1 ? p[b + 1] : this.util.dataFactory.namedNode(e.Util.RDF + "nil"));
              }
              this.emitTriple(d, f, p[0]);
            } else
              this.emitTriple(d, f, this.util.dataFactory.namedNode(e.Util.RDF + "nil"));
          }
        }
      }
      this.activeTagStack.pop(), c.collectChildTags && c.text && c.text.push(`</${c.name}>`), c.text && s && (s.text ? s.text = s.text.concat(c.text) : s.text = c.text);
    }
    onEnd() {
      if (this.features.copyRdfaPatterns) {
        this.features.copyRdfaPatterns = !1;
        for (const c in this.rdfaPatterns) {
          const s = this.rdfaPatterns[c];
          s.referenced || (s.attributes.typeof = "rdfa:Pattern", s.attributes.resource = c, this.emitPatternCopy(s.parentTag, s, c), s.referenced = !1, delete s.attributes.typeof, delete s.attributes.resource);
        }
        for (const c in this.pendingRdfaPatternCopies)
          for (const s of this.pendingRdfaPatternCopies[c])
            this.activeTagStack.push(s), this.onTagOpen("link", { property: "rdfa:copy", href: c }), this.onTagClose(), this.activeTagStack.pop();
        this.features.copyRdfaPatterns = !0;
      }
    }
    /**
     * If the new subject can be inherited from the parent object
     * if the resource defines no new subject.
     * @param {string} name The current tag name.
     * @returns {boolean} If the subject can be inherited.
     */
    isInheritSubjectInHeadBody(c) {
      return this.features.inheritSubjectInHeadBody && (c === "head" || c === "body");
    }
    /**
     * Add a list mapping for the given predicate and object in the active tag.
     * @param {IActiveTag} activeTag The active tag.
     * @param {Term | boolean} subject A subject term, this will only be used to create a separate list
     *                                 if activeTag.explicitNewSubject is true.
     * @param {Term} predicate A predicate term.
     * @param {Term | boolean} currentObjectResource The current object resource.
     */
    addListMapping(c, s, d, l) {
      if (c.explicitNewSubject) {
        const f = this.util.createBlankNode();
        this.emitTriple(this.util.getResourceOrBaseIri(s, c), d, f), this.emitTriple(f, this.util.dataFactory.namedNode(e.Util.RDF + "first"), this.util.getResourceOrBaseIri(l, c)), this.emitTriple(f, this.util.dataFactory.namedNode(e.Util.RDF + "rest"), this.util.dataFactory.namedNode(e.Util.RDF + "nil"));
      } else {
        let f = c.listMappingLocal[d.value];
        f || (c.listMappingLocal[d.value] = f = []), l && f.push(l);
      }
    }
    /**
     * Emit the given triple to the stream.
     * @param {Term} subject A subject term.
     * @param {Term} predicate A predicate term.
     * @param {Term} object An object term.
     */
    emitTriple(c, s, d) {
      c.termType === "NamedNode" && c.value.indexOf(":") < 0 || s.termType === "NamedNode" && s.value.indexOf(":") < 0 || d.termType === "NamedNode" && d.value.indexOf(":") < 0 || this.push(this.util.dataFactory.quad(c, s, d, this.defaultGraph));
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     * @param {IActiveTag} parentTag The parent tag to instantiate in.
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {string} rootPatternId The pattern id.
     */
    emitPatternCopy(c, s, d) {
      if (this.activeTagStack.push(c), s.referenced = !0, !s.constructedBlankNodes)
        s.constructedBlankNodes = [], this.util.blankNodeFactory = () => {
          const l = this.util.dataFactory.blankNode();
          return s.constructedBlankNodes.push(l), l;
        };
      else {
        let l = 0;
        this.util.blankNodeFactory = () => s.constructedBlankNodes[l++];
      }
      this.emitPatternCopyAbsolute(s, !0, d), this.util.blankNodeFactory = null, this.activeTagStack.pop();
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     *
     * This should probably not be called directly,
     * call {@link emitPatternCopy} instead.
     *
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {boolean} root If this is the root call for the given pattern.
     * @param {string} rootPatternId The pattern id.
     */
    emitPatternCopyAbsolute(c, s, d) {
      if (!(!s && c.attributes.property === "rdfa:copy" && c.attributes.href === d)) {
        this.onTagOpen(c.name, c.attributes);
        for (const l of c.text)
          this.onText(l);
        for (const l of c.children)
          this.emitPatternCopyAbsolute(l, !1, d);
        this.onTagClose();
      }
    }
    initializeParser(c) {
      return new u.Parser({
        onclosetag: () => {
          try {
            this.onTagClose(), this.htmlParseListener && this.htmlParseListener.onTagClose();
          } catch (s) {
            this.emit("error", s);
          }
        },
        onend: () => {
          try {
            this.onEnd(), this.htmlParseListener && this.htmlParseListener.onEnd();
          } catch (s) {
            this.emit("error", s);
          }
        },
        onopentag: (s, d) => {
          try {
            this.onTagOpen(s, d), this.htmlParseListener && this.htmlParseListener.onTagOpen(s, d);
          } catch (l) {
            this.emit("error", l);
          }
        },
        ontext: (s) => {
          try {
            this.onText(s), this.htmlParseListener && this.htmlParseListener.onText(s);
          } catch (d) {
            this.emit("error", d);
          }
        }
      }, {
        decodeEntities: !0,
        recognizeSelfClosing: !0,
        xmlMode: c
      });
    }
  };
  return hb.RdfaParser = n, hb;
}
var tL;
function hY() {
  return tL || (tL = 1, function(u) {
    var r = ss && ss.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ss && ss.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ese(), u), o(/* @__PURE__ */ Ose(), u), o(/* @__PURE__ */ xse(), u), o(/* @__PURE__ */ Qse(), u), o(/* @__PURE__ */ C8(), u), o(/* @__PURE__ */ lY(), u);
  }(ss)), ss;
}
var rL;
function Hse() {
  if (rL) return fb;
  rL = 1, Object.defineProperty(fb, "__esModule", { value: !0 }), fb.ActorRdfParseXmlRdfa = void 0;
  const u = /* @__PURE__ */ yh(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ hY();
  let a = class extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/xml": 1.0,
     *       "text/xml": 1.0,
     *       "image/svg+xml": 1.0
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/xml": "http://www.w3.org/ns/formats/RDFa",
     *       "text/xml": "http://www.w3.org/ns/formats/RDFa",
     *       "image/svg+xml": "http://www.w3.org/ns/formats/RDFa"
     *     }} mediaTypeFormats
     */
    constructor(e) {
      super(e);
    }
    async runHandle(e, n, i) {
      var l;
      const c = e.context.getSafe(r.KeysInitQuery.dataFactory), s = (e.headers && e.headers.get("content-language")) ?? void 0;
      e.data.on("error", (f) => d.emit("error", f));
      const d = e.data.pipe(new o.RdfaParser({
        dataFactory: c,
        baseIRI: (l = e.metadata) == null ? void 0 : l.baseIRI,
        profile: "xml",
        language: s
      }));
      return { data: d, metadata: { triples: !0 } };
    }
  };
  return fb.ActorRdfParseXmlRdfa = a, fb;
}
var nL;
function Gse() {
  return nL || (nL = 1, function(u) {
    var r = os && os.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = os && os.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Hse(), u);
  }(os)), os;
}
var hs = {}, bb = {}, T0 = {}, yb = {}, iL;
function pY() {
  if (iL) return yb;
  iL = 1, Object.defineProperty(yb, "__esModule", { value: !0 }), yb.promisifyEventEmitter = void 0;
  function u(r, o) {
    return new Promise((a, t) => {
      r.on("end", () => a(o)), r.on("error", t);
    });
  }
  return yb.promisifyEventEmitter = u, yb;
}
var aL;
function gh() {
  if (aL) return T0;
  aL = 1;
  var u = T0 && T0.__awaiter || function(a, t, e, n) {
    function i(c) {
      return c instanceof e ? c : new e(function(s) {
        s(c);
      });
    }
    return new (e || (e = Promise))(function(c, s) {
      function d(h) {
        try {
          f(n.next(h));
        } catch (p) {
          s(p);
        }
      }
      function l(h) {
        try {
          f(n.throw(h));
        } catch (p) {
          s(p);
        }
      }
      function f(h) {
        h.done ? c(h.value) : i(h.value).then(d, l);
      }
      f((n = n.apply(a, t || [])).next());
    });
  };
  Object.defineProperty(T0, "__esModule", { value: !0 }), T0.stringify = o;
  const r = pY();
  function o(a) {
    return u(this, void 0, void 0, function* () {
      let t = "";
      return a.on("data", (e) => {
        t += e;
      }), yield (0, r.promisifyEventEmitter)(a), t;
    });
  }
  return T0;
}
var T6 = {}, jE, uL;
function zse() {
  if (uL) return jE;
  uL = 1;
  var u = function() {
    var r = function(bt, Ge, Je, rt) {
      for (Je = Je || {}, rt = bt.length; rt--; Je[bt[rt]] = Ge) ;
      return Je;
    }, o = [7, 12, 13, 14, 15, 16, 20, 25, 115, 130], a = [7, 13, 16, 20, 25, 115, 130], t = [7, 13, 16, 115, 130], e = [1, 25], n = [1, 29], i = [1, 27], c = [1, 28], s = [13, 16, 115, 130], d = [13, 16, 28, 38, 40, 42, 44, 46, 48, 53, 56, 61, 67, 85, 87, 92, 93, 95, 96, 102, 110, 111, 115, 119, 120, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136], l = [28, 56], f = [1, 42], h = [46, 48, 53, 56], p = [1, 54], b = [1, 60], _ = [1, 56], y = [1, 57], m = [1, 58], g = [1, 63], T = [1, 64], v = [1, 65], E = [1, 66], R = [1, 67], L = [1, 68], A = [1, 75], w = [28, 46, 48, 53, 56], S = [28, 42, 46, 48, 53, 56], O = [13, 16, 28, 38, 40, 42, 44, 46, 48, 53, 56, 92, 115, 119, 120, 130, 131, 132, 133, 134, 135, 136], x = [13, 16, 28, 38, 40, 42, 44, 46, 48, 53, 56, 67, 85, 87, 92, 95, 96, 115, 119, 120, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136], F = [13, 16, 38, 40, 44, 92, 115, 119, 120, 130, 131, 132, 133, 134, 135, 136], j = [13, 16, 28, 38, 40, 42, 44, 46, 48, 53, 56, 67, 85, 87, 92, 95, 96, 115, 117, 118, 119, 120, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136], q = [13, 16, 28, 56, 115, 130], Q = [13, 16, 38, 58, 87, 96, 109, 115, 126, 130], G = [1, 116], K = [1, 112], U = [1, 108], ae = [1, 114], ye = [1, 111], pe = [7, 13, 16, 20, 25, 44, 48, 53, 56, 67, 85, 87, 95, 96, 115, 128, 129, 130], ee = [48, 53], Te = [48, 53, 87, 96, 126], we = [13, 16, 44, 48, 53, 56, 85, 87, 95, 96, 115, 128, 129, 130], Oe = [1, 126], be = [13, 16, 40, 44, 48, 53, 56, 85, 87, 95, 96, 115, 128, 129, 130], he = [1, 129], V = [48, 53, 67, 87, 96, 126], N = [13, 16, 40, 44, 48, 53, 56, 67, 85, 87, 95, 96, 115, 128, 129, 130], M = [1, 133], I = [13, 16, 40, 44, 48, 53, 56, 67, 85, 87, 95, 96, 102, 115, 128, 129, 130], P = [13, 16, 40, 44, 48, 53, 56, 67, 85, 87, 93, 95, 96, 102, 110, 111, 115, 128, 129, 130], B = [1, 151], z = [1, 153], H = [1, 156], J = [1, 157], k = [1, 158], W = [1, 167], le = [1, 175], fe = [13, 16, 44, 48, 53, 56, 67, 85, 87, 95, 96, 115, 128, 129, 130], me = [13, 16, 44, 48, 53, 56, 67, 85, 87, 95, 96, 115, 126, 128, 129, 130], Ne = [13, 16, 46, 92, 115, 119, 120, 130, 131, 132, 133, 134, 135, 136], xe = {
      trace: function() {
      },
      yy: {},
      symbols_: { error: 2, shaclDoc: 3, shaclDoc_repetition0: 4, shaclDoc_repetition1: 5, ttlSection: 6, EOF: 7, directive: 8, baseDecl: 9, importsDecl: 10, prefixDecl: 11, KW_BASE: 12, IRIREF: 13, KW_IMPORTS: 14, KW_PREFIX: 15, PNAME_NS: 16, nodeShapeIri: 17, iri: 18, nodeShape: 19, KW_SHAPE: 20, nodeShape_option0: 21, nodeShape_option1: 22, nodeShapeBody: 23, shapeClass: 24, KW_SHAPE_CLASS: 25, shapeClass_option0: 26, turtleAnnotation: 27, ";": 28, turtleAnnotation2: 29, predicate: 30, turtleAnnotation2_option0: 31, objectList: 32, object: 33, objectList_repetition0: 34, iriOrLiteral: 35, blankNodeSection: 36, list: 37, "(": 38, list_repetition0: 39, ")": 40, objectTail: 41, ",": 42, LB: 43, "[": 44, RB: 45, "]": 46, LP: 47, "%": 48, RP: 49, pcSection: 50, iriHead: 51, ttlStatement: 52, ".": 53, ttlSection_repetition0: 54, startNodeShape: 55, "{": 56, endNodeShape: 57, "}": 58, nodeShapeBody_repetition0: 59, targetClass: 60, "->": 61, targetClass_repetition_plus0: 62, constraint: 63, constraint_group0: 64, constraint_option0: 65, orNotComponent: 66, "|": 67, nodeNot: 68, nodeOrEmit: 69, nodeOr: 70, nodeOr_repetition_plus0: 71, nodeValue: 72, negation: 73, nodeValue_group0: 74, "=": 75, iriOrLiteralOrArray: 76, propertyShape: 77, path: 78, propertyShape_repetition0: 79, propertyOrComponent: 80, propertyNot: 81, propertyOr: 82, propertyOr_repetition_plus0: 83, propertyAtom: 84, NODEKIND: 85, shapeRef: 86, PARAM: 87, propertyCount: 88, propertyMinCount: 89, "..": 90, propertyMaxCount: 91, INTEGER: 92, "*": 93, shapeRef_group0: 94, "@": 95, "!": 96, pathAlternative: 97, additionalAlternative: 98, pathSequence: 99, pathAlternative_repetition_plus0: 100, additionalSequence: 101, "/": 102, pathEltOrInverse: 103, pathSequence_repetition_plus0: 104, pathElt: 105, pathPrimary: 106, pathMod: 107, pathInverse: 108, "^": 109, "?": 110, "+": 111, iriOrLiteralOrArray_repetition0: 112, literal: 113, iri_group0: 114, a: 115, string: 116, LANGTAG: 117, "^^": 118, DECIMAL: 119, DOUBLE: 120, literal_group0: 121, string_group0: 122, string_group1: 123, shaclDoc_repetition1_group0: 124, constraint_group0_repetition_plus0: 125, TARGET: 126, propertyShape_repetition0_group0: 127, ATPNAME_LN: 128, ATPNAME_NS: 129, PNAME_LN: 130, KW_TRUE: 131, KW_FALSE: 132, STRING_LITERAL1: 133, STRING_LITERAL2: 134, STRING_LITERAL_LONG1: 135, STRING_LITERAL_LONG2: 136, $accept: 0, $end: 1 },
      terminals_: { 2: "error", 7: "EOF", 12: "KW_BASE", 13: "IRIREF", 14: "KW_IMPORTS", 15: "KW_PREFIX", 16: "PNAME_NS", 20: "KW_SHAPE", 25: "KW_SHAPE_CLASS", 28: ";", 38: "(", 40: ")", 42: ",", 44: "[", 46: "]", 48: "%", 53: ".", 56: "{", 58: "}", 61: "->", 67: "|", 75: "=", 85: "NODEKIND", 87: "PARAM", 90: "..", 92: "INTEGER", 93: "*", 95: "@", 96: "!", 102: "/", 109: "^", 110: "?", 111: "+", 115: "a", 117: "LANGTAG", 118: "^^", 119: "DECIMAL", 120: "DOUBLE", 126: "TARGET", 128: "ATPNAME_LN", 129: "ATPNAME_NS", 130: "PNAME_LN", 131: "KW_TRUE", 132: "KW_FALSE", 133: "STRING_LITERAL1", 134: "STRING_LITERAL2", 135: "STRING_LITERAL_LONG1", 136: "STRING_LITERAL_LONG2" },
      productions_: [0, [3, 4], [8, 1], [8, 1], [8, 1], [9, 2], [10, 2], [11, 3], [17, 1], [19, 5], [24, 4], [27, 2], [29, 2], [30, 2], [32, 2], [33, 1], [33, 1], [33, 1], [37, 3], [41, 2], [43, 1], [45, 1], [36, 3], [47, 1], [49, 1], [50, 3], [51, 1], [52, 3], [6, 1], [55, 1], [57, 1], [23, 3], [60, 2], [63, 3], [66, 2], [69, 1], [70, 1], [70, 2], [68, 1], [68, 2], [72, 3], [77, 2], [80, 2], [82, 1], [82, 2], [81, 1], [81, 2], [84, 1], [84, 1], [84, 1], [84, 3], [84, 1], [88, 5], [89, 1], [91, 1], [91, 1], [86, 1], [86, 2], [73, 1], [78, 1], [98, 2], [97, 1], [97, 2], [101, 2], [99, 1], [99, 2], [105, 1], [105, 2], [103, 1], [103, 2], [108, 1], [107, 1], [107, 1], [107, 1], [106, 1], [106, 3], [76, 1], [76, 3], [35, 1], [35, 1], [18, 1], [18, 1], [18, 1], [113, 1], [113, 2], [113, 3], [113, 1], [113, 1], [113, 1], [113, 1], [116, 1], [116, 1], [4, 0], [4, 2], [124, 1], [124, 1], [5, 0], [5, 2], [21, 0], [21, 1], [22, 0], [22, 1], [26, 0], [26, 1], [31, 0], [31, 1], [34, 0], [34, 2], [39, 0], [39, 2], [54, 0], [54, 2], [59, 0], [59, 2], [62, 1], [62, 2], [125, 1], [125, 2], [64, 1], [64, 1], [65, 0], [65, 1], [71, 1], [71, 2], [74, 1], [74, 1], [127, 1], [127, 1], [79, 0], [79, 2], [83, 1], [83, 2], [94, 1], [94, 1], [100, 1], [100, 2], [104, 1], [104, 2], [112, 0], [112, 2], [114, 1], [114, 1], [121, 1], [121, 1], [122, 1], [122, 1], [123, 1], [123, 1]],
      performAction: function(Ge, Je, rt, Et, ot, Xe, Ur) {
        var ze = Xe.length - 1;
        switch (ot) {
          case 1:
            this.$ = ie(Qe.factory.namedNode(Ue("")), Qe.factory.namedNode($), Qe.factory.namedNode(Ke + "Ontology"));
            break;
          case 5:
            Qe.base = Qe.factory.namedNode(Xe[ze].slice(1, -1)), Qe.n3Parser._setBase(Ue(Qe.base.value));
            break;
          case 6:
            this.$ = ie(Qe.base, Qe.factory.namedNode(Ke + "imports"), Qe.factory.namedNode(Xe[ze].slice(1, -1)));
            break;
          case 7:
            this.$ = Qe.prefixes[Xe[ze - 1].substr(0, Xe[ze - 1].length - 1)] = Ue(Xe[ze]);
            break;
          case 8:
            Qe.nodeShapeStack = !1, ie(Qe.currentNodeShape = Xe[ze], Qe.factory.namedNode($), Qe.factory.namedNode(qe + "NodeShape"));
            break;
          case 10:
            this.$ = ie(Qe.currentNodeShape, Qe.factory.namedNode($), Qe.factory.namedNode(Y + "Class"));
            break;
          case 11:
            this.$ = He();
            break;
          case 13:
            this.$ = Xe[ze].forEach((Se) => ie(Qe.currentNodeShape, Xe[ze - 1], Se));
            break;
          case 14:
            this.$ = [Xe[ze - 1], ...Xe[ze]];
            break;
          case 18:
            this.$ = Ie(Xe[ze - 1], !0);
            break;
          case 19:
          case 34:
          case 42:
          case 60:
          case 63:
            this.$ = Xe[ze];
            break;
          case 20:
            Qe.tempCurrentNodeShape = Qe.currentNodeShape, this.$ = Qe.currentNodeShape = Ye();
            break;
          case 21:
            Qe.currentNodeShape = Qe.tempCurrentNodeShape;
            break;
          case 22:
          case 31:
            this.$ = Xe[ze - 2];
            break;
          case 23:
            Qe.tempCurrentNodeShape = Qe.currentNodeShape, Qe.currentNodeShape = Qe.currentPropertyNode;
            break;
          case 24:
            Qe.currentNodeShape = Qe.tempCurrentNodeShape;
            break;
          case 26:
            Qe.currentNodeShape = Xe[ze];
            break;
          case 29:
            Qe.nodeShapeStack ? (Qe.nodeShapeStack.push(Qe.currentNodeShape), ie(
              // In the grammar a path signals the start of a new property declaration
              Qe.currentPropertyNode,
              Qe.factory.namedNode(qe + "node"),
              Qe.currentNodeShape = Ye()
            )) : Qe.nodeShapeStack = [], this.$ = Qe.currentNodeShape;
            break;
          case 30:
            Qe.nodeShapeStack.length > 0 && (Qe.currentNodeShape = Qe.nodeShapeStack.pop());
            break;
          case 32:
            this.$ = Xe[ze].forEach((Se) => {
              ie(Qe.currentNodeShape, Qe.factory.namedNode(qe + "targetClass"), Se);
            });
            break;
          case 35:
            this.$ = ie(Qe.currentNodeShape, Qe.factory.namedNode(qe + Xe[ze][0]), Xe[ze][1]);
            break;
          case 36:
            break;
          case 37:
            const se = Ie([Xe[ze - 1], ...Xe[ze]].map((Se) => {
              const Ze = Ye();
              return ie(Ze, Qe.factory.namedNode(qe + Se[0]), Se[1]), Ze;
            }));
            this.$ = ["or", se];
            break;
          case 39:
          case 46:
            this.$ = $e("not", ...Xe[ze]);
            break;
          case 40:
          case 50:
            this.$ = [Xe[ze - 2], Xe[ze]];
            break;
          case 43:
            this.$ = Xe[ze] && je(...Xe[ze]);
            break;
          case 44:
            this.$ = je(
              "or",
              Ie([Xe[ze - 1], ...Xe[ze]].map((Se) => {
                const Ze = Ye();
                return ie(Ze, Qe.factory.namedNode(qe + Se[0]), Se[1]), Ze;
              }))
            );
            break;
          case 47:
            this.$ = [Ee[Xe[ze].value] ? "datatype" : "class", Xe[ze]];
            break;
          case 48:
            this.$ = ["nodeKind", Qe.factory.namedNode(qe + Xe[ze])];
            break;
          case 49:
            this.$ = ["node", Qe.factory.namedNode(Xe[ze])];
            break;
          case 51:
            this.$ = void 0;
            break;
          case 53:
            this.$ = Xe[ze] > 0 && je("minCount", tt(Xe[ze], de));
            break;
          case 54:
            this.$ = je("maxCount", tt(Xe[ze], de));
            break;
          case 56:
            this.$ = Le(Xe[ze].slice(1));
            break;
          case 57:
            this.$ = Ue(Xe[ze]);
            break;
          case 59:
            ie(
              // In the grammar a path signals the start of a new property declaration
              Qe.currentNodeShape,
              Qe.factory.namedNode(qe + "property"),
              Qe.currentPropertyNode = Ye()
            ), je("path", Xe[ze]);
            break;
          case 62:
            const ge = Ye();
            ie(
              ge,
              Qe.factory.namedNode(qe + "alternativePath"),
              Ie([Xe[ze - 1], ...Xe[ze]])
            ), this.$ = ge;
            break;
          case 65:
            this.$ = Ie([Xe[ze - 1], ...Xe[ze]]);
            break;
          case 67:
            ie(this.$ = Ye(), Qe.factory.namedNode(qe + Xe[ze]), Xe[ze - 1]);
            break;
          case 69:
            ie(this.$ = Ye(), Qe.factory.namedNode(qe + "inversePath"), Xe[ze]);
            break;
          case 71:
            this.$ = "zeroOrOnePath";
            break;
          case 72:
            this.$ = "zeroOrMorePath";
            break;
          case 73:
            this.$ = "oneOrMorePath";
            break;
          case 75:
            this.$ = Xe[ze - 1];
            break;
          case 77:
            this.$ = Ie(Xe[ze - 1]);
            break;
          case 80:
            this.$ = Qe.factory.namedNode(Ue(Xe[ze]));
            break;
          case 81:
            this.$ = Qe.factory.namedNode(Le(Xe[ze]));
            break;
          case 82:
            this.$ = He(Qe.factory.namedNode($));
            break;
          case 83:
            this.$ = tt(Xe[ze]);
            break;
          case 84:
            this.$ = it(Xe[ze - 1], Xe[ze].substr(1).toLowerCase());
            break;
          case 85:
            this.$ = tt(Xe[ze - 2], Xe[ze]);
            break;
          case 86:
            this.$ = tt(Xe[ze], de);
            break;
          case 87:
            this.$ = tt(Xe[ze], oe);
            break;
          case 88:
            this.$ = tt(Xe[ze].toLowerCase(), De);
            break;
          case 89:
            this.$ = tt(Xe[ze].toLowerCase(), Ve);
            break;
          case 90:
            this.$ = ne(Xe[ze], 1);
            break;
          case 91:
            this.$ = ne(Xe[ze], 3);
            break;
          case 92:
          case 96:
          case 106:
          case 108:
          case 110:
          case 112:
          case 128:
          case 138:
            this.$ = [];
            break;
          case 93:
          case 97:
          case 107:
          case 109:
          case 111:
          case 113:
          case 115:
          case 117:
          case 123:
          case 129:
          case 131:
          case 135:
          case 137:
          case 139:
            Xe[ze - 1].push(Xe[ze]);
            break;
          case 114:
          case 116:
          case 122:
          case 130:
          case 134:
          case 136:
            this.$ = [Xe[ze]];
            break;
        }
      },
      table: [r(o, [2, 92], { 3: 1, 4: 2 }), { 1: [3] }, r(a, [2, 96], { 5: 3, 8: 4, 9: 5, 10: 6, 11: 7, 12: [1, 8], 14: [1, 9], 15: [1, 10] }), r(t, [2, 110], { 6: 11, 124: 12, 54: 13, 19: 14, 24: 15, 20: [1, 16], 25: [1, 17] }), r(o, [2, 93]), r(o, [2, 2]), r(o, [2, 3]), r(o, [2, 4]), { 13: [1, 18] }, { 13: [1, 19] }, { 16: [1, 20] }, { 7: [1, 21] }, r(a, [2, 97]), { 7: [2, 28], 13: e, 16: n, 18: 24, 51: 23, 52: 22, 114: 26, 115: i, 130: c }, r(a, [2, 94]), r(a, [2, 95]), { 13: e, 16: n, 17: 30, 18: 31, 114: 26, 115: i, 130: c }, { 13: e, 16: n, 17: 32, 18: 31, 114: 26, 115: i, 130: c }, r(o, [2, 5]), r(o, [2, 6]), { 13: [1, 33] }, { 1: [2, 1] }, r(t, [2, 111]), { 13: e, 16: n, 18: 36, 29: 34, 30: 35, 114: 26, 115: i, 130: c }, r(s, [2, 26]), r(d, [2, 80]), r(d, [2, 81]), r(d, [2, 82]), r(d, [2, 140]), r(d, [2, 141]), r(l, [2, 98], { 21: 37, 60: 38, 61: [1, 39] }), r([28, 56, 61], [2, 8]), { 26: 40, 27: 41, 28: f, 56: [2, 102] }, r(o, [2, 7]), { 53: [1, 43] }, r(h, [2, 104], { 31: 44, 27: 45, 28: f }), { 13: e, 16: n, 18: 51, 32: 46, 33: 47, 35: 48, 36: 49, 37: 50, 38: p, 43: 53, 44: b, 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, { 22: 69, 27: 70, 28: f, 56: [2, 100] }, r(l, [2, 99]), { 13: e, 16: n, 18: 72, 62: 71, 114: 26, 115: i, 130: c }, { 23: 73, 55: 74, 56: A }, { 56: [2, 103] }, { 13: e, 16: n, 18: 36, 29: 76, 30: 35, 114: 26, 115: i, 130: c }, r(t, [2, 27]), r(h, [2, 12]), r(h, [2, 105]), r(w, [2, 13]), r(S, [2, 106], { 34: 77 }), r(O, [2, 15]), r(O, [2, 16]), r(O, [2, 17]), r(x, [2, 78]), r(x, [2, 79]), { 13: e, 16: n, 18: 36, 29: 78, 30: 35, 114: 26, 115: i, 130: c }, r(F, [2, 108], { 39: 79 }), r(x, [2, 83], { 117: [1, 80], 118: [1, 81] }), r(x, [2, 86]), r(x, [2, 87]), r(x, [2, 88]), r(x, [2, 89]), r(s, [2, 20]), r(j, [2, 90]), r(j, [2, 91]), r(x, [2, 142]), r(x, [2, 143]), r(j, [2, 144]), r(j, [2, 145]), r(j, [2, 146]), r(j, [2, 147]), { 23: 82, 55: 74, 56: A }, { 56: [2, 101] }, r(l, [2, 32], { 114: 26, 18: 83, 13: e, 16: n, 115: i, 130: c }), r(q, [2, 114]), r(a, [2, 10]), r(Q, [2, 112], { 59: 84 }), r(Q, [2, 29]), r(h, [2, 11]), r(w, [2, 14], { 41: 85, 42: [1, 86] }), { 45: 87, 46: [1, 88] }, { 13: e, 16: n, 18: 51, 33: 90, 35: 48, 36: 49, 37: 50, 38: p, 40: [1, 89], 43: 53, 44: b, 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, r(x, [2, 84]), { 13: e, 16: n, 18: 91, 114: 26, 115: i, 130: c }, r(a, [2, 9]), r(q, [2, 115]), { 13: e, 16: n, 18: 115, 38: G, 57: 92, 58: [1, 94], 63: 93, 64: 95, 68: 102, 69: 98, 70: 100, 72: 104, 73: 105, 74: 107, 77: 97, 78: 99, 87: K, 96: U, 97: 101, 99: 103, 103: 106, 105: 109, 106: 113, 108: 110, 109: ae, 114: 26, 115: i, 125: 96, 126: ye, 130: c }, r(S, [2, 107]), { 13: e, 16: n, 18: 51, 33: 117, 35: 48, 36: 49, 37: 50, 38: p, 43: 53, 44: b, 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, r(O, [2, 22]), r(O, [2, 21]), r(O, [2, 18]), r(F, [2, 109]), r(x, [2, 85]), r(pe, [2, 31]), r(Q, [2, 113]), r(pe, [2, 30]), { 47: 120, 48: [1, 121], 50: 119, 53: [2, 120], 65: 118 }, r(ee, [2, 118], { 70: 100, 68: 102, 72: 104, 73: 105, 74: 107, 69: 122, 87: K, 96: U, 126: ye }), r(ee, [2, 119]), r(Te, [2, 116]), r(we, [2, 128], { 79: 123 }), r(Te, [2, 35]), r(we, [2, 59]), r(Te, [2, 36], { 71: 124, 66: 125, 67: Oe }), r(be, [2, 61], { 100: 127, 98: 128, 67: he }), r(V, [2, 38]), { 72: 130, 74: 107, 87: K, 126: ye }, r(N, [2, 64], { 104: 131, 101: 132, 102: M }), { 75: [1, 134] }, r([13, 16, 56, 85, 87, 95, 115, 126, 128, 129, 130], [2, 58]), r(I, [2, 68]), { 13: e, 16: n, 18: 115, 38: G, 105: 135, 106: 113, 114: 26, 115: i, 130: c }, { 75: [2, 124] }, { 75: [2, 125] }, r(I, [2, 66], { 107: 136, 93: [1, 138], 110: [1, 137], 111: [1, 139] }), r([13, 16, 38, 115, 130], [2, 70]), r(P, [2, 74]), { 13: e, 16: n, 18: 115, 38: G, 97: 140, 99: 103, 103: 106, 105: 109, 106: 113, 108: 110, 109: ae, 114: 26, 115: i, 130: c }, r(S, [2, 19]), { 53: [1, 141] }, { 53: [2, 121] }, { 13: e, 16: n, 18: 36, 29: 142, 30: 35, 114: 26, 115: i, 130: c }, r(s, [2, 23]), r(Te, [2, 117]), r(ee, [2, 41], { 114: 26, 55: 74, 127: 143, 88: 144, 82: 145, 81: 147, 84: 148, 73: 149, 18: 150, 86: 152, 23: 154, 94: 155, 13: e, 16: n, 44: [1, 146], 56: A, 85: B, 87: z, 95: H, 96: U, 115: i, 128: J, 129: k, 130: c }), r(Te, [2, 37], { 66: 159, 67: Oe }), r(V, [2, 122]), { 68: 160, 72: 104, 73: 105, 74: 107, 87: K, 96: U, 126: ye }, r(be, [2, 62], { 98: 161, 67: he }), r(N, [2, 134]), { 13: e, 16: n, 18: 115, 38: G, 99: 162, 103: 106, 105: 109, 106: 113, 108: 110, 109: ae, 114: 26, 115: i, 130: c }, r(V, [2, 39]), r(N, [2, 65], { 101: 163, 102: M }), r(I, [2, 136]), { 13: e, 16: n, 18: 115, 38: G, 103: 164, 105: 109, 106: 113, 108: 110, 109: ae, 114: 26, 115: i, 130: c }, { 13: e, 16: n, 18: 51, 35: 166, 44: W, 76: 165, 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, r(I, [2, 69]), r(I, [2, 67]), r(I, [2, 71]), r(I, [2, 72]), r(I, [2, 73]), { 40: [1, 168] }, r(Q, [2, 33]), { 48: [1, 170], 49: 169 }, r(we, [2, 129]), r(we, [2, 126]), r(we, [2, 127]), { 89: 171, 92: [1, 172] }, r(we, [2, 43], { 83: 173, 80: 174, 67: le }), r(fe, [2, 45]), { 13: e, 16: n, 18: 150, 23: 154, 55: 74, 56: A, 84: 176, 85: B, 86: 152, 87: z, 94: 155, 95: H, 114: 26, 115: i, 128: J, 129: k, 130: c }, r(fe, [2, 47]), r(fe, [2, 48]), r(fe, [2, 49]), { 75: [1, 177] }, r(fe, [2, 51]), r(fe, [2, 56]), { 13: [1, 178] }, r(fe, [2, 132]), r(fe, [2, 133]), r(V, [2, 123]), r(V, [2, 34]), r(N, [2, 135]), r(N, [2, 60]), r(I, [2, 137]), r(I, [2, 63]), r(V, [2, 40]), r(me, [2, 76]), r(Ne, [2, 138], { 112: 179 }), r(P, [2, 75]), { 53: [2, 25] }, { 53: [2, 24] }, { 90: [1, 180] }, { 90: [2, 53] }, r(we, [2, 44], { 80: 181, 67: le }), r(fe, [2, 130]), { 13: e, 16: n, 18: 150, 23: 154, 55: 74, 56: A, 73: 149, 81: 182, 84: 148, 85: B, 86: 152, 87: z, 94: 155, 95: H, 96: U, 114: 26, 115: i, 128: J, 129: k, 130: c }, r(fe, [2, 46]), { 13: e, 16: n, 18: 51, 35: 166, 44: W, 76: 183, 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, r(fe, [2, 57]), { 13: e, 16: n, 18: 51, 35: 185, 46: [1, 184], 92: _, 113: 52, 114: 26, 115: i, 116: 55, 119: y, 120: m, 121: 59, 122: 61, 123: 62, 130: c, 131: g, 132: T, 133: v, 134: E, 135: R, 136: L }, { 91: 186, 92: [1, 187], 93: [1, 188] }, r(fe, [2, 131]), r(fe, [2, 42]), r(fe, [2, 50]), r(me, [2, 77]), r(Ne, [2, 139]), { 46: [1, 189] }, { 46: [2, 54] }, { 46: [2, 55] }, r(we, [2, 52])],
      defaultActions: { 21: [2, 1], 41: [2, 103], 70: [2, 101], 111: [2, 124], 112: [2, 125], 119: [2, 121], 169: [2, 25], 170: [2, 24], 172: [2, 53], 187: [2, 54], 188: [2, 55] },
      parseError: function(Ge, Je) {
        if (Je.recoverable)
          this.trace(Ge);
        else {
          var rt = new Error(Ge);
          throw rt.hash = Je, rt;
        }
      },
      parse: function(Ge) {
        var Je = this, rt = [0], Et = [null], ot = [], Xe = this.table, Ur = "", ze = 0, se = 0, ge = 2, Se = 1, Ze = ot.slice.call(arguments, 1), et = Object.create(this.lexer), Tt = { yy: {} };
        for (var ar in this.yy)
          Object.prototype.hasOwnProperty.call(this.yy, ar) && (Tt.yy[ar] = this.yy[ar]);
        et.setInput(Ge, Tt.yy), Tt.yy.lexer = et, Tt.yy.parser = this, typeof et.yylloc > "u" && (et.yylloc = {});
        var kt = et.yylloc;
        ot.push(kt);
        var Ui = et.options && et.options.ranges;
        typeof Tt.yy.parseError == "function" ? this.parseError = Tt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
        for (var yn = function() {
          var dn;
          return dn = et.lex() || Se, typeof dn != "number" && (dn = Je.symbols_[dn] || dn), dn;
        }, Kt, Fn, Fr, Xn, Nr = {}, cu, Vr, u0, du; ; ) {
          if (Fn = rt[rt.length - 1], this.defaultActions[Fn] ? Fr = this.defaultActions[Fn] : ((Kt === null || typeof Kt > "u") && (Kt = yn()), Fr = Xe[Fn] && Xe[Fn][Kt]), typeof Fr > "u" || !Fr.length || !Fr[0]) {
            var _n = "";
            du = [];
            for (cu in Xe[Fn])
              this.terminals_[cu] && cu > ge && du.push("'" + this.terminals_[cu] + "'");
            et.showPosition ? _n = "Parse error on line " + (ze + 1) + `:
` + et.showPosition() + `
Expecting ` + du.join(", ") + ", got '" + (this.terminals_[Kt] || Kt) + "'" : _n = "Parse error on line " + (ze + 1) + ": Unexpected " + (Kt == Se ? "end of input" : "'" + (this.terminals_[Kt] || Kt) + "'"), this.parseError(_n, {
              text: et.match,
              token: this.terminals_[Kt] || Kt,
              line: et.yylineno,
              loc: kt,
              expected: du
            });
          }
          if (Fr[0] instanceof Array && Fr.length > 1)
            throw new Error("Parse Error: multiple actions possible at state: " + Fn + ", token: " + Kt);
          switch (Fr[0]) {
            case 1:
              rt.push(Kt), Et.push(et.yytext), ot.push(et.yylloc), rt.push(Fr[1]), Kt = null, se = et.yyleng, Ur = et.yytext, ze = et.yylineno, kt = et.yylloc;
              break;
            case 2:
              if (Vr = this.productions_[Fr[1]][1], Nr.$ = Et[Et.length - Vr], Nr._$ = {
                first_line: ot[ot.length - (Vr || 1)].first_line,
                last_line: ot[ot.length - 1].last_line,
                first_column: ot[ot.length - (Vr || 1)].first_column,
                last_column: ot[ot.length - 1].last_column
              }, Ui && (Nr._$.range = [
                ot[ot.length - (Vr || 1)].range[0],
                ot[ot.length - 1].range[1]
              ]), Xn = this.performAction.apply(Nr, [
                Ur,
                se,
                ze,
                Tt.yy,
                Fr[1],
                Et,
                ot
              ].concat(Ze)), typeof Xn < "u")
                return Xn;
              Vr && (rt = rt.slice(0, -1 * Vr * 2), Et = Et.slice(0, -1 * Vr), ot = ot.slice(0, -1 * Vr)), rt.push(this.productions_[Fr[1]][0]), Et.push(Nr.$), ot.push(Nr._$), u0 = Xe[rt[rt.length - 2]][rt[rt.length - 1]], rt.push(u0);
              break;
            case 3:
              return !0;
          }
        }
        return !0;
      }
    };
    const ue = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", $ = ue + "type", D = ue + "first", C = ue + "rest", X = ue + "nil", te = "http://www.w3.org/2001/XMLSchema#", de = te + "integer", oe = te + "decimal", De = te + "double", Ve = te + "boolean", qe = "http://www.w3.org/ns/shacl#", Ke = "http://www.w3.org/2002/07/owl#", Y = "http://www.w3.org/2000/01/rdf-schema#", Ee = {
      [de]: !0,
      [oe]: !0,
      [te + "float"]: !0,
      [De]: !0,
      [te + "string"]: !0,
      [Ve]: !0,
      [te + "dateTime"]: !0,
      [te + "nonPositiveInteger"]: !0,
      [te + "negativeInteger"]: !0,
      [te + "long"]: !0,
      [te + "int"]: !0,
      [te + "short"]: !0,
      [te + "byte"]: !0,
      [te + "nonNegativeInteger"]: !0,
      [te + "unsignedLong"]: !0,
      [te + "unsignedShort"]: !0,
      [te + "unsignedByte"]: !0,
      [te + "positiveInteger"]: !0,
      [ue + "langString"]: !0
    };
    function Ie(bt, Ge = !1) {
      let Je = 0, rt = bt.length;
      if (Ge && rt === 0)
        return Qe.factory.namedNode(X);
      const Et = head = Ye();
      return rt === 0 && ie(head, Qe.factory.namedNode(C), Qe.factory.namedNode(X)), bt.forEach((ot) => {
        if (ot === void 0)
          throw new Error("b");
        ie(head, Qe.factory.namedNode(D), ot), ie(head, Qe.factory.namedNode(C), head = ++Je < rt ? Ye() : Qe.factory.namedNode(X));
      }), Et;
    }
    function Ue(bt) {
      return Qe.n3Parser._resolveIRI(bt[0] === "<" ? bt.substring(1, bt.length - 1) : bt);
    }
    function Le(bt) {
      const Ge = bt.indexOf(":"), Je = bt.substr(0, Ge), rt = Qe.prefixes[Je];
      if (!rt) throw new Error("Unknown prefix: " + Je);
      return Ue(rt + bt.substr(Ge + 1));
    }
    function tt(bt, Ge) {
      return Ge && Ge.termType !== "NamedNode" && (Ge = Qe.factory.namedNode(Ge)), Qe.factory.literal(bt, Ge);
    }
    function it(bt, Ge) {
      return Qe.factory.literal(bt, Ge);
    }
    function Ye(bt) {
      return Qe.factory.blankNode("g_" + ht++);
    }
    var ht = 0;
    Qe._resetBlanks = function() {
      ht = 0;
    };
    function ne(bt, Ge) {
      return Qe.n3Parser._lexer._unescape(bt.substring(Ge, bt.length - Ge));
    }
    function ie(bt, Ge, Je) {
      if (!bt.termType || !Ge.termType || Ge.value.includes(",") || !Je.termType)
        throw new Error(`boo ${bt.value} ${Ge.value} ${Je.value}`);
      Qe.onQuad(Qe.factory.quad(bt, Ge, Je));
    }
    function je(bt, Ge) {
      ie(Qe.currentPropertyNode, Qe.factory.namedNode(qe + bt), Ge);
    }
    function $e(bt, Ge, Je) {
      const rt = Ye();
      return ie(rt, Qe.factory.namedNode(qe + Ge), Je), [bt, rt];
    }
    function He(bt) {
      if (!Qe.extended)
        throw new Error("Encountered extended SHACLC syntax; but extended parsing is disabled");
      return bt;
    }
    var At = /* @__PURE__ */ function() {
      var bt = {
        EOF: 1,
        parseError: function(Je, rt) {
          if (this.yy.parser)
            this.yy.parser.parseError(Je, rt);
          else
            throw new Error(Je);
        },
        // resets the lexer, sets new input
        setInput: function(Ge, Je) {
          return this.yy = Je || this.yy || {}, this._input = Ge, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
        },
        // consumes and returns one char from the input
        input: function() {
          var Ge = this._input[0];
          this.yytext += Ge, this.yyleng++, this.offset++, this.match += Ge, this.matched += Ge;
          var Je = Ge.match(/(?:\r\n?|\n).*/g);
          return Je ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ge;
        },
        // unshifts one char (or a string) into the input
        unput: function(Ge) {
          var Je = Ge.length, rt = Ge.split(/(?:\r\n?|\n)/g);
          this._input = Ge + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Je), this.offset -= Je;
          var Et = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), rt.length - 1 && (this.yylineno -= rt.length - 1);
          var ot = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: rt ? (rt.length === Et.length ? this.yylloc.first_column : 0) + Et[Et.length - rt.length].length - rt[0].length : this.yylloc.first_column - Je
          }, this.options.ranges && (this.yylloc.range = [ot[0], ot[0] + this.yyleng - Je]), this.yyleng = this.yytext.length, this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function() {
          return this._more = !0, this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function() {
          if (this.options.backtrack_lexer)
            this._backtrack = !0;
          else
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          return this;
        },
        // retain first n characters of the match
        less: function(Ge) {
          this.unput(this.match.slice(Ge));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function() {
          var Ge = this.matched.substr(0, this.matched.length - this.match.length);
          return (Ge.length > 20 ? "..." : "") + Ge.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function() {
          var Ge = this.match;
          return Ge.length < 20 && (Ge += this._input.substr(0, 20 - Ge.length)), (Ge.substr(0, 20) + (Ge.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function() {
          var Ge = this.pastInput(), Je = new Array(Ge.length + 1).join("-");
          return Ge + this.upcomingInput() + `
` + Je + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function(Ge, Je) {
          var rt, Et, ot;
          if (this.options.backtrack_lexer && (ot = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          }, this.options.ranges && (ot.yylloc.range = this.yylloc.range.slice(0))), Et = Ge[0].match(/(?:\r\n?|\n).*/g), Et && (this.yylineno += Et.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: Et ? Et[Et.length - 1].length - Et[Et.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ge[0].length
          }, this.yytext += Ge[0], this.match += Ge[0], this.matches = Ge, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ge[0].length), this.matched += Ge[0], rt = this.performAction.call(this, this.yy, this, Je, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), rt)
            return rt;
          if (this._backtrack) {
            for (var Xe in ot)
              this[Xe] = ot[Xe];
            return !1;
          }
          return !1;
        },
        // return next match in input
        next: function() {
          if (this.done)
            return this.EOF;
          this._input || (this.done = !0);
          var Ge, Je, rt, Et;
          this._more || (this.yytext = "", this.match = "");
          for (var ot = this._currentRules(), Xe = 0; Xe < ot.length; Xe++)
            if (rt = this._input.match(this.rules[ot[Xe]]), rt && (!Je || rt[0].length > Je[0].length)) {
              if (Je = rt, Et = Xe, this.options.backtrack_lexer) {
                if (Ge = this.test_match(rt, ot[Xe]), Ge !== !1)
                  return Ge;
                if (this._backtrack) {
                  Je = !1;
                  continue;
                } else
                  return !1;
              } else if (!this.options.flex)
                break;
            }
          return Je ? (Ge = this.test_match(Je, ot[Et]), Ge !== !1 ? Ge : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        },
        // return next match that has a token
        lex: function() {
          var Je = this.next();
          return Je || this.lex();
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function(Je) {
          this.conditionStack.push(Je);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function() {
          var Je = this.conditionStack.length - 1;
          return Je > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function() {
          return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function(Je) {
          return Je = this.conditionStack.length - 1 - Math.abs(Je || 0), Je >= 0 ? this.conditionStack[Je] : "INITIAL";
        },
        // alias for begin(condition)
        pushState: function(Je) {
          this.begin(Je);
        },
        // return the number of states currently on the stack
        stateStackSize: function() {
          return this.conditionStack.length;
        },
        options: { flex: !0, "case-insensitive": !0 },
        performAction: function(Je, rt, Et, ot) {
          switch (Et) {
            case 0:
              break;
            case 1:
              return 12;
            case 2:
              return 14;
            case 3:
              return 15;
            case 4:
              return 25;
            case 5:
              return 20;
            case 6:
              return 131;
            case 7:
              return 132;
            case 8:
              return 85;
            case 9:
              return 126;
            case 10:
              return 87;
            case 11:
              return "PASS";
            case 12:
              return "COMMENT";
            case 13:
              return 13;
            case 14:
              return 16;
            case 15:
              return 130;
            case 16:
              return 129;
            case 17:
              return 128;
            case 18:
              return 117;
            case 19:
              return 92;
            case 20:
              return 119;
            case 21:
              return 120;
            case 22:
              return "EXPONENT";
            case 23:
              return 133;
            case 24:
              return 134;
            case 25:
              return 135;
            case 26:
              return 136;
            case 27:
              return 61;
            case 28:
              return 90;
            case 29:
              return 58;
            case 30:
              return 56;
            case 31:
              return 38;
            case 32:
              return 40;
            case 33:
              return 44;
            case 34:
              return 46;
            case 35:
              return 110;
            case 36:
              return 93;
            case 37:
              return 111;
            case 38:
              return 67;
            case 39:
              return 118;
            case 40:
              return 53;
            case 41:
              return 96;
            case 42:
              return 102;
            case 43:
              return 75;
            case 44:
              return 95;
            case 45:
              return 109;
            case 46:
              return 28;
            case 47:
              return 42;
            case 48:
              return 48;
            case 49:
              return 115;
            case 50:
              return 7;
            case 51:
              console.log(rt.yytext);
              break;
          }
        },
        rules: [/^(?:\s+|#[^\n\r]*)/i, /^(?:BASE)/i, /^(?:IMPORTS)/i, /^(?:PREFIX)/i, /^(?:shapeClass)/i, /^(?:shape)/i, /^(?:true)/i, /^(?:false)/i, /^(?:(BlankNode|IRI|Literal|BlankNodeOrIRI|BlankNodeOrLiteral|IRIOrLiteral\b))/i, /^(?:(targetNode|targetObjectsOf|targetSubjectsOf\b))/i, /^(?:(deactivated|severity|message|class|datatype|nodeKind|minExclusive|minInclusive|maxExclusive|maxInclusive|minLength|maxLength|pattern|flags|languageIn|uniqueLang|equals|disjoint|lessThan|lessThanOrEquals|qualifiedValueShape|qualifiedMinCount|qualifiedMaxCount|qualifiedValueShapesDisjoint|closed|ignoredProperties|hasValue|in))/i, /^(?:([ \t\r\n]+))/i, /^(?:(#[\r\n]*))/i, /^(?:(<([^=<>\"\{\}\|\^`\\\u0000-\u0020]|(\\u([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])|\\U([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f])))*>))/i, /^(?:((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.)*((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040]))?)?:))/i, /^(?:(((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.)*((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040]))?)?:)(((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|:|[0-9]|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.|:|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))*(((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|:|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%)))))?)))/i, /^(?:(@(([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.)*((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040]))?)?:))/i, /^(?:(@((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.)*((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040]))?)?:)(((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|:|[0-9]|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))((((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|\.|:|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))*(((([A-Z]|[a-z]|[\u00C0-\u00D6]|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]|[\uFDF0-\uFFFD])|_\b)|-|[0-9]|[\u00B7]|[\u0300-\u036F]|[\u203F-\u2040])|:|((%([0-9]|[A-F]|[a-f])([0-9]|[A-F]|[a-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%)))))?)))/i, /^(?:(@[a-zA-Z]+(-[a-zA-Z0-9]+)*))/i, /^(?:([+-]?[0-9]+))/i, /^(?:([+-]?[0-9]*\.[0-9]+))/i, /^(?:([+-]?([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.?[0-9]+([eE][+-]?[0-9]+))))/i, /^(?:([eE][+-]?[0-9]+))/i, /^(?:('(?:(?:[^\u0027\u005C\u000A\u000D])|(\\[tbnrf\\\"\']))*'))/i, /^(?:("(?:(?:[^\u0022\u005C\u000A\u000D])|(\\[tbnrf\\\"\']))*"))/i, /^(?:('''(?:(?:'|'')?(?:[^'\\]|(\\[tbnrf\\\"\'])))*'''))/i, /^(?:("""(?:(?:"|"")?(?:[^\"\\]|(\\[tbnrf\\\"\'])))*"""))/i, /^(?:->)/i, /^(?:\.\.)/i, /^(?:\})/i, /^(?:\{)/i, /^(?:\()/i, /^(?:\))/i, /^(?:\[)/i, /^(?:\])/i, /^(?:\?)/i, /^(?:\*)/i, /^(?:\+)/i, /^(?:\|)/i, /^(?:\^\^)/i, /^(?:\.)/i, /^(?:!)/i, /^(?:\/)/i, /^(?:=)/i, /^(?:@)/i, /^(?:\^)/i, /^(?:;)/i, /^(?:,)/i, /^(?:%)/i, /^(?:a)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], inclusive: !0 } }
      };
      return bt;
    }();
    xe.lexer = At;
    function Qe() {
      this.yy = {};
    }
    return Qe.prototype = xe, xe.Parser = Qe, new Qe();
  }();
  return jE = u, jE;
}
var oL;
function kse() {
  if (oL) return T6;
  oL = 1;
  const u = zse().Parser, r = iu;
  class o {
    constructor() {
    }
    parse(t, { extendedSyntax: e, baseIRI: n } = {}) {
      this._parser = new u(), this._parser.Parser.factory = r.DataFactory, this._parser.Parser.base = r.DataFactory.namedNode(n || "urn:x-base:default"), this._parser.Parser.extended = e === !0, this._parser.Parser.prefixes = {
        rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        rdfs: "http://www.w3.org/2000/01/rdf-schema#",
        sh: "http://www.w3.org/ns/shacl#",
        xsd: "http://www.w3.org/2001/XMLSchema#",
        owl: "http://www.w3.org/2002/07/owl#"
      }, this._parser.Parser.currentNodeShape = void 0, this._parser.Parser.currentPropertyNode = void 0, this._parser.Parser.nodeShapeStack = [], this._parser.Parser.tempCurrentNodeShape = void 0, this._parser.Parser.n3Parser = new r.Parser({ baseIRI: n || "urn:x-base:default" });
      const i = [];
      return this._parser.Parser.onQuad = (c) => {
        i.push(c);
      }, this._parser.parse(t), i.prefixes = this._parser.Parser.prefixes, i;
    }
  }
  return T6.Parser = o, T6.parse = function(t, e) {
    return new o().parse(t, e);
  }, T6;
}
var _b = {}, sL;
function Xse() {
  if (sL) return _b;
  sL = 1, Object.defineProperty(_b, "__esModule", { value: !0 }), _b.PrefixWrappingIterator = void 0;
  const u = /* @__PURE__ */ yt();
  let r = class extends u.WrappingIterator {
    constructor(a) {
      super(a == null ? void 0 : a.then((t) => (this.prefixes = t.prefixes, t)));
    }
    read() {
      if (this.prefixes) {
        for (const a of Object.entries(this.prefixes))
          this.emit("prefix", ...a);
        delete this.prefixes;
      }
      return super.read();
    }
  };
  return _b.PrefixWrappingIterator = r, _b;
}
var cL;
function Jse() {
  if (cL) return bb;
  cL = 1, Object.defineProperty(bb, "__esModule", { value: !0 }), bb.ActorRdfParseShaclc = void 0;
  const u = /* @__PURE__ */ yh(), r = gh(), o = Bt(), a = kse(), t = /* @__PURE__ */ Xse();
  let e = class extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "text/shaclc": 1.0,
     *       "text/shaclc-ext": 0.5
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "text/shaclc": "http://www.w3.org/ns/formats/Shaclc",
     *       "text/shaclc-ext": "http://www.w3.org/ns/formats/ShaclcExtended"
     *     }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    async runHandle(i, c, s) {
      const d = new t.PrefixWrappingIterator(
        // TODO: pass data factory
        (0, r.stringify)(i.data).then((f) => {
          var h;
          return (0, a.parse)(f, {
            extendedSyntax: c === "text/shaclc-ext",
            baseIRI: (h = i.metadata) == null ? void 0 : h.baseIRI
          });
        })
      ), l = new o.Readable({ objectMode: !0 });
      return d.on("prefix", (...f) => l.emit("prefix", ...f)), {
        data: l.wrap(d),
        metadata: { triples: !0 }
      };
    }
  };
  return bb.ActorRdfParseShaclc = e, bb;
}
var dL;
function Kse() {
  return dL || (dL = 1, function(u) {
    var r = hs && hs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = hs && hs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Jse(), u);
  }(hs)), hs;
}
var ps = {}, gb = {}, ai = {}, ui = {}, w0 = {}, ME = {}, mb = {}, lL;
function fL() {
  return lL || (lL = 1, Object.defineProperty(mb, "__esModule", { value: !0 }), mb.htmlDecodeTree = void 0, mb.htmlDecodeTree = new Uint16Array(
    // prettier-ignore
    /* @__PURE__ */ 'áµ<ÃÄ±ÊÒÕ»×ÙµÛÞ¢ßà à©àªà¶¡à¹­à¼à¼¦áá¨á¡ááááá¥\0\0\0\0\0\0á«áá¦á°á·á½¾â â°âââ»ââ ¤â¤â´â¹â¿ããºã¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à EMabcfglmnoprstu\\bfmsÂÂÂÂÂÂ¦Â³Â¹ÃÃligè»ÃäPè»&ä¦cuteè»Ãäreve;äÄiyx}rcè»Ãä;är;ìðraveè»Ãäpha;äacr;äd;æ©ÄgpÂÂ¡on;äf;ìð¸plyFunction;æ¡ingè»ÃäÄcsÂ¾Ãr;ìðign;æildeè»Ãämlè»ÃäÐaceforsuÃ¥Ã»Ã¾ÄÄÄ¢Ä§ÄªÄcrÃªÃ²kslash;æÅ¶Ã¶Ã¸;æ«§ed;æy;äÆcrtÄÄÄause;æµnoullis;æ¬a;är;ìðpf;ìð¹eve;äcÃ²Ämpeq;æÜHOacdefhilorsuÅÅÅÆÆÆ¢ÆµÆ·ÆºÇÈÉ³É¸É¾cy;ä§PYè»Â©ä©ÆcpyÅÅ¢Åºute;äÄ;iÅ§Å¨ætalDifferentialD;æleys;æ­ÈaeioÆÆÆÆron;ädilè»Ãärc;änint;æ°ot;äÄdnÆ§Æ­illa;ä¸terDot;ä·Ã²Å¿i;ä§rcleÈDMPTÇÇÇÇot;æinus;ælus;æimes;æoÄcsÇ¢Ç¸kwiseContourIntegral;æ²eCurlyÄDQÈÈoubleQuote;æuote;æÈlnpuÈÈ¨ÉÉonÄ;eÈ¥È¦æ·;æ©´ÆgitÈ¯È¶Èºruent;æ¡nt;æ¯ourIntegral;æ®ÄfrÉÉ;æoduct;ænterClockwiseContourIntegral;æ³oss;æ¨¯cr;ìðpÄ;CÊÊæap;æÖDJSZacefiosÊ Ê¬Ê°Ê´Ê¸ËËË¡Ë¦Ì³ÒÄ;oÅ¹Ê¥trahd;æ¤cy;äcy;äcy;äÆgrsÊ¿ËËger;æ¡r;æ¡hv;æ«¤ÄayËËron;ä;älÄ;tËËæa;är;ìðÄafË«Ì§ÄcmË°Ì¢riticalÈADGTÌÌÌÌcute;ä´oÅ´ÌÌ;äbleAcute;ärave;ä ilde;äond;æferentialD;æÑ°Ì½\0\0\0ÍÍ\0Ðf;ìð»Æ;DEÍÍÍä¨ot;æqual;æbleÌCDLRUVÍ£Í²ÎÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»ÍnArrow;æÄeoÎÎ¤ftÆARTÎÎÎ¡rrow;æightArrow;æeÃ¥ËngÄLRÎ«ÏeftÄARÎ³Î¹rrow;æ¸ightArrow;æºightArrow;æ¹ightÄATÏÏrrow;æee;æ¨pÉÏ©\0\0Ï¯rrow;æownArrow;æerticalBar;æ¥nÌABLRTaÐÐªÐ°ÑÑ¿Í¼rrowÆ;BUÐÐÐ¢æar;æ¤pArrow;æµreve;äeftËÐº\0Ñ\0ÑightVector;æ¥eeVector;æ¥ectorÄ;BÑÑæ½ar;æ¥ightÇÑ§\0Ñ±eeVector;æ¥ectorÄ;BÑºÑ»æar;æ¥eeÄ;AÒÒæ¤rrow;æ§ÄctÒÒr;ìðrok;äà NTacdfglmopqstuxÒ½ÓÓÓÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶ÕÕÕ Õ¥G;äHè»Ãäcuteè»ÃäÆaiyÓÓÓron;ärcè»Ãä;ä­ot;är;ìðraveè»Ãäement;æÄapÓºÓ¾cr;ätyÉÔ\0\0ÔmallSquare;æ»erySmallSquare;æ«ÄgpÔ¦Ôªon;äf;ìð¼silon;äuÄaiÔ¼ÕlÄ;TÕÕæ©µilde;ælibrium;æÄciÕÕr;æ°m;æ©³a;ämlè»ÃäÄipÕªÕ¯sts;æonentialE;æÊcfiosÖÖÖÖ²×y;ä¤r;ìðlledÉÖ\0\0Ö£mallSquare;æ¼erySmallSquare;æªÍ°Öº\0Ö¿\0\0×f;ìð½All;æriertrf;æ±cÃ²×ØJTabcdfgorst×¨×¬×¯×ºØØØØØØ£Ù¬Ù²cy;äè»>ä¾mmaÄ;d×·×¸ä;äreve;äÆeiyØØØdil;ä¢rc;ä;äot;ä r;ìð;æpf;ìð¾eaterÌEFGLSTØµÙÙÙÙÙ¦qualÄ;LØ¾Ø¿æ¥ess;æullEqual;æ§reater;æª¢ess;æ·lantEqual;æ©¾ilde;æ³cr;ìð¢;æ«ÐAacfiosuÚÚÚÚÚÚªÚ¾ÛRDcy;äªÄctÚÚek;ä;äirc;ä¤r;ælbertSpace;æÇ°Ú¯\0Ú²f;æizontalLine;æÄctÛÛÃ²Ú©rok;ä¦mpÅÛÛownHumÃ°Ä¯qual;æÜEJOacdfgmnostuÛºÛ¾ÜÜÜÜÜÜ¡Ü¨ÝÝ¸ÞÞÞcy;älig;ä²cy;äcuteè»ÃäÄiyÜÜrcè»Ãä;äot;ä°r;æraveè»ÃäÆ;apÜ Ü¯Ü¿ÄcgÜ´Ü·r;äªinaryI;ælieÃ³ÏÇ´Ý\0Ý¢Ä;eÝÝæ¬ÄgrÝÝral;æ«section;æisibleÄCTÝ¬Ý²omma;æ£imes;æ¢ÆgptÝ¿ÞÞon;ä®f;ìða;äcr;æilde;ä¨Ç«Þ\0Þcy;älè»ÃäÊcfosuÞ¬Þ·Þ¼ßßÄiyÞ±Þµrc;ä´;är;ìðpf;ìðÇ£ß\0ßr;ìð¥rcy;äkcy;äÎHJacfosß¤ß¨ß¬ß±ß½à à cy;ä¥cy;äppa;äÄeyß¶ß»dil;ä¶;är;ìðpf;ìðcr;ìð¦ÖJTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§à§à¨·à©cy;äè»<ä¼Êcmnprà ·à ¼à¡à¡à¡ute;ä¹bda;äg;æªlacetrf;ær;æÆaeyà¡à¡à¡¡ron;ä½dil;ä»;äÄfsà¡¨à¥°tÔACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥Îà¥ªÄnrà¢à¢gleBracket;æ¨rowÆ;BRà¢à¢à¢æar;æ¤ightArrow;æeiling;æoÇµà¢·\0à£bleBracket;æ¦nÇà£\0à£eeVector;æ¥¡ectorÄ;Bà£à£æar;æ¥loor;æightÄAVà£¯à£µrrow;æector;æ¥Äerà¤à¤eÆ;AVà¤à¤à¤æ£rrow;æ¤ector;æ¥iangleÆ;BEà¤¤à¤¥à¤©æ²ar;æ§qual;æ´pÆDTVà¤·à¥à¥ownVector;æ¥eeVector;æ¥ ectorÄ;Bà¥à¥æ¿ar;æ¥ectorÄ;Bà¥¥à¥¦æ¼ar;æ¥ightÃ¡ÎsÌEFGLSTà¥¾à¦à¦à¦à¦¢à¦­qualGreater;æullEqual;æ¦reater;æ¶ess;æª¡lantEqual;æ©½ilde;æ²r;ìðÄ;eà¦½à¦¾æftarrow;æidot;ä¿Ænpwà§à¨à¨gÈLRlrà§à§·à¨à¨eftÄARà§¦à§¬rrow;æµightArrow;æ·ightArrow;æ¶eftÄarÎ³à¨ightÃ¡Î¿ightÃ¡Ïf;ìðerÄLRà¨¢à¨¬eftArrow;æightArrow;æÆchtà¨¾à©à©Ã²à¡;æ°rok;ä;æªÐacefiosuà©à©à© à©·à©¼àªàªàªp;æ¤y;äÄdlà©¥à©¯iumSpace;ælintrf;æ³r;ìðnusPlus;æpf;ìðcÃ²à©¶;äÒJacefostuàª£àª§àª­à«à¬à¬à¶à¶à¶cy;äcute;äÆaeyàª´àª¹àª¾ron;ädil;ä;äÆgswà«à«°à¬ativeÆMTVà«à«à«¨ediumSpace;æhiÄcnà«¦à«Ã«à«eryThiÃ®à«tedÄGLà«¸à¬reaterGreateÃ²Ù³essLesÃ³à©Line;är;ìðÈBnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä f;æÚ;CDEGHLNPRSTVà­à­à­ªà­¼à®¡à¯«à°à±à²à²¦à³àµ¡à¶æ«¬Äouà­à­¤ngruent;æ¢pCap;æ­oubleVerticalBar;æ¦Ælqxà®à®à®ement;æualÄ;Tà®à®æ ilde;ìâÌ¸ists;æreaterÎ;EFGLSTà®¶à®·à®½à¯à¯à¯à¯¥æ¯qual;æ±ullEqual;ìâ§Ì¸reater;ìâ«Ì¸ess;æ¹lantEqual;ìâ©¾Ì¸ilde;æµumpÅà¯²à¯½ownHump;ìâÌ¸qual;ìâÌ¸eÄfsà°à°§tTriangleÆ;BEà°à°à°¡æªar;ìâ§Ì¸qual;æ¬sÌ;EGLSTà°µà°¶à°¼à±à±à±æ®qual;æ°reater;æ¸ess;ìâªÌ¸lantEqual;ìâ©½Ì¸ilde;æ´estedÄGLà±¨à±¹reaterGreater;ìâª¢Ì¸essLess;ìâª¡Ì¸recedesÆ;ESà²à²à²æqual;ìâª¯Ì¸lantEqual;æ Äeià²«à²¹verseElement;æghtTriangleÆ;BEà³à³à³æ«ar;ìâ§Ì¸qual;æ­Äquà³à´uareSuÄbpà³¨à³¹setÄ;Eà³°à³³ìâÌ¸qual;æ¢ersetÄ;Eà´à´ìâÌ¸qual;æ£Æbcpà´à´¤àµsetÄ;Eà´à´ìââqual;æceedsÈ;ESTà´²à´³à´»àµæqual;ìâª°Ì¸lantEqual;æ¡ilde;ìâ¿Ì¸ersetÄ;Eàµàµìââqual;æildeÈ;EFTàµ®àµ¯àµµàµ¿æqual;æullEqual;æilde;æerticalBar;æ¤cr;ìð©ildeè»Ãä;äÜEacdfgmoprstuvà¶½à·à·à·à·à· à·§à·¼à¸à¸ à¸¢à¸²à¸¿à¹lig;äcuteè»ÃäÄiyà·à·rcè»Ãä;äblac;är;ìðraveè»ÃäÆaeià·®à·²à·¶cr;äga;ä©cron;äpf;ìðenCurlyÄDQà¸à¸oubleQuote;æuote;æ;æ©Äclà¸§à¸¬r;ìðªashè»ÃäiÅ¬à¸·à¸¼deè»Ãäes;æ¨·mlè»ÃäerÄBPà¹à¹ Äarà¹à¹r;æ¾acÄekà¹à¹;æet;æ´arenthesis;æÒacfhilorsà¹¿àºàºàºàºàºàºàº°à»¼rtialD;æy;är;ìði;ä¦;ä usMinus;ä±Äipàº¢àº­ncareplanÃ¥Úf;æÈ;eioàº¹àººà» à»¤æª»cedesÈ;ESTà»à»à»à»æºqual;æª¯lantEqual;æ¼ilde;æ¾me;æ³Ädpà»©à»®uct;æortionÄ;aÈ¥à»¹l;æÄcià¼à¼r;ìð«;ä¨ÈUfosà¼à¼à¼à¼OTè»"ä¢r;ìðpf;æcr;ìð¬ØBEacefhiorsuà¼¾à½à½à½ à½³à¾§à¾ªà¾­áá©á´á¾arr;æ¤Gè»Â®ä®Æcnrà½à½à½ute;äg;æ«rÄ;tà½à½æ l;æ¤Æaeyà½§à½¬à½±ron;ädil;ä;ä Ä;và½¸à½¹æerseÄEUà¾à¾Älqà¾à¾ement;æuilibrium;æpEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtÐACDFTUVaà¿à¿«à¿³á¢á¨ááÏÄnrà¿à¿gleBracket;æ©rowÆ;BLà¿à¿à¿¡æar;æ¥eftArrow;æeiling;æoÇµà¿¹\0ábleBracket;æ§nÇá\0áeeVector;æ¥ectorÄ;Bááæar;æ¥loor;æÄerá­áeÆ;AVáµá¶á¼æ¢rrow;æ¦ector;æ¥iangleÆ;BEáááæ³ar;æ§qual;æµpÆDTVá£á®á¸ownVector;æ¥eeVector;æ¥ectorÄ;Bááæ¾ar;æ¥ectorÄ;Bááæar;æ¥Äpuááf;ændImplies;æ¥°ightarrow;æÄchá¹á¼r;æ;æ±leDelayed;æ§´ÚHOacfhimoqstuá¤á±á·á½ááááá¡á§áµá»á¿ÄCcá©á®Hcy;ä©y;ä¨FTcy;ä¬cute;äÊ;aeiyáááááæª¼ron;ä dil;ärc;ä;ä¡r;ìðortÈDLRUáªá´á¾áownArrowÂ»ÐeftArrowÂ»à¢ightArrowÂ»à¿pArrow;ægma;ä£allCircle;æpf;ìðÉ²á­\0\0á°t;æareÈ;ISUá»á¼áá¯æ¡ntersection;æuÄbpáásetÄ;Eááæqual;æersetÄ;Eá¨á©æqual;ænion;æcr;ìð®ar;æÈbcmpááááÄ;sááæetÄ;Eááqual;æÄchá áeedsÈ;ESTá­á®á´á¿æ»qual;æª°lantEqual;æ½ilde;æ¿ThÃ¡à¾;æÆ;esááá£ærsetÄ;Eááæqual;æetÂ»áÖHRSacfhiorsá¾ááááá±á¶ááááORNè»ÃäADE;æ¢ÄHcáácy;äy;ä¦Äbuáá;ä;ä¤Æaeyá¥áªá¯ron;ä¤dil;ä¢;ä¢r;ìðÄeiá»áÇ²á\0áefore;æ´a;äÄcnáákSpace;ìââSpace;ældeÈ;EFTá«á¬á²á¼æ¼qual;æullEqual;æilde;æpf;ìðipleDot;æÄctáár;ìð¯rok;ä¦à«¡á·ááá¦\0á¬á±\0\0\0\0\0á¸á½á·á\0á¿áááÄcrá»áuteè»ÃärÄ;oááæcir;æ¥rÇ£á\0áy;äve;ä¬Äiyáá£rcè»Ãä;ä£blac;ä°r;ìðraveè»Ãäacr;äªÄdiáá©erÄBPááÄaráár;äacÄekáá;æet;æµarenthesis;æonÄ;Pá°á±ælus;æÄgpá»á¿on;ä²f;ìðÐADETadpsáá®á¸áÏ¨ááá³rrowÆ;BDáá á¤ar;æ¤ownArrow;æownArrow;æquilibrium;æ¥®eeÄ;Aááæ¥rrow;æ¥ownÃ¡Ï³erÄLRáá¨eftArrow;æightArrow;æiÄ;lá¹áºäon;ä¥ing;ä®cr;ìð°ilde;ä¨mlè»ÃäÒDbcdefosvá§á¬á°á³á¾ááááash;æ«ar;æ««y;äashÄ;lá»á¼æ©;æ«¦Äeráá;æÆbtyáááºar;æÄ;iáácalÈBLSTá¡á¥áªá´ar;æ£ine;ä¼eparator;æilde;æThinSpace;ær;ìðpf;ìðcr;ìð±dash;æªÊcefosá§á¬á±á¶á¼irc;ä´dge;ær;ìðpf;ìðcr;ìð²Èfiosáááár;ìð;äpf;ìðcr;ìð³ÒAIUacfosuá±áµá¹á½ááááá cy;ä¯cy;äcy;ä®cuteè»ÃäÄiyáárc;ä¶;ä«r;ìðpf;ìðcr;ìð´ml;ä¸ÐHacdefosáµá¹á¿áááá á¤cy;äcute;ä¹Äayááron;ä½;äot;ä»Ç²á\0áoWidtÃ¨à«a;är;æ¨pf;æ¤cr;ìðµà¯¡ááá\0á°á¶á¿\0\0\0\0ááá«áá­\0ááá²á¹\0á¾cuteè»Ã¡ä¡reve;äÌ;Ediuyááá¡á£á¨á­æ¾;ìâ¾Ì³;æ¿rcè»Ã¢ä¢teè»Â´Ì;ä°ligè»Ã¦ä¦Ä;rÂ²áº;ìðraveè»Ã ä ÄepááÄfpáásym;æµÃ¨áha;ä±ÄapácÄclá¤á§r;äg;æ¨¿É¤á°\0\0áÊ;adsváºá»á¿ááæ§nd;æ©;æ©lope;æ©;æ©Î;elmrszááááá¿ááæ ;æ¦¤eÂ»ásdÄ;aá¥á¦æ¡Ñ¡á°á²á´á¶á¸áºá¼á¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ;vááæbÄ;dááæ¾;æ¦Äptááh;æ¢Â»Â¹arr;æ¼Ägpá£á§on;äf;ìðÎ;Eaeiopáá»á½áááá;æ©°cir;æ©¯;æd;æs;ä§roxÄ;eááÃ±áingè»Ã¥ä¥Æctyá¡á¦á¨r;ìð¶;äªmpÄ;eáá¯Ã±Êildeè»Ã£ä£mlè»Ã¤ä¤ÄciááoninÃ´É²nt;æ¨à Nabcdefiklnoprsuá­á±á°á¼ááá¸á½á á¦á ¹á¡áá¤½á¥á¥°ot;æ«­Äcrá¶ákÈcepsááááong;æpsilon;ä¶rime;æµimÄ;eááæ½q;æÅ¶á¢á¦ee;æ½edÄ;gá¬á­æeÂ»á­rkÄ;táá·brk;æ¶Äoyáá;ä±quo;æÊcmprtááá¡á¤á¨ausÄ;eÄÄptyv;æ¦°sÃ©ánoÃµÄÆahwá¯á±á³;ä²;æ¶een;æ¬r;ìðgÎcostuvwááá³ááááÆaiuáááÃ°Ý rc;æ¯pÂ»á±Ædptá¤á¨á­ot;æ¨lus;æ¨imes;æ¨É±á¹\0\0á¾cup;æ¨ar;æriangleÄduááown;æ½p;æ³plus;æ¨eÃ¥áÃ¥á­arow;æ¤Æakoá­á ¦á µÄcná²á £kÆlstáºÖ«á ozenge;æ§«riangleÈ;dlrá á á á æ´own;æ¾eft;æight;æ¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ;æ4;æck;æÄeoá ¾á¡Ä;qá¡á¡ì=â¥uiv;ìâ¡â¥t;æÈptwxá¡á¡á¡§á¡¬f;ìðÄ;táá¡£omÂ»átie;æØDHUVbdhmptuvá¢á¢á¢ªá¢»á£á£á£¬á£¿á¤á¤á¤á¤¡ÈLRlrá¢á¢á¢á¢;æ;æ;æ;æÊ;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ;æ¦;æ©;æ¤;æ§ÈLRlrá¢³á¢µá¢·á¢¹;æ;æ;æ;æÎ;HLRhlrá£á£á£á£á£á£á£æ;æ¬;æ£;æ ;æ«;æ¢;æox;æ§ÈLRlrá£¤á£¦á£¨á£ª;æ;æ;æ;æÊ;DUduÚ½á£·á£¹á£»á£½;æ¥;æ¨;æ¬;æ´inus;ælus;æimes;æ ÈLRlrá¤á¤á¤á¤;æ;æ;æ;æÎ;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ;æª;æ¡;æ;æ¼;æ¤;æÄevÄ£á¥barè»Â¦ä¦Èceioá¥á¥á¥á¥ r;ìð·mi;æmÄ;eáálÆ;bhá¥¨á¥©á¥«ä;æ§sub;æÅ¬á¥´á¥¾lÄ;eá¥¹á¥ºæ¢tÂ»á¥ºpÆ;EeÄ¯á¦á¦;æª®Ä;qÛÛà³¡á¦§\0á§¨á¨á¨á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­\0á¯½\0á°Æcprá¦­á¦²á§ute;äÌ;abcdsá¦¿á§á§á§á§á§æ©nd;æ©rcup;æ©Äauá§á§p;æ©p;æ©ot;æ©;ìâ©ï¸Äeoá§¢á§¥t;æÃ®ÚÈaeiuá§°á§»á¨á¨Ç°á§µ\0á§¸s;æ©on;ädilè»Ã§ä§rc;äpsÄ;sá¨á¨æ©m;æ©ot;äÆdmná¨á¨ á¨¦ilè»Â¸Æ­ptyv;æ¦²tèÂ¢;eá¨­á¨®ä¢rÃ¤Æ²r;ìð Æceiá¨½á©á©y;äckÄ;má©á©æarkÂ»á©;ärÎ;Ecefmsá©á© á©¢á©«áª¤áªªáª®æ;æ§Æ;elá©©á©ªá©­äq;æeÉ¡á©´\0\0áªrrowÄlrá©¼áªeft;æºight;æ»ÊRSacdáªáªáªáªáªÂ»à½;æst;æirc;æash;ænint;æ¨id;æ«¯cir;æ§ubsÄ;uáª»áª¼æ£itÂ»áª¼Ë¬á«á«á«º\0á¬onÄ;eá«á«äºÄ;qÃÃÉ­á«\0\0á«¢aÄ;tá«á«ä¬;äÆ;flá«¨á«©á««æÃ®á eÄmxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬Ä;dá»á¬ot;æ©­nÃ´ÉÆfryá¬á¬á¬;ìðoÃ¤ÉèÂ©;sÅá¬r;æÄaoá¬¥á¬©rr;æµss;æÄcuá¬²á¬·r;ìð¸Äbpá¬¼á­Ä;eá­á­æ«;æ«Ä;eá­á­æ«;æ«dot;æ¯Îdelprvwá­ á­¬á­·á®á®¬á¯á¯¹arrÄlrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æc;æarrÄ;pá­¿á®æ¶;æ¤½Ì;bcdosá®á®á®á®¡á®¥á®¨æªrcap;æ©Äauá®á®p;æ©p;æ©ot;ær;æ©;ìâªï¸Èalrvá®µá®¿á¯á¯£rrÄ;má®¼á®½æ·;æ¤¼yÆevwá¯á¯á¯qÉ°á¯\0\0á¯reÃ£á­³uÃ£á­µee;æedge;æenè»Â¤ä¤earrowÄlrá¯®á¯³eftÂ»á®ightÂ»á®½eÃ¤á¯Äciá°á°oninÃ´Ç·nt;æ±lcty;æ­à¦AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²á²á²¬á²·á³»á³¿á´áµ»á¶á¶«á¶»á·á·rÃ²Îar;æ¥¥Èglrsá±á±á±á±ger;æ eth;æ¸Ã²á³hÄ;vá±á±æÂ»à¤Å«á±¡á±§arow;æ¤aÃ£ÌÄayá±®á±³ron;ä;ä´Æ;aoÌ²á±¼á²ÄgrÊ¿á²r;ætseq;æ©·Æglmá²á²á²è»Â°ä°ta;ä´ptyv;æ¦±Äirá²£á²¨sht;æ¥¿;ìð¡arÄlrá²³á²µÂ»à£Â»áÊaegsvá³Í¸á³á³á³ mÆ;osÌ¦á³á³ndÄ;sÌ¦á³uit;æ¦amma;äin;æ²Æ;ioá³§á³¨á³¸ä·deèÃ·;oá³§á³°ntimes;ænÃ¸á³·cy;äcÉ¯á´\0\0á´rn;æop;æÊlptuwá´á´á´¢áµáµlar;ä¤f;ìðÊ;empsÌá´­á´·á´½áµqÄ;dÍá´³ot;æinus;æ¸lus;æquare;æ¡blebarwedgÃ¥ÃºnÆadhá®áµáµ§ownarrowÃ³á²arpoonÄlráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶karoÃ·à½É¯á¶\0\0á¶rn;æop;æÆcotá¶á¶£á¶¦Äryá¶á¶¡;ìð¹;äl;æ§¶rok;äÄdrá¶°á¶´ot;æ±iÄ;fá¶ºá æ¿Äahá·á·rÃ²Ð©aÃ²à¾¦angle;æ¦¦Äciá·á·y;ägrarr;æ¿à¤Dacdefglmnopqrstuxá¸á¸á¸á¸¸Õ¸á¸¼á¹á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½á½á½ÄDoá¸á´´oÃ´á²Äcsá¸á¸uteè»Ã©ä©ter;æ©®Èaioyá¸¢á¸§á¸±á¸¶ron;ärÄ;cá¸­á¸®æè»Ãªäªlon;æ;äot;äÄDrá¹á¹ot;æ;ìð¢Æ;rsá¹á¹á¹æªaveè»Ã¨ä¨Ä;dá¹á¹æªot;æªÈ;ilsá¹ªá¹«á¹²á¹´æªnters;æ§;æÄ;dá¹¹á¹ºæªot;æªÆapsáºáºáºcr;ätyÆ;sváºáºáºæetÂ»áºpÄ1;áºáº¤Ä³áº¡áº£;æ;ææÄgsáºªáº¬;äp;æÄgpáº´áº¸on;äf;ìðÆalsá»á»á»rÄ;sá»á»æl;æ§£us;æ©±iÆ;lvá»á»á»äµonÂ»á»;äµÈcsuvá»ªá»³á¼á¼£Äioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕantÄglá¼á¼trÂ»á¹essÂ»á¹ºÆaeiá¼á¼á¼ls;ä½st;ævÄ;DÈµá¼ D;æ©¸parsl;æ§¥ÄDaá¼¯á¼³ot;ærr;æ¥±Æcdiá¼¾á½á»¸r;æ¯oÃ´ÍÄahá½á½;ä·è»Ã°ä°Ämrá½á½lè»Ã«ä«o;æ¬Æcipá½¡á½¤á½§l;ä¡sÃ´Õ®Äeoá½¬á½´ctatioÃ®ÕnentialÃ¥Õ¹à§¡á¾\0á¾\0á¾¡á¾§\0\0á¿á¿\0á¿\0á¿¦á¿ªâ\0ââllingdotseÃ±á¹y;ämale;æÆilrá¾­á¾³á¿lig;èï¬É©á¾¹\0\0á¾½g;èï¬ig;èï¬;ìð£lig;èï¬lig;ìfjÆaltá¿á¿á¿¡t;æ­ig;èï¬ns;æ±of;äÇ°á¿®\0á¿³f;ìðÄakÖ¿á¿·Ä;vá¿¼á¿½æ;æ«artint;æ¨ÄaoââÄcsââÎ±ââ°â¸ââ\0âÎ²â¢â¥â§âªâ¬\0â®è»Â½ä½;æè»Â¼ä¼;æ;æ;æÆ³â´\0â¶;æ;æÊ´â¾â\0\0âè»Â¾ä¾;æ;æ5;æÆ¶â\0â;æ;æ8;æl;æwn;æ¢cr;ìð»à¢Eabcdefgijlnorstvââââ¥â°â´â°âµâºâ¿âââ¸Ìâ¾ââÄ;lÙâ;æªÆcmpâââute;äµmaÄ;dâá³ä³;æªreve;äÄiyâªâ®rc;ä;ä³ot;ä¡È;lqsØ¾Ùâ½âÆ;qsØ¾ÙâlanÃ´Ù¥È;cdlÙ¥âââ¥c;æª©otÄ;oââæªÄ;lâ¢â£æª;æªÄ;eâªâ­ìâï¸s;æªr;ìð¤Ä;gÙ³Ømel;æ·cy;äÈ;EajÙâââ;æª;æª¥;æª¤ÈEaesâââ©â´;æ©pÄ;pâ£â¤æªroxÂ»â¤Ä;qâ®â¯æªÄ;qâ®âim;æ§pf;ìðÄciââr;æmÆ;elÙ«ââ;æª;æªè>;cdlqr×®â âªâ®â³â¹Äciâ¥â§;æª§r;æ©ºot;æPar;æ¦uest;æ©¼ÊadelsââªâÙâÇ°â\0âproÃ¸âr;æ¥¸qÄlqØ¿âlesÃ³âiÃ­Ù«Äenâ£â­rtneqq;ìâ©ï¸ÃâªÔAabcefkosyâââ±âµâºâââ¯â¨â½rÃ²Î ÈilmrâââârsÃ°áfÂ»â¤ilÃ´Ú©Ädrâ â¤cy;äÆ;cwà£´â«â¯ir;æ¥;æ­ar;æirc;ä¥ÆalrââârtsÄ;uââæ¥itÂ»âlip;æ¦con;æ¹r;ìð¥sÄewâ£â©arow;æ¤¥arow;æ¤¦Êamoprâºâ¾âââ£rr;æ¿tht;æ»kÄlrââeftarrow;æ©ightarrow;æªf;ìðbar;æÆcltâ¯â´â¸r;ìð½asÃ¨â´rok;ä§Äbpââull;æhenÂ»á±à«¡â£\0âª\0â¸ââ\0ââ³\0\0â¸â¢â§â¢â¿\0ââªâ´cuteè»Ã­ä­Æ;iyÝ±â°âµrcè»Ã®ä®;ä¸Äcxâ¼â¿y;äµclè»Â¡ä¡ÄfrÎâ;ìð¦raveè»Ã¬ä¬È;inoÜ¾ââ©â®Äinâ¢â¦nt;æ¨t;æ­fin;æ§ta;æ©lig;ä³Æaopâ¾ââÆcgtâââr;ä«ÆelpÜââinÃ¥ÞarÃ´Ü h;ä±f;æ·ed;äµÊ;cfotÓ´â¬â±â½âare;æinÄ;tâ¸â¹æie;æ§doÃ´âÊ;celpÝââââ¡al;æºÄgrââerÃ³á£Ã£âarhk;æ¨rod;æ¨¼Ècgptâ¯â²â¶â»y;äon;ä¯f;ìða;ä¹uestè»Â¿ä¿Äciââr;ìð¾nÊ;EdsvÓ´âââ¡Ó³;æ¹ot;æµÄ;vâ¦â§æ´;æ³Ä;iÝ·â®lde;ä©Ç«â¸\0â¼cy;älè»Ã¯ä¯Ìcfmosuââââ¡â§âµÄiyâârc;äµ;ä¹r;ìð§ath;ä·pf;ìðÇ£â¬\0â±r;ìð¿rcy;äkcy;äÐacfghjosâââ¢â§â­â±âµâ»ppaÄ;vââäº;ä°Äeyââ dil;ä·;äºr;ìð¨reen;ä¸cy;äcy;äpf;ìðcr;ìðà®ABEHabcdefghjlmnoprstuvâ°ââââââ½âââââ¥â¹â½ââ²âââ¨âââ â Æartâ·âºâ¼rÃ²à§Ã²Îail;æ¤arr;æ¤Ä;gà¦â;æªar;æ¥¢à¥£â¥\0âª\0â±\0\0\0\0\0âµâº\0âââ\0â¹ute;äºmptyv;æ¦´raÃ®à¡bda;ä»gÆ;dlà¢ââ;æ¦Ã¥à¢;æªuoè»Â«ä«rÐ;bfhlpstà¢ââ¦â©â«â®â±âµÄ;fà¢â£s;æ¤s;æ¤Ã«âp;æ«l;æ¤¹im;æ¥³l;æ¢Æ;aeâ¿ââæª«il;æ¤Ä;sââæª­;ìâª­ï¸Æabrââârr;æ¤rk;æ²Äakâ¢â¬cÄekâ¨âª;ä»;äÄesâ±â³;æ¦lÄduâ¹â»;æ¦;æ¦Èaeuyââââron;ä¾Ädiââil;ä¼Ã¬à¢°Ã¢â©;ä»Ècqrsâ£â¦â­â½a;æ¤¶uoÄ;rà¸áÄduâ²â·har;æ¥§shar;æ¥h;æ²Ê;fgqsââà¦â³â¿æ¤tÊahlrtââ¤â·ââ¨rrowÄ;tà¢â¡aÃ©â¶arpoonÄduâ¯â´ownÂ»ÑpÂ»à¥¦eftarrows;æightÆahsââârrowÄ;sà£´à¢§arpoonÃ³à¾quigarroÃ·â°hreetimes;æÆ;qsâà¦âºlanÃ´à¦¬Ê;cdgsà¦¬ââââ¨c;æª¨otÄ;oââæ©¿Ä;rââæª;æªÄ;eâ¢â¥ìâï¸s;æªÊadegsâ³â¹â½ââpproÃ¸âot;æqÄgqââÃ´à¦gtÃ²âÃ´à¦iÃ­à¦²Æilrâà£¡âsht;æ¥¼;ìð©Ä;Eà¦â£;æªÅ¡â©â¶rÄduâ²â®Ä;là¥¥â³;æ¥ªlk;æcy;äÊ;achtà©âââârÃ²âorneÃ²á´ard;æ¥«ri;æºÄioââ¤dot;äustÄ;aâ¬â­æ°cheÂ»â­ÈEaesâ»â½ââ;æ¨pÄ;pââæªroxÂ»âÄ;qââæªÄ;qââ»im;æ¦Ðabnoptwzâ©â´â·ââ¯âââÄnrâ®â±g;æ¬r;æ½rÃ«à£gÆlmrâ¿ââeftÄarà§¦âightÃ¡à§²apsto;æ¼ightÃ¡à§½parrowÄlrâ¥â©efÃ´â­ight;æ¬Æaflâ¶â¹â½r;æ¦;ìðus;æ¨­imes;æ¨´Å¡ââst;æÃ¡áÆ;efââá ængeÂ»âarÄ;lâ¤â¥ä¨t;æ¦Êachmtâ³â¶â¼âârÃ²à¢¨orneÃ²á¶arÄ;dà¾â;æ¥­;æri;æ¿Ìachiqtââà©â¢â®â»quo;æ¹r;ìðmÆ;egà¦²âªâ¬;æª;æªÄbuâªâ³oÄ;rà¸â¹;ærok;äè<;cdhilqrà «ââ¹ââ â¥âªâ°Äciââ;æª¦r;æ©¹reÃ¥â²mes;æarr;æ¥¶uest;æ©»ÄPiâµâ¹ar;æ¦Æ;efâ à¤­á ærÄduâ â shar;æ¥har;æ¥¦Äenâ â ¡rtneqq;ìâ¨ï¸Ãâ ÜDacdefhilnopsuâ¡â¡â¢â¢â¢â¢ â¢¥â¢¨â£â£¢â£¤àªâ£³â¤Dot;æºÈclprâ¡â¡â¡£â¡½rè»Â¯ä¯Äetâ¡â¡;æÄ;eâ¡â¡æ seÂ»â¡Ä;sá»â¡¨toÈ;dluá»â¡³â¡·â¡»owÃ®ÒefÃ´à¤Ã°áker;æ®Äoyâ¢â¢mma;æ¨©;ä¼ash;æasuredangleÂ»á¦r;ìðªo;æ§Æcdnâ¢¯â¢´â£roè»ÂµäµÈ;acdá¤â¢½â£â£sÃ´á§ir;æ«°otè»Â·ÆµusÆ;bdâ£á¤â£æÄ;uá´¼â£;æ¨ªÅ£â£â£¡p;æ«Ã²âÃ°àªÄdpâ£©â£®els;æ§f;ìðÄctâ£¸â£½r;ìðposÂ»áÆ;lmâ¤â¤â¤ä¼timap;æ¸à°GLRVabcdefghijlmoprstuvwâ¥â¥â¥¾â¦â¦â§â§©â¨â¨â©â©âªâªâª¤âª¨â¬â¬â­â­¿â®®â°´â±§â±¼â³©Ägtâ¥â¥;ìâÌ¸Ä;vâ¥à¯ìâ«âÆeltâ¥â¥²â¥¶ftÄarâ¥¡â¥§rrow;æightarrow;æ;ìâÌ¸Ä;vâ¥»à±ìâªâightarrow;æÄDdâ¦â¦ash;æ¯ash;æ®Êbcnptâ¦£â¦§â¦¬â¦±â§laÂ»Ëute;äg;ìâ âÊ;Eiopà¶â¦¼â§â§â§;ìâ©°Ì¸d;ìâÌ¸s;äroÃ¸à¶urÄ;aâ§â§æ®lÄ;sâ§à¬¸Ç³â§\0â§£pè»Â à¬·mpÄ;eà¯¹à°Êaeouyâ§´â§¾â¨â¨â¨Ç°â§¹\0â§»;æ©on;ädil;ängÄ;dàµ¾â¨ot;ìâ©­Ì¸p;æ©;ä½ash;æÎ;Aadqsxà®â¨©â¨­â¨»â©â©â©rr;ærÄhrâ¨³â¨¶k;æ¤¤Ä;oá²á°ot;ìâÌ¸uiÃ¶à­£Äeiâ©â©ar;æ¤¨Ã­à®istÄ;sà® à®r;ìð«ÈEestà¯â©¦â©¹â©¼Æ;qsà®¼â©­à¯¡Æ;qsà®¼à¯â©´lanÃ´à¯¢iÃ­à¯ªÄ;rà®¶âªÂ»à®·ÆAapâªâªâªrÃ²â¥±rr;æ®ar;æ«²Æ;svà¾âªà¾Ä;dâª¡âª¢æ¼;æºcy;äÎAEadestâª·âªºâª¾â«â«â«¶â«¹rÃ²â¥¦;ìâ¦Ì¸rr;ær;æ¥È;fqsà°»â«â«£â«¯tÄarâ«â«rroÃ·â«ightarroÃ·âªÆ;qsà°»âªºâ«ªlanÃ´à±Ä;sà±â«´Â»à°¶iÃ­à±Ä;rà°µâ«¾iÄ;eà°à°¥iÃ¤à¶Äptâ¬â¬f;ìðèÂ¬;inâ¬â¬â¬¶ä¬nÈ;Edvà®â¬¤â¬¨â¬®;ìâ¹Ì¸ot;ìâµÌ¸Ç¡à®â¬³â¬µ;æ·;æ¶iÄ;và²¸â¬¼Ç¡à²¸â­â­;æ¾;æ½Æaorâ­â­£â­©rÈ;astà­»â­â­â­lleÃ¬à­»l;ìâ«½â¥;ìâÌ¸lint;æ¨Æ;ceà²â­°â­³uÃ¥à²¥Ä;cà²â­¸Ä;eà²â­½Ã±à²ÈAaitâ®â®â®â®§rÃ²â¦rrÆ;cwâ®â®â®æ;ìâ¤³Ì¸;ìâÌ¸ghtarrowÂ»â®riÄ;eà³à³Îchimpquâ®½â¯â¯â¬à­¸â¯¤â¯¯È;cerà´²â¯à´·â¯uÃ¥àµ;ìðortÉ­â¬\0\0â¯arÃ¡â­mÄ;eàµ®â¯Ä;qàµ´àµ³suÄbpâ¯«â¯­Ã¥à³¸Ã¥à´Æbcpâ¯¶â°â°È;Eesâ¯¿â°à´¢â°æ;ìâ«Ì¸etÄ;eà´â°qÄ;qà´£â°cÄ;eà´²â°Ã±à´¸È;Eesâ°¢â°£àµâ°§æ;ìâ«Ì¸etÄ;eàµâ°®qÄ;qàµ â°£Ègilrâ°½â°¿â±â±Ã¬à¯ldeè»Ã±ä±Ã§à±iangleÄlrâ±â±eftÄ;eà°â±Ã±à°¦ightÄ;eà³â±¥Ã±à³Ä;mâ±¬â±­ä½Æ;esâ±´â±µâ±¹ä£ro;æp;æÒDHadgilrsâ²â²â²â²â²£â²°â²¶â³â³£ash;æ­arr;æ¤p;ìââash;æ¬Äetâ²¨â²¬;ìâ¥â;ì>ânfin;æ§ÆAetâ²½â³â³rr;æ¤;ìâ¤âÄ;râ³â³ì<âie;ìâ´âÄAtâ³â³rr;æ¤rie;ìâµâim;ìâ¼âÆAanâ³°â³´â´rr;ærÄhrâ³ºâ³½k;æ¤£Ä;oá§á¥ear;æ¤§ááª\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµâµ âµ¥âµ²â¶á¬\0\0â¶â¶«\0â·â·\0â·â¸â¸«â¸¾â¹Äcsâ´±áªuteè»Ã³ä³Äiyâ´¼âµrÄ;cáªâµè»Ã´ä´;ä¾Êabiosáª âµâµÇâµlac;äv;æ¨¸old;æ¦¼lig;äÄcrâµ©âµ­ir;æ¦¿;ìð¬Í¯âµ¹\0\0âµ¼\0â¶n;äaveè»Ã²ä²;æ§Äbmâ¶à·´ar;æ¦µÈacitâ¶â¶â¶¥â¶¨rÃ²áªÄirâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹;æ§Æaeiâ¶±â¶µâ¶¹cr;äga;äÆcdnâ·â·Çron;ä¿;æ¦¶pf;ìð Æaelâ·â·Çr;æ¦·rp;æ¦¹Î;adiosvâ·ªâ·«â·®â¸â¸â¸â¸æ¨rÃ²áªÈ;efmâ··â·¸â¸â¸æ©rÄ;oâ·¾â·¿æ´fÂ»â·¿è»Âªäªè»Âºäºgof;æ¶r;æ©lope;æ©;æ©Æcloâ¸â¸¡â¸§Ã²â¸ashè»Ã¸ä¸l;æiÅ¬â¸¯â¸´deè»ÃµäµesÄ;aÇâ¸ºs;æ¨¶mlè»Ã¶ä¶bar;æ½à«¡â¹\0â¹½\0âºâº\0âº¢âº¹\0\0â»àº\0â¼\0\0â¼«â¾¼\0â¿rÈ;astÐâ¹§â¹²àºèÂ¶;lâ¹­â¹®ä¶leÃ¬ÐÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊcimptâºâºâºá¡¥âºnt;ä¥od;ä®il;æ°enk;æ±r;ìð­Æimoâº¨âº°âº´Ä;vâº­âº®ä;ämaÃ´à©¶ne;æÆ;tvâº¿â»â»ächforkÂ»á¿½;äÄauâ»â»nÄckâ»â»kÄ;hâ´â»;æÃ¶â´sÒ;abcdemstâ»³â»´á¤â»¹â»½â¼â¼â¼â¼ä«cir;æ¨£ir;æ¨¢Äouáµâ¼;æ¨¥;æ©²nè»Â±àºim;æ¨¦wo;æ¨§Æipuâ¼â¼ â¼¥ntint;æ¨f;ìð¡ndè»Â£ä£Ô;Eaceinosuà»â¼¿â½â½â½â¾â¾â¾â½¾â¾¶;æª³p;æª·uÃ¥à»Ä;cà»â½Ì;acensà»â½â½â½¦â½¨â½¾pproÃ¸â½urlyeÃ±à»Ã±à»Æaesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ¨iÃ­à»meÄ;sâ¾àº®æ²ÆEasâ½¸â¾â½ºÃ°â½µÆdfpà»¬â¾â¾¯Æalsâ¾ â¾¥â¾ªlar;æ®ine;æurf;æÄ;tà»»â¾´Ã¯à»»rel;æ°Äciâ¿â¿r;ìð;äncsp;æÌfiopsuâ¿â¢â¿â¿¥â¿«â¿±r;ìð®pf;ìð¢rime;æcr;ìðÆaeoâ¿¸ããtÄeiâ¿¾ãrnionÃ³Ú°nt;æ¨stÄ;eããä¿Ã±á¼Ã´à¼àªABHabcdefhilmnoprstuxããããã ãã«ãã¢ã²ãããã¤ã©ãã®ã²ãã°ã·ÆartãããrÃ²á³Ã²Ïail;æ¤arÃ²á±¥ar;æ¥¤Îcdenqrtã¨ãµã¸ã¿ãããÄeuã­ã±;ìâ½Ì±te;äiÃ£á®mptyv;æ¦³gÈ;delà¿ããã;æ¦;æ¦¥Ã¥à¿uoè»Â»ä»rÖ;abcfhlpstwà¿ã¬ã¯ã·ã¹ã¼ã¾ããããp;æ¥µÄ;fà¿ ã´s;æ¤ ;æ¤³s;æ¤Ã«âÃ°â®l;æ¥im;æ¥´l;æ£;æÄaiããil;æ¤oÄ;nããæ¶alÃ³à¼Æabrã§ãªã®rÃ²á¥rk;æ³Äakã³ã½cÄekã¹ã»;ä½;äÄesãã;æ¦lÄduãã;æ¦;æ¦Èaeuyããã§ã©ron;äÄdiã¡ã¥il;äÃ¬à¿²Ã¢ãº;äÈclqsã´ã·ã½ãa;æ¤·dhar;æ¥©uoÄ;rÈÈh;æ³Æacgããà½lÈ;ipsà½¸ããánÃ¥á»arÃ´à¾©t;æ­Æilrã©á£ã®sht;æ¥½;ìð¯Äaoã·ãrÄduã½ã¿Â»Ñ»Ä;láã;æ¥¬Ä;vããä;ä±Ægnsãã¹ã¼htÌahlrstã¤ã°ããã¤ã®rrowÄ;tà¿ã­aÃ©ãarpoonÄduã»ã¿owÃ®ã¾pÂ»áeftÄahããrrowÃ³à¿ªarpoonÃ³Õightarrows;æquigarroÃ·ãhreetimes;æg;äingdotseÃ±á¼²ÆahmãããrÃ²à¿ªaÃ²Õ;æoustÄ;aããæ±cheÂ»ãmid;æ«®Èabptã²ã½ããÄnrã·ãºg;æ­r;æ¾rÃ«áÆaflãããr;æ¦;ìð£us;æ¨®imes;æ¨µÄapãã§rÄ;gã£ã¤ä©t;æ¦olint;æ¨arÃ²ã£Èachqã»ãá¼ãquo;æºr;ìðÄbuã»ãoÄ;rÈÈÆhirããã reÃ¥ã¸mes;æiÈ;eflãªáá ¡ã«æ¹tri;æ§luhar;æ¥¨;æàµ¡ãããã¬ã¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ããã­ã±ãã±\0ã\0\0ã³cute;äquÃ¯âºÔ;Eaceinpsyá­ã³ãµã¿ããããã¦ã©;æª´Ç°ãº\0ã¼;æª¸on;ä¡uÃ¥á¾Ä;dá³ãil;ärc;äÆEasããã;æª¶p;æªºim;æ©olint;æ¨iÃ­á;äotÆ;beã´áµãµæ;æ©¦ÎAacmstxãããããã£ã­rr;ærÄhrããÃ«â¨Ä;oà¨¶à¨´tè»Â§ä§i;ä»war;æ¤©mÄinã©Ã°nuÃ³Ã±t;æ¶rÄ;oã¶âìð°Èacoyãããã rp;æ¯Ähyããcy;ä;ärtÉ­ã\0\0ãiÃ¤á¤araÃ¬â¹¯è»Â­ä­Ägmã¨ã´maÆ;fvã±ã²ã²ä;äÐ;deglnprá«ãããããã¡ã¦ot;æ©ªÄ;qá±á°Ä;Eããæª;æª Ä;Eããæª;æªe;ælus;æ¨¤arr;æ¥²arÃ²á½Èaeitã¸ãããÄlsã½ãlsetmÃ©ãªhp;æ¨³parsl;æ§¤Ädlá£ãe;æ£Ä;eããæªªÄ;sã¢ã£æª¬;ìâª¬ï¸Æflpã®ã³ãtcy;äÄ;bã¸ã¹ä¯Ä;aã¾ã¿æ§r;æ¿f;ìð¤aÄdrãÐesÄ;uããæ itÂ»ãÆcsuã ã¹ãÄauã¥ã¯pÄ;sáã«;ìâï¸pÄ;sá´ãµ;ìâï¸uÄbpã¿ãÆ;esááãetÄ;eáãÃ±áÆ;esá¨á­ãetÄ;eá¨ãÃ±á®Æ;afá»ã¦Ö°rÅ¥ã«Ö±Â»á¼arÃ²áÈcemtã¹ã¾ããr;ìðtmÃ®Ã±iÃ¬ãarÃ¦á¾ÄarããrÄ;fãá¿æÄanãã­ightÄepã£ãªpsiloÃ®á» hÃ©âº¯sÂ»â¡Êbcmnpã»ãáããÒ;Edemnprsãããããã£ã¬ã±ã¶æ;æ«ot;æª½Ä;dáãot;æ«ult;æ«ÄEeã¨ãª;æ«;ælus;æª¿arr;æ¥¹Æeiuã½ããtÆ;enãããqÄ;qáãeqÄ;qã«ã¨m;æ«Äbpãã;æ«;æ«cÌ;acensá­ã¬ã²ã¹ã»ã¦pproÃ¸ãºurlyeÃ±á¾Ã±á³ÆaesãããpproÃ¸ãqÃ±ãg;æªÚ123;Edehlmnpsã©ã¬ã¯áã²ã´ãããããã¨ã­è»Â¹ä¹è»Â²ä²è»Â³ä³;æ«Äosã¹ã¼t;æª¾ub;æ«Ä;dá¢ãot;æ«sÄouããl;æb;æ«arr;æ¥»ult;æ«ÄEeã¤ã¦;æ«;ælus;æ«Æeiuã´ããtÆ;enáã¼ãqÄ;qá¢ã²eqÄ;qã§ã¤m;æ«Äbpãã;æ«;æ«ÆAanãã ã­rr;ærÄhrã¦ã¨Ã«â®Ä;oà¨«à¨©war;æ¤ªligè»Ãäà¯¡ããã áã³ã¹\0ã¾ã\0\0\0\0\0ãã\0ãã¬\0\0\0ãÉ²ã\0\0ãget;æ;ärÃ«à¹Æaeyã¦ã«ã°ron;ä¥dil;ä£;älrec;ær;ìð±Èeikoãããµã¼Ç²ã\0ãeÄ4fááaÆ;svãããä¸ym;äÄcnã¢ã²kÄasã¨ã®pproÃ¸áimÂ»á¬sÃ°áÄasãºã®Ã°árnè»Ã¾ä¾Ç¬Ìãâ§esèÃ;bdãããäÄ;aá¤ãr;æ¨±;æ¨°Æepsã¡ã£ãÃ¡â©È;bcfÒã¬ã°ã´ot;æ¶ir;æ«±Ä;oã¹ã¼ìð¥rk;æ«Ã¡ã¢rime;æ´Æaipããã¤dÃ¥áÎadempstã¡ããããããngleÊ;dlqrã°ã±ã¶ããæµownÂ»á¶»eftÄ;eâ ã¾Ã±à¤®;æightÄ;eãªãÃ±áot;æ¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æchtã²ã½ãÄryã·ã»;ìð;äcy;ärok;ä§ÄioããxÃ´á·headÄlrãã eftarroÃ·à¡ightarrowÂ»à½à¤AHabcdfghlmoprstuwãããã¤ã°ã¼ã ã ã £ã ´ã¡ã¡ã¡«ã¢©ã£ã£ã£ªã£¶rÃ²Ï­ar;æ¥£Äcrãã¢uteè»ÃºäºÃ²árÇ£ãª\0ã­y;äve;ä­Äiyãµãºrcè»Ã»ä»;äÆabhã ã ã rÃ²á­lac;ä±aÃ²áÄirã ã sht;æ¥¾;ìð²raveè»Ã¹ä¹Å¡ã §ã ±rÄlrã ¬ã ®Â»à¥Â»álk;æÄctã ¹ã¡É¯ã ¿\0\0ã¡rnÄ;eã¡ã¡ærÂ»ã¡op;æri;æ¸Äalã¡ã¡cr;ä«è»Â¨ÍÄgpã¡¢ã¡¦on;ä³f;ìð¦Ìadhlsuáã¡¸ã¡½á²ã¢ã¢ ownÃ¡á³arpoonÄlrã¢ã¢efÃ´ã ­ighÃ´ã ¯iÆ;hlã¢ã¢ã¢äÂ»áºonÂ»ã¢parrows;æÆcitã¢°ã£ã£É¯ã¢¶\0\0ã£rnÄ;eã¢¼ã¢½ærÂ»ã¢½op;æng;ä¯ri;æ¹cr;ìðÆdirã£ã£ã£¢ot;æ°lde;ä©iÄ;fã°ã£¨Â»á Äamã£¯ã£²rÃ²ã¢¨lè»Ã¼ä¼angle;æ¦§ÞABDacdeflnoprszã¤ã¤ã¤©ã¤­ã¦µã¦¸ã¦½ã§ã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Änrã¤²ã¤·grt;æ¦Îeknprstã£ã¥ã¥ã¥ã¥ã¥¤ã¦appÃ¡âothinÃ§áºÆhirã«â»ã¥opÃ´â¾µÄ;há·ã¥¢Ã¯ãÄiuã¥©ã¥­gmÃ¡ã³Äbpã¥²ã¦setneqÄ;qã¥½ã¦ìâï¸;ìâ«ï¸setneqÄ;qã¦ã¦ìâï¸;ìâ«ï¸Ährã¦ã¦etÃ¡ãiangleÄlrã¦ªã¦¯eftÂ»à¤¥ightÂ»áy;ä²ashÂ»á¶Æelrã§ã§ã§Æ;beâ·ªã§ã§ar;æ»q;ælip;æ®Äbtã§á¨aÃ²á©r;ìð³trÃ©ã¦®suÄbpã§¯ã§±Â»à´Â»àµpf;ìð§roÃ°à»»trÃ©ã¦´Äcuã¨ã¨r;ìðÄbpã¨ã¨nÄEeã¦ã¨Â»ã¥¾nÄEeã¦ã¨Â»ã¦igzag;æ¦Îcefoprsã¨¶ã¨»ã©ã©ã©ã©¡ã©ªirc;äµÄdiã©ã©Äbgã©ã©ar;æ©eÄ;qáºã©;æerp;ær;ìð´pf;ìð¨Ä;eá¹ã©¦atÃ¨á¹cr;ìðà«£áãª\0ãª\0ãªãª\0\0ãªãª¨ãª«ãª¯\0\0ã«ã«\0ã«áátrÃ©ár;ìðµÄAaãªãªrÃ²ÏrÃ²à§¶;ä¾ÄAaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âis;æ»Ædptá¤ãªµãª¾Äflãªºá©;ìð©imÃ¥á²ÄAaã«ã«rÃ²ÏrÃ²à¨Äcqã«á¸r;ìðÄptáã«rÃ©áÐacefiosuã«°ã«½ã¬ã¬ã¬ã¬ã¬ã¬¡cÄuyã«¶ã«»teè»Ã½ä½;äÄiyã¬ã¬rc;ä·;änè»Â¥ä¥r;ìð¶cy;äpf;ìðªcr;ìðÄcmã¬¦ã¬©y;älè»Ã¿ä¿Ôacdefhioswã­ã­ã­ã­ã­¤ã­©ã­­ã­´ã­ºã®cute;äºÄayã­ã­ron;ä¾;ä·ot;ä¼Äetã­ã­¡trÃ¦áa;ä¶r;ìð·cy;ä¶grarr;æpf;ìð«cr;ìðÄjnã®ã®;æj;æ'.split("").map((u) => u.charCodeAt(0))
  )), mb;
}
var vb = {}, hL;
function pL() {
  return hL || (hL = 1, Object.defineProperty(vb, "__esModule", { value: !0 }), vb.xmlDecodeTree = void 0, vb.xmlDecodeTree = new Uint16Array(
    // prettier-ignore
    /* @__PURE__ */ "Èaglq	\x1BÉ­\0\0p;ä¦os;ä§t;ä¾t;ä¼uot;ä¢".split("").map((u) => u.charCodeAt(0))
  )), vb;
}
var CE = {}, bL;
function yL() {
  return bL || (bL = 1, function(u) {
    var r;
    Object.defineProperty(u, "__esModule", { value: !0 }), u.fromCodePoint = void 0, u.replaceCodePoint = a, u.decodeCodePoint = t;
    const o = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    u.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
    (r = String.fromCodePoint) !== null && r !== void 0 ? r : function(e) {
      let n = "";
      return e > 65535 && (e -= 65536, n += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), n += String.fromCharCode(e), n;
    };
    function a(e) {
      var n;
      return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (n = o.get(e)) !== null && n !== void 0 ? n : e;
    }
    function t(e) {
      return (0, u.fromCodePoint)(a(e));
    }
  }(CE)), CE;
}
var _L;
function bY() {
  return _L || (_L = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.fromCodePoint = u.replaceCodePoint = u.decodeCodePoint = u.xmlDecodeTree = u.htmlDecodeTree = u.EntityDecoder = u.DecodingMode = u.BinTrieFlags = void 0, u.determineBranch = b, u.decodeHTML = m, u.decodeHTMLAttribute = g, u.decodeHTMLStrict = T, u.decodeXML = v;
    const r = fL(), o = pL(), a = yL();
    var t;
    (function(A) {
      A[A.NUM = 35] = "NUM", A[A.SEMI = 59] = "SEMI", A[A.EQUALS = 61] = "EQUALS", A[A.ZERO = 48] = "ZERO", A[A.NINE = 57] = "NINE", A[A.LOWER_A = 97] = "LOWER_A", A[A.LOWER_F = 102] = "LOWER_F", A[A.LOWER_X = 120] = "LOWER_X", A[A.LOWER_Z = 122] = "LOWER_Z", A[A.UPPER_A = 65] = "UPPER_A", A[A.UPPER_F = 70] = "UPPER_F", A[A.UPPER_Z = 90] = "UPPER_Z";
    })(t || (t = {}));
    const e = 32;
    var n;
    (function(A) {
      A[A.VALUE_LENGTH = 49152] = "VALUE_LENGTH", A[A.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", A[A.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(n || (u.BinTrieFlags = n = {}));
    function i(A) {
      return A >= t.ZERO && A <= t.NINE;
    }
    function c(A) {
      return A >= t.UPPER_A && A <= t.UPPER_F || A >= t.LOWER_A && A <= t.LOWER_F;
    }
    function s(A) {
      return A >= t.UPPER_A && A <= t.UPPER_Z || A >= t.LOWER_A && A <= t.LOWER_Z || i(A);
    }
    function d(A) {
      return A === t.EQUALS || s(A);
    }
    var l;
    (function(A) {
      A[A.EntityStart = 0] = "EntityStart", A[A.NumericStart = 1] = "NumericStart", A[A.NumericDecimal = 2] = "NumericDecimal", A[A.NumericHex = 3] = "NumericHex", A[A.NamedEntity = 4] = "NamedEntity";
    })(l || (l = {}));
    var f;
    (function(A) {
      A[A.Legacy = 0] = "Legacy", A[A.Strict = 1] = "Strict", A[A.Attribute = 2] = "Attribute";
    })(f || (u.DecodingMode = f = {}));
    class h {
      constructor(w, S, O) {
        this.decodeTree = w, this.emitCodePoint = S, this.errors = O, this.state = l.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = f.Strict;
      }
      /** Resets the instance to make it reusable. */
      startEntity(w) {
        this.decodeMode = w, this.state = l.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }
      /**
       * Write an entity to the decoder. This can be called multiple times with partial entities.
       * If the entity is incomplete, the decoder will return -1.
       *
       * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
       * entity is incomplete, and resume when the next string is written.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      write(w, S) {
        switch (this.state) {
          case l.EntityStart:
            return w.charCodeAt(S) === t.NUM ? (this.state = l.NumericStart, this.consumed += 1, this.stateNumericStart(w, S + 1)) : (this.state = l.NamedEntity, this.stateNamedEntity(w, S));
          case l.NumericStart:
            return this.stateNumericStart(w, S);
          case l.NumericDecimal:
            return this.stateNumericDecimal(w, S);
          case l.NumericHex:
            return this.stateNumericHex(w, S);
          case l.NamedEntity:
            return this.stateNamedEntity(w, S);
        }
      }
      /**
       * Switches between the numeric decimal and hexadecimal states.
       *
       * Equivalent to the `Numeric character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericStart(w, S) {
        return S >= w.length ? -1 : (w.charCodeAt(S) | e) === t.LOWER_X ? (this.state = l.NumericHex, this.consumed += 1, this.stateNumericHex(w, S + 1)) : (this.state = l.NumericDecimal, this.stateNumericDecimal(w, S));
      }
      addToNumericResult(w, S, O, x) {
        if (S !== O) {
          const F = O - S;
          this.result = this.result * Math.pow(x, F) + Number.parseInt(w.substr(S, F), x), this.consumed += F;
        }
      }
      /**
       * Parses a hexadecimal numeric entity.
       *
       * Equivalent to the `Hexademical character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericHex(w, S) {
        const O = S;
        for (; S < w.length; ) {
          const x = w.charCodeAt(S);
          if (i(x) || c(x))
            S += 1;
          else
            return this.addToNumericResult(w, O, S, 16), this.emitNumericEntity(x, 3);
        }
        return this.addToNumericResult(w, O, S, 16), -1;
      }
      /**
       * Parses a decimal numeric entity.
       *
       * Equivalent to the `Decimal character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericDecimal(w, S) {
        const O = S;
        for (; S < w.length; ) {
          const x = w.charCodeAt(S);
          if (i(x))
            S += 1;
          else
            return this.addToNumericResult(w, O, S, 10), this.emitNumericEntity(x, 2);
        }
        return this.addToNumericResult(w, O, S, 10), -1;
      }
      /**
       * Validate and emit a numeric entity.
       *
       * Implements the logic from the `Hexademical character reference start
       * state` and `Numeric character reference end state` in the HTML spec.
       *
       * @param lastCp The last code point of the entity. Used to see if the
       *               entity was terminated with a semicolon.
       * @param expectedLength The minimum number of characters that should be
       *                       consumed. Used to validate that at least one digit
       *                       was consumed.
       * @returns The number of characters that were consumed.
       */
      emitNumericEntity(w, S) {
        var O;
        if (this.consumed <= S)
          return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (w === t.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === f.Strict)
          return 0;
        return this.emitCodePoint((0, a.replaceCodePoint)(this.result), this.consumed), this.errors && (w !== t.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }
      /**
       * Parses a named entity.
       *
       * Equivalent to the `Named character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNamedEntity(w, S) {
        const { decodeTree: O } = this;
        let x = O[this.treeIndex], F = (x & n.VALUE_LENGTH) >> 14;
        for (; S < w.length; S++, this.excess++) {
          const j = w.charCodeAt(S);
          if (this.treeIndex = b(O, x, this.treeIndex + Math.max(1, F), j), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === f.Attribute && // We shouldn't have consumed any characters after the entity,
            (F === 0 || // And there should be no invalid characters.
            d(j)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (x = O[this.treeIndex], F = (x & n.VALUE_LENGTH) >> 14, F !== 0) {
            if (j === t.SEMI)
              return this.emitNamedEntityData(this.treeIndex, F, this.consumed + this.excess);
            this.decodeMode !== f.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }
      /**
       * Emit a named entity that was not terminated with a semicolon.
       *
       * @returns The number of characters consumed.
       */
      emitNotTerminatedNamedEntity() {
        var w;
        const { result: S, decodeTree: O } = this, x = (O[S] & n.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(S, x, this.consumed), (w = this.errors) === null || w === void 0 || w.missingSemicolonAfterCharacterReference(), this.consumed;
      }
      /**
       * Emit a named entity.
       *
       * @param result The index of the entity in the decode tree.
       * @param valueLength The number of bytes in the entity.
       * @param consumed The number of characters consumed.
       *
       * @returns The number of characters consumed.
       */
      emitNamedEntityData(w, S, O) {
        const { decodeTree: x } = this;
        return this.emitCodePoint(S === 1 ? x[w] & ~n.VALUE_LENGTH : x[w + 1], O), S === 3 && this.emitCodePoint(x[w + 2], O), O;
      }
      /**
       * Signal to the parser that the end of the input was reached.
       *
       * Remaining data will be emitted and relevant errors will be produced.
       *
       * @returns The number of characters consumed.
       */
      end() {
        var w;
        switch (this.state) {
          case l.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== f.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          // Otherwise, emit a numeric entity if we have one.
          case l.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case l.NumericHex:
            return this.emitNumericEntity(0, 3);
          case l.NumericStart:
            return (w = this.errors) === null || w === void 0 || w.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case l.EntityStart:
            return 0;
        }
      }
    }
    u.EntityDecoder = h;
    function p(A) {
      let w = "";
      const S = new h(A, (O) => w += (0, a.fromCodePoint)(O));
      return function(x, F) {
        let j = 0, q = 0;
        for (; (q = x.indexOf("&", q)) >= 0; ) {
          w += x.slice(j, q), S.startEntity(F);
          const G = S.write(
            x,
            // Skip the "&"
            q + 1
          );
          if (G < 0) {
            j = q + S.end();
            break;
          }
          j = q + G, q = G === 0 ? j + 1 : j;
        }
        const Q = w + x.slice(j);
        return w = "", Q;
      };
    }
    function b(A, w, S, O) {
      const x = (w & n.BRANCH_LENGTH) >> 7, F = w & n.JUMP_TABLE;
      if (x === 0)
        return F !== 0 && O === F ? S : -1;
      if (F) {
        const Q = O - F;
        return Q < 0 || Q >= x ? -1 : A[S + Q] - 1;
      }
      let j = S, q = j + x - 1;
      for (; j <= q; ) {
        const Q = j + q >>> 1, G = A[Q];
        if (G < O)
          j = Q + 1;
        else if (G > O)
          q = Q - 1;
        else
          return A[Q + x];
      }
      return -1;
    }
    const _ = /* @__PURE__ */ p(r.htmlDecodeTree), y = /* @__PURE__ */ p(o.xmlDecodeTree);
    function m(A, w = f.Legacy) {
      return _(A, w);
    }
    function g(A) {
      return _(A, f.Attribute);
    }
    function T(A) {
      return _(A, f.Strict);
    }
    function v(A) {
      return y(A, f.Strict);
    }
    var E = fL();
    Object.defineProperty(u, "htmlDecodeTree", { enumerable: !0, get: function() {
      return E.htmlDecodeTree;
    } });
    var R = pL();
    Object.defineProperty(u, "xmlDecodeTree", { enumerable: !0, get: function() {
      return R.xmlDecodeTree;
    } });
    var L = yL();
    Object.defineProperty(u, "decodeCodePoint", { enumerable: !0, get: function() {
      return L.decodeCodePoint;
    } }), Object.defineProperty(u, "replaceCodePoint", { enumerable: !0, get: function() {
      return L.replaceCodePoint;
    } }), Object.defineProperty(u, "fromCodePoint", { enumerable: !0, get: function() {
      return L.fromCodePoint;
    } });
  }(ME)), ME;
}
var gL;
function yY() {
  if (gL) return w0;
  gL = 1, Object.defineProperty(w0, "__esModule", { value: !0 }), w0.QuoteType = void 0;
  const u = /* @__PURE__ */ bY();
  var r;
  (function(s) {
    s[s.Tab = 9] = "Tab", s[s.NewLine = 10] = "NewLine", s[s.FormFeed = 12] = "FormFeed", s[s.CarriageReturn = 13] = "CarriageReturn", s[s.Space = 32] = "Space", s[s.ExclamationMark = 33] = "ExclamationMark", s[s.Number = 35] = "Number", s[s.Amp = 38] = "Amp", s[s.SingleQuote = 39] = "SingleQuote", s[s.DoubleQuote = 34] = "DoubleQuote", s[s.Dash = 45] = "Dash", s[s.Slash = 47] = "Slash", s[s.Zero = 48] = "Zero", s[s.Nine = 57] = "Nine", s[s.Semi = 59] = "Semi", s[s.Lt = 60] = "Lt", s[s.Eq = 61] = "Eq", s[s.Gt = 62] = "Gt", s[s.Questionmark = 63] = "Questionmark", s[s.UpperA = 65] = "UpperA", s[s.LowerA = 97] = "LowerA", s[s.UpperF = 70] = "UpperF", s[s.LowerF = 102] = "LowerF", s[s.UpperZ = 90] = "UpperZ", s[s.LowerZ = 122] = "LowerZ", s[s.LowerX = 120] = "LowerX", s[s.OpeningSquareBracket = 91] = "OpeningSquareBracket";
  })(r || (r = {}));
  var o;
  (function(s) {
    s[s.Text = 1] = "Text", s[s.BeforeTagName = 2] = "BeforeTagName", s[s.InTagName = 3] = "InTagName", s[s.InSelfClosingTag = 4] = "InSelfClosingTag", s[s.BeforeClosingTagName = 5] = "BeforeClosingTagName", s[s.InClosingTagName = 6] = "InClosingTagName", s[s.AfterClosingTagName = 7] = "AfterClosingTagName", s[s.BeforeAttributeName = 8] = "BeforeAttributeName", s[s.InAttributeName = 9] = "InAttributeName", s[s.AfterAttributeName = 10] = "AfterAttributeName", s[s.BeforeAttributeValue = 11] = "BeforeAttributeValue", s[s.InAttributeValueDq = 12] = "InAttributeValueDq", s[s.InAttributeValueSq = 13] = "InAttributeValueSq", s[s.InAttributeValueNq = 14] = "InAttributeValueNq", s[s.BeforeDeclaration = 15] = "BeforeDeclaration", s[s.InDeclaration = 16] = "InDeclaration", s[s.InProcessingInstruction = 17] = "InProcessingInstruction", s[s.BeforeComment = 18] = "BeforeComment", s[s.CDATASequence = 19] = "CDATASequence", s[s.InSpecialComment = 20] = "InSpecialComment", s[s.InCommentLike = 21] = "InCommentLike", s[s.BeforeSpecialS = 22] = "BeforeSpecialS", s[s.BeforeSpecialT = 23] = "BeforeSpecialT", s[s.SpecialStartSequence = 24] = "SpecialStartSequence", s[s.InSpecialTag = 25] = "InSpecialTag", s[s.InEntity = 26] = "InEntity";
  })(o || (o = {}));
  function a(s) {
    return s === r.Space || s === r.NewLine || s === r.Tab || s === r.FormFeed || s === r.CarriageReturn;
  }
  function t(s) {
    return s === r.Slash || s === r.Gt || a(s);
  }
  function e(s) {
    return s >= r.LowerA && s <= r.LowerZ || s >= r.UpperA && s <= r.UpperZ;
  }
  var n;
  (function(s) {
    s[s.NoValue = 0] = "NoValue", s[s.Unquoted = 1] = "Unquoted", s[s.Single = 2] = "Single", s[s.Double = 3] = "Double";
  })(n || (w0.QuoteType = n = {}));
  const i = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    // CDATA[
    CdataEnd: new Uint8Array([93, 93, 62]),
    // ]]>
    CommentEnd: new Uint8Array([45, 45, 62]),
    // `-->`
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    // `<\/script`
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    // `</style`
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    // `</title`
    TextareaEnd: new Uint8Array([
      60,
      47,
      116,
      101,
      120,
      116,
      97,
      114,
      101,
      97
    ]),
    // `</textarea`
    XmpEnd: new Uint8Array([60, 47, 120, 109, 112])
    // `</xmp`
  };
  class c {
    constructor({ xmlMode: d = !1, decodeEntities: l = !0 }, f) {
      this.cbs = f, this.state = o.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = o.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = d, this.decodeEntities = l, this.entityDecoder = new u.EntityDecoder(d ? u.xmlDecodeTree : u.htmlDecodeTree, (h, p) => this.emitCodePoint(h, p));
    }
    reset() {
      this.state = o.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = o.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
    }
    write(d) {
      this.offset += this.buffer.length, this.buffer = d, this.parse();
    }
    end() {
      this.running && this.finish();
    }
    pause() {
      this.running = !1;
    }
    resume() {
      this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
    }
    stateText(d) {
      d === r.Lt || !this.decodeEntities && this.fastForwardTo(r.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = o.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && d === r.Amp && this.startEntity();
    }
    stateSpecialStartSequence(d) {
      const l = this.sequenceIndex === this.currentSequence.length;
      if (!(l ? (
        // If we are at the end of the sequence, make sure the tag name has ended
        t(d)
      ) : (
        // Otherwise, do a case-insensitive comparison
        (d | 32) === this.currentSequence[this.sequenceIndex]
      )))
        this.isSpecial = !1;
      else if (!l) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0, this.state = o.InTagName, this.stateInTagName(d);
    }
    /** Look for an end tag. For <title> tags, also decode entities. */
    stateInSpecialTag(d) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (d === r.Gt || a(d)) {
          const l = this.index - this.currentSequence.length;
          if (this.sectionStart < l) {
            const f = this.index;
            this.index = l, this.cbs.ontext(this.sectionStart, l), this.index = f;
          }
          this.isSpecial = !1, this.sectionStart = l + 2, this.stateInClosingTagName(d);
          return;
        }
        this.sequenceIndex = 0;
      }
      (d | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === i.TitleEnd ? this.decodeEntities && d === r.Amp && this.startEntity() : this.fastForwardTo(r.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(d === r.Lt);
    }
    stateCDATASequence(d) {
      d === i.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === i.Cdata.length && (this.state = o.InCommentLike, this.currentSequence = i.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = o.InDeclaration, this.stateInDeclaration(d));
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(d) {
      for (; ++this.index < this.buffer.length + this.offset; )
        if (this.buffer.charCodeAt(this.index - this.offset) === d)
          return !0;
      return this.index = this.buffer.length + this.offset - 1, !1;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(d) {
      d === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === i.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = o.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : d !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
    }
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    isTagStartChar(d) {
      return this.xmlMode ? !t(d) : e(d);
    }
    startSpecial(d, l) {
      this.isSpecial = !0, this.currentSequence = d, this.sequenceIndex = l, this.state = o.SpecialStartSequence;
    }
    stateBeforeTagName(d) {
      if (d === r.ExclamationMark)
        this.state = o.BeforeDeclaration, this.sectionStart = this.index + 1;
      else if (d === r.Questionmark)
        this.state = o.InProcessingInstruction, this.sectionStart = this.index + 1;
      else if (this.isTagStartChar(d)) {
        const l = d | 32;
        this.sectionStart = this.index, this.xmlMode ? this.state = o.InTagName : l === i.ScriptEnd[2] ? this.state = o.BeforeSpecialS : l === i.TitleEnd[2] || l === i.XmpEnd[2] ? this.state = o.BeforeSpecialT : this.state = o.InTagName;
      } else d === r.Slash ? this.state = o.BeforeClosingTagName : (this.state = o.Text, this.stateText(d));
    }
    stateInTagName(d) {
      t(d) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = o.BeforeAttributeName, this.stateBeforeAttributeName(d));
    }
    stateBeforeClosingTagName(d) {
      a(d) || (d === r.Gt ? this.state = o.Text : (this.state = this.isTagStartChar(d) ? o.InClosingTagName : o.InSpecialComment, this.sectionStart = this.index));
    }
    stateInClosingTagName(d) {
      (d === r.Gt || a(d)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = o.AfterClosingTagName, this.stateAfterClosingTagName(d));
    }
    stateAfterClosingTagName(d) {
      (d === r.Gt || this.fastForwardTo(r.Gt)) && (this.state = o.Text, this.sectionStart = this.index + 1);
    }
    stateBeforeAttributeName(d) {
      d === r.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = o.InSpecialTag, this.sequenceIndex = 0) : this.state = o.Text, this.sectionStart = this.index + 1) : d === r.Slash ? this.state = o.InSelfClosingTag : a(d) || (this.state = o.InAttributeName, this.sectionStart = this.index);
    }
    stateInSelfClosingTag(d) {
      d === r.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = o.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : a(d) || (this.state = o.BeforeAttributeName, this.stateBeforeAttributeName(d));
    }
    stateInAttributeName(d) {
      (d === r.Eq || t(d)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = o.AfterAttributeName, this.stateAfterAttributeName(d));
    }
    stateAfterAttributeName(d) {
      d === r.Eq ? this.state = o.BeforeAttributeValue : d === r.Slash || d === r.Gt ? (this.cbs.onattribend(n.NoValue, this.sectionStart), this.sectionStart = -1, this.state = o.BeforeAttributeName, this.stateBeforeAttributeName(d)) : a(d) || (this.cbs.onattribend(n.NoValue, this.sectionStart), this.state = o.InAttributeName, this.sectionStart = this.index);
    }
    stateBeforeAttributeValue(d) {
      d === r.DoubleQuote ? (this.state = o.InAttributeValueDq, this.sectionStart = this.index + 1) : d === r.SingleQuote ? (this.state = o.InAttributeValueSq, this.sectionStart = this.index + 1) : a(d) || (this.sectionStart = this.index, this.state = o.InAttributeValueNq, this.stateInAttributeValueNoQuotes(d));
    }
    handleInAttributeValue(d, l) {
      d === l || !this.decodeEntities && this.fastForwardTo(l) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(l === r.DoubleQuote ? n.Double : n.Single, this.index + 1), this.state = o.BeforeAttributeName) : this.decodeEntities && d === r.Amp && this.startEntity();
    }
    stateInAttributeValueDoubleQuotes(d) {
      this.handleInAttributeValue(d, r.DoubleQuote);
    }
    stateInAttributeValueSingleQuotes(d) {
      this.handleInAttributeValue(d, r.SingleQuote);
    }
    stateInAttributeValueNoQuotes(d) {
      a(d) || d === r.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(n.Unquoted, this.index), this.state = o.BeforeAttributeName, this.stateBeforeAttributeName(d)) : this.decodeEntities && d === r.Amp && this.startEntity();
    }
    stateBeforeDeclaration(d) {
      d === r.OpeningSquareBracket ? (this.state = o.CDATASequence, this.sequenceIndex = 0) : this.state = d === r.Dash ? o.BeforeComment : o.InDeclaration;
    }
    stateInDeclaration(d) {
      (d === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = o.Text, this.sectionStart = this.index + 1);
    }
    stateInProcessingInstruction(d) {
      (d === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = o.Text, this.sectionStart = this.index + 1);
    }
    stateBeforeComment(d) {
      d === r.Dash ? (this.state = o.InCommentLike, this.currentSequence = i.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = o.InDeclaration;
    }
    stateInSpecialComment(d) {
      (d === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = o.Text, this.sectionStart = this.index + 1);
    }
    stateBeforeSpecialS(d) {
      const l = d | 32;
      l === i.ScriptEnd[3] ? this.startSpecial(i.ScriptEnd, 4) : l === i.StyleEnd[3] ? this.startSpecial(i.StyleEnd, 4) : (this.state = o.InTagName, this.stateInTagName(d));
    }
    stateBeforeSpecialT(d) {
      switch (d | 32) {
        case i.TitleEnd[3]: {
          this.startSpecial(i.TitleEnd, 4);
          break;
        }
        case i.TextareaEnd[3]: {
          this.startSpecial(i.TextareaEnd, 4);
          break;
        }
        case i.XmpEnd[3]: {
          this.startSpecial(i.XmpEnd, 4);
          break;
        }
        default:
          this.state = o.InTagName, this.stateInTagName(d);
      }
    }
    startEntity() {
      this.baseState = this.state, this.state = o.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? u.DecodingMode.Strict : this.baseState === o.Text || this.baseState === o.InSpecialTag ? u.DecodingMode.Legacy : u.DecodingMode.Attribute);
    }
    stateInEntity() {
      const d = this.entityDecoder.write(this.buffer, this.index - this.offset);
      d >= 0 ? (this.state = this.baseState, d === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
      this.running && this.sectionStart !== this.index && (this.state === o.Text || this.state === o.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === o.InAttributeValueDq || this.state === o.InAttributeValueSq || this.state === o.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
    }
    shouldContinue() {
      return this.index < this.buffer.length + this.offset && this.running;
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse() {
      for (; this.shouldContinue(); ) {
        const d = this.buffer.charCodeAt(this.index - this.offset);
        switch (this.state) {
          case o.Text: {
            this.stateText(d);
            break;
          }
          case o.SpecialStartSequence: {
            this.stateSpecialStartSequence(d);
            break;
          }
          case o.InSpecialTag: {
            this.stateInSpecialTag(d);
            break;
          }
          case o.CDATASequence: {
            this.stateCDATASequence(d);
            break;
          }
          case o.InAttributeValueDq: {
            this.stateInAttributeValueDoubleQuotes(d);
            break;
          }
          case o.InAttributeName: {
            this.stateInAttributeName(d);
            break;
          }
          case o.InCommentLike: {
            this.stateInCommentLike(d);
            break;
          }
          case o.InSpecialComment: {
            this.stateInSpecialComment(d);
            break;
          }
          case o.BeforeAttributeName: {
            this.stateBeforeAttributeName(d);
            break;
          }
          case o.InTagName: {
            this.stateInTagName(d);
            break;
          }
          case o.InClosingTagName: {
            this.stateInClosingTagName(d);
            break;
          }
          case o.BeforeTagName: {
            this.stateBeforeTagName(d);
            break;
          }
          case o.AfterAttributeName: {
            this.stateAfterAttributeName(d);
            break;
          }
          case o.InAttributeValueSq: {
            this.stateInAttributeValueSingleQuotes(d);
            break;
          }
          case o.BeforeAttributeValue: {
            this.stateBeforeAttributeValue(d);
            break;
          }
          case o.BeforeClosingTagName: {
            this.stateBeforeClosingTagName(d);
            break;
          }
          case o.AfterClosingTagName: {
            this.stateAfterClosingTagName(d);
            break;
          }
          case o.BeforeSpecialS: {
            this.stateBeforeSpecialS(d);
            break;
          }
          case o.BeforeSpecialT: {
            this.stateBeforeSpecialT(d);
            break;
          }
          case o.InAttributeValueNq: {
            this.stateInAttributeValueNoQuotes(d);
            break;
          }
          case o.InSelfClosingTag: {
            this.stateInSelfClosingTag(d);
            break;
          }
          case o.InDeclaration: {
            this.stateInDeclaration(d);
            break;
          }
          case o.BeforeDeclaration: {
            this.stateBeforeDeclaration(d);
            break;
          }
          case o.BeforeComment: {
            this.stateBeforeComment(d);
            break;
          }
          case o.InProcessingInstruction: {
            this.stateInProcessingInstruction(d);
            break;
          }
          case o.InEntity: {
            this.stateInEntity();
            break;
          }
        }
        this.index++;
      }
      this.cleanup();
    }
    finish() {
      this.state === o.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
      const d = this.buffer.length + this.offset;
      this.sectionStart >= d || (this.state === o.InCommentLike ? this.currentSequence === i.CdataEnd ? this.cbs.oncdata(this.sectionStart, d, 0) : this.cbs.oncomment(this.sectionStart, d, 0) : this.state === o.InTagName || this.state === o.BeforeAttributeName || this.state === o.BeforeAttributeValue || this.state === o.AfterAttributeName || this.state === o.InAttributeName || this.state === o.InAttributeValueSq || this.state === o.InAttributeValueDq || this.state === o.InAttributeValueNq || this.state === o.InClosingTagName || this.cbs.ontext(this.sectionStart, d));
    }
    emitCodePoint(d, l) {
      this.baseState !== o.Text && this.baseState !== o.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + l, this.index = this.sectionStart - 1, this.cbs.onattribentity(d)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + l, this.index = this.sectionStart - 1, this.cbs.ontextentity(d, this.sectionStart));
    }
  }
  return w0.default = c, w0;
}
var mL;
function vL() {
  if (mL) return ui;
  mL = 1;
  var u = ui && ui.__createBinding || (Object.create ? function(_, y, m, g) {
    g === void 0 && (g = m);
    var T = Object.getOwnPropertyDescriptor(y, m);
    (!T || ("get" in T ? !y.__esModule : T.writable || T.configurable)) && (T = { enumerable: !0, get: function() {
      return y[m];
    } }), Object.defineProperty(_, g, T);
  } : function(_, y, m, g) {
    g === void 0 && (g = m), _[g] = y[m];
  }), r = ui && ui.__setModuleDefault || (Object.create ? function(_, y) {
    Object.defineProperty(_, "default", { enumerable: !0, value: y });
  } : function(_, y) {
    _.default = y;
  }), o = ui && ui.__importStar || /* @__PURE__ */ function() {
    var _ = function(y) {
      return _ = Object.getOwnPropertyNames || function(m) {
        var g = [];
        for (var T in m) Object.prototype.hasOwnProperty.call(m, T) && (g[g.length] = T);
        return g;
      }, _(y);
    };
    return function(y) {
      if (y && y.__esModule) return y;
      var m = {};
      if (y != null) for (var g = _(y), T = 0; T < g.length; T++) g[T] !== "default" && u(m, y, g[T]);
      return r(m, y), m;
    };
  }();
  Object.defineProperty(ui, "__esModule", { value: !0 }), ui.Parser = void 0;
  const a = o(yY()), t = /* @__PURE__ */ bY(), e = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), n = /* @__PURE__ */ new Set(["p"]), i = /* @__PURE__ */ new Set(["thead", "tbody"]), c = /* @__PURE__ */ new Set(["dd", "dt"]), s = /* @__PURE__ */ new Set(["rt", "rp"]), d = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", n],
    ["h1", n],
    ["h2", n],
    ["h3", n],
    ["h4", n],
    ["h5", n],
    ["h6", n],
    ["select", e],
    ["input", e],
    ["output", e],
    ["button", e],
    ["datalist", e],
    ["textarea", e],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", c],
    ["dt", c],
    ["address", n],
    ["article", n],
    ["aside", n],
    ["blockquote", n],
    ["details", n],
    ["div", n],
    ["dl", n],
    ["fieldset", n],
    ["figcaption", n],
    ["figure", n],
    ["footer", n],
    ["form", n],
    ["header", n],
    ["hr", n],
    ["main", n],
    ["nav", n],
    ["ol", n],
    ["pre", n],
    ["section", n],
    ["table", n],
    ["ul", n],
    ["rt", s],
    ["rp", s],
    ["tbody", i],
    ["tfoot", i]
  ]), l = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), f = /* @__PURE__ */ new Set(["math", "svg"]), h = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]), p = /\s|\//;
  class b {
    constructor(y, m = {}) {
      var g, T, v, E, R, L;
      this.options = m, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = y ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (g = m.lowerCaseTags) !== null && g !== void 0 ? g : this.htmlMode, this.lowerCaseAttributeNames = (T = m.lowerCaseAttributeNames) !== null && T !== void 0 ? T : this.htmlMode, this.recognizeSelfClosing = (v = m.recognizeSelfClosing) !== null && v !== void 0 ? v : !this.htmlMode, this.tokenizer = new ((E = m.Tokenizer) !== null && E !== void 0 ? E : a.default)(this.options, this), this.foreignContext = [!this.htmlMode], (L = (R = this.cbs).onparserinit) === null || L === void 0 || L.call(R, this);
    }
    // Tokenizer event handlers
    /** @internal */
    ontext(y, m) {
      var g, T;
      const v = this.getSlice(y, m);
      this.endIndex = m - 1, (T = (g = this.cbs).ontext) === null || T === void 0 || T.call(g, v), this.startIndex = m;
    }
    /** @internal */
    ontextentity(y, m) {
      var g, T;
      this.endIndex = m - 1, (T = (g = this.cbs).ontext) === null || T === void 0 || T.call(g, (0, t.fromCodePoint)(y)), this.startIndex = m;
    }
    /**
     * Checks if the current tag is a void element. Override this if you want
     * to specify your own additional void elements.
     */
    isVoidElement(y) {
      return this.htmlMode && l.has(y);
    }
    /** @internal */
    onopentagname(y, m) {
      this.endIndex = m;
      let g = this.getSlice(y, m);
      this.lowerCaseTagNames && (g = g.toLowerCase()), this.emitOpenTag(g);
    }
    emitOpenTag(y) {
      var m, g, T, v;
      this.openTagStart = this.startIndex, this.tagname = y;
      const E = this.htmlMode && d.get(y);
      if (E)
        for (; this.stack.length > 0 && E.has(this.stack[0]); ) {
          const R = this.stack.shift();
          (g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, R, !0);
        }
      this.isVoidElement(y) || (this.stack.unshift(y), this.htmlMode && (f.has(y) ? this.foreignContext.unshift(!0) : h.has(y) && this.foreignContext.unshift(!1))), (v = (T = this.cbs).onopentagname) === null || v === void 0 || v.call(T, y), this.cbs.onopentag && (this.attribs = {});
    }
    endOpenTag(y) {
      var m, g;
      this.startIndex = this.openTagStart, this.attribs && ((g = (m = this.cbs).onopentag) === null || g === void 0 || g.call(m, this.tagname, this.attribs, y), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
    }
    /** @internal */
    onopentagend(y) {
      this.endIndex = y, this.endOpenTag(!1), this.startIndex = y + 1;
    }
    /** @internal */
    onclosetag(y, m) {
      var g, T, v, E, R, L, A, w;
      this.endIndex = m;
      let S = this.getSlice(y, m);
      if (this.lowerCaseTagNames && (S = S.toLowerCase()), this.htmlMode && (f.has(S) || h.has(S)) && this.foreignContext.shift(), this.isVoidElement(S))
        this.htmlMode && S === "br" && ((E = (v = this.cbs).onopentagname) === null || E === void 0 || E.call(v, "br"), (L = (R = this.cbs).onopentag) === null || L === void 0 || L.call(R, "br", {}, !0), (w = (A = this.cbs).onclosetag) === null || w === void 0 || w.call(A, "br", !1));
      else {
        const O = this.stack.indexOf(S);
        if (O !== -1)
          for (let x = 0; x <= O; x++) {
            const F = this.stack.shift();
            (T = (g = this.cbs).onclosetag) === null || T === void 0 || T.call(g, F, x !== O);
          }
        else this.htmlMode && S === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
      }
      this.startIndex = m + 1;
    }
    /** @internal */
    onselfclosingtag(y) {
      this.endIndex = y, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = y + 1) : this.onopentagend(y);
    }
    closeCurrentTag(y) {
      var m, g;
      const T = this.tagname;
      this.endOpenTag(y), this.stack[0] === T && ((g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, T, !y), this.stack.shift());
    }
    /** @internal */
    onattribname(y, m) {
      this.startIndex = y;
      const g = this.getSlice(y, m);
      this.attribname = this.lowerCaseAttributeNames ? g.toLowerCase() : g;
    }
    /** @internal */
    onattribdata(y, m) {
      this.attribvalue += this.getSlice(y, m);
    }
    /** @internal */
    onattribentity(y) {
      this.attribvalue += (0, t.fromCodePoint)(y);
    }
    /** @internal */
    onattribend(y, m) {
      var g, T;
      this.endIndex = m, (T = (g = this.cbs).onattribute) === null || T === void 0 || T.call(g, this.attribname, this.attribvalue, y === a.QuoteType.Double ? '"' : y === a.QuoteType.Single ? "'" : y === a.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
    }
    getInstructionName(y) {
      const m = y.search(p);
      let g = m < 0 ? y : y.substr(0, m);
      return this.lowerCaseTagNames && (g = g.toLowerCase()), g;
    }
    /** @internal */
    ondeclaration(y, m) {
      this.endIndex = m;
      const g = this.getSlice(y, m);
      if (this.cbs.onprocessinginstruction) {
        const T = this.getInstructionName(g);
        this.cbs.onprocessinginstruction(`!${T}`, `!${g}`);
      }
      this.startIndex = m + 1;
    }
    /** @internal */
    onprocessinginstruction(y, m) {
      this.endIndex = m;
      const g = this.getSlice(y, m);
      if (this.cbs.onprocessinginstruction) {
        const T = this.getInstructionName(g);
        this.cbs.onprocessinginstruction(`?${T}`, `?${g}`);
      }
      this.startIndex = m + 1;
    }
    /** @internal */
    oncomment(y, m, g) {
      var T, v, E, R;
      this.endIndex = m, (v = (T = this.cbs).oncomment) === null || v === void 0 || v.call(T, this.getSlice(y, m - g)), (R = (E = this.cbs).oncommentend) === null || R === void 0 || R.call(E), this.startIndex = m + 1;
    }
    /** @internal */
    oncdata(y, m, g) {
      var T, v, E, R, L, A, w, S, O, x;
      this.endIndex = m;
      const F = this.getSlice(y, m - g);
      !this.htmlMode || this.options.recognizeCDATA ? ((v = (T = this.cbs).oncdatastart) === null || v === void 0 || v.call(T), (R = (E = this.cbs).ontext) === null || R === void 0 || R.call(E, F), (A = (L = this.cbs).oncdataend) === null || A === void 0 || A.call(L)) : ((S = (w = this.cbs).oncomment) === null || S === void 0 || S.call(w, `[CDATA[${F}]]`), (x = (O = this.cbs).oncommentend) === null || x === void 0 || x.call(O)), this.startIndex = m + 1;
    }
    /** @internal */
    onend() {
      var y, m;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (let g = 0; g < this.stack.length; g++)
          this.cbs.onclosetag(this.stack[g], !0);
      }
      (m = (y = this.cbs).onend) === null || m === void 0 || m.call(y);
    }
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    reset() {
      var y, m, g, T;
      (m = (y = this.cbs).onreset) === null || m === void 0 || m.call(y), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (T = (g = this.cbs).onparserinit) === null || T === void 0 || T.call(g, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
    }
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    parseComplete(y) {
      this.reset(), this.end(y);
    }
    getSlice(y, m) {
      for (; y - this.bufferOffset >= this.buffers[0].length; )
        this.shiftBuffer();
      let g = this.buffers[0].slice(y - this.bufferOffset, m - this.bufferOffset);
      for (; m - this.bufferOffset > this.buffers[0].length; )
        this.shiftBuffer(), g += this.buffers[0].slice(0, m - this.bufferOffset);
      return g;
    }
    shiftBuffer() {
      this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
    }
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    write(y) {
      var m, g;
      if (this.ended) {
        (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(y), this.tokenizer.running && (this.tokenizer.write(y), this.writeIndex++);
    }
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    end(y) {
      var m, g;
      if (this.ended) {
        (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".end() after done!"));
        return;
      }
      y && this.write(y), this.ended = !0, this.tokenizer.end();
    }
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    pause() {
      this.tokenizer.pause();
    }
    /**
     * Resumes parsing after `pause` was called.
     */
    resume() {
      for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      this.ended && this.tokenizer.end();
    }
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    parseChunk(y) {
      this.write(y);
    }
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    done(y) {
      this.end(y);
    }
  }
  return ui.Parser = b, ui;
}
var TL;
function Wse() {
  return TL || (TL = 1, function(u) {
    var r = ai && ai.__createBinding || (Object.create ? function(m, g, T, v) {
      v === void 0 && (v = T);
      var E = Object.getOwnPropertyDescriptor(g, T);
      (!E || ("get" in E ? !g.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
        return g[T];
      } }), Object.defineProperty(m, v, E);
    } : function(m, g, T, v) {
      v === void 0 && (v = T), m[v] = g[T];
    }), o = ai && ai.__setModuleDefault || (Object.create ? function(m, g) {
      Object.defineProperty(m, "default", { enumerable: !0, value: g });
    } : function(m, g) {
      m.default = g;
    }), a = ai && ai.__importStar || /* @__PURE__ */ function() {
      var m = function(g) {
        return m = Object.getOwnPropertyNames || function(T) {
          var v = [];
          for (var E in T) Object.prototype.hasOwnProperty.call(T, E) && (v[v.length] = E);
          return v;
        }, m(g);
      };
      return function(g) {
        if (g && g.__esModule) return g;
        var T = {};
        if (g != null) for (var v = m(g), E = 0; E < v.length; E++) v[E] !== "default" && r(T, g, v[E]);
        return o(T, g), T;
      };
    }(), t = ai && ai.__importDefault || function(m) {
      return m && m.__esModule ? m : { default: m };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.DomUtils = u.getFeed = u.ElementType = u.QuoteType = u.Tokenizer = u.DefaultHandler = u.DomHandler = u.Parser = void 0, u.parseDocument = s, u.parseDOM = d, u.createDocumentStream = l, u.createDomStream = f, u.parseFeed = y;
    const e = vL();
    var n = vL();
    Object.defineProperty(u, "Parser", { enumerable: !0, get: function() {
      return n.Parser;
    } });
    const i = /* @__PURE__ */ Vn();
    var c = /* @__PURE__ */ Vn();
    Object.defineProperty(u, "DomHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } }), Object.defineProperty(u, "DefaultHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } });
    function s(m, g) {
      const T = new i.DomHandler(void 0, g);
      return new e.Parser(T, g).end(m), T.root;
    }
    function d(m, g) {
      return s(m, g).children;
    }
    function l(m, g, T) {
      const v = new i.DomHandler((E) => m(E, v.root), g, T);
      return new e.Parser(v, g);
    }
    function f(m, g, T) {
      const v = new i.DomHandler(m, g, T);
      return new e.Parser(v, g);
    }
    var h = yY();
    Object.defineProperty(u, "Tokenizer", { enumerable: !0, get: function() {
      return t(h).default;
    } }), Object.defineProperty(u, "QuoteType", { enumerable: !0, get: function() {
      return h.QuoteType;
    } }), u.ElementType = a(/* @__PURE__ */ i0());
    const p = /* @__PURE__ */ pa();
    var b = /* @__PURE__ */ pa();
    Object.defineProperty(u, "getFeed", { enumerable: !0, get: function() {
      return b.getFeed;
    } });
    const _ = { xmlMode: !0 };
    function y(m, g = _) {
      return (0, p.getFeed)(d(m, g));
    }
    u.DomUtils = a(/* @__PURE__ */ pa());
  }(ai)), ai;
}
var wL;
function Yse() {
  if (wL) return gb;
  wL = 1, Object.defineProperty(gb, "__esModule", { value: !0 }), gb.ActorRdfParseHtml = void 0;
  const u = /* @__PURE__ */ yh(), r = /* @__PURE__ */ Wse(), o = Bt();
  class a extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "text/html": 1.0,
     *       "application/xhtml+xml": 0.9
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "text/html": "http://www.w3.org/ns/formats/HTML",
     *       "application/xhtml+xml": "http://www.w3.org/ns/formats/HTML"
     *     }} mediaTypeFormats
     */
    constructor(e) {
      super(e);
    }
    async runHandle(e, n, i) {
      var p;
      const c = new o.Readable({ objectMode: !0 });
      c._read = () => {
      };
      let s = 0, d = 1;
      function l(b) {
        c.emit("error", b);
      }
      function f() {
        --d === 0 && c.push(null);
      }
      const h = {
        baseIRI: ((p = e.metadata) == null ? void 0 : p.baseIRI) ?? "",
        context: i,
        emit: (b) => {
          s--, c.push(b);
        },
        end: f,
        error: l,
        headers: e.headers
      };
      try {
        const b = await Promise.all(this.busRdfParseHtml.publish(h));
        d += b.length;
        const _ = [];
        for (const g of b) {
          const { htmlParseListener: T } = await g.actor.run(h, void 0);
          _.push(T);
        }
        const y = new r.Parser({
          onclosetag() {
            try {
              for (const g of _)
                g.onTagClose();
            } catch (g) {
              l(g);
            }
          },
          onend() {
            try {
              for (const g of _)
                g.onEnd();
            } catch (g) {
              l(g);
            }
            f();
          },
          onopentag(g, T) {
            try {
              for (const v of _)
                v.onTagOpen(g, T);
            } catch (v) {
              l(v);
            }
          },
          ontext(g) {
            try {
              for (const T of _)
                T.onText(g);
            } catch (T) {
              l(T);
            }
          }
        }, {
          decodeEntities: !0,
          recognizeSelfClosing: !0,
          xmlMode: !1
        }), m = c._read = (g) => {
          for (s = Math.max(g, s); s > 0; ) {
            const T = e.data.read();
            if (T === null) {
              e.data.once("readable", () => m(0));
              return;
            }
            y.write(T.toString());
          }
        };
        e.data.on("error", l).on("end", () => y.end());
      } catch (b) {
        setTimeout(() => {
          c.emit("error", b);
        });
      }
      return { data: c };
    }
  }
  return gb.ActorRdfParseHtml = a, gb;
}
var SL;
function Zse() {
  return SL || (SL = 1, function(u) {
    var r = ps && ps.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ps && ps.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Yse(), u);
  }(ps)), ps;
}
var bs = {}, Tb = {}, ys = {}, wb = {}, AL;
function ece() {
  if (AL) return wb;
  AL = 1, Object.defineProperty(wb, "__esModule", { value: !0 }), wb.ActorRdfParseHtml = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF HTML parsing failed: none of the configured parsers were able to parse RDF in HTML} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return wb.ActorRdfParseHtml = r, wb;
}
var EL;
function q8() {
  return EL || (EL = 1, function(u) {
    var r = ys && ys.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ys && ys.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ece(), u);
  }(ys)), ys;
}
var _s = {}, qE = {}, OL;
function tce() {
  return OL || (OL = 1, Object.defineProperty(qE, "__esModule", { value: !0 })), qE;
}
var Sb = {}, xL;
function _Y() {
  if (xL) return Sb;
  xL = 1, Object.defineProperty(Sb, "__esModule", { value: !0 }), Sb.ItemPropertyHandlerContent = void 0;
  let u = class {
    canHandle(o, a) {
      return "content" in a;
    }
    getObject(o, a, t) {
      return a.createLiteral(o.content, t);
    }
  };
  return Sb.ItemPropertyHandlerContent = u, Sb;
}
var Ab = {}, Eb = {}, IL;
function i4() {
  if (IL) return Eb;
  IL = 1, Object.defineProperty(Eb, "__esModule", { value: !0 }), Eb.Util = void 0;
  const u = Or(), r = Tr();
  class o {
    constructor(t, e) {
      this.dataFactory = t || new u.DataFactory(), this.baseIRI = e || "";
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(t) {
      return o.IRI_REGEX.test(t);
    }
    /**
     * Create vocab terms for the given terms attribute.
     *
     * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.
     *
     * @param {string} terms An attribute value.
     * @param {IItemScope} itemScope The active item scope.
     * @param {boolean} allowRelativeIris If relative IRIs are allowed.
     * @return {Term[]} The IRI terms.
     */
    createVocabIris(t, e, n) {
      return t.split(/\s+/u).filter((i) => !!i).map((i) => {
        if (!o.isValidIri(i)) {
          if (!n)
            return;
          i = `${e.vocab || `${this.baseIRI}#`}${i}`;
        }
        return this.dataFactory.namedNode(i);
      }).filter((i) => !!i);
    }
    /**
     * Get the predicates for which the given itemprop value should cause vocabulary expansion.
     * @param terms An attribute value.
     * @param itemScope The active item scope.
     * @param vocabRegistry The active vocabulary registry.
     */
    getVocabularyExpansionType(t, e, n) {
      const i = t.split(/\s+/u);
      if (i.includes("subPropertyOf") || i.includes("equivalentProperty"))
        return [this.dataFactory.namedNode(`${o.RDF}type`)];
      if (e.vocab && e.vocab in n && n[e.vocab].properties) {
        let c = [];
        for (const [s, d] of Object.entries(n[e.vocab].properties))
          i.includes(s) && (c = [...Object.values(d).map((l) => this.dataFactory.namedNode(l))]);
        return c;
      }
      return [];
    }
    /**
     * Create a named node for the given term, which can be relative to the document base.
     * @param {string} iri A term string.
     * @return {Term} An RDF term, or undefined if invalid.
     */
    createSubject(t) {
      if (!o.isValidIri(t))
        try {
          t = (0, r.resolve)(t, this.baseIRI);
        } catch {
          return;
        }
      return this.dataFactory.namedNode(t);
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */
    createLiteral(t, e) {
      return this.dataFactory.literal(t, e.language);
    }
    /**
     * Determine the vocab IRI from a given type IRI.
     * @link https://w3c.github.io/microdata-rdf/#property-uri-generation
     * @param typeIri A type IRI.
     * @param vocabRegistry The active vocabulary registry.
     */
    deriveVocab(t, e) {
      let n;
      for (const i in e)
        if (t.startsWith(i)) {
          n = i, n.endsWith("/") || (n += "#");
          break;
        }
      if (!n) {
        const i = t.indexOf("#");
        i > 0 ? n = t.slice(0, i + 1) : n = (0, r.resolve)(".", t);
      }
      return n;
    }
  }
  return Eb.Util = o, o.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", o.XSD = "http://www.w3.org/2001/XMLSchema#", o.RDFA = "http://www.w3.org/ns/rdfa#", o.IRI_REGEX = /^([A-Za-z][\d+-.A-Za-z]*|_):[^ "<>[\\\]`{|}]*$/u, Eb;
}
var RL;
function gY() {
  if (RL) return Ab;
  RL = 1, Object.defineProperty(Ab, "__esModule", { value: !0 }), Ab.ItemPropertyHandlerNumber = void 0;
  const u = /* @__PURE__ */ i4();
  let r = class {
    constructor(a, t) {
      this.tagName = a, this.attributeName = t;
    }
    canHandle(a, t) {
      return this.tagName === a && this.attributeName in t;
    }
    getObject(a, t, e) {
      const n = a[this.attributeName];
      let i;
      return !Number.isNaN(Number.parseInt(n, 10)) && !n.includes(".") ? i = `${u.Util.XSD}integer` : Number.isNaN(Number.parseFloat(n)) || (i = `${u.Util.XSD}double`), t.dataFactory.literal(n, i && t.dataFactory.namedNode(i));
    }
  };
  return Ab.ItemPropertyHandlerNumber = r, Ab;
}
var Ob = {}, FL;
function vY() {
  if (FL) return Ob;
  FL = 1, Object.defineProperty(Ob, "__esModule", { value: !0 }), Ob.ItemPropertyHandlerTime = void 0;
  const u = /* @__PURE__ */ i4();
  let r = class mY {
    canHandle(a, t) {
      return a === "time" && "datetime" in t;
    }
    getObject(a, t, e) {
      const n = a.datetime;
      let i;
      for (const c of mY.TIME_REGEXES)
        if (c.regex.test(n)) {
          i = t.dataFactory.namedNode(u.Util.XSD + c.type);
          break;
        }
      return t.dataFactory.literal(n, i);
    }
  };
  return Ob.ItemPropertyHandlerTime = r, r.TIME_REGEXES = [
    {
      regex: /^-?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d)?S)?)?$/u,
      type: "duration"
    },
    {
      regex: /^\d+-\d\d-\d\dT\d\d:\d\d:\d\d((Z?)|([+-]\d\d:\d\d))$/u,
      type: "dateTime"
    },
    { regex: /^\d+-\d\d-\d\dZ?$/u, type: "date" },
    { regex: /^\d\d:\d\d:\d\d((Z?)|([+-]\d\d:\d\d))$/u, type: "time" },
    { regex: /^\d+-\d\d$/u, type: "gYearMonth" },
    { regex: /^\d+$/u, type: "gYear" }
  ], Ob;
}
var xb = {}, NL;
function TY() {
  if (NL) return xb;
  NL = 1, Object.defineProperty(xb, "__esModule", { value: !0 }), xb.ItemPropertyHandlerUrl = void 0;
  const u = Tr();
  let r = class {
    constructor(a, t) {
      this.tagName = a, this.attributeName = t;
    }
    canHandle(a, t) {
      return this.tagName === a && this.attributeName in t;
    }
    getObject(a, t, e) {
      return t.dataFactory.namedNode((0, u.resolve)(a[this.attributeName], t.baseIRI));
    }
  };
  return xb.ItemPropertyHandlerUrl = r, xb;
}
var BE = {}, PL;
function rce() {
  return PL || (PL = 1, Object.defineProperty(BE, "__esModule", { value: !0 })), BE;
}
var $E = {}, DL;
function nce() {
  return DL || (DL = 1, Object.defineProperty($E, "__esModule", { value: !0 })), $E;
}
var UE = {}, LL;
function ice() {
  return LL || (LL = 1, Object.defineProperty(UE, "__esModule", { value: !0 })), UE;
}
var Ib = {}, oi = {}, si = {}, VE = {}, ci = {}, w6 = {}, jL;
function ace() {
  return jL || (jL = 1, Object.defineProperty(w6, "__esModule", { value: !0 }), w6.default = new Uint16Array(
    // prettier-ignore
    'áµ<ÃÄ±ÊÒÕ»×ÙµÛÞ¢ßà à©àªà¶¡à¹­à¼à¼¦áá¨á¡ááááá¥\0\0\0\0\0\0á«áá¦á°á·á½¾â â°âââ»ââ ¤â¤â´â¹â¿ããºã¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à EMabcfglmnoprstu\\bfmsÂÂÂÂÂÂ¦Â³Â¹ÃÃligè»ÃäPè»&ä¦cuteè»Ãäreve;äÄiyx}rcè»Ãä;är;ìðraveè»Ãäpha;äacr;äd;æ©ÄgpÂÂ¡on;äf;ìð¸plyFunction;æ¡ingè»ÃäÄcsÂ¾Ãr;ìðign;æildeè»Ãämlè»ÃäÐaceforsuÃ¥Ã»Ã¾ÄÄÄ¢Ä§ÄªÄcrÃªÃ²kslash;æÅ¶Ã¶Ã¸;æ«§ed;æy;äÆcrtÄÄÄause;æµnoullis;æ¬a;är;ìðpf;ìð¹eve;äcÃ²Ämpeq;æÜHOacdefhilorsuÅÅÅÆÆÆ¢ÆµÆ·ÆºÇÈÉ³É¸É¾cy;ä§PYè»Â©ä©ÆcpyÅÅ¢Åºute;äÄ;iÅ§Å¨ætalDifferentialD;æleys;æ­ÈaeioÆÆÆÆron;ädilè»Ãärc;änint;æ°ot;äÄdnÆ§Æ­illa;ä¸terDot;ä·Ã²Å¿i;ä§rcleÈDMPTÇÇÇÇot;æinus;ælus;æimes;æoÄcsÇ¢Ç¸kwiseContourIntegral;æ²eCurlyÄDQÈÈoubleQuote;æuote;æÈlnpuÈÈ¨ÉÉonÄ;eÈ¥È¦æ·;æ©´ÆgitÈ¯È¶Èºruent;æ¡nt;æ¯ourIntegral;æ®ÄfrÉÉ;æoduct;ænterClockwiseContourIntegral;æ³oss;æ¨¯cr;ìðpÄ;CÊÊæap;æÖDJSZacefiosÊ Ê¬Ê°Ê´Ê¸ËËË¡Ë¦Ì³ÒÄ;oÅ¹Ê¥trahd;æ¤cy;äcy;äcy;äÆgrsÊ¿ËËger;æ¡r;æ¡hv;æ«¤ÄayËËron;ä;älÄ;tËËæa;är;ìðÄafË«Ì§ÄcmË°Ì¢riticalÈADGTÌÌÌÌcute;ä´oÅ´ÌÌ;äbleAcute;ärave;ä ilde;äond;æferentialD;æÑ°Ì½\0\0\0ÍÍ\0Ðf;ìð»Æ;DEÍÍÍä¨ot;æqual;æbleÌCDLRUVÍ£Í²ÎÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»ÍnArrow;æÄeoÎÎ¤ftÆARTÎÎÎ¡rrow;æightArrow;æeÃ¥ËngÄLRÎ«ÏeftÄARÎ³Î¹rrow;æ¸ightArrow;æºightArrow;æ¹ightÄATÏÏrrow;æee;æ¨pÉÏ©\0\0Ï¯rrow;æownArrow;æerticalBar;æ¥nÌABLRTaÐÐªÐ°ÑÑ¿Í¼rrowÆ;BUÐÐÐ¢æar;æ¤pArrow;æµreve;äeftËÐº\0Ñ\0ÑightVector;æ¥eeVector;æ¥ectorÄ;BÑÑæ½ar;æ¥ightÇÑ§\0Ñ±eeVector;æ¥ectorÄ;BÑºÑ»æar;æ¥eeÄ;AÒÒæ¤rrow;æ§ÄctÒÒr;ìðrok;äà NTacdfglmopqstuxÒ½ÓÓÓÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶ÕÕÕ Õ¥G;äHè»Ãäcuteè»ÃäÆaiyÓÓÓron;ärcè»Ãä;ä­ot;är;ìðraveè»Ãäement;æÄapÓºÓ¾cr;ätyÉÔ\0\0ÔmallSquare;æ»erySmallSquare;æ«ÄgpÔ¦Ôªon;äf;ìð¼silon;äuÄaiÔ¼ÕlÄ;TÕÕæ©µilde;ælibrium;æÄciÕÕr;æ°m;æ©³a;ämlè»ÃäÄipÕªÕ¯sts;æonentialE;æÊcfiosÖÖÖÖ²×y;ä¤r;ìðlledÉÖ\0\0Ö£mallSquare;æ¼erySmallSquare;æªÍ°Öº\0Ö¿\0\0×f;ìð½All;æriertrf;æ±cÃ²×ØJTabcdfgorst×¨×¬×¯×ºØØØØØØ£Ù¬Ù²cy;äè»>ä¾mmaÄ;d×·×¸ä;äreve;äÆeiyØØØdil;ä¢rc;ä;äot;ä r;ìð;æpf;ìð¾eaterÌEFGLSTØµÙÙÙÙÙ¦qualÄ;LØ¾Ø¿æ¥ess;æullEqual;æ§reater;æª¢ess;æ·lantEqual;æ©¾ilde;æ³cr;ìð¢;æ«ÐAacfiosuÚÚÚÚÚÚªÚ¾ÛRDcy;äªÄctÚÚek;ä;äirc;ä¤r;ælbertSpace;æÇ°Ú¯\0Ú²f;æizontalLine;æÄctÛÛÃ²Ú©rok;ä¦mpÅÛÛownHumÃ°Ä¯qual;æÜEJOacdfgmnostuÛºÛ¾ÜÜÜÜÜÜ¡Ü¨ÝÝ¸ÞÞÞcy;älig;ä²cy;äcuteè»ÃäÄiyÜÜrcè»Ãä;äot;ä°r;æraveè»ÃäÆ;apÜ Ü¯Ü¿ÄcgÜ´Ü·r;äªinaryI;ælieÃ³ÏÇ´Ý\0Ý¢Ä;eÝÝæ¬ÄgrÝÝral;æ«section;æisibleÄCTÝ¬Ý²omma;æ£imes;æ¢ÆgptÝ¿ÞÞon;ä®f;ìða;äcr;æilde;ä¨Ç«Þ\0Þcy;älè»ÃäÊcfosuÞ¬Þ·Þ¼ßßÄiyÞ±Þµrc;ä´;är;ìðpf;ìðÇ£ß\0ßr;ìð¥rcy;äkcy;äÎHJacfosß¤ß¨ß¬ß±ß½à à cy;ä¥cy;äppa;äÄeyß¶ß»dil;ä¶;är;ìðpf;ìðcr;ìð¦ÖJTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§à§à¨·à©cy;äè»<ä¼Êcmnprà ·à ¼à¡à¡à¡ute;ä¹bda;äg;æªlacetrf;ær;æÆaeyà¡à¡à¡¡ron;ä½dil;ä»;äÄfsà¡¨à¥°tÔACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥Îà¥ªÄnrà¢à¢gleBracket;æ¨rowÆ;BRà¢à¢à¢æar;æ¤ightArrow;æeiling;æoÇµà¢·\0à£bleBracket;æ¦nÇà£\0à£eeVector;æ¥¡ectorÄ;Bà£à£æar;æ¥loor;æightÄAVà£¯à£µrrow;æector;æ¥Äerà¤à¤eÆ;AVà¤à¤à¤æ£rrow;æ¤ector;æ¥iangleÆ;BEà¤¤à¤¥à¤©æ²ar;æ§qual;æ´pÆDTVà¤·à¥à¥ownVector;æ¥eeVector;æ¥ ectorÄ;Bà¥à¥æ¿ar;æ¥ectorÄ;Bà¥¥à¥¦æ¼ar;æ¥ightÃ¡ÎsÌEFGLSTà¥¾à¦à¦à¦à¦¢à¦­qualGreater;æullEqual;æ¦reater;æ¶ess;æª¡lantEqual;æ©½ilde;æ²r;ìðÄ;eà¦½à¦¾æftarrow;æidot;ä¿Ænpwà§à¨à¨gÈLRlrà§à§·à¨à¨eftÄARà§¦à§¬rrow;æµightArrow;æ·ightArrow;æ¶eftÄarÎ³à¨ightÃ¡Î¿ightÃ¡Ïf;ìðerÄLRà¨¢à¨¬eftArrow;æightArrow;æÆchtà¨¾à©à©Ã²à¡;æ°rok;ä;æªÐacefiosuà©à©à© à©·à©¼àªàªàªp;æ¤y;äÄdlà©¥à©¯iumSpace;ælintrf;æ³r;ìðnusPlus;æpf;ìðcÃ²à©¶;äÒJacefostuàª£àª§àª­à«à¬à¬à¶à¶à¶cy;äcute;äÆaeyàª´àª¹àª¾ron;ädil;ä;äÆgswà«à«°à¬ativeÆMTVà«à«à«¨ediumSpace;æhiÄcnà«¦à«Ã«à«eryThiÃ®à«tedÄGLà«¸à¬reaterGreateÃ²Ù³essLesÃ³à©Line;är;ìðÈBnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä f;æÚ;CDEGHLNPRSTVà­à­à­ªà­¼à®¡à¯«à°à±à²à²¦à³àµ¡à¶æ«¬Äouà­à­¤ngruent;æ¢pCap;æ­oubleVerticalBar;æ¦Ælqxà®à®à®ement;æualÄ;Tà®à®æ ilde;ìâÌ¸ists;æreaterÎ;EFGLSTà®¶à®·à®½à¯à¯à¯à¯¥æ¯qual;æ±ullEqual;ìâ§Ì¸reater;ìâ«Ì¸ess;æ¹lantEqual;ìâ©¾Ì¸ilde;æµumpÅà¯²à¯½ownHump;ìâÌ¸qual;ìâÌ¸eÄfsà°à°§tTriangleÆ;BEà°à°à°¡æªar;ìâ§Ì¸qual;æ¬sÌ;EGLSTà°µà°¶à°¼à±à±à±æ®qual;æ°reater;æ¸ess;ìâªÌ¸lantEqual;ìâ©½Ì¸ilde;æ´estedÄGLà±¨à±¹reaterGreater;ìâª¢Ì¸essLess;ìâª¡Ì¸recedesÆ;ESà²à²à²æqual;ìâª¯Ì¸lantEqual;æ Äeià²«à²¹verseElement;æghtTriangleÆ;BEà³à³à³æ«ar;ìâ§Ì¸qual;æ­Äquà³à´uareSuÄbpà³¨à³¹setÄ;Eà³°à³³ìâÌ¸qual;æ¢ersetÄ;Eà´à´ìâÌ¸qual;æ£Æbcpà´à´¤àµsetÄ;Eà´à´ìââqual;æceedsÈ;ESTà´²à´³à´»àµæqual;ìâª°Ì¸lantEqual;æ¡ilde;ìâ¿Ì¸ersetÄ;Eàµàµìââqual;æildeÈ;EFTàµ®àµ¯àµµàµ¿æqual;æullEqual;æilde;æerticalBar;æ¤cr;ìð©ildeè»Ãä;äÜEacdfgmoprstuvà¶½à·à·à·à·à· à·§à·¼à¸à¸ à¸¢à¸²à¸¿à¹lig;äcuteè»ÃäÄiyà·à·rcè»Ãä;äblac;är;ìðraveè»ÃäÆaeià·®à·²à·¶cr;äga;ä©cron;äpf;ìðenCurlyÄDQà¸à¸oubleQuote;æuote;æ;æ©Äclà¸§à¸¬r;ìðªashè»ÃäiÅ¬à¸·à¸¼deè»Ãäes;æ¨·mlè»ÃäerÄBPà¹à¹ Äarà¹à¹r;æ¾acÄekà¹à¹;æet;æ´arenthesis;æÒacfhilorsà¹¿àºàºàºàºàºàºàº°à»¼rtialD;æy;är;ìði;ä¦;ä usMinus;ä±Äipàº¢àº­ncareplanÃ¥Úf;æÈ;eioàº¹àººà» à»¤æª»cedesÈ;ESTà»à»à»à»æºqual;æª¯lantEqual;æ¼ilde;æ¾me;æ³Ädpà»©à»®uct;æortionÄ;aÈ¥à»¹l;æÄcià¼à¼r;ìð«;ä¨ÈUfosà¼à¼à¼à¼OTè»"ä¢r;ìðpf;æcr;ìð¬ØBEacefhiorsuà¼¾à½à½à½ à½³à¾§à¾ªà¾­áá©á´á¾arr;æ¤Gè»Â®ä®Æcnrà½à½à½ute;äg;æ«rÄ;tà½à½æ l;æ¤Æaeyà½§à½¬à½±ron;ädil;ä;ä Ä;và½¸à½¹æerseÄEUà¾à¾Älqà¾à¾ement;æuilibrium;æpEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtÐACDFTUVaà¿à¿«à¿³á¢á¨ááÏÄnrà¿à¿gleBracket;æ©rowÆ;BLà¿à¿à¿¡æar;æ¥eftArrow;æeiling;æoÇµà¿¹\0ábleBracket;æ§nÇá\0áeeVector;æ¥ectorÄ;Bááæar;æ¥loor;æÄerá­áeÆ;AVáµá¶á¼æ¢rrow;æ¦ector;æ¥iangleÆ;BEáááæ³ar;æ§qual;æµpÆDTVá£á®á¸ownVector;æ¥eeVector;æ¥ectorÄ;Bááæ¾ar;æ¥ectorÄ;Bááæar;æ¥Äpuááf;ændImplies;æ¥°ightarrow;æÄchá¹á¼r;æ;æ±leDelayed;æ§´ÚHOacfhimoqstuá¤á±á·á½ááááá¡á§áµá»á¿ÄCcá©á®Hcy;ä©y;ä¨FTcy;ä¬cute;äÊ;aeiyáááááæª¼ron;ä dil;ärc;ä;ä¡r;ìðortÈDLRUáªá´á¾áownArrowÂ»ÐeftArrowÂ»à¢ightArrowÂ»à¿pArrow;ægma;ä£allCircle;æpf;ìðÉ²á­\0\0á°t;æareÈ;ISUá»á¼áá¯æ¡ntersection;æuÄbpáásetÄ;Eááæqual;æersetÄ;Eá¨á©æqual;ænion;æcr;ìð®ar;æÈbcmpááááÄ;sááæetÄ;Eááqual;æÄchá áeedsÈ;ESTá­á®á´á¿æ»qual;æª°lantEqual;æ½ilde;æ¿ThÃ¡à¾;æÆ;esááá£ærsetÄ;Eááæqual;æetÂ»áÖHRSacfhiorsá¾ááááá±á¶ááááORNè»ÃäADE;æ¢ÄHcáácy;äy;ä¦Äbuáá;ä;ä¤Æaeyá¥áªá¯ron;ä¤dil;ä¢;ä¢r;ìðÄeiá»áÇ²á\0áefore;æ´a;äÄcnáákSpace;ìââSpace;ældeÈ;EFTá«á¬á²á¼æ¼qual;æullEqual;æilde;æpf;ìðipleDot;æÄctáár;ìð¯rok;ä¦à«¡á·ááá¦\0á¬á±\0\0\0\0\0á¸á½á·á\0á¿áááÄcrá»áuteè»ÃärÄ;oááæcir;æ¥rÇ£á\0áy;äve;ä¬Äiyáá£rcè»Ãä;ä£blac;ä°r;ìðraveè»Ãäacr;äªÄdiáá©erÄBPááÄaráár;äacÄekáá;æet;æµarenthesis;æonÄ;Pá°á±ælus;æÄgpá»á¿on;ä²f;ìðÐADETadpsáá®á¸áÏ¨ááá³rrowÆ;BDáá á¤ar;æ¤ownArrow;æownArrow;æquilibrium;æ¥®eeÄ;Aááæ¥rrow;æ¥ownÃ¡Ï³erÄLRáá¨eftArrow;æightArrow;æiÄ;lá¹áºäon;ä¥ing;ä®cr;ìð°ilde;ä¨mlè»ÃäÒDbcdefosvá§á¬á°á³á¾ááááash;æ«ar;æ««y;äashÄ;lá»á¼æ©;æ«¦Äeráá;æÆbtyáááºar;æÄ;iáácalÈBLSTá¡á¥áªá´ar;æ£ine;ä¼eparator;æilde;æThinSpace;ær;ìðpf;ìðcr;ìð±dash;æªÊcefosá§á¬á±á¶á¼irc;ä´dge;ær;ìðpf;ìðcr;ìð²Èfiosáááár;ìð;äpf;ìðcr;ìð³ÒAIUacfosuá±áµá¹á½ááááá cy;ä¯cy;äcy;ä®cuteè»ÃäÄiyáárc;ä¶;ä«r;ìðpf;ìðcr;ìð´ml;ä¸ÐHacdefosáµá¹á¿áááá á¤cy;äcute;ä¹Äayááron;ä½;äot;ä»Ç²á\0áoWidtÃ¨à«a;är;æ¨pf;æ¤cr;ìðµà¯¡ááá\0á°á¶á¿\0\0\0\0ááá«áá­\0ááá²á¹\0á¾cuteè»Ã¡ä¡reve;äÌ;Ediuyááá¡á£á¨á­æ¾;ìâ¾Ì³;æ¿rcè»Ã¢ä¢teè»Â´Ì;ä°ligè»Ã¦ä¦Ä;rÂ²áº;ìðraveè»Ã ä ÄepááÄfpáásym;æµÃ¨áha;ä±ÄapácÄclá¤á§r;äg;æ¨¿É¤á°\0\0áÊ;adsváºá»á¿ááæ§nd;æ©;æ©lope;æ©;æ©Î;elmrszááááá¿ááæ ;æ¦¤eÂ»ásdÄ;aá¥á¦æ¡Ñ¡á°á²á´á¶á¸áºá¼á¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ;vááæbÄ;dááæ¾;æ¦Äptááh;æ¢Â»Â¹arr;æ¼Ägpá£á§on;äf;ìðÎ;Eaeiopáá»á½áááá;æ©°cir;æ©¯;æd;æs;ä§roxÄ;eááÃ±áingè»Ã¥ä¥Æctyá¡á¦á¨r;ìð¶;äªmpÄ;eáá¯Ã±Êildeè»Ã£ä£mlè»Ã¤ä¤ÄciááoninÃ´É²nt;æ¨à Nabcdefiklnoprsuá­á±á°á¼ááá¸á½á á¦á ¹á¡áá¤½á¥á¥°ot;æ«­Äcrá¶ákÈcepsááááong;æpsilon;ä¶rime;æµimÄ;eááæ½q;æÅ¶á¢á¦ee;æ½edÄ;gá¬á­æeÂ»á­rkÄ;táá·brk;æ¶Äoyáá;ä±quo;æÊcmprtááá¡á¤á¨ausÄ;eÄÄptyv;æ¦°sÃ©ánoÃµÄÆahwá¯á±á³;ä²;æ¶een;æ¬r;ìðgÎcostuvwááá³ááááÆaiuáááÃ°Ý rc;æ¯pÂ»á±Ædptá¤á¨á­ot;æ¨lus;æ¨imes;æ¨É±á¹\0\0á¾cup;æ¨ar;æriangleÄduááown;æ½p;æ³plus;æ¨eÃ¥áÃ¥á­arow;æ¤Æakoá­á ¦á µÄcná²á £kÆlstáºÖ«á ozenge;æ§«riangleÈ;dlrá á á á æ´own;æ¾eft;æight;æ¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ;æ4;æck;æÄeoá ¾á¡Ä;qá¡á¡ì=â¥uiv;ìâ¡â¥t;æÈptwxá¡á¡á¡§á¡¬f;ìðÄ;táá¡£omÂ»átie;æØDHUVbdhmptuvá¢á¢á¢ªá¢»á£á£á£¬á£¿á¤á¤á¤á¤¡ÈLRlrá¢á¢á¢á¢;æ;æ;æ;æÊ;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ;æ¦;æ©;æ¤;æ§ÈLRlrá¢³á¢µá¢·á¢¹;æ;æ;æ;æÎ;HLRhlrá£á£á£á£á£á£á£æ;æ¬;æ£;æ ;æ«;æ¢;æox;æ§ÈLRlrá£¤á£¦á£¨á£ª;æ;æ;æ;æÊ;DUduÚ½á£·á£¹á£»á£½;æ¥;æ¨;æ¬;æ´inus;ælus;æimes;æ ÈLRlrá¤á¤á¤á¤;æ;æ;æ;æÎ;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ;æª;æ¡;æ;æ¼;æ¤;æÄevÄ£á¥barè»Â¦ä¦Èceioá¥á¥á¥á¥ r;ìð·mi;æmÄ;eáálÆ;bhá¥¨á¥©á¥«ä;æ§sub;æÅ¬á¥´á¥¾lÄ;eá¥¹á¥ºæ¢tÂ»á¥ºpÆ;EeÄ¯á¦á¦;æª®Ä;qÛÛà³¡á¦§\0á§¨á¨á¨á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­\0á¯½\0á°Æcprá¦­á¦²á§ute;äÌ;abcdsá¦¿á§á§á§á§á§æ©nd;æ©rcup;æ©Äauá§á§p;æ©p;æ©ot;æ©;ìâ©ï¸Äeoá§¢á§¥t;æÃ®ÚÈaeiuá§°á§»á¨á¨Ç°á§µ\0á§¸s;æ©on;ädilè»Ã§ä§rc;äpsÄ;sá¨á¨æ©m;æ©ot;äÆdmná¨á¨ á¨¦ilè»Â¸Æ­ptyv;æ¦²tèÂ¢;eá¨­á¨®ä¢rÃ¤Æ²r;ìð Æceiá¨½á©á©y;äckÄ;má©á©æarkÂ»á©;ärÎ;Ecefmsá©á© á©¢á©«áª¤áªªáª®æ;æ§Æ;elá©©á©ªá©­äq;æeÉ¡á©´\0\0áªrrowÄlrá©¼áªeft;æºight;æ»ÊRSacdáªáªáªáªáªÂ»à½;æst;æirc;æash;ænint;æ¨id;æ«¯cir;æ§ubsÄ;uáª»áª¼æ£itÂ»áª¼Ë¬á«á«á«º\0á¬onÄ;eá«á«äºÄ;qÃÃÉ­á«\0\0á«¢aÄ;tá«á«ä¬;äÆ;flá«¨á«©á««æÃ®á eÄmxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬Ä;dá»á¬ot;æ©­nÃ´ÉÆfryá¬á¬á¬;ìðoÃ¤ÉèÂ©;sÅá¬r;æÄaoá¬¥á¬©rr;æµss;æÄcuá¬²á¬·r;ìð¸Äbpá¬¼á­Ä;eá­á­æ«;æ«Ä;eá­á­æ«;æ«dot;æ¯Îdelprvwá­ á­¬á­·á®á®¬á¯á¯¹arrÄlrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æc;æarrÄ;pá­¿á®æ¶;æ¤½Ì;bcdosá®á®á®á®¡á®¥á®¨æªrcap;æ©Äauá®á®p;æ©p;æ©ot;ær;æ©;ìâªï¸Èalrvá®µá®¿á¯á¯£rrÄ;má®¼á®½æ·;æ¤¼yÆevwá¯á¯á¯qÉ°á¯\0\0á¯reÃ£á­³uÃ£á­µee;æedge;æenè»Â¤ä¤earrowÄlrá¯®á¯³eftÂ»á®ightÂ»á®½eÃ¤á¯Äciá°á°oninÃ´Ç·nt;æ±lcty;æ­à¦AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²á²á²¬á²·á³»á³¿á´áµ»á¶á¶«á¶»á·á·rÃ²Îar;æ¥¥Èglrsá±á±á±á±ger;æ eth;æ¸Ã²á³hÄ;vá±á±æÂ»à¤Å«á±¡á±§arow;æ¤aÃ£ÌÄayá±®á±³ron;ä;ä´Æ;aoÌ²á±¼á²ÄgrÊ¿á²r;ætseq;æ©·Æglmá²á²á²è»Â°ä°ta;ä´ptyv;æ¦±Äirá²£á²¨sht;æ¥¿;ìð¡arÄlrá²³á²µÂ»à£Â»áÊaegsvá³Í¸á³á³á³ mÆ;osÌ¦á³á³ndÄ;sÌ¦á³uit;æ¦amma;äin;æ²Æ;ioá³§á³¨á³¸ä·deèÃ·;oá³§á³°ntimes;ænÃ¸á³·cy;äcÉ¯á´\0\0á´rn;æop;æÊlptuwá´á´á´¢áµáµlar;ä¤f;ìðÊ;empsÌá´­á´·á´½áµqÄ;dÍá´³ot;æinus;æ¸lus;æquare;æ¡blebarwedgÃ¥ÃºnÆadhá®áµáµ§ownarrowÃ³á²arpoonÄlráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶karoÃ·à½É¯á¶\0\0á¶rn;æop;æÆcotá¶á¶£á¶¦Äryá¶á¶¡;ìð¹;äl;æ§¶rok;äÄdrá¶°á¶´ot;æ±iÄ;fá¶ºá æ¿Äahá·á·rÃ²Ð©aÃ²à¾¦angle;æ¦¦Äciá·á·y;ägrarr;æ¿à¤Dacdefglmnopqrstuxá¸á¸á¸á¸¸Õ¸á¸¼á¹á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½á½á½ÄDoá¸á´´oÃ´á²Äcsá¸á¸uteè»Ã©ä©ter;æ©®Èaioyá¸¢á¸§á¸±á¸¶ron;ärÄ;cá¸­á¸®æè»Ãªäªlon;æ;äot;äÄDrá¹á¹ot;æ;ìð¢Æ;rsá¹á¹á¹æªaveè»Ã¨ä¨Ä;dá¹á¹æªot;æªÈ;ilsá¹ªá¹«á¹²á¹´æªnters;æ§;æÄ;dá¹¹á¹ºæªot;æªÆapsáºáºáºcr;ätyÆ;sváºáºáºæetÂ»áºpÄ1;áºáº¤Ä³áº¡áº£;æ;ææÄgsáºªáº¬;äp;æÄgpáº´áº¸on;äf;ìðÆalsá»á»á»rÄ;sá»á»æl;æ§£us;æ©±iÆ;lvá»á»á»äµonÂ»á»;äµÈcsuvá»ªá»³á¼á¼£Äioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕantÄglá¼á¼trÂ»á¹essÂ»á¹ºÆaeiá¼á¼á¼ls;ä½st;ævÄ;DÈµá¼ D;æ©¸parsl;æ§¥ÄDaá¼¯á¼³ot;ærr;æ¥±Æcdiá¼¾á½á»¸r;æ¯oÃ´ÍÄahá½á½;ä·è»Ã°ä°Ämrá½á½lè»Ã«ä«o;æ¬Æcipá½¡á½¤á½§l;ä¡sÃ´Õ®Äeoá½¬á½´ctatioÃ®ÕnentialÃ¥Õ¹à§¡á¾\0á¾\0á¾¡á¾§\0\0á¿á¿\0á¿\0á¿¦á¿ªâ\0ââllingdotseÃ±á¹y;ämale;æÆilrá¾­á¾³á¿lig;èï¬É©á¾¹\0\0á¾½g;èï¬ig;èï¬;ìð£lig;èï¬lig;ìfjÆaltá¿á¿á¿¡t;æ­ig;èï¬ns;æ±of;äÇ°á¿®\0á¿³f;ìðÄakÖ¿á¿·Ä;vá¿¼á¿½æ;æ«artint;æ¨ÄaoââÄcsââÎ±ââ°â¸ââ\0âÎ²â¢â¥â§âªâ¬\0â®è»Â½ä½;æè»Â¼ä¼;æ;æ;æÆ³â´\0â¶;æ;æÊ´â¾â\0\0âè»Â¾ä¾;æ;æ5;æÆ¶â\0â;æ;æ8;æl;æwn;æ¢cr;ìð»à¢Eabcdefgijlnorstvââââ¥â°â´â°âµâºâ¿âââ¸Ìâ¾ââÄ;lÙâ;æªÆcmpâââute;äµmaÄ;dâá³ä³;æªreve;äÄiyâªâ®rc;ä;ä³ot;ä¡È;lqsØ¾Ùâ½âÆ;qsØ¾ÙâlanÃ´Ù¥È;cdlÙ¥âââ¥c;æª©otÄ;oââæªÄ;lâ¢â£æª;æªÄ;eâªâ­ìâï¸s;æªr;ìð¤Ä;gÙ³Ømel;æ·cy;äÈ;EajÙâââ;æª;æª¥;æª¤ÈEaesâââ©â´;æ©pÄ;pâ£â¤æªroxÂ»â¤Ä;qâ®â¯æªÄ;qâ®âim;æ§pf;ìðÄciââr;æmÆ;elÙ«ââ;æª;æªè>;cdlqr×®â âªâ®â³â¹Äciâ¥â§;æª§r;æ©ºot;æPar;æ¦uest;æ©¼ÊadelsââªâÙâÇ°â\0âproÃ¸âr;æ¥¸qÄlqØ¿âlesÃ³âiÃ­Ù«Äenâ£â­rtneqq;ìâ©ï¸ÃâªÔAabcefkosyâââ±âµâºâââ¯â¨â½rÃ²Î ÈilmrâââârsÃ°áfÂ»â¤ilÃ´Ú©Ädrâ â¤cy;äÆ;cwà£´â«â¯ir;æ¥;æ­ar;æirc;ä¥ÆalrââârtsÄ;uââæ¥itÂ»âlip;æ¦con;æ¹r;ìð¥sÄewâ£â©arow;æ¤¥arow;æ¤¦Êamoprâºâ¾âââ£rr;æ¿tht;æ»kÄlrââeftarrow;æ©ightarrow;æªf;ìðbar;æÆcltâ¯â´â¸r;ìð½asÃ¨â´rok;ä§Äbpââull;æhenÂ»á±à«¡â£\0âª\0â¸ââ\0ââ³\0\0â¸â¢â§â¢â¿\0ââªâ´cuteè»Ã­ä­Æ;iyÝ±â°âµrcè»Ã®ä®;ä¸Äcxâ¼â¿y;äµclè»Â¡ä¡ÄfrÎâ;ìð¦raveè»Ã¬ä¬È;inoÜ¾ââ©â®Äinâ¢â¦nt;æ¨t;æ­fin;æ§ta;æ©lig;ä³Æaopâ¾ââÆcgtâââr;ä«ÆelpÜââinÃ¥ÞarÃ´Ü h;ä±f;æ·ed;äµÊ;cfotÓ´â¬â±â½âare;æinÄ;tâ¸â¹æie;æ§doÃ´âÊ;celpÝââââ¡al;æºÄgrââerÃ³á£Ã£âarhk;æ¨rod;æ¨¼Ècgptâ¯â²â¶â»y;äon;ä¯f;ìða;ä¹uestè»Â¿ä¿Äciââr;ìð¾nÊ;EdsvÓ´âââ¡Ó³;æ¹ot;æµÄ;vâ¦â§æ´;æ³Ä;iÝ·â®lde;ä©Ç«â¸\0â¼cy;älè»Ã¯ä¯Ìcfmosuââââ¡â§âµÄiyâârc;äµ;ä¹r;ìð§ath;ä·pf;ìðÇ£â¬\0â±r;ìð¿rcy;äkcy;äÐacfghjosâââ¢â§â­â±âµâ»ppaÄ;vââäº;ä°Äeyââ dil;ä·;äºr;ìð¨reen;ä¸cy;äcy;äpf;ìðcr;ìðà®ABEHabcdefghjlmnoprstuvâ°ââââââ½âââââ¥â¹â½ââ²âââ¨âââ â Æartâ·âºâ¼rÃ²à§Ã²Îail;æ¤arr;æ¤Ä;gà¦â;æªar;æ¥¢à¥£â¥\0âª\0â±\0\0\0\0\0âµâº\0âââ\0â¹ute;äºmptyv;æ¦´raÃ®à¡bda;ä»gÆ;dlà¢ââ;æ¦Ã¥à¢;æªuoè»Â«ä«rÐ;bfhlpstà¢ââ¦â©â«â®â±âµÄ;fà¢â£s;æ¤s;æ¤Ã«âp;æ«l;æ¤¹im;æ¥³l;æ¢Æ;aeâ¿ââæª«il;æ¤Ä;sââæª­;ìâª­ï¸Æabrââârr;æ¤rk;æ²Äakâ¢â¬cÄekâ¨âª;ä»;äÄesâ±â³;æ¦lÄduâ¹â»;æ¦;æ¦Èaeuyââââron;ä¾Ädiââil;ä¼Ã¬à¢°Ã¢â©;ä»Ècqrsâ£â¦â­â½a;æ¤¶uoÄ;rà¸áÄduâ²â·har;æ¥§shar;æ¥h;æ²Ê;fgqsââà¦â³â¿æ¤tÊahlrtââ¤â·ââ¨rrowÄ;tà¢â¡aÃ©â¶arpoonÄduâ¯â´ownÂ»ÑpÂ»à¥¦eftarrows;æightÆahsââârrowÄ;sà£´à¢§arpoonÃ³à¾quigarroÃ·â°hreetimes;æÆ;qsâà¦âºlanÃ´à¦¬Ê;cdgsà¦¬ââââ¨c;æª¨otÄ;oââæ©¿Ä;rââæª;æªÄ;eâ¢â¥ìâï¸s;æªÊadegsâ³â¹â½ââpproÃ¸âot;æqÄgqââÃ´à¦gtÃ²âÃ´à¦iÃ­à¦²Æilrâà£¡âsht;æ¥¼;ìð©Ä;Eà¦â£;æªÅ¡â©â¶rÄduâ²â®Ä;là¥¥â³;æ¥ªlk;æcy;äÊ;achtà©âââârÃ²âorneÃ²á´ard;æ¥«ri;æºÄioââ¤dot;äustÄ;aâ¬â­æ°cheÂ»â­ÈEaesâ»â½ââ;æ¨pÄ;pââæªroxÂ»âÄ;qââæªÄ;qââ»im;æ¦Ðabnoptwzâ©â´â·ââ¯âââÄnrâ®â±g;æ¬r;æ½rÃ«à£gÆlmrâ¿ââeftÄarà§¦âightÃ¡à§²apsto;æ¼ightÃ¡à§½parrowÄlrâ¥â©efÃ´â­ight;æ¬Æaflâ¶â¹â½r;æ¦;ìðus;æ¨­imes;æ¨´Å¡ââst;æÃ¡áÆ;efââá ængeÂ»âarÄ;lâ¤â¥ä¨t;æ¦Êachmtâ³â¶â¼âârÃ²à¢¨orneÃ²á¶arÄ;dà¾â;æ¥­;æri;æ¿Ìachiqtââà©â¢â®â»quo;æ¹r;ìðmÆ;egà¦²âªâ¬;æª;æªÄbuâªâ³oÄ;rà¸â¹;ærok;äè<;cdhilqrà «ââ¹ââ â¥âªâ°Äciââ;æª¦r;æ©¹reÃ¥â²mes;æarr;æ¥¶uest;æ©»ÄPiâµâ¹ar;æ¦Æ;efâ à¤­á ærÄduâ â shar;æ¥har;æ¥¦Äenâ â ¡rtneqq;ìâ¨ï¸Ãâ ÜDacdefhilnopsuâ¡â¡â¢â¢â¢â¢ â¢¥â¢¨â£â£¢â£¤àªâ£³â¤Dot;æºÈclprâ¡â¡â¡£â¡½rè»Â¯ä¯Äetâ¡â¡;æÄ;eâ¡â¡æ seÂ»â¡Ä;sá»â¡¨toÈ;dluá»â¡³â¡·â¡»owÃ®ÒefÃ´à¤Ã°áker;æ®Äoyâ¢â¢mma;æ¨©;ä¼ash;æasuredangleÂ»á¦r;ìðªo;æ§Æcdnâ¢¯â¢´â£roè»ÂµäµÈ;acdá¤â¢½â£â£sÃ´á§ir;æ«°otè»Â·ÆµusÆ;bdâ£á¤â£æÄ;uá´¼â£;æ¨ªÅ£â£â£¡p;æ«Ã²âÃ°àªÄdpâ£©â£®els;æ§f;ìðÄctâ£¸â£½r;ìðposÂ»áÆ;lmâ¤â¤â¤ä¼timap;æ¸à°GLRVabcdefghijlmoprstuvwâ¥â¥â¥¾â¦â¦â§â§©â¨â¨â©â©âªâªâª¤âª¨â¬â¬â­â­¿â®®â°´â±§â±¼â³©Ägtâ¥â¥;ìâÌ¸Ä;vâ¥à¯ìâ«âÆeltâ¥â¥²â¥¶ftÄarâ¥¡â¥§rrow;æightarrow;æ;ìâÌ¸Ä;vâ¥»à±ìâªâightarrow;æÄDdâ¦â¦ash;æ¯ash;æ®Êbcnptâ¦£â¦§â¦¬â¦±â§laÂ»Ëute;äg;ìâ âÊ;Eiopà¶â¦¼â§â§â§;ìâ©°Ì¸d;ìâÌ¸s;äroÃ¸à¶urÄ;aâ§â§æ®lÄ;sâ§à¬¸Ç³â§\0â§£pè»Â à¬·mpÄ;eà¯¹à°Êaeouyâ§´â§¾â¨â¨â¨Ç°â§¹\0â§»;æ©on;ädil;ängÄ;dàµ¾â¨ot;ìâ©­Ì¸p;æ©;ä½ash;æÎ;Aadqsxà®â¨©â¨­â¨»â©â©â©rr;ærÄhrâ¨³â¨¶k;æ¤¤Ä;oá²á°ot;ìâÌ¸uiÃ¶à­£Äeiâ©â©ar;æ¤¨Ã­à®istÄ;sà® à®r;ìð«ÈEestà¯â©¦â©¹â©¼Æ;qsà®¼â©­à¯¡Æ;qsà®¼à¯â©´lanÃ´à¯¢iÃ­à¯ªÄ;rà®¶âªÂ»à®·ÆAapâªâªâªrÃ²â¥±rr;æ®ar;æ«²Æ;svà¾âªà¾Ä;dâª¡âª¢æ¼;æºcy;äÎAEadestâª·âªºâª¾â«â«â«¶â«¹rÃ²â¥¦;ìâ¦Ì¸rr;ær;æ¥È;fqsà°»â«â«£â«¯tÄarâ«â«rroÃ·â«ightarroÃ·âªÆ;qsà°»âªºâ«ªlanÃ´à±Ä;sà±â«´Â»à°¶iÃ­à±Ä;rà°µâ«¾iÄ;eà°à°¥iÃ¤à¶Äptâ¬â¬f;ìðèÂ¬;inâ¬â¬â¬¶ä¬nÈ;Edvà®â¬¤â¬¨â¬®;ìâ¹Ì¸ot;ìâµÌ¸Ç¡à®â¬³â¬µ;æ·;æ¶iÄ;và²¸â¬¼Ç¡à²¸â­â­;æ¾;æ½Æaorâ­â­£â­©rÈ;astà­»â­â­â­lleÃ¬à­»l;ìâ«½â¥;ìâÌ¸lint;æ¨Æ;ceà²â­°â­³uÃ¥à²¥Ä;cà²â­¸Ä;eà²â­½Ã±à²ÈAaitâ®â®â®â®§rÃ²â¦rrÆ;cwâ®â®â®æ;ìâ¤³Ì¸;ìâÌ¸ghtarrowÂ»â®riÄ;eà³à³Îchimpquâ®½â¯â¯â¬à­¸â¯¤â¯¯È;cerà´²â¯à´·â¯uÃ¥àµ;ìðortÉ­â¬\0\0â¯arÃ¡â­mÄ;eàµ®â¯Ä;qàµ´àµ³suÄbpâ¯«â¯­Ã¥à³¸Ã¥à´Æbcpâ¯¶â°â°È;Eesâ¯¿â°à´¢â°æ;ìâ«Ì¸etÄ;eà´â°qÄ;qà´£â°cÄ;eà´²â°Ã±à´¸È;Eesâ°¢â°£àµâ°§æ;ìâ«Ì¸etÄ;eàµâ°®qÄ;qàµ â°£Ègilrâ°½â°¿â±â±Ã¬à¯ldeè»Ã±ä±Ã§à±iangleÄlrâ±â±eftÄ;eà°â±Ã±à°¦ightÄ;eà³â±¥Ã±à³Ä;mâ±¬â±­ä½Æ;esâ±´â±µâ±¹ä£ro;æp;æÒDHadgilrsâ²â²â²â²â²£â²°â²¶â³â³£ash;æ­arr;æ¤p;ìââash;æ¬Äetâ²¨â²¬;ìâ¥â;ì>ânfin;æ§ÆAetâ²½â³â³rr;æ¤;ìâ¤âÄ;râ³â³ì<âie;ìâ´âÄAtâ³â³rr;æ¤rie;ìâµâim;ìâ¼âÆAanâ³°â³´â´rr;ærÄhrâ³ºâ³½k;æ¤£Ä;oá§á¥ear;æ¤§ááª\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµâµ âµ¥âµ²â¶á¬\0\0â¶â¶«\0â·â·\0â·â¸â¸«â¸¾â¹Äcsâ´±áªuteè»Ã³ä³Äiyâ´¼âµrÄ;cáªâµè»Ã´ä´;ä¾Êabiosáª âµâµÇâµlac;äv;æ¨¸old;æ¦¼lig;äÄcrâµ©âµ­ir;æ¦¿;ìð¬Í¯âµ¹\0\0âµ¼\0â¶n;äaveè»Ã²ä²;æ§Äbmâ¶à·´ar;æ¦µÈacitâ¶â¶â¶¥â¶¨rÃ²áªÄirâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹;æ§Æaeiâ¶±â¶µâ¶¹cr;äga;äÆcdnâ·â·Çron;ä¿;æ¦¶pf;ìð Æaelâ·â·Çr;æ¦·rp;æ¦¹Î;adiosvâ·ªâ·«â·®â¸â¸â¸â¸æ¨rÃ²áªÈ;efmâ··â·¸â¸â¸æ©rÄ;oâ·¾â·¿æ´fÂ»â·¿è»Âªäªè»Âºäºgof;æ¶r;æ©lope;æ©;æ©Æcloâ¸â¸¡â¸§Ã²â¸ashè»Ã¸ä¸l;æiÅ¬â¸¯â¸´deè»ÃµäµesÄ;aÇâ¸ºs;æ¨¶mlè»Ã¶ä¶bar;æ½à«¡â¹\0â¹½\0âºâº\0âº¢âº¹\0\0â»àº\0â¼\0\0â¼«â¾¼\0â¿rÈ;astÐâ¹§â¹²àºèÂ¶;lâ¹­â¹®ä¶leÃ¬ÐÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊcimptâºâºâºá¡¥âºnt;ä¥od;ä®il;æ°enk;æ±r;ìð­Æimoâº¨âº°âº´Ä;vâº­âº®ä;ämaÃ´à©¶ne;æÆ;tvâº¿â»â»ächforkÂ»á¿½;äÄauâ»â»nÄckâ»â»kÄ;hâ´â»;æÃ¶â´sÒ;abcdemstâ»³â»´á¤â»¹â»½â¼â¼â¼â¼ä«cir;æ¨£ir;æ¨¢Äouáµâ¼;æ¨¥;æ©²nè»Â±àºim;æ¨¦wo;æ¨§Æipuâ¼â¼ â¼¥ntint;æ¨f;ìð¡ndè»Â£ä£Ô;Eaceinosuà»â¼¿â½â½â½â¾â¾â¾â½¾â¾¶;æª³p;æª·uÃ¥à»Ä;cà»â½Ì;acensà»â½â½â½¦â½¨â½¾pproÃ¸â½urlyeÃ±à»Ã±à»Æaesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ¨iÃ­à»meÄ;sâ¾àº®æ²ÆEasâ½¸â¾â½ºÃ°â½µÆdfpà»¬â¾â¾¯Æalsâ¾ â¾¥â¾ªlar;æ®ine;æurf;æÄ;tà»»â¾´Ã¯à»»rel;æ°Äciâ¿â¿r;ìð;äncsp;æÌfiopsuâ¿â¢â¿â¿¥â¿«â¿±r;ìð®pf;ìð¢rime;æcr;ìðÆaeoâ¿¸ããtÄeiâ¿¾ãrnionÃ³Ú°nt;æ¨stÄ;eããä¿Ã±á¼Ã´à¼àªABHabcdefhilmnoprstuxããããã ãã«ãã¢ã²ãããã¤ã©ãã®ã²ãã°ã·ÆartãããrÃ²á³Ã²Ïail;æ¤arÃ²á±¥ar;æ¥¤Îcdenqrtã¨ãµã¸ã¿ãããÄeuã­ã±;ìâ½Ì±te;äiÃ£á®mptyv;æ¦³gÈ;delà¿ããã;æ¦;æ¦¥Ã¥à¿uoè»Â»ä»rÖ;abcfhlpstwà¿ã¬ã¯ã·ã¹ã¼ã¾ããããp;æ¥µÄ;fà¿ ã´s;æ¤ ;æ¤³s;æ¤Ã«âÃ°â®l;æ¥im;æ¥´l;æ£;æÄaiããil;æ¤oÄ;nããæ¶alÃ³à¼Æabrã§ãªã®rÃ²á¥rk;æ³Äakã³ã½cÄekã¹ã»;ä½;äÄesãã;æ¦lÄduãã;æ¦;æ¦Èaeuyããã§ã©ron;äÄdiã¡ã¥il;äÃ¬à¿²Ã¢ãº;äÈclqsã´ã·ã½ãa;æ¤·dhar;æ¥©uoÄ;rÈÈh;æ³Æacgããà½lÈ;ipsà½¸ããánÃ¥á»arÃ´à¾©t;æ­Æilrã©á£ã®sht;æ¥½;ìð¯Äaoã·ãrÄduã½ã¿Â»Ñ»Ä;láã;æ¥¬Ä;vããä;ä±Ægnsãã¹ã¼htÌahlrstã¤ã°ããã¤ã®rrowÄ;tà¿ã­aÃ©ãarpoonÄduã»ã¿owÃ®ã¾pÂ»áeftÄahããrrowÃ³à¿ªarpoonÃ³Õightarrows;æquigarroÃ·ãhreetimes;æg;äingdotseÃ±á¼²ÆahmãããrÃ²à¿ªaÃ²Õ;æoustÄ;aããæ±cheÂ»ãmid;æ«®Èabptã²ã½ããÄnrã·ãºg;æ­r;æ¾rÃ«áÆaflãããr;æ¦;ìð£us;æ¨®imes;æ¨µÄapãã§rÄ;gã£ã¤ä©t;æ¦olint;æ¨arÃ²ã£Èachqã»ãá¼ãquo;æºr;ìðÄbuã»ãoÄ;rÈÈÆhirããã reÃ¥ã¸mes;æiÈ;eflãªáá ¡ã«æ¹tri;æ§luhar;æ¥¨;æàµ¡ãããã¬ã¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ããã­ã±ãã±\0ã\0\0ã³cute;äquÃ¯âºÔ;Eaceinpsyá­ã³ãµã¿ããããã¦ã©;æª´Ç°ãº\0ã¼;æª¸on;ä¡uÃ¥á¾Ä;dá³ãil;ärc;äÆEasããã;æª¶p;æªºim;æ©olint;æ¨iÃ­á;äotÆ;beã´áµãµæ;æ©¦ÎAacmstxãããããã£ã­rr;ærÄhrããÃ«â¨Ä;oà¨¶à¨´tè»Â§ä§i;ä»war;æ¤©mÄinã©Ã°nuÃ³Ã±t;æ¶rÄ;oã¶âìð°Èacoyãããã rp;æ¯Ähyããcy;ä;ärtÉ­ã\0\0ãiÃ¤á¤araÃ¬â¹¯è»Â­ä­Ägmã¨ã´maÆ;fvã±ã²ã²ä;äÐ;deglnprá«ãããããã¡ã¦ot;æ©ªÄ;qá±á°Ä;Eããæª;æª Ä;Eããæª;æªe;ælus;æ¨¤arr;æ¥²arÃ²á½Èaeitã¸ãããÄlsã½ãlsetmÃ©ãªhp;æ¨³parsl;æ§¤Ädlá£ãe;æ£Ä;eããæªªÄ;sã¢ã£æª¬;ìâª¬ï¸Æflpã®ã³ãtcy;äÄ;bã¸ã¹ä¯Ä;aã¾ã¿æ§r;æ¿f;ìð¤aÄdrãÐesÄ;uããæ itÂ»ãÆcsuã ã¹ãÄauã¥ã¯pÄ;sáã«;ìâï¸pÄ;sá´ãµ;ìâï¸uÄbpã¿ãÆ;esááãetÄ;eáãÃ±áÆ;esá¨á­ãetÄ;eá¨ãÃ±á®Æ;afá»ã¦Ö°rÅ¥ã«Ö±Â»á¼arÃ²áÈcemtã¹ã¾ããr;ìðtmÃ®Ã±iÃ¬ãarÃ¦á¾ÄarããrÄ;fãá¿æÄanãã­ightÄepã£ãªpsiloÃ®á» hÃ©âº¯sÂ»â¡Êbcmnpã»ãáããÒ;Edemnprsãããããã£ã¬ã±ã¶æ;æ«ot;æª½Ä;dáãot;æ«ult;æ«ÄEeã¨ãª;æ«;ælus;æª¿arr;æ¥¹Æeiuã½ããtÆ;enãããqÄ;qáãeqÄ;qã«ã¨m;æ«Äbpãã;æ«;æ«cÌ;acensá­ã¬ã²ã¹ã»ã¦pproÃ¸ãºurlyeÃ±á¾Ã±á³ÆaesãããpproÃ¸ãqÃ±ãg;æªÚ123;Edehlmnpsã©ã¬ã¯áã²ã´ãããããã¨ã­è»Â¹ä¹è»Â²ä²è»Â³ä³;æ«Äosã¹ã¼t;æª¾ub;æ«Ä;dá¢ãot;æ«sÄouããl;æb;æ«arr;æ¥»ult;æ«ÄEeã¤ã¦;æ«;ælus;æ«Æeiuã´ããtÆ;enáã¼ãqÄ;qá¢ã²eqÄ;qã§ã¤m;æ«Äbpãã;æ«;æ«ÆAanãã ã­rr;ærÄhrã¦ã¨Ã«â®Ä;oà¨«à¨©war;æ¤ªligè»Ãäà¯¡ããã áã³ã¹\0ã¾ã\0\0\0\0\0ãã\0ãã¬\0\0\0ãÉ²ã\0\0ãget;æ;ärÃ«à¹Æaeyã¦ã«ã°ron;ä¥dil;ä£;älrec;ær;ìð±Èeikoãããµã¼Ç²ã\0ãeÄ4fááaÆ;svãããä¸ym;äÄcnã¢ã²kÄasã¨ã®pproÃ¸áimÂ»á¬sÃ°áÄasãºã®Ã°árnè»Ã¾ä¾Ç¬Ìãâ§esèÃ;bdãããäÄ;aá¤ãr;æ¨±;æ¨°Æepsã¡ã£ãÃ¡â©È;bcfÒã¬ã°ã´ot;æ¶ir;æ«±Ä;oã¹ã¼ìð¥rk;æ«Ã¡ã¢rime;æ´Æaipããã¤dÃ¥áÎadempstã¡ããããããngleÊ;dlqrã°ã±ã¶ããæµownÂ»á¶»eftÄ;eâ ã¾Ã±à¤®;æightÄ;eãªãÃ±áot;æ¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æchtã²ã½ãÄryã·ã»;ìð;äcy;ärok;ä§ÄioããxÃ´á·headÄlrãã eftarroÃ·à¡ightarrowÂ»à½à¤AHabcdfghlmoprstuwãããã¤ã°ã¼ã ã ã £ã ´ã¡ã¡ã¡«ã¢©ã£ã£ã£ªã£¶rÃ²Ï­ar;æ¥£Äcrãã¢uteè»ÃºäºÃ²árÇ£ãª\0ã­y;äve;ä­Äiyãµãºrcè»Ã»ä»;äÆabhã ã ã rÃ²á­lac;ä±aÃ²áÄirã ã sht;æ¥¾;ìð²raveè»Ã¹ä¹Å¡ã §ã ±rÄlrã ¬ã ®Â»à¥Â»álk;æÄctã ¹ã¡É¯ã ¿\0\0ã¡rnÄ;eã¡ã¡ærÂ»ã¡op;æri;æ¸Äalã¡ã¡cr;ä«è»Â¨ÍÄgpã¡¢ã¡¦on;ä³f;ìð¦Ìadhlsuáã¡¸ã¡½á²ã¢ã¢ ownÃ¡á³arpoonÄlrã¢ã¢efÃ´ã ­ighÃ´ã ¯iÆ;hlã¢ã¢ã¢äÂ»áºonÂ»ã¢parrows;æÆcitã¢°ã£ã£É¯ã¢¶\0\0ã£rnÄ;eã¢¼ã¢½ærÂ»ã¢½op;æng;ä¯ri;æ¹cr;ìðÆdirã£ã£ã£¢ot;æ°lde;ä©iÄ;fã°ã£¨Â»á Äamã£¯ã£²rÃ²ã¢¨lè»Ã¼ä¼angle;æ¦§ÞABDacdeflnoprszã¤ã¤ã¤©ã¤­ã¦µã¦¸ã¦½ã§ã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Änrã¤²ã¤·grt;æ¦Îeknprstã£ã¥ã¥ã¥ã¥ã¥¤ã¦appÃ¡âothinÃ§áºÆhirã«â»ã¥opÃ´â¾µÄ;há·ã¥¢Ã¯ãÄiuã¥©ã¥­gmÃ¡ã³Äbpã¥²ã¦setneqÄ;qã¥½ã¦ìâï¸;ìâ«ï¸setneqÄ;qã¦ã¦ìâï¸;ìâ«ï¸Ährã¦ã¦etÃ¡ãiangleÄlrã¦ªã¦¯eftÂ»à¤¥ightÂ»áy;ä²ashÂ»á¶Æelrã§ã§ã§Æ;beâ·ªã§ã§ar;æ»q;ælip;æ®Äbtã§á¨aÃ²á©r;ìð³trÃ©ã¦®suÄbpã§¯ã§±Â»à´Â»àµpf;ìð§roÃ°à»»trÃ©ã¦´Äcuã¨ã¨r;ìðÄbpã¨ã¨nÄEeã¦ã¨Â»ã¥¾nÄEeã¦ã¨Â»ã¦igzag;æ¦Îcefoprsã¨¶ã¨»ã©ã©ã©ã©¡ã©ªirc;äµÄdiã©ã©Äbgã©ã©ar;æ©eÄ;qáºã©;æerp;ær;ìð´pf;ìð¨Ä;eá¹ã©¦atÃ¨á¹cr;ìðà«£áãª\0ãª\0ãªãª\0\0ãªãª¨ãª«ãª¯\0\0ã«ã«\0ã«áátrÃ©ár;ìðµÄAaãªãªrÃ²ÏrÃ²à§¶;ä¾ÄAaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âis;æ»Ædptá¤ãªµãª¾Äflãªºá©;ìð©imÃ¥á²ÄAaã«ã«rÃ²ÏrÃ²à¨Äcqã«á¸r;ìðÄptáã«rÃ©áÐacefiosuã«°ã«½ã¬ã¬ã¬ã¬ã¬ã¬¡cÄuyã«¶ã«»teè»Ã½ä½;äÄiyã¬ã¬rc;ä·;änè»Â¥ä¥r;ìð¶cy;äpf;ìðªcr;ìðÄcmã¬¦ã¬©y;älè»Ã¿ä¿Ôacdefhioswã­ã­ã­ã­ã­¤ã­©ã­­ã­´ã­ºã®cute;äºÄayã­ã­ron;ä¾;ä·ot;ä¼Äetã­ã­¡trÃ¦áa;ä¶r;ìð·cy;ä¶grarr;æpf;ìð«cr;ìðÄjnã®ã®;æj;æ'.split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), w6;
}
var S6 = {}, ML;
function uce() {
  return ML || (ML = 1, Object.defineProperty(S6, "__esModule", { value: !0 }), S6.default = new Uint16Array(
    // prettier-ignore
    "Èaglq	\x1BÉ­\0\0p;ä¦os;ä§t;ä¾t;ä¼uot;ä¢".split("").map(function(u) {
      return u.charCodeAt(0);
    })
  )), S6;
}
var QE = {}, CL;
function qL() {
  return CL || (CL = 1, function(u) {
    var r;
    Object.defineProperty(u, "__esModule", { value: !0 }), u.replaceCodePoint = u.fromCodePoint = void 0;
    var o = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    u.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (r = String.fromCodePoint) !== null && r !== void 0 ? r : function(e) {
      var n = "";
      return e > 65535 && (e -= 65536, n += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), n += String.fromCharCode(e), n;
    };
    function a(e) {
      var n;
      return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (n = o.get(e)) !== null && n !== void 0 ? n : e;
    }
    u.replaceCodePoint = a;
    function t(e) {
      return (0, u.fromCodePoint)(a(e));
    }
    u.default = t;
  }(QE)), QE;
}
var BL;
function wY() {
  return BL || (BL = 1, function(u) {
    var r = ci && ci.__createBinding || (Object.create ? function(S, O, x, F) {
      F === void 0 && (F = x);
      var j = Object.getOwnPropertyDescriptor(O, x);
      (!j || ("get" in j ? !O.__esModule : j.writable || j.configurable)) && (j = { enumerable: !0, get: function() {
        return O[x];
      } }), Object.defineProperty(S, F, j);
    } : function(S, O, x, F) {
      F === void 0 && (F = x), S[F] = O[x];
    }), o = ci && ci.__setModuleDefault || (Object.create ? function(S, O) {
      Object.defineProperty(S, "default", { enumerable: !0, value: O });
    } : function(S, O) {
      S.default = O;
    }), a = ci && ci.__importStar || function(S) {
      if (S && S.__esModule) return S;
      var O = {};
      if (S != null) for (var x in S) x !== "default" && Object.prototype.hasOwnProperty.call(S, x) && r(O, S, x);
      return o(O, S), O;
    }, t = ci && ci.__importDefault || function(S) {
      return S && S.__esModule ? S : { default: S };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.decodeXML = u.decodeHTMLStrict = u.decodeHTMLAttribute = u.decodeHTML = u.determineBranch = u.EntityDecoder = u.DecodingMode = u.BinTrieFlags = u.fromCodePoint = u.replaceCodePoint = u.decodeCodePoint = u.xmlDecodeTree = u.htmlDecodeTree = void 0;
    var e = t(/* @__PURE__ */ ace());
    u.htmlDecodeTree = e.default;
    var n = t(/* @__PURE__ */ uce());
    u.xmlDecodeTree = n.default;
    var i = a(/* @__PURE__ */ qL());
    u.decodeCodePoint = i.default;
    var c = /* @__PURE__ */ qL();
    Object.defineProperty(u, "replaceCodePoint", { enumerable: !0, get: function() {
      return c.replaceCodePoint;
    } }), Object.defineProperty(u, "fromCodePoint", { enumerable: !0, get: function() {
      return c.fromCodePoint;
    } });
    var s;
    (function(S) {
      S[S.NUM = 35] = "NUM", S[S.SEMI = 59] = "SEMI", S[S.EQUALS = 61] = "EQUALS", S[S.ZERO = 48] = "ZERO", S[S.NINE = 57] = "NINE", S[S.LOWER_A = 97] = "LOWER_A", S[S.LOWER_F = 102] = "LOWER_F", S[S.LOWER_X = 120] = "LOWER_X", S[S.LOWER_Z = 122] = "LOWER_Z", S[S.UPPER_A = 65] = "UPPER_A", S[S.UPPER_F = 70] = "UPPER_F", S[S.UPPER_Z = 90] = "UPPER_Z";
    })(s || (s = {}));
    var d = 32, l;
    (function(S) {
      S[S.VALUE_LENGTH = 49152] = "VALUE_LENGTH", S[S.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", S[S.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(l = u.BinTrieFlags || (u.BinTrieFlags = {}));
    function f(S) {
      return S >= s.ZERO && S <= s.NINE;
    }
    function h(S) {
      return S >= s.UPPER_A && S <= s.UPPER_F || S >= s.LOWER_A && S <= s.LOWER_F;
    }
    function p(S) {
      return S >= s.UPPER_A && S <= s.UPPER_Z || S >= s.LOWER_A && S <= s.LOWER_Z || f(S);
    }
    function b(S) {
      return S === s.EQUALS || p(S);
    }
    var _;
    (function(S) {
      S[S.EntityStart = 0] = "EntityStart", S[S.NumericStart = 1] = "NumericStart", S[S.NumericDecimal = 2] = "NumericDecimal", S[S.NumericHex = 3] = "NumericHex", S[S.NamedEntity = 4] = "NamedEntity";
    })(_ || (_ = {}));
    var y;
    (function(S) {
      S[S.Legacy = 0] = "Legacy", S[S.Strict = 1] = "Strict", S[S.Attribute = 2] = "Attribute";
    })(y = u.DecodingMode || (u.DecodingMode = {}));
    var m = (
      /** @class */
      function() {
        function S(O, x, F) {
          this.decodeTree = O, this.emitCodePoint = x, this.errors = F, this.state = _.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = y.Strict;
        }
        return S.prototype.startEntity = function(O) {
          this.decodeMode = O, this.state = _.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, S.prototype.write = function(O, x) {
          switch (this.state) {
            case _.EntityStart:
              return O.charCodeAt(x) === s.NUM ? (this.state = _.NumericStart, this.consumed += 1, this.stateNumericStart(O, x + 1)) : (this.state = _.NamedEntity, this.stateNamedEntity(O, x));
            case _.NumericStart:
              return this.stateNumericStart(O, x);
            case _.NumericDecimal:
              return this.stateNumericDecimal(O, x);
            case _.NumericHex:
              return this.stateNumericHex(O, x);
            case _.NamedEntity:
              return this.stateNamedEntity(O, x);
          }
        }, S.prototype.stateNumericStart = function(O, x) {
          return x >= O.length ? -1 : (O.charCodeAt(x) | d) === s.LOWER_X ? (this.state = _.NumericHex, this.consumed += 1, this.stateNumericHex(O, x + 1)) : (this.state = _.NumericDecimal, this.stateNumericDecimal(O, x));
        }, S.prototype.addToNumericResult = function(O, x, F, j) {
          if (x !== F) {
            var q = F - x;
            this.result = this.result * Math.pow(j, q) + parseInt(O.substr(x, q), j), this.consumed += q;
          }
        }, S.prototype.stateNumericHex = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j) || h(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 16), this.emitNumericEntity(j, 3);
          }
          return this.addToNumericResult(O, F, x, 16), -1;
        }, S.prototype.stateNumericDecimal = function(O, x) {
          for (var F = x; x < O.length; ) {
            var j = O.charCodeAt(x);
            if (f(j))
              x += 1;
            else
              return this.addToNumericResult(O, F, x, 10), this.emitNumericEntity(j, 2);
          }
          return this.addToNumericResult(O, F, x, 10), -1;
        }, S.prototype.emitNumericEntity = function(O, x) {
          var F;
          if (this.consumed <= x)
            return (F = this.errors) === null || F === void 0 || F.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (O === s.SEMI)
            this.consumed += 1;
          else if (this.decodeMode === y.Strict)
            return 0;
          return this.emitCodePoint((0, i.replaceCodePoint)(this.result), this.consumed), this.errors && (O !== s.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, S.prototype.stateNamedEntity = function(O, x) {
          for (var F = this.decodeTree, j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14; x < O.length; x++, this.excess++) {
            var Q = O.charCodeAt(x);
            if (this.treeIndex = T(F, j, this.treeIndex + Math.max(1, q), Q), this.treeIndex < 0)
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === y.Attribute && // We shouldn't have consumed any characters after the entity,
              (q === 0 || // And there should be no invalid characters.
              b(Q)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (j = F[this.treeIndex], q = (j & l.VALUE_LENGTH) >> 14, q !== 0) {
              if (Q === s.SEMI)
                return this.emitNamedEntityData(this.treeIndex, q, this.consumed + this.excess);
              this.decodeMode !== y.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, S.prototype.emitNotTerminatedNamedEntity = function() {
          var O, x = this, F = x.result, j = x.decodeTree, q = (j[F] & l.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(F, q, this.consumed), (O = this.errors) === null || O === void 0 || O.missingSemicolonAfterCharacterReference(), this.consumed;
        }, S.prototype.emitNamedEntityData = function(O, x, F) {
          var j = this.decodeTree;
          return this.emitCodePoint(x === 1 ? j[O] & ~l.VALUE_LENGTH : j[O + 1], F), x === 3 && this.emitCodePoint(j[O + 2], F), F;
        }, S.prototype.end = function() {
          var O;
          switch (this.state) {
            case _.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== y.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            // Otherwise, emit a numeric entity if we have one.
            case _.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case _.NumericHex:
              return this.emitNumericEntity(0, 3);
            case _.NumericStart:
              return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case _.EntityStart:
              return 0;
          }
        }, S;
      }()
    );
    u.EntityDecoder = m;
    function g(S) {
      var O = "", x = new m(S, function(F) {
        return O += (0, i.fromCodePoint)(F);
      });
      return function(j, q) {
        for (var Q = 0, G = 0; (G = j.indexOf("&", G)) >= 0; ) {
          O += j.slice(Q, G), x.startEntity(q);
          var K = x.write(
            j,
            // Skip the "&"
            G + 1
          );
          if (K < 0) {
            Q = G + x.end();
            break;
          }
          Q = G + K, G = K === 0 ? Q + 1 : Q;
        }
        var U = O + j.slice(Q);
        return O = "", U;
      };
    }
    function T(S, O, x, F) {
      var j = (O & l.BRANCH_LENGTH) >> 7, q = O & l.JUMP_TABLE;
      if (j === 0)
        return q !== 0 && F === q ? x : -1;
      if (q) {
        var Q = F - q;
        return Q < 0 || Q >= j ? -1 : S[x + Q] - 1;
      }
      for (var G = x, K = G + j - 1; G <= K; ) {
        var U = G + K >>> 1, ae = S[U];
        if (ae < F)
          G = U + 1;
        else if (ae > F)
          K = U - 1;
        else
          return S[U + j];
      }
      return -1;
    }
    u.determineBranch = T;
    var v = g(e.default), E = g(n.default);
    function R(S, O) {
      return O === void 0 && (O = y.Legacy), v(S, O);
    }
    u.decodeHTML = R;
    function L(S) {
      return v(S, y.Attribute);
    }
    u.decodeHTMLAttribute = L;
    function A(S) {
      return v(S, y.Strict);
    }
    u.decodeHTMLStrict = A;
    function w(S) {
      return E(S, y.Strict);
    }
    u.decodeXML = w;
  }(ci)), ci;
}
var $L;
function SY() {
  return $L || ($L = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.QuoteType = void 0;
    var r = /* @__PURE__ */ wY(), o;
    (function(f) {
      f[f.Tab = 9] = "Tab", f[f.NewLine = 10] = "NewLine", f[f.FormFeed = 12] = "FormFeed", f[f.CarriageReturn = 13] = "CarriageReturn", f[f.Space = 32] = "Space", f[f.ExclamationMark = 33] = "ExclamationMark", f[f.Number = 35] = "Number", f[f.Amp = 38] = "Amp", f[f.SingleQuote = 39] = "SingleQuote", f[f.DoubleQuote = 34] = "DoubleQuote", f[f.Dash = 45] = "Dash", f[f.Slash = 47] = "Slash", f[f.Zero = 48] = "Zero", f[f.Nine = 57] = "Nine", f[f.Semi = 59] = "Semi", f[f.Lt = 60] = "Lt", f[f.Eq = 61] = "Eq", f[f.Gt = 62] = "Gt", f[f.Questionmark = 63] = "Questionmark", f[f.UpperA = 65] = "UpperA", f[f.LowerA = 97] = "LowerA", f[f.UpperF = 70] = "UpperF", f[f.LowerF = 102] = "LowerF", f[f.UpperZ = 90] = "UpperZ", f[f.LowerZ = 122] = "LowerZ", f[f.LowerX = 120] = "LowerX", f[f.OpeningSquareBracket = 91] = "OpeningSquareBracket";
    })(o || (o = {}));
    var a;
    (function(f) {
      f[f.Text = 1] = "Text", f[f.BeforeTagName = 2] = "BeforeTagName", f[f.InTagName = 3] = "InTagName", f[f.InSelfClosingTag = 4] = "InSelfClosingTag", f[f.BeforeClosingTagName = 5] = "BeforeClosingTagName", f[f.InClosingTagName = 6] = "InClosingTagName", f[f.AfterClosingTagName = 7] = "AfterClosingTagName", f[f.BeforeAttributeName = 8] = "BeforeAttributeName", f[f.InAttributeName = 9] = "InAttributeName", f[f.AfterAttributeName = 10] = "AfterAttributeName", f[f.BeforeAttributeValue = 11] = "BeforeAttributeValue", f[f.InAttributeValueDq = 12] = "InAttributeValueDq", f[f.InAttributeValueSq = 13] = "InAttributeValueSq", f[f.InAttributeValueNq = 14] = "InAttributeValueNq", f[f.BeforeDeclaration = 15] = "BeforeDeclaration", f[f.InDeclaration = 16] = "InDeclaration", f[f.InProcessingInstruction = 17] = "InProcessingInstruction", f[f.BeforeComment = 18] = "BeforeComment", f[f.CDATASequence = 19] = "CDATASequence", f[f.InSpecialComment = 20] = "InSpecialComment", f[f.InCommentLike = 21] = "InCommentLike", f[f.BeforeSpecialS = 22] = "BeforeSpecialS", f[f.SpecialStartSequence = 23] = "SpecialStartSequence", f[f.InSpecialTag = 24] = "InSpecialTag", f[f.BeforeEntity = 25] = "BeforeEntity", f[f.BeforeNumericEntity = 26] = "BeforeNumericEntity", f[f.InNamedEntity = 27] = "InNamedEntity", f[f.InNumericEntity = 28] = "InNumericEntity", f[f.InHexEntity = 29] = "InHexEntity";
    })(a || (a = {}));
    function t(f) {
      return f === o.Space || f === o.NewLine || f === o.Tab || f === o.FormFeed || f === o.CarriageReturn;
    }
    function e(f) {
      return f === o.Slash || f === o.Gt || t(f);
    }
    function n(f) {
      return f >= o.Zero && f <= o.Nine;
    }
    function i(f) {
      return f >= o.LowerA && f <= o.LowerZ || f >= o.UpperA && f <= o.UpperZ;
    }
    function c(f) {
      return f >= o.UpperA && f <= o.UpperF || f >= o.LowerA && f <= o.LowerF;
    }
    var s;
    (function(f) {
      f[f.NoValue = 0] = "NoValue", f[f.Unquoted = 1] = "Unquoted", f[f.Single = 2] = "Single", f[f.Double = 3] = "Double";
    })(s = u.QuoteType || (u.QuoteType = {}));
    var d = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    }, l = (
      /** @class */
      function() {
        function f(h, p) {
          var b = h.xmlMode, _ = b === void 0 ? !1 : b, y = h.decodeEntities, m = y === void 0 ? !0 : y;
          this.cbs = p, this.state = a.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = a.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = _, this.decodeEntities = m, this.entityTrie = _ ? r.xmlDecodeTree : r.htmlDecodeTree;
        }
        return f.prototype.reset = function() {
          this.state = a.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = a.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
        }, f.prototype.write = function(h) {
          this.offset += this.buffer.length, this.buffer = h, this.parse();
        }, f.prototype.end = function() {
          this.running && this.finish();
        }, f.prototype.pause = function() {
          this.running = !1;
        }, f.prototype.resume = function() {
          this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
        }, f.prototype.getIndex = function() {
          return this.index;
        }, f.prototype.getSectionStart = function() {
          return this.sectionStart;
        }, f.prototype.stateText = function(h) {
          h === o.Lt || !this.decodeEntities && this.fastForwardTo(o.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = a.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && h === o.Amp && (this.state = a.BeforeEntity);
        }, f.prototype.stateSpecialStartSequence = function(h) {
          var p = this.sequenceIndex === this.currentSequence.length, b = p ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            e(h)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (h | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!b)
            this.isSpecial = !1;
          else if (!p) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0, this.state = a.InTagName, this.stateInTagName(h);
        }, f.prototype.stateInSpecialTag = function(h) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (h === o.Gt || t(h)) {
              var p = this.index - this.currentSequence.length;
              if (this.sectionStart < p) {
                var b = this.index;
                this.index = p, this.cbs.ontext(this.sectionStart, p), this.index = b;
              }
              this.isSpecial = !1, this.sectionStart = p + 2, this.stateInClosingTagName(h);
              return;
            }
            this.sequenceIndex = 0;
          }
          (h | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === d.TitleEnd ? this.decodeEntities && h === o.Amp && (this.state = a.BeforeEntity) : this.fastForwardTo(o.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(h === o.Lt);
        }, f.prototype.stateCDATASequence = function(h) {
          h === d.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === d.Cdata.length && (this.state = a.InCommentLike, this.currentSequence = d.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = a.InDeclaration, this.stateInDeclaration(h));
        }, f.prototype.fastForwardTo = function(h) {
          for (; ++this.index < this.buffer.length + this.offset; )
            if (this.buffer.charCodeAt(this.index - this.offset) === h)
              return !0;
          return this.index = this.buffer.length + this.offset - 1, !1;
        }, f.prototype.stateInCommentLike = function(h) {
          h === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === d.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = a.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : h !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }, f.prototype.isTagStartChar = function(h) {
          return this.xmlMode ? !e(h) : i(h);
        }, f.prototype.startSpecial = function(h, p) {
          this.isSpecial = !0, this.currentSequence = h, this.sequenceIndex = p, this.state = a.SpecialStartSequence;
        }, f.prototype.stateBeforeTagName = function(h) {
          if (h === o.ExclamationMark)
            this.state = a.BeforeDeclaration, this.sectionStart = this.index + 1;
          else if (h === o.Questionmark)
            this.state = a.InProcessingInstruction, this.sectionStart = this.index + 1;
          else if (this.isTagStartChar(h)) {
            var p = h | 32;
            this.sectionStart = this.index, !this.xmlMode && p === d.TitleEnd[2] ? this.startSpecial(d.TitleEnd, 3) : this.state = !this.xmlMode && p === d.ScriptEnd[2] ? a.BeforeSpecialS : a.InTagName;
          } else h === o.Slash ? this.state = a.BeforeClosingTagName : (this.state = a.Text, this.stateText(h));
        }, f.prototype.stateInTagName = function(h) {
          e(h) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h));
        }, f.prototype.stateBeforeClosingTagName = function(h) {
          t(h) || (h === o.Gt ? this.state = a.Text : (this.state = this.isTagStartChar(h) ? a.InClosingTagName : a.InSpecialComment, this.sectionStart = this.index));
        }, f.prototype.stateInClosingTagName = function(h) {
          (h === o.Gt || t(h)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.AfterClosingTagName, this.stateAfterClosingTagName(h));
        }, f.prototype.stateAfterClosingTagName = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.state = a.Text, this.baseState = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeAttributeName = function(h) {
          h === o.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = a.InSpecialTag, this.sequenceIndex = 0) : this.state = a.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : h === o.Slash ? this.state = a.InSelfClosingTag : t(h) || (this.state = a.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateInSelfClosingTag = function(h) {
          h === o.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = a.Text, this.baseState = a.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : t(h) || (this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h));
        }, f.prototype.stateInAttributeName = function(h) {
          (h === o.Eq || e(h)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = a.AfterAttributeName, this.stateAfterAttributeName(h));
        }, f.prototype.stateAfterAttributeName = function(h) {
          h === o.Eq ? this.state = a.BeforeAttributeValue : h === o.Slash || h === o.Gt ? (this.cbs.onattribend(s.NoValue, this.index), this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h)) : t(h) || (this.cbs.onattribend(s.NoValue, this.index), this.state = a.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateBeforeAttributeValue = function(h) {
          h === o.DoubleQuote ? (this.state = a.InAttributeValueDq, this.sectionStart = this.index + 1) : h === o.SingleQuote ? (this.state = a.InAttributeValueSq, this.sectionStart = this.index + 1) : t(h) || (this.sectionStart = this.index, this.state = a.InAttributeValueNq, this.stateInAttributeValueNoQuotes(h));
        }, f.prototype.handleInAttributeValue = function(h, p) {
          h === p || !this.decodeEntities && this.fastForwardTo(p) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(p === o.DoubleQuote ? s.Double : s.Single, this.index), this.state = a.BeforeAttributeName) : this.decodeEntities && h === o.Amp && (this.baseState = this.state, this.state = a.BeforeEntity);
        }, f.prototype.stateInAttributeValueDoubleQuotes = function(h) {
          this.handleInAttributeValue(h, o.DoubleQuote);
        }, f.prototype.stateInAttributeValueSingleQuotes = function(h) {
          this.handleInAttributeValue(h, o.SingleQuote);
        }, f.prototype.stateInAttributeValueNoQuotes = function(h) {
          t(h) || h === o.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(s.Unquoted, this.index), this.state = a.BeforeAttributeName, this.stateBeforeAttributeName(h)) : this.decodeEntities && h === o.Amp && (this.baseState = this.state, this.state = a.BeforeEntity);
        }, f.prototype.stateBeforeDeclaration = function(h) {
          h === o.OpeningSquareBracket ? (this.state = a.CDATASequence, this.sequenceIndex = 0) : this.state = h === o.Dash ? a.BeforeComment : a.InDeclaration;
        }, f.prototype.stateInDeclaration = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateInProcessingInstruction = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeComment = function(h) {
          h === o.Dash ? (this.state = a.InCommentLike, this.currentSequence = d.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = a.InDeclaration;
        }, f.prototype.stateInSpecialComment = function(h) {
          (h === o.Gt || this.fastForwardTo(o.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = a.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeSpecialS = function(h) {
          var p = h | 32;
          p === d.ScriptEnd[3] ? this.startSpecial(d.ScriptEnd, 4) : p === d.StyleEnd[3] ? this.startSpecial(d.StyleEnd, 4) : (this.state = a.InTagName, this.stateInTagName(h));
        }, f.prototype.stateBeforeEntity = function(h) {
          this.entityExcess = 1, this.entityResult = 0, h === o.Number ? this.state = a.BeforeNumericEntity : h === o.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = a.InNamedEntity, this.stateInNamedEntity(h));
        }, f.prototype.stateInNamedEntity = function(h) {
          if (this.entityExcess += 1, this.trieIndex = (0, r.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, h), this.trieIndex < 0) {
            this.emitNamedEntity(), this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var p = this.trieCurrent & r.BinTrieFlags.VALUE_LENGTH;
          if (p) {
            var b = (p >> 14) - 1;
            if (!this.allowLegacyEntity() && h !== o.Semi)
              this.trieIndex += b;
            else {
              var _ = this.index - this.entityExcess + 1;
              _ > this.sectionStart && this.emitPartial(this.sectionStart, _), this.entityResult = this.trieIndex, this.trieIndex += b, this.entityExcess = 0, this.sectionStart = this.index + 1, b === 0 && this.emitNamedEntity();
            }
          }
        }, f.prototype.emitNamedEntity = function() {
          if (this.state = this.baseState, this.entityResult !== 0) {
            var h = (this.entityTrie[this.entityResult] & r.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (h) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~r.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        }, f.prototype.stateBeforeNumericEntity = function(h) {
          (h | 32) === o.LowerX ? (this.entityExcess++, this.state = a.InHexEntity) : (this.state = a.InNumericEntity, this.stateInNumericEntity(h));
        }, f.prototype.emitNumericEntity = function(h) {
          var p = this.index - this.entityExcess - 1, b = p + 2 + +(this.state === a.InHexEntity);
          b !== this.index && (p > this.sectionStart && this.emitPartial(this.sectionStart, p), this.sectionStart = this.index + Number(h), this.emitCodePoint((0, r.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
        }, f.prototype.stateInNumericEntity = function(h) {
          h === o.Semi ? this.emitNumericEntity(!0) : n(h) ? (this.entityResult = this.entityResult * 10 + (h - o.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.stateInHexEntity = function(h) {
          h === o.Semi ? this.emitNumericEntity(!0) : n(h) ? (this.entityResult = this.entityResult * 16 + (h - o.Zero), this.entityExcess++) : c(h) ? (this.entityResult = this.entityResult * 16 + ((h | 32) - o.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === a.Text || this.baseState === a.InSpecialTag);
        }, f.prototype.cleanup = function() {
          this.running && this.sectionStart !== this.index && (this.state === a.Text || this.state === a.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === a.InAttributeValueDq || this.state === a.InAttributeValueSq || this.state === a.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
        }, f.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        }, f.prototype.parse = function() {
          for (; this.shouldContinue(); ) {
            var h = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case a.Text: {
                this.stateText(h);
                break;
              }
              case a.SpecialStartSequence: {
                this.stateSpecialStartSequence(h);
                break;
              }
              case a.InSpecialTag: {
                this.stateInSpecialTag(h);
                break;
              }
              case a.CDATASequence: {
                this.stateCDATASequence(h);
                break;
              }
              case a.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(h);
                break;
              }
              case a.InAttributeName: {
                this.stateInAttributeName(h);
                break;
              }
              case a.InCommentLike: {
                this.stateInCommentLike(h);
                break;
              }
              case a.InSpecialComment: {
                this.stateInSpecialComment(h);
                break;
              }
              case a.BeforeAttributeName: {
                this.stateBeforeAttributeName(h);
                break;
              }
              case a.InTagName: {
                this.stateInTagName(h);
                break;
              }
              case a.InClosingTagName: {
                this.stateInClosingTagName(h);
                break;
              }
              case a.BeforeTagName: {
                this.stateBeforeTagName(h);
                break;
              }
              case a.AfterAttributeName: {
                this.stateAfterAttributeName(h);
                break;
              }
              case a.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(h);
                break;
              }
              case a.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(h);
                break;
              }
              case a.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(h);
                break;
              }
              case a.AfterClosingTagName: {
                this.stateAfterClosingTagName(h);
                break;
              }
              case a.BeforeSpecialS: {
                this.stateBeforeSpecialS(h);
                break;
              }
              case a.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(h);
                break;
              }
              case a.InSelfClosingTag: {
                this.stateInSelfClosingTag(h);
                break;
              }
              case a.InDeclaration: {
                this.stateInDeclaration(h);
                break;
              }
              case a.BeforeDeclaration: {
                this.stateBeforeDeclaration(h);
                break;
              }
              case a.BeforeComment: {
                this.stateBeforeComment(h);
                break;
              }
              case a.InProcessingInstruction: {
                this.stateInProcessingInstruction(h);
                break;
              }
              case a.InNamedEntity: {
                this.stateInNamedEntity(h);
                break;
              }
              case a.BeforeEntity: {
                this.stateBeforeEntity(h);
                break;
              }
              case a.InHexEntity: {
                this.stateInHexEntity(h);
                break;
              }
              case a.InNumericEntity: {
                this.stateInNumericEntity(h);
                break;
              }
              default:
                this.stateBeforeNumericEntity(h);
            }
            this.index++;
          }
          this.cleanup();
        }, f.prototype.finish = function() {
          this.state === a.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
        }, f.prototype.handleTrailingData = function() {
          var h = this.buffer.length + this.offset;
          this.state === a.InCommentLike ? this.currentSequence === d.CdataEnd ? this.cbs.oncdata(this.sectionStart, h, 0) : this.cbs.oncomment(this.sectionStart, h, 0) : this.state === a.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === a.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === a.InTagName || this.state === a.BeforeAttributeName || this.state === a.BeforeAttributeValue || this.state === a.AfterAttributeName || this.state === a.InAttributeName || this.state === a.InAttributeValueSq || this.state === a.InAttributeValueDq || this.state === a.InAttributeValueNq || this.state === a.InClosingTagName || this.cbs.ontext(this.sectionStart, h);
        }, f.prototype.emitPartial = function(h, p) {
          this.baseState !== a.Text && this.baseState !== a.InSpecialTag ? this.cbs.onattribdata(h, p) : this.cbs.ontext(h, p);
        }, f.prototype.emitCodePoint = function(h) {
          this.baseState !== a.Text && this.baseState !== a.InSpecialTag ? this.cbs.onattribentity(h) : this.cbs.ontextentity(h);
        }, f;
      }()
    );
    u.default = l;
  }(VE)), VE;
}
var UL;
function VL() {
  if (UL) return si;
  UL = 1;
  var u = si && si.__createBinding || (Object.create ? function(_, y, m, g) {
    g === void 0 && (g = m);
    var T = Object.getOwnPropertyDescriptor(y, m);
    (!T || ("get" in T ? !y.__esModule : T.writable || T.configurable)) && (T = { enumerable: !0, get: function() {
      return y[m];
    } }), Object.defineProperty(_, g, T);
  } : function(_, y, m, g) {
    g === void 0 && (g = m), _[g] = y[m];
  }), r = si && si.__setModuleDefault || (Object.create ? function(_, y) {
    Object.defineProperty(_, "default", { enumerable: !0, value: y });
  } : function(_, y) {
    _.default = y;
  }), o = si && si.__importStar || function(_) {
    if (_ && _.__esModule) return _;
    var y = {};
    if (_ != null) for (var m in _) m !== "default" && Object.prototype.hasOwnProperty.call(_, m) && u(y, _, m);
    return r(y, _), y;
  };
  Object.defineProperty(si, "__esModule", { value: !0 }), si.Parser = void 0;
  var a = o(/* @__PURE__ */ SY()), t = /* @__PURE__ */ wY(), e = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), n = /* @__PURE__ */ new Set(["p"]), i = /* @__PURE__ */ new Set(["thead", "tbody"]), c = /* @__PURE__ */ new Set(["dd", "dt"]), s = /* @__PURE__ */ new Set(["rt", "rp"]), d = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", n],
    ["h1", n],
    ["h2", n],
    ["h3", n],
    ["h4", n],
    ["h5", n],
    ["h6", n],
    ["select", e],
    ["input", e],
    ["output", e],
    ["button", e],
    ["datalist", e],
    ["textarea", e],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", c],
    ["dt", c],
    ["address", n],
    ["article", n],
    ["aside", n],
    ["blockquote", n],
    ["details", n],
    ["div", n],
    ["dl", n],
    ["fieldset", n],
    ["figcaption", n],
    ["figure", n],
    ["footer", n],
    ["form", n],
    ["header", n],
    ["hr", n],
    ["main", n],
    ["nav", n],
    ["ol", n],
    ["pre", n],
    ["section", n],
    ["table", n],
    ["ul", n],
    ["rt", s],
    ["rp", s],
    ["tbody", i],
    ["tfoot", i]
  ]), l = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), f = /* @__PURE__ */ new Set(["math", "svg"]), h = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]), p = /\s|\//, b = (
    /** @class */
    function() {
      function _(y, m) {
        m === void 0 && (m = {});
        var g, T, v, E, R;
        this.options = m, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = y ?? {}, this.lowerCaseTagNames = (g = m.lowerCaseTags) !== null && g !== void 0 ? g : !m.xmlMode, this.lowerCaseAttributeNames = (T = m.lowerCaseAttributeNames) !== null && T !== void 0 ? T : !m.xmlMode, this.tokenizer = new ((v = m.Tokenizer) !== null && v !== void 0 ? v : a.default)(this.options, this), (R = (E = this.cbs).onparserinit) === null || R === void 0 || R.call(E, this);
      }
      return _.prototype.ontext = function(y, m) {
        var g, T, v = this.getSlice(y, m);
        this.endIndex = m - 1, (T = (g = this.cbs).ontext) === null || T === void 0 || T.call(g, v), this.startIndex = m;
      }, _.prototype.ontextentity = function(y) {
        var m, g, T = this.tokenizer.getSectionStart();
        this.endIndex = T - 1, (g = (m = this.cbs).ontext) === null || g === void 0 || g.call(m, (0, t.fromCodePoint)(y)), this.startIndex = T;
      }, _.prototype.isVoidElement = function(y) {
        return !this.options.xmlMode && l.has(y);
      }, _.prototype.onopentagname = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        this.lowerCaseTagNames && (g = g.toLowerCase()), this.emitOpenTag(g);
      }, _.prototype.emitOpenTag = function(y) {
        var m, g, T, v;
        this.openTagStart = this.startIndex, this.tagname = y;
        var E = !this.options.xmlMode && d.get(y);
        if (E)
          for (; this.stack.length > 0 && E.has(this.stack[this.stack.length - 1]); ) {
            var R = this.stack.pop();
            (g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, R, !0);
          }
        this.isVoidElement(y) || (this.stack.push(y), f.has(y) ? this.foreignContext.push(!0) : h.has(y) && this.foreignContext.push(!1)), (v = (T = this.cbs).onopentagname) === null || v === void 0 || v.call(T, y), this.cbs.onopentag && (this.attribs = {});
      }, _.prototype.endOpenTag = function(y) {
        var m, g;
        this.startIndex = this.openTagStart, this.attribs && ((g = (m = this.cbs).onopentag) === null || g === void 0 || g.call(m, this.tagname, this.attribs, y), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
      }, _.prototype.onopentagend = function(y) {
        this.endIndex = y, this.endOpenTag(!1), this.startIndex = y + 1;
      }, _.prototype.onclosetag = function(y, m) {
        var g, T, v, E, R, L;
        this.endIndex = m;
        var A = this.getSlice(y, m);
        if (this.lowerCaseTagNames && (A = A.toLowerCase()), (f.has(A) || h.has(A)) && this.foreignContext.pop(), this.isVoidElement(A))
          !this.options.xmlMode && A === "br" && ((T = (g = this.cbs).onopentagname) === null || T === void 0 || T.call(g, "br"), (E = (v = this.cbs).onopentag) === null || E === void 0 || E.call(v, "br", {}, !0), (L = (R = this.cbs).onclosetag) === null || L === void 0 || L.call(R, "br", !1));
        else {
          var w = this.stack.lastIndexOf(A);
          if (w !== -1)
            if (this.cbs.onclosetag)
              for (var S = this.stack.length - w; S--; )
                this.cbs.onclosetag(this.stack.pop(), S !== 0);
            else
              this.stack.length = w;
          else !this.options.xmlMode && A === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
        }
        this.startIndex = m + 1;
      }, _.prototype.onselfclosingtag = function(y) {
        this.endIndex = y, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = y + 1) : this.onopentagend(y);
      }, _.prototype.closeCurrentTag = function(y) {
        var m, g, T = this.tagname;
        this.endOpenTag(y), this.stack[this.stack.length - 1] === T && ((g = (m = this.cbs).onclosetag) === null || g === void 0 || g.call(m, T, !y), this.stack.pop());
      }, _.prototype.onattribname = function(y, m) {
        this.startIndex = y;
        var g = this.getSlice(y, m);
        this.attribname = this.lowerCaseAttributeNames ? g.toLowerCase() : g;
      }, _.prototype.onattribdata = function(y, m) {
        this.attribvalue += this.getSlice(y, m);
      }, _.prototype.onattribentity = function(y) {
        this.attribvalue += (0, t.fromCodePoint)(y);
      }, _.prototype.onattribend = function(y, m) {
        var g, T;
        this.endIndex = m, (T = (g = this.cbs).onattribute) === null || T === void 0 || T.call(g, this.attribname, this.attribvalue, y === a.QuoteType.Double ? '"' : y === a.QuoteType.Single ? "'" : y === a.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
      }, _.prototype.getInstructionName = function(y) {
        var m = y.search(p), g = m < 0 ? y : y.substr(0, m);
        return this.lowerCaseTagNames && (g = g.toLowerCase()), g;
      }, _.prototype.ondeclaration = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        if (this.cbs.onprocessinginstruction) {
          var T = this.getInstructionName(g);
          this.cbs.onprocessinginstruction("!".concat(T), "!".concat(g));
        }
        this.startIndex = m + 1;
      }, _.prototype.onprocessinginstruction = function(y, m) {
        this.endIndex = m;
        var g = this.getSlice(y, m);
        if (this.cbs.onprocessinginstruction) {
          var T = this.getInstructionName(g);
          this.cbs.onprocessinginstruction("?".concat(T), "?".concat(g));
        }
        this.startIndex = m + 1;
      }, _.prototype.oncomment = function(y, m, g) {
        var T, v, E, R;
        this.endIndex = m, (v = (T = this.cbs).oncomment) === null || v === void 0 || v.call(T, this.getSlice(y, m - g)), (R = (E = this.cbs).oncommentend) === null || R === void 0 || R.call(E), this.startIndex = m + 1;
      }, _.prototype.oncdata = function(y, m, g) {
        var T, v, E, R, L, A, w, S, O, x;
        this.endIndex = m;
        var F = this.getSlice(y, m - g);
        this.options.xmlMode || this.options.recognizeCDATA ? ((v = (T = this.cbs).oncdatastart) === null || v === void 0 || v.call(T), (R = (E = this.cbs).ontext) === null || R === void 0 || R.call(E, F), (A = (L = this.cbs).oncdataend) === null || A === void 0 || A.call(L)) : ((S = (w = this.cbs).oncomment) === null || S === void 0 || S.call(w, "[CDATA[".concat(F, "]]")), (x = (O = this.cbs).oncommentend) === null || x === void 0 || x.call(O)), this.startIndex = m + 1;
      }, _.prototype.onend = function() {
        var y, m;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var g = this.stack.length; g > 0; this.cbs.onclosetag(this.stack[--g], !0))
            ;
        }
        (m = (y = this.cbs).onend) === null || m === void 0 || m.call(y);
      }, _.prototype.reset = function() {
        var y, m, g, T;
        (m = (y = this.cbs).onreset) === null || m === void 0 || m.call(y), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (T = (g = this.cbs).onparserinit) === null || T === void 0 || T.call(g, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
      }, _.prototype.parseComplete = function(y) {
        this.reset(), this.end(y);
      }, _.prototype.getSlice = function(y, m) {
        for (; y - this.bufferOffset >= this.buffers[0].length; )
          this.shiftBuffer();
        for (var g = this.buffers[0].slice(y - this.bufferOffset, m - this.bufferOffset); m - this.bufferOffset > this.buffers[0].length; )
          this.shiftBuffer(), g += this.buffers[0].slice(0, m - this.bufferOffset);
        return g;
      }, _.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
      }, _.prototype.write = function(y) {
        var m, g;
        if (this.ended) {
          (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(y), this.tokenizer.running && (this.tokenizer.write(y), this.writeIndex++);
      }, _.prototype.end = function(y) {
        var m, g;
        if (this.ended) {
          (g = (m = this.cbs).onerror) === null || g === void 0 || g.call(m, new Error(".end() after done!"));
          return;
        }
        y && this.write(y), this.ended = !0, this.tokenizer.end();
      }, _.prototype.pause = function() {
        this.tokenizer.pause();
      }, _.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
          this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end();
      }, _.prototype.parseChunk = function(y) {
        this.write(y);
      }, _.prototype.done = function(y) {
        this.end(y);
      }, _;
    }()
  );
  return si.Parser = b, si;
}
var QL;
function oce() {
  return QL || (QL = 1, function(u) {
    var r = oi && oi.__createBinding || (Object.create ? function(y, m, g, T) {
      T === void 0 && (T = g);
      var v = Object.getOwnPropertyDescriptor(m, g);
      (!v || ("get" in v ? !m.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
        return m[g];
      } }), Object.defineProperty(y, T, v);
    } : function(y, m, g, T) {
      T === void 0 && (T = g), y[T] = m[g];
    }), o = oi && oi.__setModuleDefault || (Object.create ? function(y, m) {
      Object.defineProperty(y, "default", { enumerable: !0, value: m });
    } : function(y, m) {
      y.default = m;
    }), a = oi && oi.__importStar || function(y) {
      if (y && y.__esModule) return y;
      var m = {};
      if (y != null) for (var g in y) g !== "default" && Object.prototype.hasOwnProperty.call(y, g) && r(m, y, g);
      return o(m, y), m;
    }, t = oi && oi.__importDefault || function(y) {
      return y && y.__esModule ? y : { default: y };
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.DomUtils = u.parseFeed = u.getFeed = u.ElementType = u.Tokenizer = u.createDomStream = u.parseDOM = u.parseDocument = u.DefaultHandler = u.DomHandler = u.Parser = void 0;
    var e = /* @__PURE__ */ VL(), n = /* @__PURE__ */ VL();
    Object.defineProperty(u, "Parser", { enumerable: !0, get: function() {
      return n.Parser;
    } });
    var i = /* @__PURE__ */ Vn(), c = /* @__PURE__ */ Vn();
    Object.defineProperty(u, "DomHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } }), Object.defineProperty(u, "DefaultHandler", { enumerable: !0, get: function() {
      return c.DomHandler;
    } });
    function s(y, m) {
      var g = new i.DomHandler(void 0, m);
      return new e.Parser(g, m).end(y), g.root;
    }
    u.parseDocument = s;
    function d(y, m) {
      return s(y, m).children;
    }
    u.parseDOM = d;
    function l(y, m, g) {
      var T = new i.DomHandler(y, m, g);
      return new e.Parser(T, m);
    }
    u.createDomStream = l;
    var f = /* @__PURE__ */ SY();
    Object.defineProperty(u, "Tokenizer", { enumerable: !0, get: function() {
      return t(f).default;
    } }), u.ElementType = a(/* @__PURE__ */ i0());
    var h = /* @__PURE__ */ pa(), p = /* @__PURE__ */ pa();
    Object.defineProperty(u, "getFeed", { enumerable: !0, get: function() {
      return p.getFeed;
    } });
    var b = { xmlMode: !0 };
    function _(y, m) {
      return m === void 0 && (m = b), (0, h.getFeed)(d(y, m));
    }
    u.parseFeed = _, u.DomUtils = a(/* @__PURE__ */ pa());
  }(oi)), oi;
}
const sce = {
  "http://schema.org/": { properties: { additionalType: { subPropertyOf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" } } },
  "http://microformats.org/profile/hcard": {}
};
var HL;
function cce() {
  if (HL) return Ib;
  HL = 1, Object.defineProperty(Ib, "__esModule", { value: !0 }), Ib.MicrodataRdfParser = void 0;
  const u = /* @__PURE__ */ oce(), r = Bt(), o = /* @__PURE__ */ _Y(), a = /* @__PURE__ */ gY(), t = /* @__PURE__ */ vY(), e = /* @__PURE__ */ TY(), n = /* @__PURE__ */ i4(), i = sce;
  let c = class fx extends r.Transform {
    constructor(d) {
      super({ readableObjectMode: !0 }), this.itemScopeStack = [], this.textBufferStack = [], this.isEmittingReferences = !1, this.pendingItemRefsDomain = {}, this.pendingItemRefsRangeFinalized = {}, this.pendingItemRefsRangeCollecting = {}, d = d || {}, this.options = d, this.util = new n.Util(d.dataFactory, d.baseIRI), this.defaultGraph = d.defaultGraph || this.util.dataFactory.defaultGraph(), this.htmlParseListener = d.htmlParseListener, this.vocabRegistry = d.vocabRegistry || i, this.parser = this.initializeParser(!!d.xmlMode);
    }
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {RDF.Stream} A quad stream.
     */
    import(d) {
      const l = new r.PassThrough({ readableObjectMode: !0 });
      d.on("error", (h) => f.emit("error", h)), d.on("data", (h) => l.push(h)), d.on("end", () => l.push(null));
      const f = l.pipe(new fx(this.options));
      return f;
    }
    _transform(d, l, f) {
      this.parser.write(d.toString()), f();
    }
    _flush(d) {
      this.parser.end(), d();
    }
    /**
     * Get the current item scope for the current depth.
     * This will skip all undefined item scopes.
     * @param parent If we should start looking one level higher in the stack.
     */
    getItemScope(d) {
      let l = this.itemScopeStack.length - (d ? 2 : 1);
      for (; l > 0 && !this.itemScopeStack[l]; )
        l--;
      return this.itemScopeStack[l];
    }
    /**
     * Get the current stack depth.
     */
    getDepth() {
      return this.itemScopeStack.length;
    }
    onTagOpen(d, l) {
      if (!this.isEmittingReferences) {
        if ("id" in l) {
          const h = l.id;
          this.pendingItemRefsRangeCollecting[h] = {
            events: [],
            counter: 0,
            ids: []
          };
        }
        for (const h of Object.values(this.pendingItemRefsRangeCollecting))
          h.counter++, h.events.push({ type: "open", name: d, attributes: l });
      }
      this.textBufferStack.push(void 0);
      let f;
      if ("itemscope" in l) {
        let h;
        if (this.emittingReferencesItemScopeIdGenerator)
          h = this.emittingReferencesItemScopeIdGenerator();
        else {
          h = "itemid" in l && this.util.createSubject(l.itemid) || this.util.dataFactory.blankNode();
          for (const b of Object.values(this.pendingItemRefsRangeCollecting))
            b.ids.push(h);
        }
        f = { subject: h }, this.isEmittingReferences && (f.blockEmission = !0);
        const p = this.getItemScope();
        p && p.vocab && (f.vocab = p.vocab), this.itemScopeStack.push(f);
      } else
        f = this.getItemScope(), this.itemScopeStack.push(void 0);
      if (f) {
        if ("itemtype" in l)
          for (const h of this.util.createVocabIris(l.itemtype, f, !1))
            f.vocab || (f.vocab = this.util.deriveVocab(h.value, this.vocabRegistry)), f.blockEmission || this.emitTriple(f.subject, this.util.dataFactory.namedNode(`${n.Util.RDF}type`), h);
        if ("lang" in l && (f.language = l.lang), "xml:lang" in l && (f.language = l["xml:lang"]), "itemscope" in l && !this.isEmittingReferences && "itemref" in l)
          for (const h of l.itemref.split(/\s+/u))
            h in this.pendingItemRefsDomain || (this.pendingItemRefsDomain[h] = []), this.pendingItemRefsDomain[h].push(f), this.tryToEmitReferences(h, f);
      }
      "itemprop" in l && this.handleItemProperties(l.itemprop, !1, f, d, l), "itemprop-reverse" in l && this.handleItemProperties(l["itemprop-reverse"], !0, f, d, l);
    }
    onText(d) {
      if (!this.isEmittingReferences)
        for (const l of Object.values(this.pendingItemRefsRangeCollecting))
          l.events.push({ type: "text", data: d });
      for (const l of this.textBufferStack)
        l && l.push(d);
    }
    onTagClose() {
      if (!this.isEmittingReferences)
        for (const [l, f] of Object.entries(this.pendingItemRefsRangeCollecting))
          f.counter--, f.events.push({ type: "close" }), f.counter === 0 && (this.pendingItemRefsRangeFinalized[l] = f, delete this.pendingItemRefsRangeCollecting[l], this.tryToEmitReferences(l));
      const d = this.getItemScope(!0);
      if (d) {
        const l = this.getDepth();
        if (d.predicates && l in d.predicates)
          for (const [f, h] of Object.entries(d.predicates[l])) {
            const p = this.util.createLiteral(this.textBufferStack[l].join(""), d);
            this.emitPredicateTriples(d, h, p, f === "reverse"), delete d.predicates[l][f];
          }
      }
      this.itemScopeStack.pop(), this.textBufferStack.pop();
    }
    onEnd() {
    }
    /**
     * Initialize a new HtmlParser.
     * @param xmlMode If the parser should be setup in strict mode.
     */
    initializeParser(d) {
      return new u.Parser({
        onclosetag: () => {
          try {
            this.onTagClose(), this.htmlParseListener && this.htmlParseListener.onTagClose();
          } catch (l) {
            this.emit("error", l);
          }
        },
        onend: () => {
          try {
            this.onEnd(), this.htmlParseListener && this.htmlParseListener.onEnd();
          } catch (l) {
            this.emit("error", l);
          }
        },
        onopentag: (l, f) => {
          try {
            this.onTagOpen(l, f), this.htmlParseListener && this.htmlParseListener.onTagOpen(l, f);
          } catch (h) {
            this.emit("error", h);
          }
        },
        ontext: (l) => {
          try {
            this.onText(l), this.htmlParseListener && this.htmlParseListener.onText(l);
          } catch (f) {
            this.emit("error", f);
          }
        }
      }, {
        decodeEntities: !0,
        recognizeSelfClosing: !0,
        xmlMode: d
      });
    }
    /**
     * Handle the given item properties.
     * @param itempropValue The value of itemprop or itemprop-reverse.
     * @param reverse If the item properties are reversed (itemprop-reverse).
     * @param itemScope The current item scope.
     * @param tagName The current tag name.
     * @param tagAttributes The current tag attributes.
     */
    handleItemProperties(d, l, f, h, p) {
      const b = this.getItemScope(!0);
      if (b) {
        const _ = this.getDepth(), y = this.util.createVocabIris(d, b, !0);
        b.predicates || (b.predicates = {}), b.predicates[_] || (b.predicates[_] = {});
        const m = l ? "reverse" : "forward";
        b.predicates[_][m] = y;
        for (const g of this.util.getVocabularyExpansionType(d, b, this.vocabRegistry))
          y.push(g);
        if (f && "itemscope" in p)
          this.emitPredicateTriples(b, y, f.subject, l), delete b.predicates[_][m];
        else
          for (const g of fx.ITEM_PROPERTY_HANDLERS)
            if (g.canHandle(h, p)) {
              const T = g.getObject(p, this.util, b);
              this.emitPredicateTriples(b, y, T, l), delete b.predicates[_][m];
            }
        b.predicates[_][m] && (this.textBufferStack[_] = []);
      }
    }
    /**
     * Emit the given object for the given predicates.
     * @param itemScope The current item scope.
     * @param predicates An array of predicates.
     * @param object An object.
     * @param reverse If the triples should be reversed.
     */
    emitPredicateTriples(d, l, f, h) {
      if (!d.blockEmission)
        for (const p of l)
          h ? f.termType !== "Literal" && this.emitTriple(f, p, d.subject) : this.emitTriple(d.subject, p, f);
    }
    /**
     * Emit the given triple to the stream.
     * @param {Quad_Subject} subject A subject term.
     * @param {Quad_Predicate} predicate A predicate term.
     * @param {Quad_Object} object An object term.
     */
    emitTriple(d, l, f) {
      this.push(this.util.dataFactory.quad(d, l, f, this.defaultGraph));
    }
    /**
     * Attempt to emit all pending itemrefs for the given reference.
     * @param reference An item reference id.
     * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.
     */
    tryToEmitReferences(d, l) {
      const f = this.pendingItemRefsRangeFinalized[d];
      if (f) {
        let h;
        if (l) {
          h = [l];
          const p = this.pendingItemRefsDomain[d].indexOf(l);
          this.pendingItemRefsDomain[d].splice(p, 1);
        } else
          h = this.pendingItemRefsDomain[d], delete this.pendingItemRefsDomain[d];
        if (h) {
          const p = this.itemScopeStack, b = this.textBufferStack;
          this.isEmittingReferences = !0;
          for (const _ of h) {
            this.itemScopeStack = [_], this.textBufferStack = [void 0];
            const y = [...f.ids];
            this.emittingReferencesItemScopeIdGenerator = () => y.shift();
            for (const m of f.events)
              switch (m.type) {
                case "open":
                  this.onTagOpen(m.name, m.attributes);
                  break;
                case "text":
                  this.onText(m.data);
                  break;
                case "close":
                  this.onTagClose();
                  break;
              }
          }
          this.emittingReferencesItemScopeIdGenerator = void 0, this.itemScopeStack = p, this.textBufferStack = b, this.isEmittingReferences = !1;
        }
      }
    }
  };
  return Ib.MicrodataRdfParser = c, c.ITEM_PROPERTY_HANDLERS = [
    new o.ItemPropertyHandlerContent(),
    new e.ItemPropertyHandlerUrl("a", "href"),
    new e.ItemPropertyHandlerUrl("area", "href"),
    new e.ItemPropertyHandlerUrl("audio", "src"),
    new e.ItemPropertyHandlerUrl("embed", "src"),
    new e.ItemPropertyHandlerUrl("iframe", "src"),
    new e.ItemPropertyHandlerUrl("img", "src"),
    new e.ItemPropertyHandlerUrl("link", "href"),
    new e.ItemPropertyHandlerUrl("object", "data"),
    new e.ItemPropertyHandlerUrl("source", "src"),
    new e.ItemPropertyHandlerUrl("track", "src"),
    new e.ItemPropertyHandlerUrl("video", "src"),
    new a.ItemPropertyHandlerNumber("data", "value"),
    new a.ItemPropertyHandlerNumber("meter", "value"),
    new t.ItemPropertyHandlerTime()
  ], Ib;
}
var GL;
function dce() {
  return GL || (GL = 1, function(u) {
    var r = _s && _s.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _s && _s.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ tce(), u), o(/* @__PURE__ */ _Y(), u), o(/* @__PURE__ */ gY(), u), o(/* @__PURE__ */ vY(), u), o(/* @__PURE__ */ TY(), u), o(/* @__PURE__ */ rce(), u), o(/* @__PURE__ */ nce(), u), o(/* @__PURE__ */ ice(), u), o(/* @__PURE__ */ cce(), u), o(/* @__PURE__ */ i4(), u);
  }(_s)), _s;
}
var zL;
function lce() {
  if (zL) return Tb;
  zL = 1, Object.defineProperty(Tb, "__esModule", { value: !0 }), Tb.ActorRdfParseHtmlMicrodata = void 0;
  const u = /* @__PURE__ */ q8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ dce();
  let t = class extends u.ActorRdfParseHtml {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = n.headers ? n.headers.get("content-type") : null, s = c == null ? void 0 : c.includes("xml"), d = new a.MicrodataRdfParser({ dataFactory: i, baseIRI: n.baseIRI, xmlMode: s });
      d.on("error", n.error), d.on("data", n.emit);
      const l = d.onEnd;
      return d.onEnd = () => {
        l.call(d), n.end();
      }, { htmlParseListener: d };
    }
  };
  return Tb.ActorRdfParseHtmlMicrodata = t, Tb;
}
var kL;
function fce() {
  return kL || (kL = 1, function(u) {
    var r = bs && bs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bs && bs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ lce(), u);
  }(bs)), bs;
}
var gs = {}, Rb = {}, XL;
function hce() {
  if (XL) return Rb;
  XL = 1, Object.defineProperty(Rb, "__esModule", { value: !0 }), Rb.ActorRdfParseHtmlRdfa = void 0;
  const u = /* @__PURE__ */ q8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ hY();
  let t = class extends u.ActorRdfParseHtml {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = n.headers ? n.headers.get("content-type") : null, s = (n.headers && n.headers.get("content-language")) ?? void 0, d = c && c.includes("xml") ? "xhtml" : "html", l = new a.RdfaParser({ dataFactory: i, baseIRI: n.baseIRI, profile: d, language: s });
      l.on("error", n.error), l.on("data", n.emit);
      const f = l.onEnd;
      return l.onEnd = () => {
        f.call(l), n.end();
      }, { htmlParseListener: l };
    }
  };
  return Rb.ActorRdfParseHtmlRdfa = t, Rb;
}
var JL;
function pce() {
  return JL || (JL = 1, function(u) {
    var r = gs && gs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = gs && gs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hce(), u);
  }(gs)), gs;
}
var ms = {}, Fb = {}, vs = {}, Nb = {}, KL;
function bce() {
  if (KL) return Nb;
  KL = 1, Object.defineProperty(Nb, "__esModule", { value: !0 }), Nb.ActorRdfResolveHypermediaLinks = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Hypermedia link resolution failed: none of the configured actors were able to resolve links from metadata} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Nb.ActorRdfResolveHypermediaLinks = r, Nb;
}
var WL;
function yce() {
  return WL || (WL = 1, function(u) {
    var r = vs && vs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vs && vs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ bce(), u);
  }(vs)), vs;
}
var YL;
function _ce() {
  if (YL) return Fb;
  YL = 1, Object.defineProperty(Fb, "__esModule", { value: !0 }), Fb.ActorRdfResolveHypermediaLinksNext = void 0;
  const u = /* @__PURE__ */ yce(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfResolveHypermediaLinks {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return !t.metadata.next || t.metadata.next.length === 0 ? (0, r.failTest)(`Actor ${this.name} requires a 'next' metadata entry.`) : (0, r.passTestVoid)();
    }
    async run(t) {
      return { links: t.metadata.next.map((e) => ({ url: e })) };
    }
  };
  return Fb.ActorRdfResolveHypermediaLinksNext = o, Fb;
}
var ZL;
function gce() {
  return ZL || (ZL = 1, function(u) {
    var r = ms && ms.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ms && ms.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _ce(), u);
  }(ms)), ms;
}
var Ts = {}, Pb = {}, ws = {}, Db = {}, ej;
function mce() {
  if (ej) return Db;
  ej = 1, Object.defineProperty(Db, "__esModule", { value: !0 }), Db.ActorRdfResolveHypermediaLinksQueue = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Link queue creation failed: none of the configured actors were able to create a link queue starting from ${action.firstUrl}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Db.ActorRdfResolveHypermediaLinksQueue = r, Db;
}
var HE = {}, tj;
function vce() {
  return tj || (tj = 1, Object.defineProperty(HE, "__esModule", { value: !0 })), HE;
}
var Lb = {}, rj;
function Tce() {
  if (rj) return Lb;
  rj = 1, Object.defineProperty(Lb, "__esModule", { value: !0 }), Lb.LinkQueueWrapper = void 0;
  let u = class {
    constructor(o) {
      this.linkQueue = o;
    }
    push(o, a) {
      return this.linkQueue.push(o, a);
    }
    getSize() {
      return this.linkQueue.getSize();
    }
    isEmpty() {
      return this.linkQueue.isEmpty();
    }
    pop() {
      return this.linkQueue.pop();
    }
    peek() {
      return this.linkQueue.peek();
    }
  };
  return Lb.LinkQueueWrapper = u, Lb;
}
var nj;
function wce() {
  return nj || (nj = 1, function(u) {
    var r = ws && ws.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ws && ws.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ mce(), u), o(/* @__PURE__ */ vce(), u), o(/* @__PURE__ */ Tce(), u);
  }(ws)), ws;
}
var jb = {}, ij;
function AY() {
  if (ij) return jb;
  ij = 1, Object.defineProperty(jb, "__esModule", { value: !0 }), jb.LinkQueueFifo = void 0;
  let u = class {
    constructor() {
      this.links = [];
    }
    push(o) {
      return this.links.push(o), !0;
    }
    getSize() {
      return this.links.length;
    }
    isEmpty() {
      return this.links.length === 0;
    }
    pop() {
      return this.links.shift();
    }
    peek() {
      return this.links[0];
    }
  };
  return jb.LinkQueueFifo = u, jb;
}
var aj;
function Sce() {
  if (aj) return Pb;
  aj = 1, Object.defineProperty(Pb, "__esModule", { value: !0 }), Pb.ActorRdfResolveHypermediaLinksQueueFifo = void 0;
  const u = /* @__PURE__ */ wce(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ AY();
  let a = class extends u.ActorRdfResolveHypermediaLinksQueue {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      return { linkQueue: new o.LinkQueueFifo() };
    }
  };
  return Pb.ActorRdfResolveHypermediaLinksQueueFifo = a, Pb;
}
var uj;
function Ace() {
  return uj || (uj = 1, function(u) {
    var r = Ts && Ts.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ts && Ts.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Sce(), u), o(/* @__PURE__ */ AY(), u);
  }(Ts)), Ts;
}
var Ss = {}, Mb = {}, As = {}, Cb = {}, oj;
function Ece() {
  if (oj) return Cb;
  oj = 1, Object.defineProperty(Cb, "__esModule", { value: !0 }), Cb.ActorRdfSerialize = void 0;
  const u = /* @__PURE__ */ ph();
  let r = class extends u.ActorAbstractMediaTyped {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(a) {
      super(a);
    }
  };
  return Cb.ActorRdfSerialize = r, Cb;
}
var qb = {}, sj;
function Oce() {
  if (sj) return qb;
  sj = 1, Object.defineProperty(qb, "__esModule", { value: !0 }), qb.ActorRdfSerializeFixedMediaTypes = void 0;
  const u = /* @__PURE__ */ ph(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorAbstractMediaTypedFixed {
    /* eslint-disable max-len */
    /**
     * TODO: rm this (and eslint-disable) once we remove the abstract media typed actor
     * @param args -
     *   \ @defaultNested {<cbrs:components/ActorRdfSerialize.jsonld#ActorRdfSerialize_default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF serialization failed: none of the configured serializers were able to handle media type ${action.handleMediaType}} busFailMessage
     */
    constructor(t) {
      super(t);
    }
    /* eslint-enable max-len */
    async testHandleChecked() {
      return (0, r.passTestVoid)();
    }
  };
  return qb.ActorRdfSerializeFixedMediaTypes = o, qb;
}
var cj;
function B8() {
  return cj || (cj = 1, function(u) {
    var r = As && As.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = As && As.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ece(), u), o(/* @__PURE__ */ Oce(), u);
  }(As)), As;
}
var dj;
function xce() {
  if (dj) return Mb;
  dj = 1, Object.defineProperty(Mb, "__esModule", { value: !0 }), Mb.ActorRdfSerializeN3 = void 0;
  const u = /* @__PURE__ */ B8(), r = iu;
  let o = class extends u.ActorRdfSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/n-quads": 1.0,
     *       "application/trig": 0.95,
     *       "application/n-triples": 0.8,
     *       "text/turtle": 0.6,
     *       "text/n3": 0.35
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/n-quads": "http://www.w3.org/ns/formats/N-Quads",
     *       "application/trig": "http://www.w3.org/ns/formats/TriG",
     *       "application/n-triples": "http://www.w3.org/ns/formats/N-Triples",
     *       "text/turtle": "http://www.w3.org/ns/formats/Turtle",
     *       "text/n3": "http://www.w3.org/ns/formats/N3"
     *     }} mediaTypeFormats
     */
    constructor(t) {
      super(t);
    }
    async runHandle(t, e) {
      const n = new r.StreamWriter({ format: e });
      let i;
      return "pipe" in t.quadStream ? (t.quadStream.on("error", (c) => n.emit("error", c)), i = t.quadStream.pipe(n)) : i = n.import(t.quadStream), { data: i, triples: e === "text/turtle" || e === "application/n-triples" || e === "text/n3" };
    }
  };
  return Mb.ActorRdfSerializeN3 = o, Mb;
}
var lj;
function Ice() {
  return lj || (lj = 1, function(u) {
    var r = Ss && Ss.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ss && Ss.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ xce(), u);
  }(Ss)), Ss;
}
var Es = {}, Bb = {}, Os = {}, $b = {}, xs = {}, Ub = {}, GE = {}, fj;
function a4() {
  return fj || (fj = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.ERROR_CODES = u.ErrorCoded = void 0;
    class r extends Error {
      /* istanbul ignore next */
      constructor(a, t) {
        super(a), this.code = t;
      }
    }
    u.ErrorCoded = r, function(o) {
      o.COLLIDING_KEYWORDS = "colliding keywords", o.CONFLICTING_INDEXES = "conflicting indexes", o.CYCLIC_IRI_MAPPING = "cyclic IRI mapping", o.INVALID_ID_VALUE = "invalid @id value", o.INVALID_INDEX_VALUE = "invalid @index value", o.INVALID_NEST_VALUE = "invalid @nest value", o.INVALID_PREFIX_VALUE = "invalid @prefix value", o.INVALID_PROPAGATE_VALUE = "invalid @propagate value", o.INVALID_REVERSE_VALUE = "invalid @reverse value", o.INVALID_IMPORT_VALUE = "invalid @import value", o.INVALID_VERSION_VALUE = "invalid @version value", o.INVALID_BASE_IRI = "invalid base IRI", o.INVALID_CONTAINER_MAPPING = "invalid container mapping", o.INVALID_CONTEXT_ENTRY = "invalid context entry", o.INVALID_CONTEXT_NULLIFICATION = "invalid context nullification", o.INVALID_DEFAULT_LANGUAGE = "invalid default language", o.INVALID_INCLUDED_VALUE = "invalid @included value", o.INVALID_IRI_MAPPING = "invalid IRI mapping", o.INVALID_JSON_LITERAL = "invalid JSON literal", o.INVALID_KEYWORD_ALIAS = "invalid keyword alias", o.INVALID_LANGUAGE_MAP_VALUE = "invalid language map value", o.INVALID_LANGUAGE_MAPPING = "invalid language mapping", o.INVALID_LANGUAGE_TAGGED_STRING = "invalid language-tagged string", o.INVALID_LANGUAGE_TAGGED_VALUE = "invalid language-tagged value", o.INVALID_LOCAL_CONTEXT = "invalid local context", o.INVALID_REMOTE_CONTEXT = "invalid remote context", o.INVALID_REVERSE_PROPERTY = "invalid reverse property", o.INVALID_REVERSE_PROPERTY_MAP = "invalid reverse property map", o.INVALID_REVERSE_PROPERTY_VALUE = "invalid reverse property value", o.INVALID_SCOPED_CONTEXT = "invalid scoped context", o.INVALID_SCRIPT_ELEMENT = "invalid script element", o.INVALID_SET_OR_LIST_OBJECT = "invalid set or list object", o.INVALID_TERM_DEFINITION = "invalid term definition", o.INVALID_TYPE_MAPPING = "invalid type mapping", o.INVALID_TYPE_VALUE = "invalid type value", o.INVALID_TYPED_VALUE = "invalid typed value", o.INVALID_VALUE_OBJECT = "invalid value object", o.INVALID_VALUE_OBJECT_VALUE = "invalid value object value", o.INVALID_VOCAB_MAPPING = "invalid vocab mapping", o.IRI_CONFUSED_WITH_PREFIX = "IRI confused with prefix", o.KEYWORD_REDEFINITION = "keyword redefinition", o.LOADING_DOCUMENT_FAILED = "loading document failed", o.LOADING_REMOTE_CONTEXT_FAILED = "loading remote context failed", o.MULTIPLE_CONTEXT_LINK_HEADERS = "multiple context link headers", o.PROCESSING_MODE_CONFLICT = "processing mode conflict", o.PROTECTED_TERM_REDEFINITION = "protected term redefinition", o.CONTEXT_OVERFLOW = "context overflow", o.INVALID_BASE_DIRECTION = "invalid base direction", o.RECURSIVE_CONTEXT_INCLUSION = "recursive context inclusion", o.INVALID_STREAMING_KEY_ORDER = "invalid streaming key order", o.INVALID_EMBEDDED_NODE = "invalid embedded node", o.INVALID_ANNOTATION = "invalid annotation";
    }(u.ERROR_CODES || (u.ERROR_CODES = {}));
  }(GE)), GE;
}
var Vb = {}, hj;
function EY() {
  if (hj) return Vb;
  hj = 1, Object.defineProperty(Vb, "__esModule", { value: !0 }), Vb.FetchDocumentLoader = void 0;
  const u = /* @__PURE__ */ a4(), r = Aw(), o = Tr();
  class a {
    constructor(e) {
      this.fetcher = e;
    }
    async load(e) {
      const n = await (this.fetcher || fetch)(e, { headers: new Headers({ accept: "application/ld+json" }) });
      if (n.ok && n.headers) {
        let i = n.headers.get("Content-Type");
        if (i) {
          const c = i.indexOf(";");
          c > 0 && (i = i.substr(0, c));
        }
        if (i === "application/ld+json")
          return await n.json();
        if (n.headers.has("Link")) {
          let c;
          if (n.headers.forEach((s, d) => {
            if (d === "link") {
              const l = (0, r.parse)(s);
              for (const f of l.get("type", "application/ld+json"))
                if (f.rel === "alternate") {
                  if (c)
                    throw new Error("Multiple JSON-LD alternate links were found on " + e);
                  c = (0, o.resolve)(f.uri, e);
                }
            }
          }), c)
            return this.load(c);
        }
        throw new u.ErrorCoded(`Unsupported JSON-LD media type ${i}`, u.ERROR_CODES.LOADING_DOCUMENT_FAILED);
      } else
        throw new Error(n.statusText || `Status code: ${n.status}`);
    }
  }
  return Vb.FetchDocumentLoader = a, Vb;
}
var zE = {}, Qb = {}, pj;
function $8() {
  if (pj) return Qb;
  pj = 1, Object.defineProperty(Qb, "__esModule", { value: !0 }), Qb.Util = void 0;
  class u {
    /**
     * Check if the given term is a valid compact IRI.
     * Otherwise, it may be an IRI.
     * @param {string} term A term.
     * @return {boolean} If it is a compact IRI.
     */
    static isCompactIri(o) {
      return o.indexOf(":") > 0 && !(o && o[0] === "#");
    }
    /**
     * Get the prefix from the given term.
     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {string} The prefix or null.
     */
    static getPrefix(o, a) {
      if (o && o[0] === "#")
        return null;
      const t = o.indexOf(":");
      if (t >= 0) {
        if (o.length > t + 1 && o.charAt(t + 1) === "/" && o.charAt(t + 2) === "/")
          return null;
        const e = o.substr(0, t);
        if (e === "_")
          return null;
        if (a[e])
          return e;
      }
      return null;
    }
    /**
     * From a given context entry value, get the string value, or the @id field.
     * @param contextValue A value for a term in a context.
     * @return {string} The id value, or null.
     */
    static getContextValueId(o) {
      if (o === null || typeof o == "string")
        return o;
      const a = o["@id"];
      return a || null;
    }
    /**
     * Check if the given simple term definition (string-based value of a context term)
     * should be considered a prefix.
     * @param value A simple term definition value.
     * @param options Options that define the way how expansion must be done.
     */
    static isSimpleTermDefinitionPrefix(o, a) {
      return !u.isPotentialKeyword(o) && (a.allowPrefixNonGenDelims || typeof o == "string" && (o[0] === "_" || u.isPrefixIriEndingWithGenDelim(o)));
    }
    /**
     * Check if the given keyword is of the keyword format "@"1*ALPHA.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is of the keyword format.
     */
    static isPotentialKeyword(o) {
      return typeof o == "string" && u.KEYWORD_REGEX.test(o);
    }
    /**
     * Check if the given prefix ends with a gen-delim character.
     * @param {string} prefixIri A prefix IRI.
     * @return {boolean} If the given prefix IRI is valid.
     */
    static isPrefixIriEndingWithGenDelim(o) {
      return u.ENDS_WITH_GEN_DELIM.test(o);
    }
    /**
     * Check if the given context value can be a prefix value.
     * @param value A context value.
     * @return {boolean} If it can be a prefix value.
     */
    static isPrefixValue(o) {
      return o && (typeof o == "string" || o && typeof o == "object");
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(o) {
      return !!(o && u.IRI_REGEX.test(o));
    }
    /**
     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIriWeak(o) {
      return !!o && o[0] !== ":" && u.IRI_REGEX_WEAK.test(o);
    }
    /**
     * Check if the given keyword is a defined according to the JSON-LD specification.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is valid.
     */
    static isValidKeyword(o) {
      return u.VALID_KEYWORDS[o];
    }
    /**
     * Check if the given term is protected in the context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {string} key A context term.
     * @return {boolean} If the given term has an @protected flag.
     */
    static isTermProtected(o, a) {
      const t = o[a];
      return typeof t != "string" && t && t["@protected"];
    }
    /**
     * Check if the given context has at least one protected term.
     * @param context A context.
     * @return If the context has a protected term.
     */
    static hasProtectedTerms(o) {
      for (const a of Object.keys(o))
        if (u.isTermProtected(o, a))
          return !0;
      return !1;
    }
    /**
     * Check if the given key is an internal reserved keyword.
     * @param key A context key.
     */
    static isReservedInternalKeyword(o) {
      return o.startsWith("@__");
    }
    /**
     * Check if two objects are deepEqual to on another.
     * @param object1 The first object to test.
     * @param object2 The second object to test.
     */
    static deepEqual(o, a) {
      const t = Object.keys(o), e = Object.keys(a);
      return t.length !== e.length ? !1 : t.every((n) => {
        const i = o[n], c = a[n];
        return i === c || i !== null && c !== null && typeof i == "object" && typeof c == "object" && this.deepEqual(i, c);
      });
    }
  }
  return u.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/, u.IRI_REGEX_WEAK = /(?::[^:])|\//, u.KEYWORD_REGEX = /^@[a-z]+$/i, u.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/, u.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/, u.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/, u.VALID_KEYWORDS = {
    "@annotation": !0,
    "@base": !0,
    "@container": !0,
    "@context": !0,
    "@direction": !0,
    "@graph": !0,
    "@id": !0,
    "@import": !0,
    "@included": !0,
    "@index": !0,
    "@json": !0,
    "@language": !0,
    "@list": !0,
    "@nest": !0,
    "@none": !0,
    "@prefix": !0,
    "@propagate": !0,
    "@protected": !0,
    "@reverse": !0,
    "@set": !0,
    "@type": !0,
    "@value": !0,
    "@version": !0,
    "@vocab": !0
  }, u.EXPAND_KEYS_BLACKLIST = [
    "@base",
    "@vocab",
    "@language",
    "@version",
    "@direction"
  ], u.ALIAS_DOMAIN_BLACKLIST = [
    "@container",
    "@graph",
    "@id",
    "@index",
    "@list",
    "@nest",
    "@none",
    "@prefix",
    "@reverse",
    "@set",
    "@type",
    "@value",
    "@version"
  ], u.ALIAS_RANGE_BLACKLIST = [
    "@context",
    "@preserve"
  ], u.CONTAINERS = [
    "@list",
    "@set",
    "@index",
    "@language",
    "@graph",
    "@id",
    "@type"
  ], u.CONTAINERS_1_0 = [
    "@list",
    "@set",
    "@index"
  ], Qb.Util = u, Qb;
}
var bj;
function OY() {
  return bj || (bj = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.defaultExpandOptions = u.JsonLdContextNormalized = void 0;
    const r = Tr(), o = /* @__PURE__ */ a4(), a = /* @__PURE__ */ $8();
    class t {
      constructor(n) {
        this.contextRaw = n;
      }
      /**
       * @return The raw inner context.
       */
      getContextRaw() {
        return this.contextRaw;
      }
      /**
       * Expand the term or prefix of the given term if it has one,
       * otherwise return the term as-is.
       *
       * This will try to expand the IRI as much as possible.
       *
       * Iff in vocab-mode, then other references to other terms in the context can be used,
       * such as to `myTerm`:
       * ```
       * {
       *   "myTerm": "http://example.org/myLongTerm"
       * }
       * ```
       *
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,
       *                              otherwise it is considered a regular term that is expanded based on @base.
       * @param {IExpandOptions} options Options that define the way how expansion must be done.
       * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
       * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).
       */
      expandTerm(n, i, c = u.defaultExpandOptions) {
        const s = this.contextRaw[n];
        if (s === null || s && s["@id"] === null)
          return null;
        let d = !0;
        if (s && i) {
          const _ = a.Util.getContextValueId(s);
          if (_ && _ !== n)
            if (typeof _ != "string" || !a.Util.isValidIri(_) && !a.Util.isValidKeyword(_))
              a.Util.isPotentialKeyword(_) || (d = !1);
            else
              return _;
        }
        const l = a.Util.getPrefix(n, this.contextRaw), f = this.contextRaw["@vocab"], h = (!!f || f === "") && f.indexOf(":") < 0, p = this.contextRaw["@base"], b = a.Util.isPotentialKeyword(n);
        if (l) {
          const _ = this.contextRaw[l], y = a.Util.getContextValueId(_);
          if (y) {
            if (typeof _ == "string" || !c.allowPrefixForcing) {
              if (!a.Util.isSimpleTermDefinitionPrefix(y, c))
                return n;
            } else if (y[0] !== "_" && !b && !_["@prefix"] && !(n in this.contextRaw))
              return n;
            return y + n.substr(l.length + 1);
          }
        } else if (i && (f || f === "" || c.allowVocabRelativeToBase && p && h) && !b && !a.Util.isCompactIri(n))
          if (h) {
            if (c.allowVocabRelativeToBase)
              return (f || p ? (0, r.resolve)(f, p) : "") + n;
            throw new o.ErrorCoded(`Relative vocab expansion for term '${n}' with vocab '${f}' is not allowed.`, o.ERROR_CODES.INVALID_VOCAB_MAPPING);
          } else
            return f + n;
        else if (!i && p && !b && !a.Util.isCompactIri(n))
          return (0, r.resolve)(n, p);
        if (d)
          return n;
        throw new o.ErrorCoded(`Invalid IRI mapping found for context entry '${n}': '${JSON.stringify(s)}'`, o.ERROR_CODES.INVALID_IRI_MAPPING);
      }
      /**
       * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
       *
       * This will try to compact the IRI as much as possible.
       *
       * @param {string} iri An IRI to compact.
       * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
       *                        otherwise it is considered a regular term that is compacted based on @base.
       * @return {string} The compacted term or the IRI as-is.
       */
      compactIri(n, i) {
        if (i && this.contextRaw["@vocab"] && n.startsWith(this.contextRaw["@vocab"]))
          return n.substr(this.contextRaw["@vocab"].length);
        if (!i && this.contextRaw["@base"] && n.startsWith(this.contextRaw["@base"]))
          return n.substr(this.contextRaw["@base"].length);
        const c = { prefix: "", suffix: n };
        for (const s in this.contextRaw) {
          const d = this.contextRaw[s];
          if (d && !a.Util.isPotentialKeyword(s)) {
            const l = a.Util.getContextValueId(d);
            if (n.startsWith(l)) {
              const f = n.substr(l.length);
              if (f)
                f.length < c.suffix.length && (c.prefix = s, c.suffix = f);
              else if (i)
                return s;
            }
          }
        }
        return c.prefix ? c.prefix + ":" + c.suffix : n;
      }
    }
    u.JsonLdContextNormalized = t, u.defaultExpandOptions = {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    };
  }(zE)), zE;
}
var yj;
function Rce() {
  if (yj) return Ub;
  yj = 1, Object.defineProperty(Ub, "__esModule", { value: !0 }), Ub.ContextParser = void 0;
  const u = Tr(), r = /* @__PURE__ */ a4(), o = /* @__PURE__ */ EY(), a = /* @__PURE__ */ OY(), t = /* @__PURE__ */ $8();
  class e {
    constructor(i) {
      i = i || {}, this.documentLoader = i.documentLoader || new o.FetchDocumentLoader(), this.documentCache = {}, this.validateContext = !i.skipValidation, this.expandContentTypeToBase = !!i.expandContentTypeToBase, this.remoteContextsDepthLimit = i.remoteContextsDepthLimit || 32, this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in i ? !!i.redirectSchemaOrgHttps : !0;
    }
    /**
     * Validate the given @language value.
     * An error will be thrown if it is invalid.
     * @param value An @language value.
     * @param {boolean} strictRange If the string value should be strictly checked against a regex.
     * @param {string} errorCode The error code to emit on errors.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateLanguage(i, c, s) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(i)}'`, s);
      if (!t.Util.REGEX_LANGUAGE_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(i)}'`, s);
        return !1;
      }
      return !0;
    }
    /**
     * Validate the given @direction value.
     * An error will be thrown if it is invalid.
     * @param value An @direction value.
     * @param {boolean} strictValues If the string value should be strictly checked against a regex.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateDirection(i, c) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
      if (!t.Util.REGEX_DIRECTION_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
        return !1;
      }
      return !0;
    }
    /**
     * Add an @id term for all @reverse terms.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     */
    idifyReverseTerms(i) {
      for (const c of Object.keys(i)) {
        let s = i[c];
        if (s && typeof s == "object" && s["@reverse"] && !s["@id"]) {
          if (typeof s["@reverse"] != "string" || t.Util.isValidKeyword(s["@reverse"]))
            throw new r.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${s["@reverse"]}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
          s = i[c] = Object.assign(Object.assign({}, s), { "@id": s["@reverse"] }), s["@id"] = s["@reverse"], t.Util.isPotentialKeyword(s["@reverse"]) ? delete s["@reverse"] : s["@reverse"] = !0;
        }
      }
      return i;
    }
    /**
     * Expand all prefixed terms in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
     *                                          via @base if @vocab is set to null.
     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all
     * keys in the context will be expanded.
     */
    expandPrefixedTerms(i, c, s) {
      const d = i.getContextRaw();
      for (const l of s || Object.keys(d))
        if (t.Util.EXPAND_KEYS_BLACKLIST.indexOf(l) < 0 && !t.Util.isReservedInternalKeyword(l)) {
          const f = d[l];
          if (t.Util.isPotentialKeyword(l) && t.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(l) >= 0 && (l !== "@type" || typeof d[l] == "object" && !(d[l]["@protected"] || d[l]["@container"] === "@set")))
            throw new r.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          if (t.Util.ALIAS_RANGE_BLACKLIST.indexOf(t.Util.getContextValueId(f)) >= 0)
            throw new r.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.INVALID_KEYWORD_ALIAS);
          if (f && t.Util.isPotentialKeyword(t.Util.getContextValueId(f)) && f["@prefix"] === !0)
            throw new r.ErrorCoded(`Tried to use keyword aliases as prefix: '${l}': '${JSON.stringify(f)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          for (; t.Util.isPrefixValue(d[l]); ) {
            const h = d[l];
            let p = !1;
            if (typeof h == "string")
              d[l] = i.expandTerm(h, !0), p = p || h !== d[l];
            else {
              const b = h["@id"], _ = h["@type"], y = !("@prefix" in h) || t.Util.isValidIri(l);
              if ("@id" in h)
                b != null && typeof b == "string" && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": i.expandTerm(b, !0) }), p = p || b !== d[l]["@id"]);
              else if (!t.Util.isPotentialKeyword(l) && y) {
                const m = i.expandTerm(l, !0);
                m !== l && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": m }), p = !0);
              }
              if (_ && typeof _ == "string" && _ !== "@vocab" && (!h["@container"] || !h["@container"]["@type"]) && y) {
                let m = i.expandTerm(_, !0);
                c && _ === m && (m = i.expandTerm(_, !1)), m !== _ && (p = !0, d[l] = Object.assign(Object.assign({}, d[l]), { "@type": m }));
              }
            }
            if (!p)
              break;
          }
        }
    }
    /**
     * Normalize the @language entries in the given context to lowercase.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} parseOptions The parsing options.
     */
    normalize(i, { processingMode: c, normalizeLanguageTags: s }) {
      if (s || c === 1)
        for (const d of Object.keys(i))
          if (d === "@language" && typeof i[d] == "string")
            i[d] = i[d].toLowerCase();
          else {
            const l = i[d];
            if (l && typeof l == "object" && typeof l["@language"] == "string") {
              const f = l["@language"].toLowerCase();
              f !== l["@language"] && (i[d] = Object.assign(Object.assign({}, l), { "@language": f }));
            }
          }
    }
    /**
     * Convert all @container strings and array values to hash-based values.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     */
    containersToHash(i) {
      for (const c of Object.keys(i)) {
        const s = i[c];
        if (s && typeof s == "object") {
          if (typeof s["@container"] == "string")
            i[c] = Object.assign(Object.assign({}, s), { "@container": { [s["@container"]]: !0 } });
          else if (Array.isArray(s["@container"])) {
            const d = {};
            for (const l of s["@container"])
              d[l] = !0;
            i[c] = Object.assign(Object.assign({}, s), { "@container": d });
          }
        }
      }
    }
    /**
     * Normalize and apply context-level @protected terms onto each term separately.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {number} processingMode The processing mode.
     */
    applyScopedProtected(i, { processingMode: c }, s) {
      if (c && c >= 1.1 && i["@protected"]) {
        for (const d of Object.keys(i))
          if (!t.Util.isReservedInternalKeyword(d) && !t.Util.isPotentialKeyword(d) && !t.Util.isTermProtected(i, d)) {
            const l = i[d];
            l && typeof l == "object" ? "@protected" in i[d] || (i[d] = Object.assign(Object.assign({}, i[d]), { "@protected": !0 })) : (i[d] = {
              "@id": l,
              "@protected": !0
            }, t.Util.isSimpleTermDefinitionPrefix(l, s) && (i[d] = Object.assign(Object.assign({}, i[d]), { "@prefix": !0 })));
          }
        delete i["@protected"];
      }
    }
    /**
     * Check if the given context inheritance does not contain any overrides of protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.
     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.
     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all
     * keys defined in contextAfter will be checked.
     */
    validateKeywordRedefinitions(i, c, s, d) {
      for (const l of d ?? Object.keys(c))
        if (t.Util.isTermProtected(i, l) && (typeof c[l] == "string" ? c[l] = { "@id": c[l], "@protected": !0 } : c[l] = Object.assign(Object.assign({}, c[l]), { "@protected": !0 }), !t.Util.deepEqual(i[l], c[l])))
          throw new r.ErrorCoded(`Attempted to override the protected keyword ${l} from ${JSON.stringify(t.Util.getContextValueId(i[l]))} to ${JSON.stringify(t.Util.getContextValueId(c[l]))}`, r.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
    }
    /**
     * Validate the entries of the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options The parse options.
     */
    validate(i, { processingMode: c }) {
      for (const s of Object.keys(i)) {
        if (t.Util.isReservedInternalKeyword(s))
          continue;
        if (s === "")
          throw new r.ErrorCoded(`The empty term is not allowed, got: '${s}': '${JSON.stringify(i[s])}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
        const d = i[s], l = typeof d;
        if (t.Util.isPotentialKeyword(s)) {
          switch (s.substr(1)) {
            case "vocab":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @vocab IRI: ${d}`, r.ERROR_CODES.INVALID_VOCAB_MAPPING);
              break;
            case "base":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @base IRI: ${i[s]}`, r.ERROR_CODES.INVALID_BASE_IRI);
              break;
            case "language":
              d !== null && e.validateLanguage(d, !0, r.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
              break;
            case "version":
              if (d !== null && l !== "number")
                throw new r.ErrorCoded(`Found an invalid @version number: ${d}`, r.ERROR_CODES.INVALID_VERSION_VALUE);
              break;
            case "direction":
              d !== null && e.validateDirection(d, !0);
              break;
            case "propagate":
              if (c === 1)
                throw new r.ErrorCoded(`Found an illegal @propagate keyword: ${d}`, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              if (d !== null && l !== "boolean")
                throw new r.ErrorCoded(`Found an invalid @propagate value: ${d}`, r.ERROR_CODES.INVALID_PROPAGATE_VALUE);
              break;
          }
          if (t.Util.isValidKeyword(s) && t.Util.isValidKeyword(t.Util.getContextValueId(d)))
            throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${t.Util.getContextValueId(d)}'`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          continue;
        }
        if (d !== null)
          switch (l) {
            case "string":
              if (t.Util.getPrefix(d, i) === s)
                throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
              if (t.Util.isValidIriWeak(s)) {
                if (d === "@type")
                  throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                if (t.Util.isValidIri(d) && d !== new a.JsonLdContextNormalized(i).expandTerm(s))
                  throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              }
              break;
            case "object":
              if (!t.Util.isCompactIri(s) && !("@id" in d) && (d["@type"] === "@id" ? !i["@base"] : !i["@vocab"]))
                throw new r.ErrorCoded(`Missing @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              for (const f of Object.keys(d)) {
                const h = d[f];
                if (h)
                  switch (f) {
                    case "@id":
                      if (t.Util.isValidKeyword(h) && h !== "@type" && h !== "@id" && h !== "@graph" && h !== "@nest")
                        throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.isValidIriWeak(s)) {
                        if (h === "@type")
                          throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                        if (t.Util.isValidIri(h) && h !== new a.JsonLdContextNormalized(i).expandTerm(s))
                          throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`Detected non-string @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.getPrefix(h, i) === s)
                        throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
                      break;
                    case "@type":
                      if (d["@container"] === "@type" && h !== "@id" && h !== "@vocab")
                        throw new r.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(l)}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (h !== "@id" && h !== "@vocab" && (c === 1 || h !== "@json") && (c === 1 || h !== "@none") && (h[0] === "_" || !t.Util.isValidIri(h)))
                        throw new r.ErrorCoded(`A context @type must be an absolute IRI, found: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      break;
                    case "@reverse":
                      if (typeof h == "string" && d["@id"] && d["@id"] !== h)
                        throw new r.ErrorCoded(`Found non-matching @id and @reverse term values in '${s}':'${h}' and '${d["@id"]}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      if ("@nest" in d)
                        throw new r.ErrorCoded(`@nest is not allowed in the reverse property '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      break;
                    case "@container":
                      if (c === 1 && (Object.keys(h).length > 1 || t.Util.CONTAINERS_1_0.indexOf(Object.keys(h)[0]) < 0))
                        throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${Object.keys(h)}') in 1.0, must be only one of ${t.Util.CONTAINERS_1_0.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      for (const p of Object.keys(h)) {
                        if (p === "@list" && d["@reverse"])
                          throw new r.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        if (t.Util.CONTAINERS.indexOf(p) < 0)
                          throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${p}'), must be one of ${t.Util.CONTAINERS.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      }
                      break;
                    case "@language":
                      e.validateLanguage(h, !0, r.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                      break;
                    case "@direction":
                      e.validateDirection(h, !0);
                      break;
                    case "@prefix":
                      if (h !== null && typeof h != "boolean")
                        throw new r.ErrorCoded(`Found an invalid term @prefix boolean in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_PREFIX_VALUE);
                      if (!("@id" in d) && !t.Util.isValidIri(s))
                        throw new r.ErrorCoded(`Invalid @prefix definition for '${s}' ('${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@index":
                      if (c === 1 || !d["@container"] || !d["@container"]["@index"])
                        throw new r.ErrorCoded(`Attempt to add illegal key to value object: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@nest":
                      if (t.Util.isPotentialKeyword(h) && h !== "@nest")
                        throw new r.ErrorCoded(`Found an invalid term @nest value in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_NEST_VALUE);
                  }
              }
              break;
            default:
              throw new r.ErrorCoded(`Found an invalid term value: '${s}': '${d}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          }
      }
    }
    /**
     * Apply the @base context entry to the given context under certain circumstances.
     * @param context A context.
     * @param options Parsing options.
     * @param inheritFromParent If the @base value from the parent context can be inherited.
     * @return The given context.
     */
    applyBaseEntry(i, c, s) {
      return typeof i == "string" || (s && !("@base" in i) && c.parentContext && typeof c.parentContext == "object" && "@base" in c.parentContext && (i["@base"] = c.parentContext["@base"], c.parentContext["@__baseDocument"] && (i["@__baseDocument"] = !0)), c.baseIRI && !c.external && ("@base" in i ? i["@base"] !== null && typeof i["@base"] == "string" && !t.Util.isValidIri(i["@base"]) && (i["@base"] = (0, u.resolve)(i["@base"], c.parentContext && c.parentContext["@base"] || c.baseIRI)) : (i["@base"] = c.baseIRI, i["@__baseDocument"] = !0))), i;
    }
    /**
     * Resolve relative context IRIs, or return full IRIs as-is.
     * @param {string} contextIri A context IRI.
     * @param {string} baseIRI A base IRI.
     * @return {string} The normalized context IRI.
     */
    normalizeContextIri(i, c) {
      if (!t.Util.isValidIri(i))
        try {
          i = (0, u.resolve)(i, c);
        } catch {
          throw new Error(`Invalid context IRI: ${i}`);
        }
      return this.redirectSchemaOrgHttps && i.startsWith("http://schema.org") && (i = "https://schema.org/"), i;
    }
    /**
     * Parse scoped contexts in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options Parsing options.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all
     * keys in the context will be iterated over.
     */
    async parseInnerContexts(i, c, s) {
      for (const d of s ?? Object.keys(i)) {
        const l = i[d];
        if (l && typeof l == "object" && "@context" in l && l["@context"] !== null && !c.ignoreScopedContexts) {
          if (this.validateContext)
            try {
              const f = Object.assign(Object.assign({}, i), { [d]: Object.assign({}, i[d]) });
              delete f[d]["@context"], await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, parentContext: f, ignoreProtection: !0, ignoreRemoteScopedContexts: !0, ignoreScopedContexts: !0 }));
            } catch (f) {
              throw new r.ErrorCoded(f.message, r.ERROR_CODES.INVALID_SCOPED_CONTEXT);
            }
          i[d] = Object.assign(Object.assign({}, l), { "@context": (await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, minimalProcessing: !0, ignoreRemoteScopedContexts: !0, parentContext: i }))).getContextRaw() });
        }
      }
      return i;
    }
    async parse(i, c = {}, s = {}) {
      const { baseIRI: d, parentContext: l, external: f, processingMode: h = e.DEFAULT_PROCESSING_MODE, normalizeLanguageTags: p, ignoreProtection: b, minimalProcessing: _ } = c, y = c.remoteContexts || {};
      if (Object.keys(y).length >= this.remoteContextsDepthLimit)
        throw new r.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(y), r.ERROR_CODES.CONTEXT_OVERFLOW);
      if (i == null) {
        if (!b && l && t.Util.hasProtectedTerms(l))
          throw new r.ErrorCoded("Illegal context nullification when terms are protected", r.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
        return new a.JsonLdContextNormalized(this.applyBaseEntry({}, c, !1));
      } else if (typeof i == "string") {
        const m = this.normalizeContextIri(i, d), g = this.getOverriddenLoad(m, c);
        if (g)
          return new a.JsonLdContextNormalized(g);
        const T = await this.parse(await this.load(m), Object.assign(Object.assign({}, c), { baseIRI: m, external: !0, remoteContexts: Object.assign(Object.assign({}, y), { [m]: !0 }) }));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (Array.isArray(i)) {
        const m = [], g = await Promise.all(i.map((v, E) => {
          if (typeof v == "string") {
            const R = this.normalizeContextIri(v, d);
            m[E] = R;
            const L = this.getOverriddenLoad(R, c);
            return L || this.load(R);
          } else
            return v;
        }));
        if (_)
          return new a.JsonLdContextNormalized(g);
        const T = await g.reduce((v, E, R) => v.then((L) => this.parse(
          E,
          Object.assign(Object.assign({}, c), { baseIRI: m[R] || c.baseIRI, external: !!m[R] || c.external, parentContext: L.getContextRaw(), remoteContexts: m[R] ? Object.assign(Object.assign({}, y), { [m[R]]: !0 }) : y }),
          // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers
          {
            skipValidation: R < g.length - 1
          }
        )), Promise.resolve(new a.JsonLdContextNormalized(l || {})));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (typeof i == "object") {
        if ("@context" in i)
          return await this.parse(i["@context"], c);
        if (i = Object.assign({}, i), f && delete i["@base"], this.applyBaseEntry(i, c, !0), this.containersToHash(i), _)
          return new a.JsonLdContextNormalized(i);
        let m = {};
        if ("@import" in i)
          if (h >= 1.1) {
            if (typeof i["@import"] != "string")
              throw new r.ErrorCoded("An @import value must be a string, but got " + typeof i["@import"], r.ERROR_CODES.INVALID_IMPORT_VALUE);
            m = await this.loadImportContext(this.normalizeContextIri(i["@import"], d)), delete i["@import"];
          } else
            throw new r.ErrorCoded("Context importing is not supported in JSON-LD 1.0", r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        this.applyScopedProtected(m, { processingMode: h }, a.defaultExpandOptions);
        const g = Object.assign(m, i);
        this.idifyReverseTerms(g), this.normalize(g, { processingMode: h, normalizeLanguageTags: p }), this.applyScopedProtected(g, { processingMode: h }, a.defaultExpandOptions);
        const T = Object.keys(g), v = [];
        if (typeof l == "object")
          for (const R in l)
            R in g ? v.push(R) : g[R] = l[R];
        await this.parseInnerContexts(g, c, T);
        const E = new a.JsonLdContextNormalized(g);
        return (g && g["@version"] || e.DEFAULT_PROCESSING_MODE) >= 1.1 && (i["@vocab"] && typeof i["@vocab"] == "string" || i["@vocab"] === "") && (l && "@vocab" in l && i["@vocab"].indexOf(":") < 0 ? g["@vocab"] = l["@vocab"] + i["@vocab"] : (t.Util.isCompactIri(i["@vocab"]) || i["@vocab"] in g) && (g["@vocab"] = E.expandTerm(i["@vocab"], !0))), this.expandPrefixedTerms(E, this.expandContentTypeToBase, T), !b && l && h >= 1.1 && this.validateKeywordRedefinitions(l, g, a.defaultExpandOptions, v), this.validateContext && !s.skipValidation && this.validate(g, { processingMode: h }), E;
      } else
        throw new r.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${i}`, r.ERROR_CODES.INVALID_LOCAL_CONTEXT);
    }
    /**
     * Fetch the given URL as a raw JSON-LD context.
     * @param url An URL.
     * @return A promise resolving to a raw JSON-LD context.
     */
    async load(i) {
      const c = this.documentCache[i];
      if (c)
        return c;
      let s;
      try {
        s = await this.documentLoader.load(i);
      } catch (d) {
        throw new r.ErrorCoded(`Failed to load remote context ${i}: ${d.message}`, r.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
      }
      if (!("@context" in s))
        throw new r.ErrorCoded(`Missing @context in remote context at ${i}`, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      return this.documentCache[i] = s["@context"];
    }
    /**
     * Override the given context that may be loaded.
     *
     * This will check whether or not the url is recursively being loaded.
     * @param url An URL.
     * @param options Parsing options.
     * @return An overridden context, or null.
     *         Optionally an error can be thrown if a cyclic context is detected.
     */
    getOverriddenLoad(i, c) {
      if (i in (c.remoteContexts || {})) {
        if (c.ignoreRemoteScopedContexts)
          return i;
        throw new r.ErrorCoded("Detected a cyclic context inclusion of " + i, r.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
      }
      return null;
    }
    /**
     * Load an @import'ed context.
     * @param importContextIri The full URI of an @import value.
     */
    async loadImportContext(i) {
      let c = await this.load(i);
      if (typeof c != "object" || Array.isArray(c))
        throw new r.ErrorCoded("An imported context must be a single object: " + i, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      if ("@import" in c)
        throw new r.ErrorCoded("An imported context can not import another context: " + i, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
      return c = Object.assign({}, c), this.containersToHash(c), c;
    }
  }
  return e.DEFAULT_PROCESSING_MODE = 1.1, Ub.ContextParser = e, Ub;
}
var kE = {}, _j;
function Fce() {
  return _j || (_j = 1, Object.defineProperty(kE, "__esModule", { value: !0 })), kE;
}
var XE = {}, gj;
function Nce() {
  return gj || (gj = 1, Object.defineProperty(XE, "__esModule", { value: !0 })), XE;
}
var mj;
function xY() {
  return mj || (mj = 1, function(u) {
    var r = xs && xs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xs && xs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rce(), u), o(/* @__PURE__ */ a4(), u), o(/* @__PURE__ */ EY(), u), o(/* @__PURE__ */ Fce(), u), o(/* @__PURE__ */ Nce(), u), o(/* @__PURE__ */ OY(), u), o(/* @__PURE__ */ $8(), u);
  }(xs)), xs;
}
var Hb = {}, vj;
function Pce() {
  if (vj) return Hb;
  vj = 1, Object.defineProperty(Hb, "__esModule", { value: !0 }), Hb.SeparatorType = void 0;
  let u = class {
    constructor(o) {
      this.label = o;
    }
  };
  return Hb.SeparatorType = u, u.COMMA = new u(","), u.OBJECT_START = new u("{"), u.OBJECT_END = new u("}"), u.OBJECT_END_COMMA = new u("},"), u.ARRAY_START = new u("["), u.ARRAY_END = new u("]"), u.ARRAY_END_COMMA = new u("],"), u.GRAPH_FIELD_NONCOMPACT = new u('"@graph": ['), u.GRAPH_FIELD_COMPACT = new u('"@graph":['), u.CONTEXT_FIELD = new u('"@context":'), Hb;
}
var Gb = {}, Tj;
function IY() {
  if (Tj) return Gb;
  Tj = 1, Object.defineProperty(Gb, "__esModule", { value: !0 }), Gb.Util = void 0;
  const u = /* @__PURE__ */ xY();
  class r {
    /**
     * Convert an RDF term to a JSON value.
     * @param {Term} term An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     * @param {ITermToValueOptions} options Conversion options.
     * @return {any} A JSON value.
     */
    static termToValue(a, t, e = {
      compactIds: !1,
      useNativeTypes: !1
    }) {
      switch (a.termType) {
        case "NamedNode":
          const n = t.compactIri(a.value, e.vocab);
          return e.compactIds ? n : { "@id": n };
        case "DefaultGraph":
          return e.compactIds ? a.value : { "@id": a.value };
        case "BlankNode":
          const i = `_:${a.value}`;
          return e.compactIds ? i : { "@id": i };
        case "Literal":
          if (a.datatype.value === r.RDF_JSON) {
            let d;
            try {
              d = JSON.parse(a.value);
            } catch (l) {
              throw new u.ErrorCoded("Invalid JSON literal: " + l.message, u.ERROR_CODES.INVALID_JSON_LITERAL);
            }
            return {
              "@value": d,
              "@type": "@json"
            };
          }
          if (e.rdfDirection === "i18n-datatype" && a.datatype.value.startsWith(r.I18N)) {
            const [d, l] = a.datatype.value.substr(r.I18N.length, a.datatype.value.length).split("_");
            return Object.assign(Object.assign({ "@value": a.value }, d ? { "@language": d } : {}), l ? { "@direction": l } : {});
          }
          const c = a.datatype.value === r.XSD_STRING, s = {
            "@value": !c && e.useNativeTypes ? r.stringToNativeType(a.value, a.datatype.value) : a.value
          };
          return a.language ? Object.assign(Object.assign({}, s), { "@language": a.language }) : !c && typeof s["@value"] == "string" ? Object.assign(Object.assign({}, s), { "@type": a.datatype.value }) : s;
      }
    }
    /**
     * Convert a string term to a native type.
     * If no conversion is possible, the original string will be returned.
     * @param {string} value An RDF term's string value.
     * @param {string} type
     * @return {any}
     */
    static stringToNativeType(a, t) {
      if (t.startsWith(r.XSD))
        switch (t.substr(r.XSD.length)) {
          case "boolean":
            if (a === "true")
              return !0;
            if (a === "false")
              return !1;
            throw new Error(`Invalid xsd:boolean value '${a}'`);
          case "integer":
          case "number":
          case "int":
          case "byte":
          case "long":
            const n = parseInt(a, 10);
            if (isNaN(n))
              throw new Error(`Invalid xsd:integer value '${a}'`);
            return n;
          case "float":
          case "double":
            const i = parseFloat(a);
            if (isNaN(i))
              throw new Error(`Invalid xsd:float value '${a}'`);
            return i;
        }
      return a;
    }
  }
  return Gb.Util = r, r.XSD = "http://www.w3.org/2001/XMLSchema#", r.XSD_STRING = r.XSD + "string", r.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", r.RDF_TYPE = r.RDF + "type", r.RDF_JSON = r.RDF + "JSON", r.I18N = "https://www.w3.org/ns/i18n#", Gb;
}
var wj;
function Dce() {
  if (wj) return $b;
  wj = 1, Object.defineProperty($b, "__esModule", { value: !0 }), $b.JsonLdSerializer = void 0;
  const u = /* @__PURE__ */ xY(), r = /* @__PURE__ */ Pce(), o = /* @__PURE__ */ IY(), a = Bt();
  let t = class RY extends a.Transform {
    constructor(n = {}) {
      super({ objectMode: !0 }), this.indentation = 0, this.options = n, this.options.baseIRI && !this.options.context && (this.options.context = { "@base": this.options.baseIRI }), this.options.context ? (this.originalContext = this.options.context, this.context = new u.ContextParser().parse(this.options.context, { baseIRI: this.options.baseIRI })) : this.context = Promise.resolve(new u.JsonLdContextNormalized({}));
    }
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {NodeJS.EventEmitter} A quad stream.
     */
    import(n) {
      const i = new a.PassThrough({ objectMode: !0 });
      n.on("error", (s) => c.emit("error", s)), n.on("data", (s) => i.push(s)), n.on("end", () => i.push(null));
      const c = i.pipe(new RY(this.options));
      return c;
    }
    /**
     * Transforms a quad into the text stream.
     * @param {Quad} quad An RDF quad.
     * @param {string} encoding An (ignored) encoding.
     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the transformation is done
     * @private
     */
    _transform(n, i, c) {
      this.context.then((s) => {
        this.transformQuad(n, s), c();
      }).catch(c);
    }
    /**
     * Construct a list in an RDF.Term object that can be used
     * inside a quad's object to write into the serializer
     * as a list using the @list keyword.
     * @param {RDF.Quad_Object[]} values A list of values, can be empty.
     * @return {RDF.Quad_Object} A term that should be used in the object position of the quad that is written to the serializer.
     */
    async list(n) {
      const i = await this.context;
      return {
        "@list": n.map((c) => o.Util.termToValue(c, i, this.options))
      };
    }
    /**
     * Called when the incoming stream is closed.
     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the flushing is done.
     * @private
     */
    _flush(n) {
      return this.opened || this.pushDocumentStart(), this.lastPredicate && this.endPredicate(), this.lastSubject && this.endSubject(), this.lastGraph && this.lastGraph.termType !== "DefaultGraph" && this.endGraph(), this.endDocument(), n(null, null);
    }
    /**
     * Transforms a quad into the text stream.
     * @param {Quad} quad An RDF quad.
     * @param {JsonLdContextNormalized} context A context for compacting.
     */
    transformQuad(n, i) {
      this.opened || this.pushDocumentStart();
      const c = this.lastGraph && this.lastGraph.termType !== "DefaultGraph" && this.lastGraph.equals(n.subject);
      if (!c && (!this.lastGraph || !n.graph.equals(this.lastGraph))) {
        let s = n.graph.termType !== "DefaultGraph" && this.lastSubject && this.lastSubject.equals(n.graph);
        this.lastGraph && (this.lastGraph.termType !== "DefaultGraph" ? (this.endPredicate(), this.endSubject(), this.endGraph(!0), s = !1) : s ? (this.endPredicate(!0), this.lastSubject = null) : (this.endPredicate(), this.endSubject(!0))), n.graph.termType !== "DefaultGraph" && (s || this.pushId(n.graph, !0, i), this.pushSeparator(this.options.space ? r.SeparatorType.GRAPH_FIELD_NONCOMPACT : r.SeparatorType.GRAPH_FIELD_COMPACT), this.indentation++), this.lastGraph = n.graph;
      }
      (!this.lastSubject || !n.subject.equals(this.lastSubject)) && (c ? (this.endPredicate(), this.endSubject(), this.indentation--, this.pushSeparator(r.SeparatorType.ARRAY_END_COMMA), this.lastGraph = n.graph) : (this.lastSubject && (this.endPredicate(), this.endSubject(!0)), this.pushId(n.subject, !0, i)), this.lastSubject = n.subject), (!this.lastPredicate || !n.predicate.equals(this.lastPredicate)) && (this.lastPredicate && this.endPredicate(!0), this.pushPredicate(n.predicate, i)), this.pushObject(n.object, i);
    }
    pushDocumentStart() {
      this.opened = !0, this.originalContext && !this.options.excludeContext ? (this.pushSeparator(r.SeparatorType.OBJECT_START), this.indentation++, this.pushSeparator(r.SeparatorType.CONTEXT_FIELD), this.pushIndented(JSON.stringify(this.originalContext, null, this.options.space) + ","), this.pushSeparator(this.options.space ? r.SeparatorType.GRAPH_FIELD_NONCOMPACT : r.SeparatorType.GRAPH_FIELD_COMPACT), this.indentation++) : (this.pushSeparator(r.SeparatorType.ARRAY_START), this.indentation++);
    }
    /**
     * Push the given term as an @id field.
     * @param {Term} term An RDF term.
     * @param startOnNewLine If `{` should start on a new line
     * @param {JsonLdContextNormalized} context The context.
     */
    pushId(n, i, c) {
      if (n.termType === "Quad")
        this.pushNestedQuad(n, !0, c);
      else {
        const s = n.termType === "BlankNode" ? "_:" + n.value : c.compactIri(n.value, !1);
        i ? this.pushSeparator(r.SeparatorType.OBJECT_START) : (this.push(r.SeparatorType.OBJECT_START.label), this.options.space && this.push(`
`)), this.indentation++, this.pushIndented(this.options.space ? `"@id": "${s}",` : `"@id":"${s}",`);
      }
    }
    /**
     * Push the given predicate field.
     * @param {Term} predicate An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     */
    pushPredicate(n, i) {
      let c = n.value;
      !this.options.useRdfType && c === o.Util.RDF_TYPE && (c = "@type", this.objectOptions = Object.assign(Object.assign({}, this.options), { compactIds: !0, vocab: !0 }));
      const s = i.compactIri(c, !0);
      this.pushIndented(this.options.space ? `"${s}": [` : `"${s}":[`), this.indentation++, this.lastPredicate = n;
    }
    /**
     * Push the given object value.
     * @param {Term} object An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     */
    pushObject(n, i) {
      if (this.hadObjectForPredicate ? this.pushSeparator(r.SeparatorType.COMMA) : this.hadObjectForPredicate = !0, n.termType === "Quad") {
        const s = this.lastSubject, d = this.lastPredicate;
        this.hadObjectForPredicate = !1, this.pushNestedQuad(n, !1, i), this.endSubject(!1), this.hadObjectForPredicate = !0, this.lastPredicate = d, this.lastSubject = s;
        return;
      }
      let c;
      try {
        n["@list"] ? c = n : c = o.Util.termToValue(n, i, this.objectOptions || this.options);
      } catch (s) {
        return this.emit("error", s);
      }
      this.pushIndented(JSON.stringify(c, null, this.options.space));
    }
    pushNestedQuad(n, i, c) {
      this.pushSeparator(r.SeparatorType.OBJECT_START), this.indentation++, this.pushIndented(this.options.space ? '"@id": ' : '"@id":', !1), n.graph.termType !== "DefaultGraph" && this.emit("error", new Error(`Found a nested quad with the non-default graph: ${n.graph.value}`)), this.pushId(n.subject, !1, c), this.pushPredicate(n.predicate, c), this.pushObject(n.object, c), this.endPredicate(!1), this.endSubject(i);
    }
    endDocument() {
      this.opened = !1, this.originalContext && !this.options.excludeContext ? (this.indentation--, this.pushSeparator(r.SeparatorType.ARRAY_END), this.indentation--, this.pushSeparator(r.SeparatorType.OBJECT_END)) : (this.indentation--, this.pushSeparator(r.SeparatorType.ARRAY_END));
    }
    /**
     * Push the end of a predicate and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    endPredicate(n) {
      this.indentation--, this.pushSeparator(n ? r.SeparatorType.ARRAY_END_COMMA : r.SeparatorType.ARRAY_END), this.hadObjectForPredicate = !1, this.objectOptions = null, this.lastPredicate = null;
    }
    /**
     * Push the end of a subject and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    endSubject(n) {
      this.indentation--, this.pushSeparator(n ? r.SeparatorType.OBJECT_END_COMMA : r.SeparatorType.OBJECT_END), this.lastSubject = null;
    }
    /**
     * Push the end of a graph and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    endGraph(n) {
      this.indentation--, this.pushSeparator(r.SeparatorType.ARRAY_END), this.indentation--, this.pushSeparator(n ? r.SeparatorType.OBJECT_END_COMMA : r.SeparatorType.OBJECT_END), this.lastGraph = null;
    }
    /**
     * Puh the given separator.
     * @param {SeparatorType} type A type of separator.
     */
    pushSeparator(n) {
      this.pushIndented(n.label);
    }
    /**
     * An indentation-aware variant of {@link #push}.
     * All strings that are pushed here will be prefixed by {@link #indentation} amount of spaces.
     * @param {string} data A string.
     * @param pushNewLine If a newline should be pushed afterwards.
     */
    pushIndented(n, i = !0) {
      const c = this.getIndentPrefix(), s = n.split(`
`).map((d) => c + d).join(`
`);
      this.push(s), this.options.space && i && this.push(`
`);
    }
    /**
     * @return {string} Get the current indentation prefix based on {@link #indentation}.
     */
    getIndentPrefix() {
      return this.options.space ? this.options.space.repeat(this.indentation) : "";
    }
  };
  return $b.JsonLdSerializer = t, $b;
}
var Sj;
function Lce() {
  return Sj || (Sj = 1, function(u) {
    var r = Os && Os.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Os && Os.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Dce(), u), o(/* @__PURE__ */ IY(), u);
  }(Os)), Os;
}
var Aj;
function jce() {
  if (Aj) return Bb;
  Aj = 1, Object.defineProperty(Bb, "__esModule", { value: !0 }), Bb.ActorRdfSerializeJsonLd = void 0;
  const u = /* @__PURE__ */ B8(), r = /* @__PURE__ */ Lce();
  let o = class extends u.ActorRdfSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/ld+json": 1.0
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD"
     *     }} mediaTypeFormats
     */
    constructor(t) {
      super(t);
    }
    async runHandle(t, e, n) {
      const i = new r.JsonLdSerializer({ space: " ".repeat(this.jsonStringifyIndentSpaces) });
      let c;
      return "pipe" in t.quadStream ? (t.quadStream.on("error", (s) => i.emit("error", s)), c = t.quadStream.pipe(i)) : c = i.import(t.quadStream), { data: c };
    }
  };
  return Bb.ActorRdfSerializeJsonLd = o, Bb;
}
var Ej;
function Mce() {
  return Ej || (Ej = 1, function(u) {
    var r = Es && Es.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Es && Es.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ jce(), u);
  }(Es)), Es;
}
var Is = {}, zb = {}, A6 = {}, Oj;
function Cce() {
  if (Oj) return A6;
  Oj = 1, Object.defineProperty(A6, "__esModule", { value: !0 });
  function u(o, a) {
    return new Promise((t, e) => {
      o.on("end", () => t(a)), o.on("error", e);
    });
  }
  function r(o) {
    const a = [];
    return u(o.on("data", (t) => a.push(t)), a);
  }
  return A6.default = r, A6;
}
var ta = {}, Na = {}, kb = {}, Xb = {}, xj;
function qce() {
  if (xj) return Xb;
  xj = 1, Object.defineProperty(Xb, "__esModule", { value: !0 }), Xb.fragment = void 0;
  function u(a) {
    let t = a;
    (t.endsWith("/") || t.endsWith("#")) && (t = t.slice(0, t.length - 1));
    const e = [];
    t.lastIndexOf("/") > 0 && e.push(t.lastIndexOf("/")), t.lastIndexOf("#") > 0 && e.push(t.lastIndexOf("#"));
    const n = Math.max(...e);
    return t.slice(n + 1);
  }
  function r(a) {
    var t;
    const e = (t = a.split(/[^a-z0-9]+/ig).filter((n) => n !== "").map((n) => n[0].toUpperCase() + n.slice(1)).join("").match(/[a-z][a-z0-9]+/ig)) === null || t === void 0 ? void 0 : t[0];
    return typeof e > "u" ? void 0 : e[0].toLowerCase() + e.slice(1);
  }
  function o(a) {
    let t = u(a);
    return t = t ? r(t) : void 0, t || "v";
  }
  return Xb.fragment = o, Xb;
}
var Rs = {}, Fs = {}, ra = {}, E6 = { exports: {} }, Ij;
function Bce() {
  return Ij || (Ij = 1, function(u, r) {
    var o = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof zf < "u" && zf, a = function() {
      function e() {
        this.fetch = !1, this.DOMException = o.DOMException;
      }
      return e.prototype = o, new e();
    }();
    (function(e) {
      (function(n) {
        var i = typeof e < "u" && e || typeof self < "u" && self || // eslint-disable-next-line no-undef
        typeof zf < "u" && zf || {}, c = {
          searchParams: "URLSearchParams" in i,
          iterable: "Symbol" in i && "iterator" in Symbol,
          blob: "FileReader" in i && "Blob" in i && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in i,
          arrayBuffer: "ArrayBuffer" in i
        };
        function s(j) {
          return j && DataView.prototype.isPrototypeOf(j);
        }
        if (c.arrayBuffer)
          var d = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], l = ArrayBuffer.isView || function(j) {
            return j && d.indexOf(Object.prototype.toString.call(j)) > -1;
          };
        function f(j) {
          if (typeof j != "string" && (j = String(j)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(j) || j === "")
            throw new TypeError('Invalid character in header field name: "' + j + '"');
          return j.toLowerCase();
        }
        function h(j) {
          return typeof j != "string" && (j = String(j)), j;
        }
        function p(j) {
          var q = {
            next: function() {
              var Q = j.shift();
              return { done: Q === void 0, value: Q };
            }
          };
          return c.iterable && (q[Symbol.iterator] = function() {
            return q;
          }), q;
        }
        function b(j) {
          this.map = {}, j instanceof b ? j.forEach(function(q, Q) {
            this.append(Q, q);
          }, this) : Array.isArray(j) ? j.forEach(function(q) {
            if (q.length != 2)
              throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + q.length);
            this.append(q[0], q[1]);
          }, this) : j && Object.getOwnPropertyNames(j).forEach(function(q) {
            this.append(q, j[q]);
          }, this);
        }
        b.prototype.append = function(j, q) {
          j = f(j), q = h(q);
          var Q = this.map[j];
          this.map[j] = Q ? Q + ", " + q : q;
        }, b.prototype.delete = function(j) {
          delete this.map[f(j)];
        }, b.prototype.get = function(j) {
          return j = f(j), this.has(j) ? this.map[j] : null;
        }, b.prototype.has = function(j) {
          return this.map.hasOwnProperty(f(j));
        }, b.prototype.set = function(j, q) {
          this.map[f(j)] = h(q);
        }, b.prototype.forEach = function(j, q) {
          for (var Q in this.map)
            this.map.hasOwnProperty(Q) && j.call(q, this.map[Q], Q, this);
        }, b.prototype.keys = function() {
          var j = [];
          return this.forEach(function(q, Q) {
            j.push(Q);
          }), p(j);
        }, b.prototype.values = function() {
          var j = [];
          return this.forEach(function(q) {
            j.push(q);
          }), p(j);
        }, b.prototype.entries = function() {
          var j = [];
          return this.forEach(function(q, Q) {
            j.push([Q, q]);
          }), p(j);
        }, c.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries);
        function _(j) {
          if (!j._noBody) {
            if (j.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            j.bodyUsed = !0;
          }
        }
        function y(j) {
          return new Promise(function(q, Q) {
            j.onload = function() {
              q(j.result);
            }, j.onerror = function() {
              Q(j.error);
            };
          });
        }
        function m(j) {
          var q = new FileReader(), Q = y(q);
          return q.readAsArrayBuffer(j), Q;
        }
        function g(j) {
          var q = new FileReader(), Q = y(q), G = /charset=([A-Za-z0-9_-]+)/.exec(j.type), K = G ? G[1] : "utf-8";
          return q.readAsText(j, K), Q;
        }
        function T(j) {
          for (var q = new Uint8Array(j), Q = new Array(q.length), G = 0; G < q.length; G++)
            Q[G] = String.fromCharCode(q[G]);
          return Q.join("");
        }
        function v(j) {
          if (j.slice)
            return j.slice(0);
          var q = new Uint8Array(j.byteLength);
          return q.set(new Uint8Array(j)), q.buffer;
        }
        function E() {
          return this.bodyUsed = !1, this._initBody = function(j) {
            this.bodyUsed = this.bodyUsed, this._bodyInit = j, j ? typeof j == "string" ? this._bodyText = j : c.blob && Blob.prototype.isPrototypeOf(j) ? this._bodyBlob = j : c.formData && FormData.prototype.isPrototypeOf(j) ? this._bodyFormData = j : c.searchParams && URLSearchParams.prototype.isPrototypeOf(j) ? this._bodyText = j.toString() : c.arrayBuffer && c.blob && s(j) ? (this._bodyArrayBuffer = v(j.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(j) || l(j)) ? this._bodyArrayBuffer = v(j) : this._bodyText = j = Object.prototype.toString.call(j) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof j == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(j) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, c.blob && (this.blob = function() {
            var j = _(this);
            if (j)
              return j;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }), this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var j = _(this);
              return j || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
                this._bodyArrayBuffer.buffer.slice(
                  this._bodyArrayBuffer.byteOffset,
                  this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                )
              ) : Promise.resolve(this._bodyArrayBuffer));
            } else {
              if (c.blob)
                return this.blob().then(m);
              throw new Error("could not read as ArrayBuffer");
            }
          }, this.text = function() {
            var j = _(this);
            if (j)
              return j;
            if (this._bodyBlob)
              return g(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(T(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, c.formData && (this.formData = function() {
            return this.text().then(w);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var R = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function L(j) {
          var q = j.toUpperCase();
          return R.indexOf(q) > -1 ? q : j;
        }
        function A(j, q) {
          if (!(this instanceof A))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          q = q || {};
          var Q = q.body;
          if (j instanceof A) {
            if (j.bodyUsed)
              throw new TypeError("Already read");
            this.url = j.url, this.credentials = j.credentials, q.headers || (this.headers = new b(j.headers)), this.method = j.method, this.mode = j.mode, this.signal = j.signal, !Q && j._bodyInit != null && (Q = j._bodyInit, j.bodyUsed = !0);
          } else
            this.url = String(j);
          if (this.credentials = q.credentials || this.credentials || "same-origin", (q.headers || !this.headers) && (this.headers = new b(q.headers)), this.method = L(q.method || this.method || "GET"), this.mode = q.mode || this.mode || null, this.signal = q.signal || this.signal || function() {
            if ("AbortController" in i) {
              var U = new AbortController();
              return U.signal;
            }
          }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && Q)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          if (this._initBody(Q), (this.method === "GET" || this.method === "HEAD") && (q.cache === "no-store" || q.cache === "no-cache")) {
            var G = /([?&])_=[^&]*/;
            if (G.test(this.url))
              this.url = this.url.replace(G, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
            else {
              var K = /\?/;
              this.url += (K.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
            }
          }
        }
        A.prototype.clone = function() {
          return new A(this, { body: this._bodyInit });
        };
        function w(j) {
          var q = new FormData();
          return j.trim().split("&").forEach(function(Q) {
            if (Q) {
              var G = Q.split("="), K = G.shift().replace(/\+/g, " "), U = G.join("=").replace(/\+/g, " ");
              q.append(decodeURIComponent(K), decodeURIComponent(U));
            }
          }), q;
        }
        function S(j) {
          var q = new b(), Q = j.replace(/\r?\n[\t ]+/g, " ");
          return Q.split("\r").map(function(G) {
            return G.indexOf(`
`) === 0 ? G.substr(1, G.length) : G;
          }).forEach(function(G) {
            var K = G.split(":"), U = K.shift().trim();
            if (U) {
              var ae = K.join(":").trim();
              try {
                q.append(U, ae);
              } catch (ye) {
                console.warn("Response " + ye.message);
              }
            }
          }), q;
        }
        E.call(A.prototype);
        function O(j, q) {
          if (!(this instanceof O))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          if (q || (q = {}), this.type = "default", this.status = q.status === void 0 ? 200 : q.status, this.status < 200 || this.status > 599)
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          this.ok = this.status >= 200 && this.status < 300, this.statusText = q.statusText === void 0 ? "" : "" + q.statusText, this.headers = new b(q.headers), this.url = q.url || "", this._initBody(j);
        }
        E.call(O.prototype), O.prototype.clone = function() {
          return new O(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new b(this.headers),
            url: this.url
          });
        }, O.error = function() {
          var j = new O(null, { status: 200, statusText: "" });
          return j.ok = !1, j.status = 0, j.type = "error", j;
        };
        var x = [301, 302, 303, 307, 308];
        O.redirect = function(j, q) {
          if (x.indexOf(q) === -1)
            throw new RangeError("Invalid status code");
          return new O(null, { status: q, headers: { location: j } });
        }, n.DOMException = i.DOMException;
        try {
          new n.DOMException();
        } catch {
          n.DOMException = function(q, Q) {
            this.message = q, this.name = Q;
            var G = Error(q);
            this.stack = G.stack;
          }, n.DOMException.prototype = Object.create(Error.prototype), n.DOMException.prototype.constructor = n.DOMException;
        }
        function F(j, q) {
          return new Promise(function(Q, G) {
            var K = new A(j, q);
            if (K.signal && K.signal.aborted)
              return G(new n.DOMException("Aborted", "AbortError"));
            var U = new XMLHttpRequest();
            function ae() {
              U.abort();
            }
            U.onload = function() {
              var ee = {
                statusText: U.statusText,
                headers: S(U.getAllResponseHeaders() || "")
              };
              K.url.indexOf("file://") === 0 && (U.status < 200 || U.status > 599) ? ee.status = 200 : ee.status = U.status, ee.url = "responseURL" in U ? U.responseURL : ee.headers.get("X-Request-URL");
              var Te = "response" in U ? U.response : U.responseText;
              setTimeout(function() {
                Q(new O(Te, ee));
              }, 0);
            }, U.onerror = function() {
              setTimeout(function() {
                G(new TypeError("Network request failed"));
              }, 0);
            }, U.ontimeout = function() {
              setTimeout(function() {
                G(new TypeError("Network request timed out"));
              }, 0);
            }, U.onabort = function() {
              setTimeout(function() {
                G(new n.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function ye(ee) {
              try {
                return ee === "" && i.location.href ? i.location.href : ee;
              } catch {
                return ee;
              }
            }
            if (U.open(K.method, ye(K.url), !0), K.credentials === "include" ? U.withCredentials = !0 : K.credentials === "omit" && (U.withCredentials = !1), "responseType" in U && (c.blob ? U.responseType = "blob" : c.arrayBuffer && (U.responseType = "arraybuffer")), q && typeof q.headers == "object" && !(q.headers instanceof b || i.Headers && q.headers instanceof i.Headers)) {
              var pe = [];
              Object.getOwnPropertyNames(q.headers).forEach(function(ee) {
                pe.push(f(ee)), U.setRequestHeader(ee, h(q.headers[ee]));
              }), K.headers.forEach(function(ee, Te) {
                pe.indexOf(Te) === -1 && U.setRequestHeader(Te, ee);
              });
            } else
              K.headers.forEach(function(ee, Te) {
                U.setRequestHeader(Te, ee);
              });
            K.signal && (K.signal.addEventListener("abort", ae), U.onreadystatechange = function() {
              U.readyState === 4 && K.signal.removeEventListener("abort", ae);
            }), U.send(typeof K._bodyInit > "u" ? null : K._bodyInit);
          });
        }
        return F.polyfill = !0, i.fetch || (i.fetch = F, i.Headers = b, i.Request = A, i.Response = O), n.Headers = b, n.Request = A, n.Response = O, n.fetch = F, Object.defineProperty(n, "__esModule", { value: !0 }), n;
      })({});
    })(a), a.fetch.ponyfill = !0, delete a.fetch.polyfill;
    var t = o.fetch ? o : a;
    r = t.fetch, r.default = t.fetch, r.fetch = t.fetch, r.Headers = t.Headers, r.Request = t.Request, r.Response = t.Response, u.exports = r;
  }(E6, E6.exports)), E6.exports;
}
var Rj;
function U8() {
  if (Rj) return ra;
  Rj = 1;
  var u = ra && ra.__awaiter || function(t, e, n, i) {
    function c(s) {
      return s instanceof n ? s : new n(function(d) {
        d(s);
      });
    }
    return new (n || (n = Promise))(function(s, d) {
      function l(p) {
        try {
          h(i.next(p));
        } catch (b) {
          d(b);
        }
      }
      function f(p) {
        try {
          h(i.throw(p));
        } catch (b) {
          d(b);
        }
      }
      function h(p) {
        p.done ? s(p.value) : c(p.value).then(l, f);
      }
      h((i = i.apply(t, e || [])).next());
    });
  };
  Object.defineProperty(ra, "__esModule", { value: !0 }), ra.fetchContext = ra.fetchJson = void 0;
  const r = Bce();
  function o(t, e) {
    var n;
    return u(this, void 0, void 0, function* () {
      return (yield ((n = e == null ? void 0 : e.fetch) !== null && n !== void 0 ? n : r.fetch)(t)).json();
    });
  }
  ra.fetchJson = o;
  function a(t, e) {
    return u(this, void 0, void 0, function* () {
      return (yield o(t, e))["@context"];
    });
  }
  return ra.fetchContext = a, ra;
}
var Fj;
function $ce() {
  if (Fj) return Fs;
  Fj = 1;
  var u = Fs && Fs.__awaiter || function(a, t, e, n) {
    function i(c) {
      return c instanceof e ? c : new e(function(s) {
        s(c);
      });
    }
    return new (e || (e = Promise))(function(c, s) {
      function d(h) {
        try {
          f(n.next(h));
        } catch (p) {
          s(p);
        }
      }
      function l(h) {
        try {
          f(n.throw(h));
        } catch (p) {
          s(p);
        }
      }
      function f(h) {
        h.done ? c(h.value) : i(h.value).then(d, l);
      }
      f((n = n.apply(a, t || [])).next());
    });
  };
  Object.defineProperty(Fs, "__esModule", { value: !0 }), Fs.lookupUri = void 0;
  const r = U8();
  function o(a, t) {
    return u(this, void 0, void 0, function* () {
      const e = (yield (0, r.fetchContext)(`https://prefix.cc/${a}.file.jsonld`, t))[a];
      if (typeof e != "string")
        throw new Error(`Expected uri to be a string, received: ${e} of type ${typeof e}`);
      return e;
    });
  }
  return Fs.lookupUri = o, Fs;
}
var Ns = {}, Nj;
function Uce() {
  if (Nj) return Ns;
  Nj = 1;
  var u = Ns && Ns.__awaiter || function(a, t, e, n) {
    function i(c) {
      return c instanceof e ? c : new e(function(s) {
        s(c);
      });
    }
    return new (e || (e = Promise))(function(c, s) {
      function d(h) {
        try {
          f(n.next(h));
        } catch (p) {
          s(p);
        }
      }
      function l(h) {
        try {
          f(n.throw(h));
        } catch (p) {
          s(p);
        }
      }
      function f(h) {
        h.done ? c(h.value) : i(h.value).then(d, l);
      }
      f((n = n.apply(a, t || [])).next());
    });
  };
  Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.lookupPrefix = void 0;
  const r = U8();
  function o(a, t) {
    return u(this, void 0, void 0, function* () {
      const e = new URL("https://prefix.cc/reverse");
      e.searchParams.append("uri", a), e.searchParams.append("format", "jsonld");
      const n = Object.keys(yield (0, r.fetchContext)(e, t));
      if (n.length === 0)
        throw new Error("No prefixes returned");
      return n[0];
    });
  }
  return Ns.lookupPrefix = o, Ns;
}
var Ps = {}, Pj;
function Vce() {
  if (Pj) return Ps;
  Pj = 1;
  var u = Ps && Ps.__awaiter || function(a, t, e, n) {
    function i(c) {
      return c instanceof e ? c : new e(function(s) {
        s(c);
      });
    }
    return new (e || (e = Promise))(function(c, s) {
      function d(h) {
        try {
          f(n.next(h));
        } catch (p) {
          s(p);
        }
      }
      function l(h) {
        try {
          f(n.throw(h));
        } catch (p) {
          s(p);
        }
      }
      function f(h) {
        h.done ? c(h.value) : i(h.value).then(d, l);
      }
      f((n = n.apply(a, t || [])).next());
    });
  };
  Object.defineProperty(Ps, "__esModule", { value: !0 }), Ps.lookupAllPrefixes = void 0;
  const r = U8();
  function o(a) {
    return u(this, void 0, void 0, function* () {
      return (0, r.fetchContext)("https://prefix.cc/context", a);
    });
  }
  return Ps.lookupAllPrefixes = o, Ps;
}
var Dj;
function Lj() {
  return Dj || (Dj = 1, function(u) {
    var r = Rs && Rs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Rs && Rs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o($ce(), u), o(Uce(), u), o(Vce(), u);
  }(Rs)), Rs;
}
var jj;
function Qce() {
  return jj || (jj = 1, function(u) {
    var r = kb && kb.__awaiter || function(i, c, s, d) {
      function l(f) {
        return f instanceof s ? f : new s(function(h) {
          h(f);
        });
      }
      return new (s || (s = Promise))(function(f, h) {
        function p(y) {
          try {
            _(d.next(y));
          } catch (m) {
            h(m);
          }
        }
        function b(y) {
          try {
            _(d.throw(y));
          } catch (m) {
            h(m);
          }
        }
        function _(y) {
          y.done ? f(y.value) : l(y.value).then(p, b);
        }
        _((d = d.apply(i, c || [])).next());
      });
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), u.lookupAllPrefixes = u.prefixToUri = u.uriToPrefix = void 0;
    const o = qce(), a = Lj();
    function t(i, c) {
      return r(this, void 0, void 0, function* () {
        let s;
        try {
          s = yield (0, a.lookupPrefix)(i, c);
        } catch {
          c != null && c.mintOnUnknown && (s = (0, o.fragment)(i).slice(0, 4));
        }
        if (typeof s < "u" && typeof (c == null ? void 0 : c.existingPrefixes) == "object" && s in c.existingPrefixes) {
          let d = 0;
          for (; `${s}${d}` in c.existingPrefixes; )
            d += 1;
          s = `${s}${d}`;
        }
        return s;
      });
    }
    u.uriToPrefix = t;
    function e(i, c) {
      return r(this, void 0, void 0, function* () {
        try {
          return yield (0, a.lookupUri)(i, c);
        } catch {
          return;
        }
      });
    }
    u.prefixToUri = e;
    var n = Lj();
    Object.defineProperty(u, "lookupAllPrefixes", { enumerable: !0, get: function() {
      return n.lookupAllPrefixes;
    } });
  }(kb)), kb;
}
var Jb = {}, Mj;
function Hce() {
  if (Mj) return Jb;
  Mj = 1, Object.defineProperty(Jb, "__esModule", { value: !0 }), Jb.getShaclName = void 0;
  function u(r) {
    if (r.termType !== "NamedNode" || !r.value.startsWith(
      "http://www.w3.org/ns/shacl#"
      /* sh._ */
    ))
      throw new Error(`Term ${r.value} is not part of the SHACL namespace`);
    return r.value.slice(27);
  }
  return Jb.getShaclName = u, Jb;
}
var O6 = {}, Cj;
function Gce() {
  return Cj || (Cj = 1, Object.defineProperty(O6, "__esModule", { value: !0 }), O6.default = {
    deactivated: !0,
    severity: !0,
    message: !0,
    class: !0,
    datatype: !0,
    nodeKind: !0,
    minExclusive: !0,
    minInclusive: !0,
    maxExclusive: !0,
    maxInclusive: !0,
    minLength: !0,
    maxLength: !0,
    pattern: !0,
    flags: !0,
    languageIn: !0,
    uniqueLang: !0,
    equals: !0,
    disjoint: !0,
    lessThan: !0,
    lessThanOrEquals: !0,
    qualifiedValueShape: !0,
    qualifiedMinCount: !0,
    qualifiedMaxCount: !0,
    qualifiedValueShapesDisjoint: !0,
    closed: !0,
    ignoredProperties: !0,
    hasValue: !0,
    in: !0,
    // This is here so that we can exract it from alts
    node: !0
  }), O6;
}
var x6 = {}, qj;
function zce() {
  return qj || (qj = 1, Object.defineProperty(x6, "__esModule", { value: !0 }), x6.default = {
    owl: "http://www.w3.org/2002/07/owl#",
    rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    rdfs: "http://www.w3.org/2000/01/rdf-schema#",
    sh: "http://www.w3.org/ns/shacl#",
    xsd: "http://www.w3.org/2001/XMLSchema#"
  }), x6;
}
var I6 = {}, Bj;
function kce() {
  return Bj || (Bj = 1, Object.defineProperty(I6, "__esModule", { value: !0 }), I6.default = {
    targetNode: !0,
    targetObjectsOf: !0,
    targetSubjectsOf: !0,
    deactivated: !0,
    severity: !0,
    message: !0,
    class: !0,
    datatype: !0,
    nodeKind: !0,
    minExclusive: !0,
    minInclusive: !0,
    maxExclusive: !0,
    maxInclusive: !0,
    minLength: !0,
    maxLength: !0,
    pattern: !0,
    flags: !0,
    languageIn: !0,
    equals: !0,
    disjoint: !0,
    closed: !0,
    ignoredProperties: !0,
    hasValue: !0,
    in: !0
  }), I6;
}
var $j;
function Xce() {
  if ($j) return Na;
  $j = 1;
  var u = Na && Na.__awaiter || function(h, p, b, _) {
    function y(m) {
      return m instanceof b ? m : new b(function(g) {
        g(m);
      });
    }
    return new (b || (b = Promise))(function(m, g) {
      function T(R) {
        try {
          E(_.next(R));
        } catch (L) {
          g(L);
        }
      }
      function v(R) {
        try {
          E(_.throw(R));
        } catch (L) {
          g(L);
        }
      }
      function E(R) {
        R.done ? m(R.value) : y(R.value).then(T, v);
      }
      E((_ = _.apply(h, p || [])).next());
    });
  }, r = Na && Na.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(Na, "__esModule", { value: !0 });
  const o = iu, a = Qce(), t = Ow(), e = Hce(), n = r(Gce()), i = r(zce()), c = r(kce());
  function s(h) {
    var p;
    return (p = /^[^]*[#/]/.exec(h)) === null || p === void 0 ? void 0 : p[0];
  }
  const d = {
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
    "http://www.w3.org/2000/01/rdf-schema#": "rdfs",
    "http://www.w3.org/ns/shacl#": "sh",
    "http://www.w3.org/2001/XMLSchema#": "xsd"
  }, l = {
    rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    rdfs: "http://www.w3.org/2000/01/rdf-schema#",
    sh: "http://www.w3.org/ns/shacl#",
    xsd: "http://www.w3.org/2001/XMLSchema#"
  };
  class f {
    constructor(p, b, _ = {}, y = void 0, m = !0, g = !1, T, v = !1) {
      this.store = p, this.base = y, this.errorOnExtraQuads = m, this.mintUnspecifiedPrefixes = g, this.fetch = T, this.extendedSyntax = v, this.prefixes = {}, this.prefixRev = {};
      for (const E of Object.keys(_)) {
        const R = _[E], L = typeof R == "string" ? R : R.value;
        !(L in d) && !(E in l) && (this.prefixRev[L] = E, this.prefixes[E] = L);
      }
      this.writer = b;
    }
    /**
     * Used to initiate the flow of data through the writer.
     */
    // TODO: Make initialisation async
    write() {
      return u(this, void 0, void 0, function* () {
        const p = this.store.getQuads(null, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", "http://www.w3.org/2002/07/owl#Ontology", null);
        if (p.length === 1 && p[0].subject.termType === "NamedNode") {
          const _ = p[0].subject;
          this.store.removeQuads(p), _.equals(new o.NamedNode("urn:x-base:default")) || this.writer.add(`BASE ${(0, t.termToString)(_)}`), yield this.writeImports(_);
        } else
          throw new Error("Base expected");
        if (this.mintUnspecifiedPrefixes) {
          const _ = /* @__PURE__ */ new Set();
          for (const m of [
            ...this.store.getSubjects(null, null, null),
            ...this.store.getPredicates(null, null, null),
            ...this.store.getObjects(null, null, null)
          ])
            if (m.termType === "NamedNode") {
              const g = s(m.value);
              g && !(g in this.prefixRev) && !(g in d) && _.add(g);
            }
          const y = Object.assign(Object.assign({}, this.prefixes), l);
          yield Promise.all([..._].map((m) => (0, a.uriToPrefix)(m, {
            fetch: this.fetch,
            mintOnUnknown: !0,
            existingPrefixes: y
          }).then((g) => {
            this.prefixes[g] = m, y[g] = m, this.prefixRev[m] = g;
          })));
        }
        const b = new Set([
          ...this.store.getSubjects(null, null, null),
          ...this.store.getPredicates(null, null, null),
          ...this.store.getObjects(null, null, null)
        ].filter((_) => _.termType === "NamedNode").map((_) => s(_.value)).filter((_) => typeof _ == "string"));
        for (const _ in this.prefixRev)
          b.has(_) || (delete this.prefixes[this.prefixRev[_]], delete this.prefixRev[_]);
        if (yield this.writePrefixes(), this.prefixes = Object.assign(Object.assign({}, this.prefixes), l), this.prefixRev = Object.assign(Object.assign({}, this.prefixRev), d), this.writer.newLine(), yield this.writeShapes(), this.extendedSyntax) {
          const _ = this.store.getSubjects(null, null, null);
          _.length > 0 && this.writer.newLine(1);
          for (const y of _)
            this.writer.add(yield this.termToString(y, !0, !0)), this.writer.add(" "), this.writer.indent(), yield this.writeTurtlePredicates(y), this.writer.deindent();
          _.length > 0 && (this.writer.add(" ."), this.writer.newLine());
        }
        if (this.errorOnExtraQuads && this.store.size > 0)
          throw new Error(`Dataset contains quads that cannot be written in SHACLC [
${new o.Writer({ prefixes: this.prefixes }).quadsToString(this.store.getQuads(null, null, null, null))}]`);
        this.writer.end();
      });
    }
    writeImports(p) {
      return u(this, void 0, void 0, function* () {
        const b = this.store.getObjectsOnce(p, new o.NamedNode(
          "http://www.w3.org/2002/07/owl#imports"
          /* owl.imports */
        ), null);
        if (b.length > 0)
          for (const _ of b)
            this.writer.add(`IMPORTS <${_.value}>`, !0);
      });
    }
    writePrefixes() {
      return u(this, void 0, void 0, function* () {
        const p = Object.keys(this.prefixes).filter((b) => !(b in i.default)).sort();
        if (p.length > 0)
          for (const b of p)
            this.writer.add(`PREFIX ${b}: <${this.prefixes[b]}>`, !0);
      });
    }
    termToString(p, b = !1, _ = !1) {
      return u(this, void 0, void 0, function* () {
        try {
          if (b)
            throw new Error("Shacl name disabled");
          return (0, e.getShaclName)(p);
        } catch {
        }
        if (p.termType === "NamedNode") {
          const y = s(p.value);
          return y && y in this.prefixRev && y in this.prefixRev ? `${this.prefixRev[y]}:${p.value.slice(y.length)}` : (0, t.termToString)(p);
        }
        if (p.termType === "Literal")
          return p.datatypeString === "http://www.w3.org/2001/XMLSchema#integer" || p.datatypeString === "http://www.w3.org/2001/XMLSchema#boolean" ? p.value : (0, t.termToString)(p);
        throw p.termType === "BlankNode" && _ && (0, t.termToString)(p), new Error(`Invalid term type for extra statement ${p.value} (${p.termType})`);
      });
    }
    writeShapes() {
      return u(this, void 0, void 0, function* () {
        for (const p of this.store.getSubjectsOnce(new o.NamedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
          /* rdf.type */
        ), new o.NamedNode(
          "http://www.w3.org/ns/shacl#NodeShape"
          /* sh.NodeShape */
        ), null)) {
          this.store.getQuadsOnce(p, new o.NamedNode(
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
            /* rdf.type */
          ), new o.NamedNode(
            "http://www.w3.org/2000/01/rdf-schema#Class"
            /* rdfs.Class */
          ), null).length > 0 ? this.writer.add("shapeClass ") : this.writer.add("shape "), this.writer.add(yield this.termToString(p)), this.writer.add(" ");
          const b = this.store.getObjectsOnce(p, new o.NamedNode(
            "http://www.w3.org/ns/shacl#targetClass"
            /* sh.targetClass */
          ), null);
          if (b.length > 0) {
            this.writer.add("-> ");
            for (const y of b)
              y.termType === "NamedNode" ? this.writer.add(yield this.termToString(y)) : (this.writer.add("!"), this.writer.add(yield this.termToString(this.singleObject(y, new o.NamedNode(
                "http://www.w3.org/ns/shacl#not"
                /* sh.not */
              ), !0)))), this.writer.add(" ");
          }
          const _ = this.store.getPredicates(p, null, null).filter((y) => [
            new o.NamedNode(
              "http://www.w3.org/ns/shacl#targetClass"
              /* sh.targetClass */
            ),
            new o.NamedNode(
              "http://www.w3.org/ns/shacl#property"
              /* sh.property */
            ),
            // TODO: See if "and" should be here as well
            new o.NamedNode(
              "http://www.w3.org/ns/shacl#or"
              /* sh.or */
            ),
            ...Object.keys(c.default).map((m) => new o.NamedNode("http://www.w3.org/ns/shacl#" + m))
          ].every((m) => !y.equals(m)));
          _.length > 0 && (this.writer.add(";"), this.writer.indent(), this.writer.newLine(1)), this.extendedSyntax && (yield this.writeGivenTurtlePredicates(p, _)), _.length > 0 && (this.writer.add(" "), this.writer.deindent()), yield this.writeShapeBody(p, !1);
        }
      });
    }
    getSingleProperty(p, b) {
      let _ = [p];
      try {
        let y = (0, e.getShaclName)(p.predicate), m = "pred";
        if (y === "not") {
          const g = this.store.getQuadsOnce(p.object, null, null, null);
          if (_ = _.concat(g), g.length !== 1)
            throw new Error("Can only handle having one predicate of 'not'");
          [p] = g, y = (0, e.getShaclName)(p.predicate), m = "not";
        }
        if (!(y in b))
          throw new Error(`${y} is not allowed`);
        return { name: y, type: m, object: p.object };
      } catch {
        this.store.addQuads(_);
      }
    }
    singleLayerPropertiesList(p, b) {
      const _ = [];
      for (const y of this.store.getQuadsOnce(p, null, null, null)) {
        const m = this.getSingleProperty(y, b);
        m && _.push(m);
      }
      return _;
    }
    expectOneProperty(p, b) {
      const _ = this.store.getQuadsOnce(p, null, null, null);
      if (_.length === 1) {
        const y = this.getSingleProperty(_[0], b);
        if (y)
          return y;
      }
      this.store.addQuads(_);
    }
    orProperties(p, b) {
      const _ = [];
      for (const y of this.store.getQuadsOnce(p, new o.NamedNode(
        "http://www.w3.org/ns/shacl#or"
        /* sh.or */
      ), null, null)) {
        const m = [];
        for (const g of this.getList(y.object)) {
          const T = this.expectOneProperty(g, b);
          if (!T)
            throw this.store.addQuad(y), new Error("Each entry of the 'or' statement must declare exactly one property");
          m.push(T);
        }
        _.push(m);
      }
      return _;
    }
    /**
     * Extract an rdf:list
     */
    getList(p) {
      let b = p;
      const _ = [];
      for (; !b.equals(new o.NamedNode(
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"
        /* rdf.nil */
      )); )
        _.push(this.singleObject(b, new o.NamedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first"
          /* rdf.first */
        ), !0)), b = this.singleObject(b, new o.NamedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"
          /* rdf.rest */
        ), !0);
      return _;
    }
    writeIriLiteralOrArray(p) {
      return u(this, void 0, void 0, function* () {
        if (p.termType === "BlankNode") {
          this.writer.add("[");
          let b = !0;
          for (const _ of this.getList(p))
            b ? b = !1 : this.writer.add(" "), this.writer.add(yield this.termToString(_));
          this.writer.add("]");
        } else
          this.writer.add(yield this.termToString(p));
      });
    }
    singleObject(p, b, _) {
      var y;
      return (y = this.singleQuad(p, b, _)) === null || y === void 0 ? void 0 : y.object;
    }
    singleQuad(p, b, _ = !1) {
      const y = this.store.getQuadsOnce(p, b, null, null);
      if (_ && y.length !== 1)
        throw this.store.addQuads(y), new Error(`The subject and predicate ${p == null ? void 0 : p.value} ${b == null ? void 0 : b.value} must have exactly one object. Instead has ${y.length}`);
      if (y.length > 1)
        throw this.store.addQuads(y), new Error(`The subject and predicate ${p == null ? void 0 : p.value} ${b == null ? void 0 : b.value} can have at most one object. Instead has ${y.length}`);
      return y.length === 1 ? y[0] : void 0;
    }
    writeAssigment({ name: p, type: b, object: _ }) {
      return u(this, void 0, void 0, function* () {
        b === "not" && this.writer.add("!"), this.writer.add(p), this.writer.add("="), yield this.writeIriLiteralOrArray(_);
      });
    }
    writeAtom({ name: p, type: b, object: _ }) {
      return u(this, void 0, void 0, function* () {
        switch (b === "not" && this.writer.add("!"), p) {
          case "node": {
            if (_.termType === "NamedNode")
              this.writer.add(`@${yield this.termToString(_)}`);
            else if (_.termType === "BlankNode")
              yield this.writeShapeBody(_);
            else
              throw new Error("Invalid nested shape, must be blank node or IRI");
            return;
          }
          case "nodeKind": {
            this.writer.add((0, e.getShaclName)(_));
            return;
          }
          case "class": {
            this.writer.add(yield this.termToString(_));
            return;
          }
          case "datatype": {
            this.writer.add(yield this.termToString(_));
            return;
          }
          default:
            this.writer.add(p), this.writer.add("="), yield this.writeIriLiteralOrArray(_);
        }
      });
    }
    writeAssigments(p, b = " ", _ = !0, y) {
      return u(this, void 0, void 0, function* () {
        for (const m of p)
          _ ? _ = !1 : this.writer.add(b), y ? yield this.writeAtom(m) : yield this.writeAssigment(m);
      });
    }
    writeParams(p, b = !0, _, y = !1, m = !1) {
      return u(this, void 0, void 0, function* () {
        const g = this.orProperties(p, _), T = this.singleLayerPropertiesList(p, _);
        m && (g.length > 0 || T.length > 0) && this.writer.newLine(1);
        for (const v of g)
          b ? b = !1 : this.writer.add(" "), yield this.writeAssigments(v, "|", !0, y);
        yield this.writeAssigments(T, " ", b, y), m && (g.length > 0 || T.length > 0) && this.writer.add(" .");
      });
    }
    writeShapeBody(p, b = !0) {
      return u(this, void 0, void 0, function* () {
        this.writer.add("{").indent();
        const _ = this.store.getObjectsOnce(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#property"
          /* sh.property */
        ), null);
        yield this.writeParams(p, !0, c.default, !1, !0);
        for (const y of _)
          this.writer.newLine(1), yield this.writeProperty(y);
        this.writer.deindent().newLine(1), b ? this.writer.add("} .") : this.writer.add("}").newLine(1);
      });
    }
    writeProperty(p) {
      return u(this, void 0, void 0, function* () {
        yield this.writePath(this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#path"
          /* sh.path */
        ), !0));
        const b = this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#minCount"
          /* sh.minCount */
        )), _ = this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#maxCount"
          /* sh.maxCount */
        )), y = this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#nodeKind"
          /* sh.nodeKind */
        )), m = this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#class"
          /* sh._class */
        )), g = this.singleObject(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#datatype"
          /* sh.datatype */
        )), T = this.store.getObjectsOnce(p, new o.NamedNode(
          "http://www.w3.org/ns/shacl#node"
          /* sh.node */
        ), null);
        if (y && (this.writer.add(" "), this.writer.add((0, e.getShaclName)(y))), m && (this.writer.add(" "), this.writer.add(yield this.termToString(m))), g && (this.writer.add(" "), this.writer.add(yield this.termToString(g))), b !== void 0 || _ !== void 0) {
          if (this.writer.add(" ["), b) {
            if (b.termType !== "Literal" || b.datatypeString !== "http://www.w3.org/2001/XMLSchema#integer")
              throw new Error("Invalid min value, must me an integer literal");
            this.writer.add(b.value);
          } else
            this.writer.add("0");
          if (this.writer.add(".."), _) {
            if (_.termType !== "Literal" || _.datatypeString !== "http://www.w3.org/2001/XMLSchema#integer")
              throw new Error("Invalid max value, must me an integer literal");
            this.store.removeMatches(p, new o.NamedNode(
              "http://www.w3.org/ns/shacl#maxCount"
              /* sh.maxCount */
            ), void 0, void 0), this.writer.add(_.value);
          } else
            this.writer.add("*");
          this.writer.add("]");
        }
        yield this.writeParams(p, !1, n.default, !0);
        const v = [];
        for (const E of T)
          if (E.termType === "NamedNode")
            this.writer.add(" "), this.writer.add(`@${yield this.termToString(E)}`);
          else if (E.termType === "BlankNode")
            v.push(E);
          else
            throw new Error("Invalid nested shape, must be blank node or IRI");
        for (const E of v)
          this.writer.add(" "), yield this.writeShapeBody(E);
        this.extendedSyntax && this.store.getQuads(p, null, null, null).length > 0 && (this.writer.add(" %"), this.writer.indent(), this.writer.newLine(1), yield this.writeTurtlePredicates(p), this.writer.deindent(), this.writer.newLine(1), this.writer.add("%")), v.length === 0 && this.writer.add(" .");
      });
    }
    writeTurtlePredicates(p) {
      return u(this, void 0, void 0, function* () {
        return this.writeGivenTurtlePredicates(p, this.store.getPredicates(p, null, null));
      });
    }
    writeGivenTurtlePredicates(p, b) {
      return u(this, void 0, void 0, function* () {
        let _ = !1;
        if (b.some((y) => y.equals(o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")))) {
          const y = this.store.getObjectsOnce(p, o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), null);
          y.length > 0 && (_ = !0, this.writer.add("a "), yield this.writeTurtleObjects(y));
        }
        for (const y of b)
          y.equals(o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")) || (_ ? (this.writer.add(" ;"), this.writer.newLine(1)) : _ = !0, this.writer.add(yield this.termToString(y, !0)), this.writer.add(" "), yield this.writeTurtleObjects(this.store.getObjectsOnce(p, y, null)));
      });
    }
    writeTurtleObjects(p) {
      return u(this, void 0, void 0, function* () {
        const b = [], _ = [];
        for (const m of p)
          m.termType === "BlankNode" && [...this.store.match(null, null, m), ...this.store.match(null, m, null)].length === 0 ? b.push(m) : _.push(m);
        this.writer.add((yield Promise.all(_.map((m) => this.termToString(m, !0, !0)))).join(", "));
        let y = _.length > 0;
        if (b.length > 0)
          for (const m of b)
            y ? this.writer.add(", ") : y = !0, (yield this.writeList(m)) || (this.writer.add("["), this.writer.indent(), this.writer.newLine(1), yield this.writeTurtlePredicates(m), this.writer.deindent(), this.writer.newLine(1), this.writer.add("]"));
      });
    }
    writeList(p) {
      return u(this, void 0, void 0, function* () {
        let b = p;
        const _ = [], y = [];
        for (; !b.equals(o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")); ) {
          const g = this.store.getQuadsOnce(b, o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), null, null), T = this.store.getQuadsOnce(b, o.DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), null, null);
          if (y.push(...g, ...T), g.length !== 1 || T.length !== 1 || this.store.getQuads(b, null, null, null).length !== 0)
            return this.store.addQuads(y), !1;
          _.push(g[0].object), b = T[0].object;
        }
        let m = !1;
        this.writer.add("(");
        for (const g of _)
          m ? this.writer.add(" ") : m = !0, yield this.writeTurtleObjects([g]);
        return this.writer.add(")"), !0;
      });
    }
    writePath(p, b = !1) {
      return u(this, void 0, void 0, function* () {
        if (p.termType === "NamedNode")
          this.writer.add(yield this.termToString(p));
        else if (p.termType === "BlankNode") {
          const _ = this.store.getQuadsOnce(p, null, null, null);
          if (_.length === 1) {
            const { predicate: y, object: m } = _[0];
            switch (y.value) {
              case "http://www.w3.org/ns/shacl#inversePath":
                this.writer.add("^"), yield this.writePath(m, !0);
                return;
              case "http://www.w3.org/ns/shacl#alternativePath": {
                const g = this.getList(m);
                if (g.length === 0)
                  throw new Error("Invalid Alternative Path - no options");
                if (g.length === 1)
                  yield this.writePath(g[0]);
                else {
                  b && this.writer.add("(");
                  let T = !0;
                  for (const v of g)
                    T ? T = !1 : this.writer.add("|"), yield this.writePath(v, !0);
                  b && this.writer.add(")");
                }
                return;
              }
              case "http://www.w3.org/ns/shacl#zeroOrMorePath":
                yield this.writePath(m, !0), this.writer.add("*");
                return;
              case "http://www.w3.org/ns/shacl#oneOrMorePath":
                yield this.writePath(m, !0), this.writer.add("+");
                return;
              case "http://www.w3.org/ns/shacl#zeroOrOnePath":
                yield this.writePath(m, !0), this.writer.add("?");
                return;
              default:
                throw new Error(`Invalid path type ${p.value}`);
            }
          } else {
            this.store.addQuads(_);
            const y = this.getList(p);
            if (y.length === 0)
              throw new Error("Invalid Path");
            {
              b && this.writer.add("(");
              let m = !0;
              for (const g of y)
                m ? m = !1 : this.writer.add("/"), yield this.writePath(g, !0);
              b && this.writer.add(")");
            }
          }
        } else
          throw new Error("Path should be named node or blank node");
      });
    }
  }
  return Na.default = f, Na;
}
var R6 = {}, Uj;
function Jce() {
  if (Uj) return R6;
  Uj = 1, Object.defineProperty(R6, "__esModule", { value: !0 });
  class u {
    constructor(o) {
      this.indents = 0, this.write = o.write, this.end = o.end;
    }
    indent() {
      return this.indents += 1, this;
    }
    deindent() {
      if (this.indents < 1)
        throw new Error(`Trying to deindent when indent is only ${this.indents}`);
      return this.indents -= 1, this;
    }
    add(o, a = !1) {
      return this.write(a ? `
${"	".repeat(this.indents)}${o}` : o, "utf-8"), this;
    }
    newLine(o = 2) {
      return this.write(`
`.repeat(o) + "	".repeat(this.indents), "utf-8"), this;
    }
  }
  return R6.default = u, R6;
}
var F6 = {}, Vj;
function Kce() {
  if (Vj) return F6;
  Vj = 1, Object.defineProperty(F6, "__esModule", { value: !0 });
  const u = iu;
  class r extends u.Store {
    getQuadsOnce(a, t, e, n) {
      const i = this.getQuads(a, t, e, n);
      return this.removeQuads(i), i;
    }
    getSubjectsOnce(a, t, e) {
      return this.getQuadsOnce(null, a, t, e).map((n) => n.subject);
    }
    getObjectsOnce(a, t, e) {
      return this.getQuadsOnce(a, t, null, e).map((n) => n.object);
    }
  }
  return F6.default = r, F6;
}
var Qj;
function Wce() {
  if (Qj) return ta;
  Qj = 1;
  var u = ta && ta.__awaiter || function(i, c, s, d) {
    function l(f) {
      return f instanceof s ? f : new s(function(h) {
        h(f);
      });
    }
    return new (s || (s = Promise))(function(f, h) {
      function p(y) {
        try {
          _(d.next(y));
        } catch (m) {
          h(m);
        }
      }
      function b(y) {
        try {
          _(d.throw(y));
        } catch (m) {
          h(m);
        }
      }
      function _(y) {
        y.done ? f(y.value) : l(y.value).then(p, b);
      }
      _((d = d.apply(i, c || [])).next());
    });
  }, r = ta && ta.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(ta, "__esModule", { value: !0 }), ta.write = void 0;
  const o = iu, a = r(Xce()), t = r(Jce()), e = r(Kce());
  function n(i, c) {
    return u(this, void 0, void 0, function* () {
      return new Promise((s, d) => u(this, void 0, void 0, function* () {
        try {
          let l = "";
          const f = new e.default(i), h = f.getGraphs(null, null, null);
          if (h.length > 1)
            throw new Error("More than one graph found - can serialize in the default graph");
          if (h.length === 1 && !h[0].equals(o.DataFactory.defaultGraph()))
            throw new Error(`Expected all triples to be in the default graph, instead triples were in ${h[0].value}`);
          const p = new t.default({
            write: (_) => {
              l += _;
            },
            end: () => {
              let _ = f.getQuads(null, null, null, null);
              _.length === 0 && (_ = void 0), s({
                text: l,
                extraQuads: _
              });
            }
          });
          yield new a.default(f, p, c == null ? void 0 : c.prefixes, void 0, (c == null ? void 0 : c.errorOnUnused) !== !1, c == null ? void 0 : c.mintPrefixes, c == null ? void 0 : c.fetch, c == null ? void 0 : c.extendedSyntax).write();
        } catch (l) {
          d(l);
        }
      }));
    });
  }
  return ta.write = n, ta;
}
var Hj;
function Yce() {
  if (Hj) return zb;
  Hj = 1, Object.defineProperty(zb, "__esModule", { value: !0 }), zb.ActorRdfSerializeShaclc = void 0;
  const u = /* @__PURE__ */ B8(), r = Cce(), o = Bt(), a = Wce();
  let t = class extends u.ActorRdfSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "text/shaclc": 1.0,
     *       "text/shaclc-ext": 0.5
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "text/shaclc": "http://www.w3.org/ns/formats/Shaclc",
     *       "text/shaclc-ext": "http://www.w3.org/ns/formats/ShaclcExtended"
     *     }} mediaTypeFormats
     */
    constructor(n) {
      super(n);
    }
    async runHandle(n, i) {
      const c = new o.Readable();
      c._read = () => {
      };
      try {
        const s = {};
        n.quadStream.on("prefix", (l, f) => {
          s[l] = f;
        });
        const { text: d } = await (0, a.write)(await (0, r.default)(n.quadStream), { errorOnUnused: !0, extendedSyntax: i === "text/shaclc-ext", prefixes: s });
        c.push(d), c.push(null);
      } catch (s) {
        c._read = () => {
          c.emit("error", s);
        };
      }
      return {
        data: c,
        triples: !0
      };
    }
  };
  return zb.ActorRdfSerializeShaclc = t, zb;
}
var Gj;
function Zce() {
  return Gj || (Gj = 1, function(u) {
    var r = Is && Is.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Is && Is.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Yce(), u);
  }(Is)), Is;
}
var Ds = {}, Kb = {}, Ls = {}, Wb = {}, zj;
function FY() {
  if (zj) return Wb;
  zj = 1, Object.defineProperty(Wb, "__esModule", { value: !0 }), Wb.ActorRdfUpdateQuads = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF updating failed: none of the configured actors were able to handle an update} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Wb.ActorRdfUpdateQuads = r, Wb;
}
var na = {}, kj;
function ede() {
  if (kj) return na;
  kj = 1, Object.defineProperty(na, "__esModule", { value: !0 }), na.ActorRdfUpdateQuadsDestination = na.deskolemize = na.deskolemizeStream = void 0;
  const u = /* @__PURE__ */ tW(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ FY();
  function t(i, c, s) {
    return c == null ? void 0 : c.map((d) => (0, u.deskolemizeQuad)(i, d, s));
  }
  na.deskolemizeStream = t;
  function e(i) {
    var l;
    const c = i.context.getSafe(r.KeysInitQuery.dataFactory), s = i.context.get(r.KeysRdfUpdateQuads.destination), d = (l = i.context.get(r.KeysQuerySourceIdentify.sourceIds)) == null ? void 0 : l.get(s);
    return d ? {
      ...i,
      quadStreamInsert: t(c, i.quadStreamInsert, d),
      quadStreamDelete: t(c, i.quadStreamDelete, d)
    } : i;
  }
  na.deskolemize = e;
  let n = class extends a.ActorRdfUpdateQuads {
    async test(c) {
      return (0, o.passTestVoid)();
    }
    async run(c) {
      const s = await this.getDestination(c.context);
      return await this.getOutput(s, e(c));
    }
    /**
     * Get the output of the given action on a destination.
     * @param {IQuadDestination} destination A quad destination, possibly lazy.
     * @param {IActionRdfUpdateQuads} action The action.
     */
    async getOutput(c, s) {
      return { execute: async () => {
        await c.update({ insert: s.quadStreamInsert, delete: s.quadStreamDelete }), await (s.deleteGraphs ? c.deleteGraphs(s.deleteGraphs.graphs, s.deleteGraphs.requireExistence, s.deleteGraphs.dropGraphs) : Promise.resolve()), await (s.createGraphs ? c.createGraphs(s.createGraphs.graphs, s.createGraphs.requireNonExistence) : Promise.resolve());
      } };
    }
  };
  return na.ActorRdfUpdateQuadsDestination = n, na;
}
var JE = {}, Xj;
function tde() {
  return Xj || (Xj = 1, Object.defineProperty(JE, "__esModule", { value: !0 })), JE;
}
var tn = {}, Jj;
function rde() {
  if (Jj) return tn;
  Jj = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.getContextDestinationUrl = tn.getContextDestination = tn.getDataDestinationContext = tn.getDataDestinationValue = tn.getDataDestinationType = tn.isDataDestinationRawType = void 0;
  const u = /* @__PURE__ */ Be();
  function r(i) {
    return typeof i == "string" || "remove" in i;
  }
  tn.isDataDestinationRawType = r;
  function o(i) {
    return typeof i == "string" ? "" : "remove" in i ? "rdfjsStore" : i.type;
  }
  tn.getDataDestinationType = o;
  function a(i) {
    return r(i) ? i : i.value;
  }
  tn.getDataDestinationValue = a;
  function t(i, c) {
    return typeof i == "string" || "remove" in i || !i.context ? c : c.merge(i.context);
  }
  tn.getDataDestinationContext = t;
  function e(i) {
    return i.get(u.KeysRdfUpdateQuads.destination);
  }
  tn.getContextDestination = e;
  function n(i) {
    if (i) {
      let c = a(i);
      if (typeof c == "string") {
        const s = c.indexOf("#");
        return s >= 0 && (c = c.slice(0, s)), c;
      }
    }
  }
  return tn.getContextDestinationUrl = n, tn;
}
var Kj;
function V8() {
  return Kj || (Kj = 1, function(u) {
    var r = Ls && Ls.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ls && Ls.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ FY(), u), o(/* @__PURE__ */ ede(), u), o(/* @__PURE__ */ tde(), u), o(/* @__PURE__ */ rde(), u);
  }(Ls)), Ls;
}
var Yb = {}, Wj;
function nde() {
  if (Wj) return Yb;
  Wj = 1, Object.defineProperty(Yb, "__esModule", { value: !0 }), Yb.RdfJsQuadDestination = void 0;
  const u = pY(), r = lr();
  let o = class {
    constructor(t, e) {
      this.dataFactory = t, this.store = e;
    }
    async update(t) {
      t.delete && await (0, u.promisifyEventEmitter)(this.store.remove(t.delete)), t.insert && await (0, u.promisifyEventEmitter)(this.store.import(t.insert));
    }
    async deleteGraphs(t, e, n) {
      switch (t) {
        case "ALL":
          await (0, u.promisifyEventEmitter)(this.store.deleteGraph(this.dataFactory.defaultGraph()));
        // Drop through to remove all named graphs
        case "NAMED":
          const i = this.store.match(), c = {};
          i.on("data", (s) => {
            s.graph.termType !== "DefaultGraph" && (c[(0, r.termToString)(s.graph)] = !0);
          }), await (0, u.promisifyEventEmitter)(i), await Promise.all(Object.keys(c).map((s) => (0, u.promisifyEventEmitter)(this.store.deleteGraph((0, r.stringToTerm)(s, this.dataFactory)))));
          break;
        default:
          for (const s of Array.isArray(t) ? t : [t])
            await (0, u.promisifyEventEmitter)(this.store.deleteGraph(s));
      }
    }
    async createGraphs(t, e) {
      if (e)
        for (const n of t) {
          const i = this.store.match(void 0, void 0, void 0, n);
          await new Promise((c, s) => {
            i.once("data", () => {
              s(new Error(`Unable to create graph ${n.value} as it already exists`));
            }), i.on("end", c), i.on("error", s);
          });
        }
    }
  };
  return Yb.RdfJsQuadDestination = o, Yb;
}
var Yj;
function ide() {
  if (Yj) return Kb;
  Yj = 1, Object.defineProperty(Kb, "__esModule", { value: !0 }), Kb.ActorRdfUpdateQuadsRdfJsStore = void 0;
  const u = /* @__PURE__ */ V8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ nde();
  let t = class extends u.ActorRdfUpdateQuadsDestination {
    constructor(n) {
      super(n);
    }
    async test(n) {
      var c;
      const i = (0, u.getContextDestination)(n.context);
      return !i || typeof i == "string" || !("remove" in i) && "value" in i && !((c = i.value) != null && c.remove) ? (0, o.failTest)(`${this.name} received an invalid rdfjsStore.`) : (0, o.passTestVoid)();
    }
    async getDestination(n) {
      const i = (0, u.getContextDestination)(n);
      return new a.RdfJsQuadDestination(n.getSafe(r.KeysInitQuery.dataFactory), "remove" in i ? i : i.value);
    }
  };
  return Kb.ActorRdfUpdateQuadsRdfJsStore = t, Kb;
}
var Zj;
function ade() {
  return Zj || (Zj = 1, function(u) {
    var r = Ds && Ds.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ds && Ds.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ide(), u);
  }(Ds)), Ds;
}
var js = {}, Zb = {}, ey = {}, eM;
function ude() {
  if (eM) return ey;
  eM = 1, Object.defineProperty(ey, "__esModule", { value: !0 }), ey.ExpressionFunctionBnode = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ g8(), a = /* @__PURE__ */ ve();
  let t = class hx extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: a.SparqlOperator.BNODE,
        apply: async (n) => {
          const { args: i, mapping: c, exprEval: s } = n, d = i.length === 1 ? await s.evaluatorExpressionEvaluation(i[0], c) : void 0;
          let l;
          if (d) {
            const h = hx.bnodeTree.search([d], s.context.getSafe(r.KeysExpressionEvaluator.superTypeProvider), s.context.getSafe(r.KeysInitQuery.functionArgumentsCache));
            if (!h)
              throw new a.InvalidArgumentTypes(i, a.SparqlOperator.BNODE);
            l = h(s)([d]).str();
          }
          const f = new o.BlankNodeBindingsScoped(l ?? `BNODE_${hx.bnodeCounter++}`);
          return new a.BlankNode(f);
        }
      });
    }
    checkArity(n) {
      return n.length === 0 || n.length === 1;
    }
  };
  return ey.ExpressionFunctionBnode = t, t.bnodeTree = (0, a.declare)(a.SparqlOperator.BNODE).onString1(() => (e) => e).collect(), t.bnodeCounter = 0, ey;
}
var tM;
function ode() {
  if (tM) return Zb;
  tM = 1, Object.defineProperty(Zb, "__esModule", { value: !0 }), Zb.ActorFunctionFactoryExpressionBnode = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ ude();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.BNODE],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionBnode();
    }
  };
  return Zb.ActorFunctionFactoryExpressionBnode = a, Zb;
}
var rM;
function sde() {
  return rM || (rM = 1, function(u) {
    var r = js && js.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = js && js.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ode(), u);
  }(js)), js;
}
var Ms = {}, ty = {}, ry = {}, nM;
function cde() {
  if (nM) return ry;
  nM = 1, Object.defineProperty(ry, "__esModule", { value: !0 }), ry.ExpressionFunctionBound = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ru(), a = /* @__PURE__ */ ve();
  let t = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: a.SparqlOperator.BOUND,
        apply: async ({ args: n, mapping: i, exprEval: c }) => {
          const s = n[0];
          if (s.expressionType !== o.ExpressionType.Variable)
            throw new a.InvalidArgumentTypes(n, a.SparqlOperator.BOUND);
          const d = i.has((0, a.expressionToVar)(c.context.getSafe(r.KeysInitQuery.dataFactory), s));
          return (0, a.bool)(d);
        }
      });
    }
  };
  return ry.ExpressionFunctionBound = t, ry;
}
var iM;
function dde() {
  if (iM) return ty;
  iM = 1, Object.defineProperty(ty, "__esModule", { value: !0 }), ty.ActorFunctionFactoryExpressionBound = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ cde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.BOUND],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionBound();
    }
  };
  return ty.ActorFunctionFactoryExpressionBound = a, ty;
}
var aM;
function lde() {
  return aM || (aM = 1, function(u) {
    var r = Ms && Ms.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ms && Ms.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ dde(), u);
  }(Ms)), Ms;
}
var Cs = {}, ny = {}, iy = {}, uM;
function fde() {
  if (uM) return iy;
  uM = 1, Object.defineProperty(iy, "__esModule", { value: !0 }), iy.ExpressionFunctionCoalesce = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: r.SparqlOperator.COALESCE,
        apply: async ({ args: t, mapping: e, exprEval: n }) => {
          const i = [];
          for (const c of t)
            try {
              return await n.evaluatorExpressionEvaluation(c, e);
            } catch (s) {
              i.push(s);
            }
          throw new r.CoalesceError(i);
        }
      });
    }
  };
  return iy.ExpressionFunctionCoalesce = o, iy;
}
var oM;
function hde() {
  if (oM) return ny;
  oM = 1, Object.defineProperty(ny, "__esModule", { value: !0 }), ny.ActorFunctionFactoryExpressionCoalesce = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ fde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.COALESCE],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionCoalesce();
    }
  };
  return ny.ActorFunctionFactoryExpressionCoalesce = a, ny;
}
var sM;
function pde() {
  return sM || (sM = 1, function(u) {
    var r = Cs && Cs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Cs && Cs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hde(), u);
  }(Cs)), Cs;
}
var qs = {}, ay = {}, uy = {}, cM;
function bde() {
  if (cM) return uy;
  cM = 1, Object.defineProperty(uy, "__esModule", { value: !0 }), uy.ExpressionFunctionConcat = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class px extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: o.SparqlOperator.CONCAT,
        apply: async (e) => {
          const { args: n, mapping: i, exprEval: c } = e, s = n.map(async (p) => c.evaluatorExpressionEvaluation(p, i)).map(async (p) => {
            const b = px.concatTree.search([await p], c.context.getSafe(r.KeysExpressionEvaluator.superTypeProvider), c.context.getSafe(r.KeysInitQuery.functionArgumentsCache));
            if (!b)
              throw new o.InvalidArgumentTypes(n, o.SparqlOperator.CONCAT);
            return b(c)([await p]);
          }), d = await Promise.all(s), f = d.map((p) => p.typedValue).join(""), h = px.langAllEqual(d) ? d[0].language : void 0;
          return h ? (0, o.langString)(f, h) : (0, o.string)(f);
        }
      });
    }
    static langAllEqual(e) {
      return e.length > 0 && e.every((n) => n.language === e[0].language);
    }
  };
  return uy.ExpressionFunctionConcat = a, a.concatTree = (0, o.declare)(o.SparqlOperator.CONCAT).onStringly1(() => (t) => t).collect(), uy;
}
var dM;
function yde() {
  if (dM) return ay;
  dM = 1, Object.defineProperty(ay, "__esModule", { value: !0 }), ay.ActorFunctionFactoryExpressionConcat = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ bde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.CONCAT],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionConcat();
    }
  };
  return ay.ActorFunctionFactoryExpressionConcat = a, ay;
}
var lM;
function _de() {
  return lM || (lM = 1, function(u) {
    var r = qs && qs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = qs && qs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ yde(), u);
  }(qs)), qs;
}
var Bs = {}, oy = {}, sy = {}, fM;
function gde() {
  if (fM) return sy;
  fM = 1, Object.defineProperty(sy, "__esModule", { value: !0 }), sy.NamedExtension = void 0;
  const u = /* @__PURE__ */ KK(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.ExpressionFunctionBase {
    constructor({ operator: e, functionDefinition: n }) {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: e,
        apply: async ({ args: i, exprEval: c, mapping: s }) => {
          const d = await Promise.all(i.map((l) => c.evaluatorExpressionEvaluation(l, s)));
          try {
            return new o.TermTransformer(c.context.getSafe(r.KeysExpressionEvaluator.superTypeProvider)).transformRDFTermUnsafe(await n(d.map((l) => l.toRDF(c.context.getSafe(r.KeysInitQuery.dataFactory)))));
          } catch (l) {
            throw new o.ExtensionFunctionError(this.operator, l);
          }
        }
      });
    }
  };
  return sy.NamedExtension = a, sy;
}
var hM;
function mde() {
  if (hM) return oy;
  hM = 1, Object.defineProperty(oy, "__esModule", { value: !0 }), oy.ActorFunctionFactoryExpressionExtensions = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = Or(), t = /* @__PURE__ */ gde();
  let e = class extends u.ActorFunctionFactory {
    constructor(i) {
      super(i);
    }
    async test({ context: i, functionName: c }) {
      return await i.getSafe(r.KeysExpressionEvaluator.extensionFunctionCreator)(new a.DataFactory().namedNode(c)) ? (0, o.passTestVoid)() : (0, o.failTest)(`Actor ${this.name} can only provide non-termExpression implementations for functions that are provided through config entries like: ${r.KeysInitQuery.extensionFunctionCreator.name} or ${r.KeysInitQuery.extensionFunctions.name}`);
    }
    async run({ context: i, functionName: c }) {
      const d = await i.getSafe(r.KeysExpressionEvaluator.extensionFunctionCreator)(new a.DataFactory().namedNode(c));
      return new t.NamedExtension({
        operator: c,
        functionDefinition: d
      });
    }
  };
  return oy.ActorFunctionFactoryExpressionExtensions = e, oy;
}
var pM;
function vde() {
  return pM || (pM = 1, function(u) {
    var r = Bs && Bs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bs && Bs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ mde(), u);
  }(Bs)), Bs;
}
var $s = {}, cy = {}, dy = {}, bM;
function Tde() {
  if (bM) return dy;
  bM = 1, Object.defineProperty(dy, "__esModule", { value: !0 }), dy.ExpressionFunctionIf = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: 3,
        operator: r.SparqlOperator.IF,
        apply: async ({ args: t, mapping: e, exprEval: n }) => (await n.evaluatorExpressionEvaluation(t[0], e)).coerceEBV() ? n.evaluatorExpressionEvaluation(t[1], e) : n.evaluatorExpressionEvaluation(t[2], e)
      });
    }
  };
  return dy.ExpressionFunctionIf = o, dy;
}
var yM;
function wde() {
  if (yM) return cy;
  yM = 1, Object.defineProperty(cy, "__esModule", { value: !0 }), cy.ActorFunctionFactoryExpressionIf = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Tde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IF],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionIf();
    }
  };
  return cy.ActorFunctionFactoryExpressionIf = a, cy;
}
var _M;
function Sde() {
  return _M || (_M = 1, function(u) {
    var r = $s && $s.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $s && $s.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ wde(), u);
  }($s)), $s;
}
var Us = {}, ly = {}, fy = {}, gM;
function Ade() {
  if (gM) return fy;
  gM = 1, Object.defineProperty(fy, "__esModule", { value: !0 }), fy.ExpressionFunctionLogicalAnd = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.LOGICAL_AND,
        apply: async ({ args: t, mapping: e, exprEval: n }) => {
          const [i, c] = t;
          try {
            if (!(await n.evaluatorExpressionEvaluation(i, e)).coerceEBV())
              return (0, r.bool)(!1);
            const f = (await n.evaluatorExpressionEvaluation(c, e)).coerceEBV();
            return (0, r.bool)(f);
          } catch (s) {
            if ((await n.evaluatorExpressionEvaluation(c, e)).coerceEBV())
              throw s;
            return (0, r.bool)(!1);
          }
        }
      });
    }
  };
  return fy.ExpressionFunctionLogicalAnd = o, fy;
}
var mM;
function Ede() {
  if (mM) return ly;
  mM = 1, Object.defineProperty(ly, "__esModule", { value: !0 }), ly.ActorFunctionFactoryExpressionLogicalAnd = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ade();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LOGICAL_AND],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionLogicalAnd();
    }
  };
  return ly.ActorFunctionFactoryExpressionLogicalAnd = a, ly;
}
var vM;
function Ode() {
  return vM || (vM = 1, function(u) {
    var r = Us && Us.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Us && Us.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ede(), u);
  }(Us)), Us;
}
var Vs = {}, hy = {}, py = {}, TM;
function xde() {
  if (TM) return py;
  TM = 1, Object.defineProperty(py, "__esModule", { value: !0 }), py.ExpressionFunctionLogicalOr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.LOGICAL_OR,
        apply: async ({ args: t, mapping: e, exprEval: n }) => {
          const [i, c] = t;
          try {
            if ((await n.evaluatorExpressionEvaluation(i, e)).coerceEBV())
              return (0, r.bool)(!0);
            const f = (await n.evaluatorExpressionEvaluation(c, e)).coerceEBV();
            return (0, r.bool)(f);
          } catch (s) {
            if (!(await n.evaluatorExpressionEvaluation(c, e)).coerceEBV())
              throw s;
            return (0, r.bool)(!0);
          }
        }
      });
    }
  };
  return py.ExpressionFunctionLogicalOr = o, py;
}
var wM;
function Ide() {
  if (wM) return hy;
  wM = 1, Object.defineProperty(hy, "__esModule", { value: !0 }), hy.ActorFunctionFactoryExpressionLogicalOr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ xde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LOGICAL_OR],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionLogicalOr();
    }
  };
  return hy.ActorFunctionFactoryExpressionLogicalOr = a, hy;
}
var SM;
function Rde() {
  return SM || (SM = 1, function(u) {
    var r = Vs && Vs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vs && Vs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ide(), u);
  }(Vs)), Vs;
}
var Qs = {}, by = {}, yy = {}, AM;
function Fde() {
  if (AM) return yy;
  AM = 1, Object.defineProperty(yy, "__esModule", { value: !0 }), yy.ExpressionFunctionSameTerm = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.ExpressionFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: o.SparqlOperator.SAME_TERM,
        apply: async ({ args: e, mapping: n, exprEval: i }) => {
          const c = i.context.getSafe(r.KeysInitQuery.dataFactory), [s, d] = e.map((h) => i.evaluatorExpressionEvaluation(h, n)), [l, f] = await Promise.all([s, d]);
          return (0, o.bool)(l.toRDF(c).equals(f.toRDF(c)));
        }
      });
    }
  };
  return yy.ExpressionFunctionSameTerm = a, yy;
}
var EM;
function Nde() {
  if (EM) return by;
  EM = 1, Object.defineProperty(by, "__esModule", { value: !0 }), by.ActorFunctionFactoryExpressionSameTerm = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Fde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SAME_TERM],
        termFunction: !1
      });
    }
    async run(e) {
      return new o.ExpressionFunctionSameTerm();
    }
  };
  return by.ActorFunctionFactoryExpressionSameTerm = a, by;
}
var OM;
function Pde() {
  return OM || (OM = 1, function(u) {
    var r = Qs && Qs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Qs && Qs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Nde(), u);
  }(Qs)), Qs;
}
var Hs = {}, _y = {}, gy = {}, xM;
function Dde() {
  if (xM) return gy;
  xM = 1, Object.defineProperty(gy, "__esModule", { value: !0 }), gy.TermFunctionAbs = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.ABS,
        overloads: (0, r.declare)(r.SparqlOperator.ABS).numericConverter(() => (t) => Math.abs(t)).collect()
      });
    }
  };
  return gy.TermFunctionAbs = o, gy;
}
var IM;
function Lde() {
  if (IM) return _y;
  IM = 1, Object.defineProperty(_y, "__esModule", { value: !0 }), _y.ActorFunctionFactoryTermAbs = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Dde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.ABS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionAbs();
    }
  };
  return _y.ActorFunctionFactoryTermAbs = a, _y;
}
var RM;
function jde() {
  return RM || (RM = 1, function(u) {
    var r = Hs && Hs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Hs && Hs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Lde(), u);
  }(Hs)), Hs;
}
var Gs = {}, my = {}, vy = {}, cS = { exports: {} }, Mde = cS.exports, FM;
function u4() {
  return FM || (FM = 1, function(u) {
    (function(r) {
      var o, a = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, t = Math.ceil, e = Math.floor, n = "[BigNumber Error] ", i = n + "Number primitive has more than 15 significant digits: ", c = 1e14, s = 14, d = 9007199254740991, l = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], f = 1e7, h = 1e9;
      function p(E) {
        var R, L, A, w = ee.prototype = { constructor: ee, toString: null, valueOf: null }, S = new ee(1), O = 20, x = 4, F = -7, j = 21, q = -1e7, Q = 1e7, G = !1, K = 1, U = 0, ae = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "Â ",
          // non-breaking space
          suffix: ""
        }, ye = "0123456789abcdefghijklmnopqrstuvwxyz", pe = !0;
        function ee(V, N) {
          var M, I, P, B, z, H, J, k, W = this;
          if (!(W instanceof ee)) return new ee(V, N);
          if (N == null) {
            if (V && V._isBigNumber === !0) {
              W.s = V.s, !V.c || V.e > Q ? W.c = W.e = null : V.e < q ? W.c = [W.e = 0] : (W.e = V.e, W.c = V.c.slice());
              return;
            }
            if ((H = typeof V == "number") && V * 0 == 0) {
              if (W.s = 1 / V < 0 ? (V = -V, -1) : 1, V === ~~V) {
                for (B = 0, z = V; z >= 10; z /= 10, B++) ;
                B > Q ? W.c = W.e = null : (W.e = B, W.c = [V]);
                return;
              }
              k = String(V);
            } else {
              if (!a.test(k = String(V))) return A(W, k, H);
              W.s = k.charCodeAt(0) == 45 ? (k = k.slice(1), -1) : 1;
            }
            (B = k.indexOf(".")) > -1 && (k = k.replace(".", "")), (z = k.search(/e/i)) > 0 ? (B < 0 && (B = z), B += +k.slice(z + 1), k = k.substring(0, z)) : B < 0 && (B = k.length);
          } else {
            if (m(N, 2, ye.length, "Base"), N == 10 && pe)
              return W = new ee(V), be(W, O + W.e + 1, x);
            if (k = String(V), H = typeof V == "number") {
              if (V * 0 != 0) return A(W, k, H, N);
              if (W.s = 1 / V < 0 ? (k = k.slice(1), -1) : 1, ee.DEBUG && k.replace(/^0\.0*|\./, "").length > 15)
                throw Error(i + V);
            } else
              W.s = k.charCodeAt(0) === 45 ? (k = k.slice(1), -1) : 1;
            for (M = ye.slice(0, N), B = z = 0, J = k.length; z < J; z++)
              if (M.indexOf(I = k.charAt(z)) < 0) {
                if (I == ".") {
                  if (z > B) {
                    B = J;
                    continue;
                  }
                } else if (!P && (k == k.toUpperCase() && (k = k.toLowerCase()) || k == k.toLowerCase() && (k = k.toUpperCase()))) {
                  P = !0, z = -1, B = 0;
                  continue;
                }
                return A(W, String(V), H, N);
              }
            H = !1, k = L(k, N, 10, W.s), (B = k.indexOf(".")) > -1 ? k = k.replace(".", "") : B = k.length;
          }
          for (z = 0; k.charCodeAt(z) === 48; z++) ;
          for (J = k.length; k.charCodeAt(--J) === 48; ) ;
          if (k = k.slice(z, ++J)) {
            if (J -= z, H && ee.DEBUG && J > 15 && (V > d || V !== e(V)))
              throw Error(i + W.s * V);
            if ((B = B - z - 1) > Q)
              W.c = W.e = null;
            else if (B < q)
              W.c = [W.e = 0];
            else {
              if (W.e = B, W.c = [], z = (B + 1) % s, B < 0 && (z += s), z < J) {
                for (z && W.c.push(+k.slice(0, z)), J -= s; z < J; )
                  W.c.push(+k.slice(z, z += s));
                z = s - (k = k.slice(z)).length;
              } else
                z -= J;
              for (; z--; k += "0") ;
              W.c.push(+k);
            }
          } else
            W.c = [W.e = 0];
        }
        ee.clone = p, ee.ROUND_UP = 0, ee.ROUND_DOWN = 1, ee.ROUND_CEIL = 2, ee.ROUND_FLOOR = 3, ee.ROUND_HALF_UP = 4, ee.ROUND_HALF_DOWN = 5, ee.ROUND_HALF_EVEN = 6, ee.ROUND_HALF_CEIL = 7, ee.ROUND_HALF_FLOOR = 8, ee.EUCLID = 9, ee.config = ee.set = function(V) {
          var N, M;
          if (V != null)
            if (typeof V == "object") {
              if (V.hasOwnProperty(N = "DECIMAL_PLACES") && (M = V[N], m(M, 0, h, N), O = M), V.hasOwnProperty(N = "ROUNDING_MODE") && (M = V[N], m(M, 0, 8, N), x = M), V.hasOwnProperty(N = "EXPONENTIAL_AT") && (M = V[N], M && M.pop ? (m(M[0], -h, 0, N), m(M[1], 0, h, N), F = M[0], j = M[1]) : (m(M, -h, h, N), F = -(j = M < 0 ? -M : M))), V.hasOwnProperty(N = "RANGE"))
                if (M = V[N], M && M.pop)
                  m(M[0], -h, -1, N), m(M[1], 1, h, N), q = M[0], Q = M[1];
                else if (m(M, -h, h, N), M)
                  q = -(Q = M < 0 ? -M : M);
                else
                  throw Error(n + N + " cannot be zero: " + M);
              if (V.hasOwnProperty(N = "CRYPTO"))
                if (M = V[N], M === !!M)
                  if (M)
                    if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                      G = M;
                    else
                      throw G = !M, Error(n + "crypto unavailable");
                  else
                    G = M;
                else
                  throw Error(n + N + " not true or false: " + M);
              if (V.hasOwnProperty(N = "MODULO_MODE") && (M = V[N], m(M, 0, 9, N), K = M), V.hasOwnProperty(N = "POW_PRECISION") && (M = V[N], m(M, 0, h, N), U = M), V.hasOwnProperty(N = "FORMAT"))
                if (M = V[N], typeof M == "object") ae = M;
                else throw Error(n + N + " not an object: " + M);
              if (V.hasOwnProperty(N = "ALPHABET"))
                if (M = V[N], typeof M == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(M))
                  pe = M.slice(0, 10) == "0123456789", ye = M;
                else
                  throw Error(n + N + " invalid: " + M);
            } else
              throw Error(n + "Object expected: " + V);
          return {
            DECIMAL_PLACES: O,
            ROUNDING_MODE: x,
            EXPONENTIAL_AT: [F, j],
            RANGE: [q, Q],
            CRYPTO: G,
            MODULO_MODE: K,
            POW_PRECISION: U,
            FORMAT: ae,
            ALPHABET: ye
          };
        }, ee.isBigNumber = function(V) {
          if (!V || V._isBigNumber !== !0) return !1;
          if (!ee.DEBUG) return !0;
          var N, M, I = V.c, P = V.e, B = V.s;
          e: if ({}.toString.call(I) == "[object Array]") {
            if ((B === 1 || B === -1) && P >= -h && P <= h && P === e(P)) {
              if (I[0] === 0) {
                if (P === 0 && I.length === 1) return !0;
                break e;
              }
              if (N = (P + 1) % s, N < 1 && (N += s), String(I[0]).length == N) {
                for (N = 0; N < I.length; N++)
                  if (M = I[N], M < 0 || M >= c || M !== e(M)) break e;
                if (M !== 0) return !0;
              }
            }
          } else if (I === null && P === null && (B === null || B === 1 || B === -1))
            return !0;
          throw Error(n + "Invalid BigNumber: " + V);
        }, ee.maximum = ee.max = function() {
          return we(arguments, -1);
        }, ee.minimum = ee.min = function() {
          return we(arguments, 1);
        }, ee.random = function() {
          var V = 9007199254740992, N = Math.random() * V & 2097151 ? function() {
            return e(Math.random() * V);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(M) {
            var I, P, B, z, H, J = 0, k = [], W = new ee(S);
            if (M == null ? M = O : m(M, 0, h), z = t(M / s), G)
              if (crypto.getRandomValues) {
                for (I = crypto.getRandomValues(new Uint32Array(z *= 2)); J < z; )
                  H = I[J] * 131072 + (I[J + 1] >>> 11), H >= 9e15 ? (P = crypto.getRandomValues(new Uint32Array(2)), I[J] = P[0], I[J + 1] = P[1]) : (k.push(H % 1e14), J += 2);
                J = z / 2;
              } else if (crypto.randomBytes) {
                for (I = crypto.randomBytes(z *= 7); J < z; )
                  H = (I[J] & 31) * 281474976710656 + I[J + 1] * 1099511627776 + I[J + 2] * 4294967296 + I[J + 3] * 16777216 + (I[J + 4] << 16) + (I[J + 5] << 8) + I[J + 6], H >= 9e15 ? crypto.randomBytes(7).copy(I, J) : (k.push(H % 1e14), J += 7);
                J = z / 7;
              } else
                throw G = !1, Error(n + "crypto unavailable");
            if (!G)
              for (; J < z; )
                H = N(), H < 9e15 && (k[J++] = H % 1e14);
            for (z = k[--J], M %= s, z && M && (H = l[s - M], k[J] = e(z / H) * H); k[J] === 0; k.pop(), J--) ;
            if (J < 0)
              k = [B = 0];
            else {
              for (B = -1; k[0] === 0; k.splice(0, 1), B -= s) ;
              for (J = 1, H = k[0]; H >= 10; H /= 10, J++) ;
              J < s && (B -= s - J);
            }
            return W.e = B, W.c = k, W;
          };
        }(), ee.sum = function() {
          for (var V = 1, N = arguments, M = new ee(N[0]); V < N.length; ) M = M.plus(N[V++]);
          return M;
        }, L = /* @__PURE__ */ function() {
          var V = "0123456789";
          function N(M, I, P, B) {
            for (var z, H = [0], J, k = 0, W = M.length; k < W; ) {
              for (J = H.length; J--; H[J] *= I) ;
              for (H[0] += B.indexOf(M.charAt(k++)), z = 0; z < H.length; z++)
                H[z] > P - 1 && (H[z + 1] == null && (H[z + 1] = 0), H[z + 1] += H[z] / P | 0, H[z] %= P);
            }
            return H.reverse();
          }
          return function(M, I, P, B, z) {
            var H, J, k, W, le, fe, me, Ne, xe = M.indexOf("."), ue = O, $ = x;
            for (xe >= 0 && (W = U, U = 0, M = M.replace(".", ""), Ne = new ee(I), fe = Ne.pow(M.length - xe), U = W, Ne.c = N(
              v(_(fe.c), fe.e, "0"),
              10,
              P,
              V
            ), Ne.e = Ne.c.length), me = N(M, I, P, z ? (H = ye, V) : (H = V, ye)), k = W = me.length; me[--W] == 0; me.pop()) ;
            if (!me[0]) return H.charAt(0);
            if (xe < 0 ? --k : (fe.c = me, fe.e = k, fe.s = B, fe = R(fe, Ne, ue, $, P), me = fe.c, le = fe.r, k = fe.e), J = k + ue + 1, xe = me[J], W = P / 2, le = le || J < 0 || me[J + 1] != null, le = $ < 4 ? (xe != null || le) && ($ == 0 || $ == (fe.s < 0 ? 3 : 2)) : xe > W || xe == W && ($ == 4 || le || $ == 6 && me[J - 1] & 1 || $ == (fe.s < 0 ? 8 : 7)), J < 1 || !me[0])
              M = le ? v(H.charAt(1), -ue, H.charAt(0)) : H.charAt(0);
            else {
              if (me.length = J, le)
                for (--P; ++me[--J] > P; )
                  me[J] = 0, J || (++k, me = [1].concat(me));
              for (W = me.length; !me[--W]; ) ;
              for (xe = 0, M = ""; xe <= W; M += H.charAt(me[xe++])) ;
              M = v(M, k, H.charAt(0));
            }
            return M;
          };
        }(), R = /* @__PURE__ */ function() {
          function V(I, P, B) {
            var z, H, J, k, W = 0, le = I.length, fe = P % f, me = P / f | 0;
            for (I = I.slice(); le--; )
              J = I[le] % f, k = I[le] / f | 0, z = me * J + k * fe, H = fe * J + z % f * f + W, W = (H / B | 0) + (z / f | 0) + me * k, I[le] = H % B;
            return W && (I = [W].concat(I)), I;
          }
          function N(I, P, B, z) {
            var H, J;
            if (B != z)
              J = B > z ? 1 : -1;
            else
              for (H = J = 0; H < B; H++)
                if (I[H] != P[H]) {
                  J = I[H] > P[H] ? 1 : -1;
                  break;
                }
            return J;
          }
          function M(I, P, B, z) {
            for (var H = 0; B--; )
              I[B] -= H, H = I[B] < P[B] ? 1 : 0, I[B] = H * z + I[B] - P[B];
            for (; !I[0] && I.length > 1; I.splice(0, 1)) ;
          }
          return function(I, P, B, z, H) {
            var J, k, W, le, fe, me, Ne, xe, ue, $, D, C, X, te, de, oe, De, Ve = I.s == P.s ? 1 : -1, qe = I.c, Ke = P.c;
            if (!qe || !qe[0] || !Ke || !Ke[0])
              return new ee(
                // Return NaN if either NaN, or both Infinity or 0.
                !I.s || !P.s || (qe ? Ke && qe[0] == Ke[0] : !Ke) ? NaN : (
                  // Return Â±0 if x is Â±0 or y is Â±Infinity, or return Â±Infinity as y is Â±0.
                  qe && qe[0] == 0 || !Ke ? Ve * 0 : Ve / 0
                )
              );
            for (xe = new ee(Ve), ue = xe.c = [], k = I.e - P.e, Ve = B + k + 1, H || (H = c, k = b(I.e / s) - b(P.e / s), Ve = Ve / s | 0), W = 0; Ke[W] == (qe[W] || 0); W++) ;
            if (Ke[W] > (qe[W] || 0) && k--, Ve < 0)
              ue.push(1), le = !0;
            else {
              for (te = qe.length, oe = Ke.length, W = 0, Ve += 2, fe = e(H / (Ke[0] + 1)), fe > 1 && (Ke = V(Ke, fe, H), qe = V(qe, fe, H), oe = Ke.length, te = qe.length), X = oe, $ = qe.slice(0, oe), D = $.length; D < oe; $[D++] = 0) ;
              De = Ke.slice(), De = [0].concat(De), de = Ke[0], Ke[1] >= H / 2 && de++;
              do {
                if (fe = 0, J = N(Ke, $, oe, D), J < 0) {
                  if (C = $[0], oe != D && (C = C * H + ($[1] || 0)), fe = e(C / de), fe > 1)
                    for (fe >= H && (fe = H - 1), me = V(Ke, fe, H), Ne = me.length, D = $.length; N(me, $, Ne, D) == 1; )
                      fe--, M(me, oe < Ne ? De : Ke, Ne, H), Ne = me.length, J = 1;
                  else
                    fe == 0 && (J = fe = 1), me = Ke.slice(), Ne = me.length;
                  if (Ne < D && (me = [0].concat(me)), M($, me, D, H), D = $.length, J == -1)
                    for (; N(Ke, $, oe, D) < 1; )
                      fe++, M($, oe < D ? De : Ke, D, H), D = $.length;
                } else J === 0 && (fe++, $ = [0]);
                ue[W++] = fe, $[0] ? $[D++] = qe[X] || 0 : ($ = [qe[X]], D = 1);
              } while ((X++ < te || $[0] != null) && Ve--);
              le = $[0] != null, ue[0] || ue.splice(0, 1);
            }
            if (H == c) {
              for (W = 1, Ve = ue[0]; Ve >= 10; Ve /= 10, W++) ;
              be(xe, B + (xe.e = W + k * s - 1) + 1, z, le);
            } else
              xe.e = k, xe.r = +le;
            return xe;
          };
        }();
        function Te(V, N, M, I) {
          var P, B, z, H, J;
          if (M == null ? M = x : m(M, 0, 8), !V.c) return V.toString();
          if (P = V.c[0], z = V.e, N == null)
            J = _(V.c), J = I == 1 || I == 2 && (z <= F || z >= j) ? T(J, z) : v(J, z, "0");
          else if (V = be(new ee(V), N, M), B = V.e, J = _(V.c), H = J.length, I == 1 || I == 2 && (N <= B || B <= F)) {
            for (; H < N; J += "0", H++) ;
            J = T(J, B);
          } else if (N -= z, J = v(J, B, "0"), B + 1 > H) {
            if (--N > 0) for (J += "."; N--; J += "0") ;
          } else if (N += B - H, N > 0)
            for (B + 1 == H && (J += "."); N--; J += "0") ;
          return V.s < 0 && P ? "-" + J : J;
        }
        function we(V, N) {
          for (var M, I, P = 1, B = new ee(V[0]); P < V.length; P++)
            I = new ee(V[P]), (!I.s || (M = y(B, I)) === N || M === 0 && B.s === N) && (B = I);
          return B;
        }
        function Oe(V, N, M) {
          for (var I = 1, P = N.length; !N[--P]; N.pop()) ;
          for (P = N[0]; P >= 10; P /= 10, I++) ;
          return (M = I + M * s - 1) > Q ? V.c = V.e = null : M < q ? V.c = [V.e = 0] : (V.e = M, V.c = N), V;
        }
        A = /* @__PURE__ */ function() {
          var V = /^(-?)0([xbo])(?=\w[\w.]*$)/i, N = /^([^.]+)\.$/, M = /^\.([^.]+)$/, I = /^-?(Infinity|NaN)$/, P = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(B, z, H, J) {
            var k, W = H ? z : z.replace(P, "");
            if (I.test(W))
              B.s = isNaN(W) ? null : W < 0 ? -1 : 1;
            else {
              if (!H && (W = W.replace(V, function(le, fe, me) {
                return k = (me = me.toLowerCase()) == "x" ? 16 : me == "b" ? 2 : 8, !J || J == k ? fe : le;
              }), J && (k = J, W = W.replace(N, "$1").replace(M, "0.$1")), z != W))
                return new ee(W, k);
              if (ee.DEBUG)
                throw Error(n + "Not a" + (J ? " base " + J : "") + " number: " + z);
              B.s = null;
            }
            B.c = B.e = null;
          };
        }();
        function be(V, N, M, I) {
          var P, B, z, H, J, k, W, le = V.c, fe = l;
          if (le) {
            e: {
              for (P = 1, H = le[0]; H >= 10; H /= 10, P++) ;
              if (B = N - P, B < 0)
                B += s, z = N, J = le[k = 0], W = e(J / fe[P - z - 1] % 10);
              else if (k = t((B + 1) / s), k >= le.length)
                if (I) {
                  for (; le.length <= k; le.push(0)) ;
                  J = W = 0, P = 1, B %= s, z = B - s + 1;
                } else
                  break e;
              else {
                for (J = H = le[k], P = 1; H >= 10; H /= 10, P++) ;
                B %= s, z = B - s + P, W = z < 0 ? 0 : e(J / fe[P - z - 1] % 10);
              }
              if (I = I || N < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              le[k + 1] != null || (z < 0 ? J : J % fe[P - z - 1]), I = M < 4 ? (W || I) && (M == 0 || M == (V.s < 0 ? 3 : 2)) : W > 5 || W == 5 && (M == 4 || I || M == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (B > 0 ? z > 0 ? J / fe[P - z] : 0 : le[k - 1]) % 10 & 1 || M == (V.s < 0 ? 8 : 7)), N < 1 || !le[0])
                return le.length = 0, I ? (N -= V.e + 1, le[0] = fe[(s - N % s) % s], V.e = -N || 0) : le[0] = V.e = 0, V;
              if (B == 0 ? (le.length = k, H = 1, k--) : (le.length = k + 1, H = fe[s - B], le[k] = z > 0 ? e(J / fe[P - z] % fe[z]) * H : 0), I)
                for (; ; )
                  if (k == 0) {
                    for (B = 1, z = le[0]; z >= 10; z /= 10, B++) ;
                    for (z = le[0] += H, H = 1; z >= 10; z /= 10, H++) ;
                    B != H && (V.e++, le[0] == c && (le[0] = 1));
                    break;
                  } else {
                    if (le[k] += H, le[k] != c) break;
                    le[k--] = 0, H = 1;
                  }
              for (B = le.length; le[--B] === 0; le.pop()) ;
            }
            V.e > Q ? V.c = V.e = null : V.e < q && (V.c = [V.e = 0]);
          }
          return V;
        }
        function he(V) {
          var N, M = V.e;
          return M === null ? V.toString() : (N = _(V.c), N = M <= F || M >= j ? T(N, M) : v(N, M, "0"), V.s < 0 ? "-" + N : N);
        }
        return w.absoluteValue = w.abs = function() {
          var V = new ee(this);
          return V.s < 0 && (V.s = 1), V;
        }, w.comparedTo = function(V, N) {
          return y(this, new ee(V, N));
        }, w.decimalPlaces = w.dp = function(V, N) {
          var M, I, P, B = this;
          if (V != null)
            return m(V, 0, h), N == null ? N = x : m(N, 0, 8), be(new ee(B), V + B.e + 1, N);
          if (!(M = B.c)) return null;
          if (I = ((P = M.length - 1) - b(this.e / s)) * s, P = M[P]) for (; P % 10 == 0; P /= 10, I--) ;
          return I < 0 && (I = 0), I;
        }, w.dividedBy = w.div = function(V, N) {
          return R(this, new ee(V, N), O, x);
        }, w.dividedToIntegerBy = w.idiv = function(V, N) {
          return R(this, new ee(V, N), 0, 1);
        }, w.exponentiatedBy = w.pow = function(V, N) {
          var M, I, P, B, z, H, J, k, W, le = this;
          if (V = new ee(V), V.c && !V.isInteger())
            throw Error(n + "Exponent not an integer: " + he(V));
          if (N != null && (N = new ee(N)), H = V.e > 14, !le.c || !le.c[0] || le.c[0] == 1 && !le.e && le.c.length == 1 || !V.c || !V.c[0])
            return W = new ee(Math.pow(+he(le), H ? V.s * (2 - g(V)) : +he(V))), N ? W.mod(N) : W;
          if (J = V.s < 0, N) {
            if (N.c ? !N.c[0] : !N.s) return new ee(NaN);
            I = !J && le.isInteger() && N.isInteger(), I && (le = le.mod(N));
          } else {
            if (V.e > 9 && (le.e > 0 || le.e < -1 || (le.e == 0 ? le.c[0] > 1 || H && le.c[1] >= 24e7 : le.c[0] < 8e13 || H && le.c[0] <= 9999975e7)))
              return B = le.s < 0 && g(V) ? -0 : 0, le.e > -1 && (B = 1 / B), new ee(J ? 1 / B : B);
            U && (B = t(U / s + 2));
          }
          for (H ? (M = new ee(0.5), J && (V.s = 1), k = g(V)) : (P = Math.abs(+he(V)), k = P % 2), W = new ee(S); ; ) {
            if (k) {
              if (W = W.times(le), !W.c) break;
              B ? W.c.length > B && (W.c.length = B) : I && (W = W.mod(N));
            }
            if (P) {
              if (P = e(P / 2), P === 0) break;
              k = P % 2;
            } else if (V = V.times(M), be(V, V.e + 1, 1), V.e > 14)
              k = g(V);
            else {
              if (P = +he(V), P === 0) break;
              k = P % 2;
            }
            le = le.times(le), B ? le.c && le.c.length > B && (le.c.length = B) : I && (le = le.mod(N));
          }
          return I ? W : (J && (W = S.div(W)), N ? W.mod(N) : B ? be(W, U, x, z) : W);
        }, w.integerValue = function(V) {
          var N = new ee(this);
          return V == null ? V = x : m(V, 0, 8), be(N, N.e + 1, V);
        }, w.isEqualTo = w.eq = function(V, N) {
          return y(this, new ee(V, N)) === 0;
        }, w.isFinite = function() {
          return !!this.c;
        }, w.isGreaterThan = w.gt = function(V, N) {
          return y(this, new ee(V, N)) > 0;
        }, w.isGreaterThanOrEqualTo = w.gte = function(V, N) {
          return (N = y(this, new ee(V, N))) === 1 || N === 0;
        }, w.isInteger = function() {
          return !!this.c && b(this.e / s) > this.c.length - 2;
        }, w.isLessThan = w.lt = function(V, N) {
          return y(this, new ee(V, N)) < 0;
        }, w.isLessThanOrEqualTo = w.lte = function(V, N) {
          return (N = y(this, new ee(V, N))) === -1 || N === 0;
        }, w.isNaN = function() {
          return !this.s;
        }, w.isNegative = function() {
          return this.s < 0;
        }, w.isPositive = function() {
          return this.s > 0;
        }, w.isZero = function() {
          return !!this.c && this.c[0] == 0;
        }, w.minus = function(V, N) {
          var M, I, P, B, z = this, H = z.s;
          if (V = new ee(V, N), N = V.s, !H || !N) return new ee(NaN);
          if (H != N)
            return V.s = -N, z.plus(V);
          var J = z.e / s, k = V.e / s, W = z.c, le = V.c;
          if (!J || !k) {
            if (!W || !le) return W ? (V.s = -N, V) : new ee(le ? z : NaN);
            if (!W[0] || !le[0])
              return le[0] ? (V.s = -N, V) : new ee(W[0] ? z : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                x == 3 ? -0 : 0
              ));
          }
          if (J = b(J), k = b(k), W = W.slice(), H = J - k) {
            for ((B = H < 0) ? (H = -H, P = W) : (k = J, P = le), P.reverse(), N = H; N--; P.push(0)) ;
            P.reverse();
          } else
            for (I = (B = (H = W.length) < (N = le.length)) ? H : N, H = N = 0; N < I; N++)
              if (W[N] != le[N]) {
                B = W[N] < le[N];
                break;
              }
          if (B && (P = W, W = le, le = P, V.s = -V.s), N = (I = le.length) - (M = W.length), N > 0) for (; N--; W[M++] = 0) ;
          for (N = c - 1; I > H; ) {
            if (W[--I] < le[I]) {
              for (M = I; M && !W[--M]; W[M] = N) ;
              --W[M], W[I] += c;
            }
            W[I] -= le[I];
          }
          for (; W[0] == 0; W.splice(0, 1), --k) ;
          return W[0] ? Oe(V, W, k) : (V.s = x == 3 ? -1 : 1, V.c = [V.e = 0], V);
        }, w.modulo = w.mod = function(V, N) {
          var M, I, P = this;
          return V = new ee(V, N), !P.c || !V.s || V.c && !V.c[0] ? new ee(NaN) : !V.c || P.c && !P.c[0] ? new ee(P) : (K == 9 ? (I = V.s, V.s = 1, M = R(P, V, 0, 3), V.s = I, M.s *= I) : M = R(P, V, 0, K), V = P.minus(M.times(V)), !V.c[0] && K == 1 && (V.s = P.s), V);
        }, w.multipliedBy = w.times = function(V, N) {
          var M, I, P, B, z, H, J, k, W, le, fe, me, Ne, xe, ue, $ = this, D = $.c, C = (V = new ee(V, N)).c;
          if (!D || !C || !D[0] || !C[0])
            return !$.s || !V.s || D && !D[0] && !C || C && !C[0] && !D ? V.c = V.e = V.s = null : (V.s *= $.s, !D || !C ? V.c = V.e = null : (V.c = [0], V.e = 0)), V;
          for (I = b($.e / s) + b(V.e / s), V.s *= $.s, J = D.length, le = C.length, J < le && (Ne = D, D = C, C = Ne, P = J, J = le, le = P), P = J + le, Ne = []; P--; Ne.push(0)) ;
          for (xe = c, ue = f, P = le; --P >= 0; ) {
            for (M = 0, fe = C[P] % ue, me = C[P] / ue | 0, z = J, B = P + z; B > P; )
              k = D[--z] % ue, W = D[z] / ue | 0, H = me * k + W * fe, k = fe * k + H % ue * ue + Ne[B] + M, M = (k / xe | 0) + (H / ue | 0) + me * W, Ne[B--] = k % xe;
            Ne[B] = M;
          }
          return M ? ++I : Ne.splice(0, 1), Oe(V, Ne, I);
        }, w.negated = function() {
          var V = new ee(this);
          return V.s = -V.s || null, V;
        }, w.plus = function(V, N) {
          var M, I = this, P = I.s;
          if (V = new ee(V, N), N = V.s, !P || !N) return new ee(NaN);
          if (P != N)
            return V.s = -N, I.minus(V);
          var B = I.e / s, z = V.e / s, H = I.c, J = V.c;
          if (!B || !z) {
            if (!H || !J) return new ee(P / 0);
            if (!H[0] || !J[0]) return J[0] ? V : new ee(H[0] ? I : P * 0);
          }
          if (B = b(B), z = b(z), H = H.slice(), P = B - z) {
            for (P > 0 ? (z = B, M = J) : (P = -P, M = H), M.reverse(); P--; M.push(0)) ;
            M.reverse();
          }
          for (P = H.length, N = J.length, P - N < 0 && (M = J, J = H, H = M, N = P), P = 0; N; )
            P = (H[--N] = H[N] + J[N] + P) / c | 0, H[N] = c === H[N] ? 0 : H[N] % c;
          return P && (H = [P].concat(H), ++z), Oe(V, H, z);
        }, w.precision = w.sd = function(V, N) {
          var M, I, P, B = this;
          if (V != null && V !== !!V)
            return m(V, 1, h), N == null ? N = x : m(N, 0, 8), be(new ee(B), V, N);
          if (!(M = B.c)) return null;
          if (P = M.length - 1, I = P * s + 1, P = M[P]) {
            for (; P % 10 == 0; P /= 10, I--) ;
            for (P = M[0]; P >= 10; P /= 10, I++) ;
          }
          return V && B.e + 1 > I && (I = B.e + 1), I;
        }, w.shiftedBy = function(V) {
          return m(V, -d, d), this.times("1e" + V);
        }, w.squareRoot = w.sqrt = function() {
          var V, N, M, I, P, B = this, z = B.c, H = B.s, J = B.e, k = O + 4, W = new ee("0.5");
          if (H !== 1 || !z || !z[0])
            return new ee(!H || H < 0 && (!z || z[0]) ? NaN : z ? B : 1 / 0);
          if (H = Math.sqrt(+he(B)), H == 0 || H == 1 / 0 ? (N = _(z), (N.length + J) % 2 == 0 && (N += "0"), H = Math.sqrt(+N), J = b((J + 1) / 2) - (J < 0 || J % 2), H == 1 / 0 ? N = "5e" + J : (N = H.toExponential(), N = N.slice(0, N.indexOf("e") + 1) + J), M = new ee(N)) : M = new ee(H + ""), M.c[0]) {
            for (J = M.e, H = J + k, H < 3 && (H = 0); ; )
              if (P = M, M = W.times(P.plus(R(B, P, k, 1))), _(P.c).slice(0, H) === (N = _(M.c)).slice(0, H))
                if (M.e < J && --H, N = N.slice(H - 3, H + 1), N == "9999" || !I && N == "4999") {
                  if (!I && (be(P, P.e + O + 2, 0), P.times(P).eq(B))) {
                    M = P;
                    break;
                  }
                  k += 4, H += 4, I = 1;
                } else {
                  (!+N || !+N.slice(1) && N.charAt(0) == "5") && (be(M, M.e + O + 2, 1), V = !M.times(M).eq(B));
                  break;
                }
          }
          return be(M, M.e + O + 1, x, V);
        }, w.toExponential = function(V, N) {
          return V != null && (m(V, 0, h), V++), Te(this, V, N, 1);
        }, w.toFixed = function(V, N) {
          return V != null && (m(V, 0, h), V = V + this.e + 1), Te(this, V, N);
        }, w.toFormat = function(V, N, M) {
          var I, P = this;
          if (M == null)
            V != null && N && typeof N == "object" ? (M = N, N = null) : V && typeof V == "object" ? (M = V, V = N = null) : M = ae;
          else if (typeof M != "object")
            throw Error(n + "Argument not an object: " + M);
          if (I = P.toFixed(V, N), P.c) {
            var B, z = I.split("."), H = +M.groupSize, J = +M.secondaryGroupSize, k = M.groupSeparator || "", W = z[0], le = z[1], fe = P.s < 0, me = fe ? W.slice(1) : W, Ne = me.length;
            if (J && (B = H, H = J, J = B, Ne -= B), H > 0 && Ne > 0) {
              for (B = Ne % H || H, W = me.substr(0, B); B < Ne; B += H) W += k + me.substr(B, H);
              J > 0 && (W += k + me.slice(B)), fe && (W = "-" + W);
            }
            I = le ? W + (M.decimalSeparator || "") + ((J = +M.fractionGroupSize) ? le.replace(
              new RegExp("\\d{" + J + "}\\B", "g"),
              "$&" + (M.fractionGroupSeparator || "")
            ) : le) : W;
          }
          return (M.prefix || "") + I + (M.suffix || "");
        }, w.toFraction = function(V) {
          var N, M, I, P, B, z, H, J, k, W, le, fe, me = this, Ne = me.c;
          if (V != null && (H = new ee(V), !H.isInteger() && (H.c || H.s !== 1) || H.lt(S)))
            throw Error(n + "Argument " + (H.isInteger() ? "out of range: " : "not an integer: ") + he(H));
          if (!Ne) return new ee(me);
          for (N = new ee(S), k = M = new ee(S), I = J = new ee(S), fe = _(Ne), B = N.e = fe.length - me.e - 1, N.c[0] = l[(z = B % s) < 0 ? s + z : z], V = !V || H.comparedTo(N) > 0 ? B > 0 ? N : k : H, z = Q, Q = 1 / 0, H = new ee(fe), J.c[0] = 0; W = R(H, N, 0, 1), P = M.plus(W.times(I)), P.comparedTo(V) != 1; )
            M = I, I = P, k = J.plus(W.times(P = k)), J = P, N = H.minus(W.times(P = N)), H = P;
          return P = R(V.minus(M), I, 0, 1), J = J.plus(P.times(k)), M = M.plus(P.times(I)), J.s = k.s = me.s, B = B * 2, le = R(k, I, B, x).minus(me).abs().comparedTo(
            R(J, M, B, x).minus(me).abs()
          ) < 1 ? [k, I] : [J, M], Q = z, le;
        }, w.toNumber = function() {
          return +he(this);
        }, w.toPrecision = function(V, N) {
          return V != null && m(V, 1, h), Te(this, V, N, 2);
        }, w.toString = function(V) {
          var N, M = this, I = M.s, P = M.e;
          return P === null ? I ? (N = "Infinity", I < 0 && (N = "-" + N)) : N = "NaN" : (V == null ? N = P <= F || P >= j ? T(_(M.c), P) : v(_(M.c), P, "0") : V === 10 && pe ? (M = be(new ee(M), O + P + 1, x), N = v(_(M.c), M.e, "0")) : (m(V, 2, ye.length, "Base"), N = L(v(_(M.c), P, "0"), 10, V, I, !0)), I < 0 && M.c[0] && (N = "-" + N)), N;
        }, w.valueOf = w.toJSON = function() {
          return he(this);
        }, w._isBigNumber = !0, E != null && ee.set(E), ee;
      }
      function b(E) {
        var R = E | 0;
        return E > 0 || E === R ? R : R - 1;
      }
      function _(E) {
        for (var R, L, A = 1, w = E.length, S = E[0] + ""; A < w; ) {
          for (R = E[A++] + "", L = s - R.length; L--; R = "0" + R) ;
          S += R;
        }
        for (w = S.length; S.charCodeAt(--w) === 48; ) ;
        return S.slice(0, w + 1 || 1);
      }
      function y(E, R) {
        var L, A, w = E.c, S = R.c, O = E.s, x = R.s, F = E.e, j = R.e;
        if (!O || !x) return null;
        if (L = w && !w[0], A = S && !S[0], L || A) return L ? A ? 0 : -x : O;
        if (O != x) return O;
        if (L = O < 0, A = F == j, !w || !S) return A ? 0 : !w ^ L ? 1 : -1;
        if (!A) return F > j ^ L ? 1 : -1;
        for (x = (F = w.length) < (j = S.length) ? F : j, O = 0; O < x; O++) if (w[O] != S[O]) return w[O] > S[O] ^ L ? 1 : -1;
        return F == j ? 0 : F > j ^ L ? 1 : -1;
      }
      function m(E, R, L, A) {
        if (E < R || E > L || E !== e(E))
          throw Error(n + (A || "Argument") + (typeof E == "number" ? E < R || E > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(E));
      }
      function g(E) {
        var R = E.c.length - 1;
        return b(E.e / s) == R && E.c[R] % 2 != 0;
      }
      function T(E, R) {
        return (E.length > 1 ? E.charAt(0) + "." + E.slice(1) : E) + (R < 0 ? "e" : "e+") + R;
      }
      function v(E, R, L) {
        var A, w;
        if (R < 0) {
          for (w = L + "."; ++R; w += L) ;
          E = w + E;
        } else if (A = E.length, ++R > A) {
          for (w = L, R -= A; --R; w += L) ;
          E += w;
        } else R < A && (E = E.slice(0, R) + "." + E.slice(R));
        return E;
      }
      o = p(), o.default = o.BigNumber = o, u.exports ? u.exports = o : (r || (r = typeof self < "u" && self ? self : window), r.BigNumber = o);
    })(Mde);
  }(cS)), cS.exports;
}
var NM;
function Cde() {
  if (NM) return vy;
  NM = 1, Object.defineProperty(vy, "__esModule", { value: !0 }), vy.TermFunctionAddition = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = u4();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.ADDITION,
        overloads: (0, r.declare)(r.SparqlOperator.ADDITION).arithmetic(() => (e, n) => new o.BigNumber(e).plus(n).toNumber()).set([r.TypeURL.XSD_DATE_TIME, r.TypeURL.XSD_DAY_TIME_DURATION], () => ([e, n]) => (
          // https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-dateTime
          new r.DateTimeLiteral((0, r.addDurationToDateTime)(e.typedValue, (0, r.defaultedDurationRepresentation)(n.typedValue)))
        )).copy({
          from: [r.TypeURL.XSD_DATE_TIME, r.TypeURL.XSD_DAY_TIME_DURATION],
          to: [r.TypeURL.XSD_DATE_TIME, r.TypeURL.XSD_YEAR_MONTH_DURATION]
        }).set([r.TypeURL.XSD_DATE, r.TypeURL.XSD_DAY_TIME_DURATION], () => ([e, n]) => (
          // https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-date
          new r.DateLiteral((0, r.addDurationToDateTime)((0, r.defaultedDateTimeRepresentation)(e.typedValue), (0, r.defaultedDurationRepresentation)(n.typedValue)))
        )).copy({
          from: [r.TypeURL.XSD_DATE, r.TypeURL.XSD_DAY_TIME_DURATION],
          to: [r.TypeURL.XSD_DATE, r.TypeURL.XSD_YEAR_MONTH_DURATION]
        }).set([r.TypeURL.XSD_TIME, r.TypeURL.XSD_DAY_TIME_DURATION], () => ([e, n]) => (
          // https://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-time
          new r.TimeLiteral((0, r.addDurationToDateTime)((0, r.defaultedDateTimeRepresentation)(e.typedValue), (0, r.defaultedDurationRepresentation)(n.typedValue)))
        )).copy({
          from: [r.TypeURL.XSD_TIME, r.TypeURL.XSD_DAY_TIME_DURATION],
          to: [r.TypeURL.XSD_TIME, r.TypeURL.XSD_YEAR_MONTH_DURATION]
        }).collect()
      });
    }
  };
  return vy.TermFunctionAddition = a, vy;
}
var PM;
function qde() {
  if (PM) return my;
  PM = 1, Object.defineProperty(my, "__esModule", { value: !0 }), my.ActorFunctionFactoryTermAddition = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Cde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.ADDITION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionAddition();
    }
  };
  return my.ActorFunctionFactoryTermAddition = a, my;
}
var DM;
function Bde() {
  return DM || (DM = 1, function(u) {
    var r = Gs && Gs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Gs && Gs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qde(), u);
  }(Gs)), Gs;
}
var zs = {}, Ty = {}, wy = {}, LM;
function $de() {
  if (LM) return wy;
  LM = 1, Object.defineProperty(wy, "__esModule", { value: !0 }), wy.TermFunctionCeil = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.CEIL,
        overloads: (0, r.declare)(r.SparqlOperator.CEIL).numericConverter(() => (t) => Math.ceil(t)).collect()
      });
    }
  };
  return wy.TermFunctionCeil = o, wy;
}
var jM;
function Ude() {
  if (jM) return Ty;
  jM = 1, Object.defineProperty(Ty, "__esModule", { value: !0 }), Ty.ActorFunctionFactoryTermCeil = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ $de();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.CEIL],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionCeil();
    }
  };
  return Ty.ActorFunctionFactoryTermCeil = a, Ty;
}
var MM;
function Vde() {
  return MM || (MM = 1, function(u) {
    var r = zs && zs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zs && zs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ude(), u);
  }(zs)), zs;
}
var ks = {}, Sy = {}, Ay = {}, CM;
function Qde() {
  if (CM) return Ay;
  CM = 1, Object.defineProperty(Ay, "__esModule", { value: !0 }), Ay.TermFunctionContains = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.CONTAINS,
        overloads: (0, r.declare)(r.SparqlOperator.CONTAINS).onBinaryTyped([r.TypeAlias.SPARQL_STRINGLY, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.bool)(t.includes(e))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.RDF_LANG_STRING], () => (t, e) => {
          if (t.language !== e.language)
            throw new r.IncompatibleLanguageOperation(t, e);
          return (0, r.bool)(t.typedValue.includes(e.typedValue));
        }).collect()
      });
    }
  };
  return Ay.TermFunctionContains = o, Ay;
}
var qM;
function Hde() {
  if (qM) return Sy;
  qM = 1, Object.defineProperty(Sy, "__esModule", { value: !0 }), Sy.ActorFunctionFactoryTermContains = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Qde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.CONTAINS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionContains();
    }
  };
  return Sy.ActorFunctionFactoryTermContains = a, Sy;
}
var BM;
function Gde() {
  return BM || (BM = 1, function(u) {
    var r = ks && ks.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ks && ks.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Hde(), u);
  }(ks)), ks;
}
var Xs = {}, Ey = {}, Oy = {}, $M;
function zde() {
  if ($M) return Oy;
  $M = 1, Object.defineProperty(Oy, "__esModule", { value: !0 }), Oy.TermFunctionDatatype = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.DATATYPE,
        overloads: (0, r.declare)(r.SparqlOperator.DATATYPE).onLiteral1(() => (t) => new r.NamedNode(t.dataType)).collect()
      });
    }
  };
  return Oy.TermFunctionDatatype = o, Oy;
}
var UM;
function kde() {
  if (UM) return Ey;
  UM = 1, Object.defineProperty(Ey, "__esModule", { value: !0 }), Ey.ActorFunctionFactoryTermDatatype = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ zde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.DATATYPE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionDatatype();
    }
  };
  return Ey.ActorFunctionFactoryTermDatatype = a, Ey;
}
var VM;
function Xde() {
  return VM || (VM = 1, function(u) {
    var r = Xs && Xs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xs && Xs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ kde(), u);
  }(Xs)), Xs;
}
var Js = {}, xy = {}, Iy = {}, QM;
function Jde() {
  if (QM) return Iy;
  QM = 1, Object.defineProperty(Iy, "__esModule", { value: !0 }), Iy.TermFunctionDay = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.DAY,
        overloads: (0, r.declare)(r.SparqlOperator.DAY).onDateTime1(() => (t) => (0, r.integer)(t.typedValue.day)).set([r.TypeURL.XSD_DATE], () => ([t]) => (0, r.integer)(t.typedValue.day)).collect()
      });
    }
  };
  return Iy.TermFunctionDay = o, Iy;
}
var HM;
function Kde() {
  if (HM) return xy;
  HM = 1, Object.defineProperty(xy, "__esModule", { value: !0 }), xy.ActorFunctionFactoryTermDay = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Jde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.DAY],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionDay();
    }
  };
  return xy.ActorFunctionFactoryTermDay = a, xy;
}
var GM;
function Wde() {
  return GM || (GM = 1, function(u) {
    var r = Js && Js.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Js && Js.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Kde(), u);
  }(Js)), Js;
}
var Ks = {}, Ry = {}, Fy = {}, zM;
function Yde() {
  if (zM) return Fy;
  zM = 1, Object.defineProperty(Fy, "__esModule", { value: !0 }), Fy.TermFunctionDivision = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = u4();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.DIVISION,
        overloads: (0, r.declare)(r.SparqlOperator.DIVISION).arithmetic(() => (e, n) => new o.BigNumber(e).div(n).toNumber()).onBinaryTyped([r.TypeURL.XSD_INTEGER, r.TypeURL.XSD_INTEGER], () => (e, n) => {
          if (n === 0)
            throw new r.ExpressionError("Integer division by 0");
          return (0, r.decimal)(new o.BigNumber(e).div(n).toNumber());
        }).collect()
      });
    }
  };
  return Fy.TermFunctionDivision = a, Fy;
}
var kM;
function Zde() {
  if (kM) return Ry;
  kM = 1, Object.defineProperty(Ry, "__esModule", { value: !0 }), Ry.ActorFunctionFactoryTermDivision = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Yde();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.DIVISION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionDivision();
    }
  };
  return Ry.ActorFunctionFactoryTermDivision = a, Ry;
}
var XM;
function ele() {
  return XM || (XM = 1, function(u) {
    var r = Ks && Ks.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ks && Ks.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Zde(), u);
  }(Ks)), Ks;
}
var Ws = {}, Ny = {}, Py = {}, JM;
function tle() {
  if (JM) return Py;
  JM = 1, Object.defineProperty(Py, "__esModule", { value: !0 }), Py.TermFunctionEncodeForUri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.ENCODE_FOR_URI,
        overloads: (0, r.declare)(r.SparqlOperator.ENCODE_FOR_URI).onStringly1Typed(() => (t) => (0, r.string)(encodeURI(t))).collect()
      });
    }
  };
  return Py.TermFunctionEncodeForUri = o, Py;
}
var KM;
function rle() {
  if (KM) return Ny;
  KM = 1, Object.defineProperty(Ny, "__esModule", { value: !0 }), Ny.ActorFunctionFactoryTermEncodeForUri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ tle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.ENCODE_FOR_URI],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionEncodeForUri();
    }
  };
  return Ny.ActorFunctionFactoryTermEncodeForUri = a, Ny;
}
var WM;
function nle() {
  return WM || (WM = 1, function(u) {
    var r = Ws && Ws.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ws && Ws.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rle(), u);
  }(Ws)), Ws;
}
var Ys = {}, Dy = {}, Ly = {}, YM;
function ile() {
  if (YM) return Ly;
  YM = 1, Object.defineProperty(Ly, "__esModule", { value: !0 }), Ly.TermFunctionEquality = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: o.SparqlOperator.EQUAL,
        overloads: (0, o.declare)(o.SparqlOperator.EQUAL).numberTest(() => (e, n) => e === n).stringTest(() => (e, n) => e.localeCompare(n) === 0).set([o.TypeURL.RDF_LANG_STRING, o.TypeURL.RDF_LANG_STRING], () => ([e, n]) => (0, o.bool)(e.str() === n.str() && e.language === n.language)).set([o.TypeAlias.SPARQL_STRINGLY, o.TypeAlias.SPARQL_STRINGLY], () => () => (0, o.bool)(!1)).booleanTest(() => (e, n) => e === n).dateTimeTest((e) => (n, i) => (0, o.toUTCDate)(n, e.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime() === (0, o.toUTCDate)(i, e.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime()).copy({
          // https://www.w3.org/TR/xpath-functions/#func-date-equal
          from: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DATE_TIME],
          to: [o.TypeURL.XSD_DATE, o.TypeURL.XSD_DATE]
        }).set(["quad", "quad"], (e) => ([n, i]) => (0, o.bool)(this.applyOnTerms([n.subject, i.subject], e).coerceEBV() && this.applyOnTerms([n.predicate, i.predicate], e).coerceEBV() && this.applyOnTerms([n.object, i.object], e).coerceEBV() && this.applyOnTerms([n.graph, i.graph], e).coerceEBV()), !1).set(["term", "term"], (e) => ([n, i]) => {
          const c = n.toRDF(e.context.getSafe(r.KeysInitQuery.dataFactory)), s = i.toRDF(e.context.getSafe(r.KeysInitQuery.dataFactory)), d = c.equals(s);
          if (!d && c.termType === "Literal" && s.termType === "Literal")
            throw new o.RDFEqualTypeError([n, i]);
          return (0, o.bool)(d);
        }, !1).set([o.TypeURL.XSD_DURATION, o.TypeURL.XSD_DURATION], () => ([e, n]) => (0, o.bool)((0, o.yearMonthDurationsToMonths)((0, o.defaultedYearMonthDurationRepresentation)(e.typedValue)) === (0, o.yearMonthDurationsToMonths)((0, o.defaultedYearMonthDurationRepresentation)(n.typedValue)) && (0, o.dayTimeDurationsToSeconds)((0, o.defaultedDayTimeDurationRepresentation)(e.typedValue)) === (0, o.dayTimeDurationsToSeconds)((0, o.defaultedDayTimeDurationRepresentation)(n.typedValue)))).set([o.TypeURL.XSD_TIME, o.TypeURL.XSD_TIME], (e) => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-time-equal
          (0, o.bool)((0, o.toUTCDate)((0, o.defaultedDateTimeRepresentation)(n.typedValue), e.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime() === (0, o.toUTCDate)((0, o.defaultedDateTimeRepresentation)(i.typedValue), e.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime())
        )).collect()
      });
    }
  };
  return Ly.TermFunctionEquality = a, Ly;
}
var ZM;
function ale() {
  if (ZM) return Dy;
  ZM = 1, Object.defineProperty(Dy, "__esModule", { value: !0 }), Dy.ActorFunctionFactoryTermEquality = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ ile();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.EQUAL],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionEquality();
    }
  };
  return Dy.ActorFunctionFactoryTermEquality = a, Dy;
}
var eC;
function ule() {
  return eC || (eC = 1, function(u) {
    var r = Ys && Ys.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ys && Ys.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ale(), u);
  }(Ys)), Ys;
}
var Zs = {}, jy = {}, My = {}, tC;
function ole() {
  if (tC) return My;
  tC = 1, Object.defineProperty(My, "__esModule", { value: !0 }), My.TermFunctionFloor = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.FLOOR,
        overloads: (0, r.declare)(r.SparqlOperator.FLOOR).numericConverter(() => (t) => Math.floor(t)).collect()
      });
    }
  };
  return My.TermFunctionFloor = o, My;
}
var rC;
function sle() {
  if (rC) return jy;
  rC = 1, Object.defineProperty(jy, "__esModule", { value: !0 }), jy.ActorFunctionFactoryTermFloor = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ ole();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.FLOOR],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionFloor();
    }
  };
  return jy.ActorFunctionFactoryTermFloor = a, jy;
}
var nC;
function cle() {
  return nC || (nC = 1, function(u) {
    var r = Zs && Zs.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zs && Zs.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ sle(), u);
  }(Zs)), Zs;
}
var ec = {}, Cy = {}, qy = {}, iC;
function dle() {
  if (iC) return qy;
  iC = 1, Object.defineProperty(qy, "__esModule", { value: !0 }), qy.TermFunctionHours = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.HOURS,
        overloads: (0, r.declare)(r.SparqlOperator.HOURS).onDateTime1(() => (t) => (0, r.integer)(t.typedValue.hours)).set([r.TypeURL.XSD_TIME], () => ([t]) => (0, r.integer)(t.typedValue.hours)).collect()
      });
    }
  };
  return qy.TermFunctionHours = o, qy;
}
var aC;
function lle() {
  if (aC) return Cy;
  aC = 1, Object.defineProperty(Cy, "__esModule", { value: !0 }), Cy.ActorFunctionFactoryTermHours = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ dle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.HOURS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionHours();
    }
  };
  return Cy.ActorFunctionFactoryTermHours = a, Cy;
}
var uC;
function fle() {
  return uC || (uC = 1, function(u) {
    var r = ec && ec.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ec && ec.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ lle(), u);
  }(ec)), ec;
}
var tc = {}, By = {}, $y = {}, oC;
function hle() {
  if (oC) return $y;
  oC = 1, Object.defineProperty($y, "__esModule", { value: !0 }), $y.TermFunctionIri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve(), a = Tr();
  let t = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: o.SparqlOperator.IRI,
        overloads: (0, o.declare)(o.SparqlOperator.IRI).set(["namedNode"], (n) => (i) => {
          const c = i[0], s = (0, a.resolve)(c.str(), n.context.get(r.KeysInitQuery.baseIRI) ?? "");
          return new o.NamedNode(s);
        }).onString1((n) => (i) => {
          const c = (0, a.resolve)(i.str(), n.context.get(r.KeysInitQuery.baseIRI) ?? "");
          return new o.NamedNode(c);
        }).collect()
      });
    }
  };
  return $y.TermFunctionIri = t, $y;
}
var sC;
function ple() {
  if (sC) return By;
  sC = 1, Object.defineProperty(By, "__esModule", { value: !0 }), By.ActorFunctionFactoryTermIri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ hle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IRI, r.SparqlOperator.URI],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIri();
    }
  };
  return By.ActorFunctionFactoryTermIri = a, By;
}
var cC;
function ble() {
  return cC || (cC = 1, function(u) {
    var r = tc && tc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = tc && tc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ple(), u);
  }(tc)), tc;
}
var rc = {}, Uy = {}, Vy = {}, dC;
function yle() {
  if (dC) return Vy;
  dC = 1, Object.defineProperty(Vy, "__esModule", { value: !0 }), Vy.TermFunctionIsBlank = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.IS_BLANK,
        overloads: (0, r.declare)(r.SparqlOperator.IS_BLANK).onTerm1(() => (t) => (0, r.bool)(t.termType === "blankNode")).collect()
      });
    }
  };
  return Vy.TermFunctionIsBlank = o, Vy;
}
var lC;
function _le() {
  if (lC) return Uy;
  lC = 1, Object.defineProperty(Uy, "__esModule", { value: !0 }), Uy.ActorFunctionFactoryTermIsBlank = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ yle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IS_BLANK],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIsBlank();
    }
  };
  return Uy.ActorFunctionFactoryTermIsBlank = a, Uy;
}
var fC;
function gle() {
  return fC || (fC = 1, function(u) {
    var r = rc && rc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = rc && rc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _le(), u);
  }(rc)), rc;
}
var nc = {}, Qy = {}, Hy = {}, hC;
function mle() {
  if (hC) return Hy;
  hC = 1, Object.defineProperty(Hy, "__esModule", { value: !0 }), Hy.TermFunctionIsIri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.IS_IRI,
        overloads: (0, r.declare)(r.SparqlOperator.IS_IRI).onTerm1(() => (t) => (0, r.bool)(t.termType === "namedNode")).collect()
      });
    }
  };
  return Hy.TermFunctionIsIri = o, Hy;
}
var pC;
function vle() {
  if (pC) return Qy;
  pC = 1, Object.defineProperty(Qy, "__esModule", { value: !0 }), Qy.ActorFunctionFactoryTermIsIri = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ mle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IS_IRI, r.SparqlOperator.IS_URI],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIsIri();
    }
  };
  return Qy.ActorFunctionFactoryTermIsIri = a, Qy;
}
var bC;
function Tle() {
  return bC || (bC = 1, function(u) {
    var r = nc && nc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = nc && nc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ vle(), u);
  }(nc)), nc;
}
var ic = {}, Gy = {}, zy = {}, yC;
function wle() {
  if (yC) return zy;
  yC = 1, Object.defineProperty(zy, "__esModule", { value: !0 }), zy.TermFunctionIsLiteral = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.IS_LITERAL,
        overloads: (0, r.declare)(r.SparqlOperator.IS_LITERAL).onTerm1(() => (t) => (0, r.bool)(t.termType === "literal")).collect()
      });
    }
  };
  return zy.TermFunctionIsLiteral = o, zy;
}
var _C;
function Sle() {
  if (_C) return Gy;
  _C = 1, Object.defineProperty(Gy, "__esModule", { value: !0 }), Gy.ActorFunctionFactoryTermIsLiteral = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ wle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IS_LITERAL],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIsLiteral();
    }
  };
  return Gy.ActorFunctionFactoryTermIsLiteral = a, Gy;
}
var gC;
function Ale() {
  return gC || (gC = 1, function(u) {
    var r = ic && ic.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ic && ic.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Sle(), u);
  }(ic)), ic;
}
var ac = {}, ky = {}, Xy = {}, mC;
function Ele() {
  if (mC) return Xy;
  mC = 1, Object.defineProperty(Xy, "__esModule", { value: !0 }), Xy.TermFunctionIsNumeric = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.IS_NUMERIC,
        overloads: (0, r.declare)(r.SparqlOperator.IS_NUMERIC).onNumeric1(() => () => (0, r.bool)(!0)).onTerm1(() => () => (0, r.bool)(!1)).collect()
      });
    }
  };
  return Xy.TermFunctionIsNumeric = o, Xy;
}
var vC;
function Ole() {
  if (vC) return ky;
  vC = 1, Object.defineProperty(ky, "__esModule", { value: !0 }), ky.ActorFunctionFactoryTermIsNumeric = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ele();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IS_NUMERIC],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIsNumeric();
    }
  };
  return ky.ActorFunctionFactoryTermIsNumeric = a, ky;
}
var TC;
function xle() {
  return TC || (TC = 1, function(u) {
    var r = ac && ac.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ac && ac.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ole(), u);
  }(ac)), ac;
}
var uc = {}, Jy = {}, Ky = {}, wC;
function Ile() {
  if (wC) return Ky;
  wC = 1, Object.defineProperty(Ky, "__esModule", { value: !0 }), Ky.TermFunctionIsTriple = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.IS_TRIPLE,
        overloads: (0, r.declare)(r.SparqlOperator.IS_TRIPLE).onTerm1(() => (t) => (0, r.bool)(t.termType === "quad")).collect()
      });
    }
  };
  return Ky.TermFunctionIsTriple = o, Ky;
}
var SC;
function Rle() {
  if (SC) return Jy;
  SC = 1, Object.defineProperty(Jy, "__esModule", { value: !0 }), Jy.ActorFunctionFactoryTermIsTriple = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ile();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IS_TRIPLE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionIsTriple();
    }
  };
  return Jy.ActorFunctionFactoryTermIsTriple = a, Jy;
}
var AC;
function Fle() {
  return AC || (AC = 1, function(u) {
    var r = uc && uc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = uc && uc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rle(), u);
  }(uc)), uc;
}
var oc = {}, Wy = {}, Yy = {}, EC;
function Nle() {
  if (EC) return Yy;
  EC = 1, Object.defineProperty(Yy, "__esModule", { value: !0 }), Yy.TermFunctionLang = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.LANG,
        overloads: (0, r.declare)(r.SparqlOperator.LANG).onLiteral1(() => (t) => (0, r.string)(t.language ?? "")).collect()
      });
    }
  };
  return Yy.TermFunctionLang = o, Yy;
}
var OC;
function Ple() {
  if (OC) return Wy;
  OC = 1, Object.defineProperty(Wy, "__esModule", { value: !0 }), Wy.ActorFunctionFactoryTermLang = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Nle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LANG],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionLang();
    }
  };
  return Wy.ActorFunctionFactoryTermLang = a, Wy;
}
var xC;
function Dle() {
  return xC || (xC = 1, function(u) {
    var r = oc && oc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = oc && oc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ple(), u);
  }(oc)), oc;
}
var sc = {}, Zy = {}, e_ = {}, IC;
function Lle() {
  if (IC) return e_;
  IC = 1, Object.defineProperty(e_, "__esModule", { value: !0 }), e_.TermFunctionLangmatches = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class N0 extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.LANG_MATCHES,
        overloads: (0, r.declare)(r.SparqlOperator.LANG_MATCHES).onBinaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.bool)(N0.langMatches(t, e))).collect()
      });
    }
    // TODO: Not an XPath function
    // TODO: Publish as package
    // https://www.ietf.org/rfc/rfc4647.txt
    // https://www.w3.org/TR/sparql11-query/#func-langMatches
    static langMatches(t, e) {
      const n = t.split("-"), i = e.split("-");
      if (!N0.matchLangTag(i[0], n[0]) && !N0.isWildCard(n[0]))
        return !1;
      let c = 1, s = 1;
      for (; s < i.length; ) {
        if (N0.isWildCard(i[s])) {
          s++;
          continue;
        }
        if (c === n.length)
          return !1;
        if (N0.matchLangTag(i[s], n[c])) {
          c++, s++;
          continue;
        }
        if (n[c].length === 1)
          return !1;
        c++;
      }
      return !0;
    }
    static isWildCard(t) {
      return t === "*";
    }
    static matchLangTag(t, e) {
      return new RegExp(`/${t}/`, "iu").test(`/${e}/`);
    }
  };
  return e_.TermFunctionLangmatches = o, e_;
}
var RC;
function jle() {
  if (RC) return Zy;
  RC = 1, Object.defineProperty(Zy, "__esModule", { value: !0 }), Zy.ActorFunctionFactoryTermLangmatches = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Lle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LANG_MATCHES],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionLangmatches();
    }
  };
  return Zy.ActorFunctionFactoryTermLangmatches = a, Zy;
}
var FC;
function Mle() {
  return FC || (FC = 1, function(u) {
    var r = sc && sc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = sc && sc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ jle(), u);
  }(sc)), sc;
}
var cc = {}, t_ = {}, r_ = {}, NC;
function Cle() {
  if (NC) return r_;
  NC = 1, Object.defineProperty(r_, "__esModule", { value: !0 }), r_.TermFunctionLcase = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.LCASE,
        overloads: (0, r.declare)(r.SparqlOperator.LCASE).onString1Typed(() => (t) => (0, r.string)(t.toLowerCase())).onLangString1(() => (t) => (0, r.langString)(t.typedValue.toLowerCase(), t.language)).collect()
      });
    }
  };
  return r_.TermFunctionLcase = o, r_;
}
var PC;
function qle() {
  if (PC) return t_;
  PC = 1, Object.defineProperty(t_, "__esModule", { value: !0 }), t_.ActorFunctionFactoryTermLcase = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Cle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LCASE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionLcase();
    }
  };
  return t_.ActorFunctionFactoryTermLcase = a, t_;
}
var DC;
function Ble() {
  return DC || (DC = 1, function(u) {
    var r = cc && cc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = cc && cc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qle(), u);
  }(cc)), cc;
}
var dc = {}, n_ = {}, i_ = {}, KE = { exports: {} }, LC;
function $le() {
  return LC || (LC = 1, function(u, r) {
    (function(o) {
      u.exports = o();
    })(function(o) {
      var a = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function t(y, m) {
        var g = y[0], T = y[1], v = y[2], E = y[3];
        g += (T & v | ~T & E) + m[0] - 680876936 | 0, g = (g << 7 | g >>> 25) + T | 0, E += (g & T | ~g & v) + m[1] - 389564586 | 0, E = (E << 12 | E >>> 20) + g | 0, v += (E & g | ~E & T) + m[2] + 606105819 | 0, v = (v << 17 | v >>> 15) + E | 0, T += (v & E | ~v & g) + m[3] - 1044525330 | 0, T = (T << 22 | T >>> 10) + v | 0, g += (T & v | ~T & E) + m[4] - 176418897 | 0, g = (g << 7 | g >>> 25) + T | 0, E += (g & T | ~g & v) + m[5] + 1200080426 | 0, E = (E << 12 | E >>> 20) + g | 0, v += (E & g | ~E & T) + m[6] - 1473231341 | 0, v = (v << 17 | v >>> 15) + E | 0, T += (v & E | ~v & g) + m[7] - 45705983 | 0, T = (T << 22 | T >>> 10) + v | 0, g += (T & v | ~T & E) + m[8] + 1770035416 | 0, g = (g << 7 | g >>> 25) + T | 0, E += (g & T | ~g & v) + m[9] - 1958414417 | 0, E = (E << 12 | E >>> 20) + g | 0, v += (E & g | ~E & T) + m[10] - 42063 | 0, v = (v << 17 | v >>> 15) + E | 0, T += (v & E | ~v & g) + m[11] - 1990404162 | 0, T = (T << 22 | T >>> 10) + v | 0, g += (T & v | ~T & E) + m[12] + 1804603682 | 0, g = (g << 7 | g >>> 25) + T | 0, E += (g & T | ~g & v) + m[13] - 40341101 | 0, E = (E << 12 | E >>> 20) + g | 0, v += (E & g | ~E & T) + m[14] - 1502002290 | 0, v = (v << 17 | v >>> 15) + E | 0, T += (v & E | ~v & g) + m[15] + 1236535329 | 0, T = (T << 22 | T >>> 10) + v | 0, g += (T & E | v & ~E) + m[1] - 165796510 | 0, g = (g << 5 | g >>> 27) + T | 0, E += (g & v | T & ~v) + m[6] - 1069501632 | 0, E = (E << 9 | E >>> 23) + g | 0, v += (E & T | g & ~T) + m[11] + 643717713 | 0, v = (v << 14 | v >>> 18) + E | 0, T += (v & g | E & ~g) + m[0] - 373897302 | 0, T = (T << 20 | T >>> 12) + v | 0, g += (T & E | v & ~E) + m[5] - 701558691 | 0, g = (g << 5 | g >>> 27) + T | 0, E += (g & v | T & ~v) + m[10] + 38016083 | 0, E = (E << 9 | E >>> 23) + g | 0, v += (E & T | g & ~T) + m[15] - 660478335 | 0, v = (v << 14 | v >>> 18) + E | 0, T += (v & g | E & ~g) + m[4] - 405537848 | 0, T = (T << 20 | T >>> 12) + v | 0, g += (T & E | v & ~E) + m[9] + 568446438 | 0, g = (g << 5 | g >>> 27) + T | 0, E += (g & v | T & ~v) + m[14] - 1019803690 | 0, E = (E << 9 | E >>> 23) + g | 0, v += (E & T | g & ~T) + m[3] - 187363961 | 0, v = (v << 14 | v >>> 18) + E | 0, T += (v & g | E & ~g) + m[8] + 1163531501 | 0, T = (T << 20 | T >>> 12) + v | 0, g += (T & E | v & ~E) + m[13] - 1444681467 | 0, g = (g << 5 | g >>> 27) + T | 0, E += (g & v | T & ~v) + m[2] - 51403784 | 0, E = (E << 9 | E >>> 23) + g | 0, v += (E & T | g & ~T) + m[7] + 1735328473 | 0, v = (v << 14 | v >>> 18) + E | 0, T += (v & g | E & ~g) + m[12] - 1926607734 | 0, T = (T << 20 | T >>> 12) + v | 0, g += (T ^ v ^ E) + m[5] - 378558 | 0, g = (g << 4 | g >>> 28) + T | 0, E += (g ^ T ^ v) + m[8] - 2022574463 | 0, E = (E << 11 | E >>> 21) + g | 0, v += (E ^ g ^ T) + m[11] + 1839030562 | 0, v = (v << 16 | v >>> 16) + E | 0, T += (v ^ E ^ g) + m[14] - 35309556 | 0, T = (T << 23 | T >>> 9) + v | 0, g += (T ^ v ^ E) + m[1] - 1530992060 | 0, g = (g << 4 | g >>> 28) + T | 0, E += (g ^ T ^ v) + m[4] + 1272893353 | 0, E = (E << 11 | E >>> 21) + g | 0, v += (E ^ g ^ T) + m[7] - 155497632 | 0, v = (v << 16 | v >>> 16) + E | 0, T += (v ^ E ^ g) + m[10] - 1094730640 | 0, T = (T << 23 | T >>> 9) + v | 0, g += (T ^ v ^ E) + m[13] + 681279174 | 0, g = (g << 4 | g >>> 28) + T | 0, E += (g ^ T ^ v) + m[0] - 358537222 | 0, E = (E << 11 | E >>> 21) + g | 0, v += (E ^ g ^ T) + m[3] - 722521979 | 0, v = (v << 16 | v >>> 16) + E | 0, T += (v ^ E ^ g) + m[6] + 76029189 | 0, T = (T << 23 | T >>> 9) + v | 0, g += (T ^ v ^ E) + m[9] - 640364487 | 0, g = (g << 4 | g >>> 28) + T | 0, E += (g ^ T ^ v) + m[12] - 421815835 | 0, E = (E << 11 | E >>> 21) + g | 0, v += (E ^ g ^ T) + m[15] + 530742520 | 0, v = (v << 16 | v >>> 16) + E | 0, T += (v ^ E ^ g) + m[2] - 995338651 | 0, T = (T << 23 | T >>> 9) + v | 0, g += (v ^ (T | ~E)) + m[0] - 198630844 | 0, g = (g << 6 | g >>> 26) + T | 0, E += (T ^ (g | ~v)) + m[7] + 1126891415 | 0, E = (E << 10 | E >>> 22) + g | 0, v += (g ^ (E | ~T)) + m[14] - 1416354905 | 0, v = (v << 15 | v >>> 17) + E | 0, T += (E ^ (v | ~g)) + m[5] - 57434055 | 0, T = (T << 21 | T >>> 11) + v | 0, g += (v ^ (T | ~E)) + m[12] + 1700485571 | 0, g = (g << 6 | g >>> 26) + T | 0, E += (T ^ (g | ~v)) + m[3] - 1894986606 | 0, E = (E << 10 | E >>> 22) + g | 0, v += (g ^ (E | ~T)) + m[10] - 1051523 | 0, v = (v << 15 | v >>> 17) + E | 0, T += (E ^ (v | ~g)) + m[1] - 2054922799 | 0, T = (T << 21 | T >>> 11) + v | 0, g += (v ^ (T | ~E)) + m[8] + 1873313359 | 0, g = (g << 6 | g >>> 26) + T | 0, E += (T ^ (g | ~v)) + m[15] - 30611744 | 0, E = (E << 10 | E >>> 22) + g | 0, v += (g ^ (E | ~T)) + m[6] - 1560198380 | 0, v = (v << 15 | v >>> 17) + E | 0, T += (E ^ (v | ~g)) + m[13] + 1309151649 | 0, T = (T << 21 | T >>> 11) + v | 0, g += (v ^ (T | ~E)) + m[4] - 145523070 | 0, g = (g << 6 | g >>> 26) + T | 0, E += (T ^ (g | ~v)) + m[11] - 1120210379 | 0, E = (E << 10 | E >>> 22) + g | 0, v += (g ^ (E | ~T)) + m[2] + 718787259 | 0, v = (v << 15 | v >>> 17) + E | 0, T += (E ^ (v | ~g)) + m[9] - 343485551 | 0, T = (T << 21 | T >>> 11) + v | 0, y[0] = g + y[0] | 0, y[1] = T + y[1] | 0, y[2] = v + y[2] | 0, y[3] = E + y[3] | 0;
      }
      function e(y) {
        var m = [], g;
        for (g = 0; g < 64; g += 4)
          m[g >> 2] = y.charCodeAt(g) + (y.charCodeAt(g + 1) << 8) + (y.charCodeAt(g + 2) << 16) + (y.charCodeAt(g + 3) << 24);
        return m;
      }
      function n(y) {
        var m = [], g;
        for (g = 0; g < 64; g += 4)
          m[g >> 2] = y[g] + (y[g + 1] << 8) + (y[g + 2] << 16) + (y[g + 3] << 24);
        return m;
      }
      function i(y) {
        var m = y.length, g = [1732584193, -271733879, -1732584194, 271733878], T, v, E, R, L, A;
        for (T = 64; T <= m; T += 64)
          t(g, e(y.substring(T - 64, T)));
        for (y = y.substring(T - 64), v = y.length, E = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], T = 0; T < v; T += 1)
          E[T >> 2] |= y.charCodeAt(T) << (T % 4 << 3);
        if (E[T >> 2] |= 128 << (T % 4 << 3), T > 55)
          for (t(g, E), T = 0; T < 16; T += 1)
            E[T] = 0;
        return R = m * 8, R = R.toString(16).match(/(.*?)(.{0,8})$/), L = parseInt(R[2], 16), A = parseInt(R[1], 16) || 0, E[14] = L, E[15] = A, t(g, E), g;
      }
      function c(y) {
        var m = y.length, g = [1732584193, -271733879, -1732584194, 271733878], T, v, E, R, L, A;
        for (T = 64; T <= m; T += 64)
          t(g, n(y.subarray(T - 64, T)));
        for (y = T - 64 < m ? y.subarray(T - 64) : new Uint8Array(0), v = y.length, E = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], T = 0; T < v; T += 1)
          E[T >> 2] |= y[T] << (T % 4 << 3);
        if (E[T >> 2] |= 128 << (T % 4 << 3), T > 55)
          for (t(g, E), T = 0; T < 16; T += 1)
            E[T] = 0;
        return R = m * 8, R = R.toString(16).match(/(.*?)(.{0,8})$/), L = parseInt(R[2], 16), A = parseInt(R[1], 16) || 0, E[14] = L, E[15] = A, t(g, E), g;
      }
      function s(y) {
        var m = "", g;
        for (g = 0; g < 4; g += 1)
          m += a[y >> g * 8 + 4 & 15] + a[y >> g * 8 & 15];
        return m;
      }
      function d(y) {
        var m;
        for (m = 0; m < y.length; m += 1)
          y[m] = s(y[m]);
        return y.join("");
      }
      d(i("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
        function y(m, g) {
          return m = m | 0 || 0, m < 0 ? Math.max(m + g, 0) : Math.min(m, g);
        }
        ArrayBuffer.prototype.slice = function(m, g) {
          var T = this.byteLength, v = y(m, T), E = T, R, L, A, w;
          return g !== o && (E = y(g, T)), v > E ? new ArrayBuffer(0) : (R = E - v, L = new ArrayBuffer(R), A = new Uint8Array(L), w = new Uint8Array(this, v, R), A.set(w), L);
        };
      }();
      function l(y) {
        return /[\u0080-\uFFFF]/.test(y) && (y = unescape(encodeURIComponent(y))), y;
      }
      function f(y, m) {
        var g = y.length, T = new ArrayBuffer(g), v = new Uint8Array(T), E;
        for (E = 0; E < g; E += 1)
          v[E] = y.charCodeAt(E);
        return m ? v : T;
      }
      function h(y) {
        return String.fromCharCode.apply(null, new Uint8Array(y));
      }
      function p(y, m, g) {
        var T = new Uint8Array(y.byteLength + m.byteLength);
        return T.set(new Uint8Array(y)), T.set(new Uint8Array(m), y.byteLength), T;
      }
      function b(y) {
        var m = [], g = y.length, T;
        for (T = 0; T < g - 1; T += 2)
          m.push(parseInt(y.substr(T, 2), 16));
        return String.fromCharCode.apply(String, m);
      }
      function _() {
        this.reset();
      }
      return _.prototype.append = function(y) {
        return this.appendBinary(l(y)), this;
      }, _.prototype.appendBinary = function(y) {
        this._buff += y, this._length += y.length;
        var m = this._buff.length, g;
        for (g = 64; g <= m; g += 64)
          t(this._hash, e(this._buff.substring(g - 64, g)));
        return this._buff = this._buff.substring(g - 64), this;
      }, _.prototype.end = function(y) {
        var m = this._buff, g = m.length, T, v = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], E;
        for (T = 0; T < g; T += 1)
          v[T >> 2] |= m.charCodeAt(T) << (T % 4 << 3);
        return this._finish(v, g), E = d(this._hash), y && (E = b(E)), this.reset(), E;
      }, _.prototype.reset = function() {
        return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
      }, _.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      }, _.prototype.setState = function(y) {
        return this._buff = y.buff, this._length = y.length, this._hash = y.hash, this;
      }, _.prototype.destroy = function() {
        delete this._hash, delete this._buff, delete this._length;
      }, _.prototype._finish = function(y, m) {
        var g = m, T, v, E;
        if (y[g >> 2] |= 128 << (g % 4 << 3), g > 55)
          for (t(this._hash, y), g = 0; g < 16; g += 1)
            y[g] = 0;
        T = this._length * 8, T = T.toString(16).match(/(.*?)(.{0,8})$/), v = parseInt(T[2], 16), E = parseInt(T[1], 16) || 0, y[14] = v, y[15] = E, t(this._hash, y);
      }, _.hash = function(y, m) {
        return _.hashBinary(l(y), m);
      }, _.hashBinary = function(y, m) {
        var g = i(y), T = d(g);
        return m ? b(T) : T;
      }, _.ArrayBuffer = function() {
        this.reset();
      }, _.ArrayBuffer.prototype.append = function(y) {
        var m = p(this._buff.buffer, y), g = m.length, T;
        for (this._length += y.byteLength, T = 64; T <= g; T += 64)
          t(this._hash, n(m.subarray(T - 64, T)));
        return this._buff = T - 64 < g ? new Uint8Array(m.buffer.slice(T - 64)) : new Uint8Array(0), this;
      }, _.ArrayBuffer.prototype.end = function(y) {
        var m = this._buff, g = m.length, T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], v, E;
        for (v = 0; v < g; v += 1)
          T[v >> 2] |= m[v] << (v % 4 << 3);
        return this._finish(T, g), E = d(this._hash), y && (E = b(E)), this.reset(), E;
      }, _.ArrayBuffer.prototype.reset = function() {
        return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
      }, _.ArrayBuffer.prototype.getState = function() {
        var y = _.prototype.getState.call(this);
        return y.buff = h(y.buff), y;
      }, _.ArrayBuffer.prototype.setState = function(y) {
        return y.buff = f(y.buff, !0), _.prototype.setState.call(this, y);
      }, _.ArrayBuffer.prototype.destroy = _.prototype.destroy, _.ArrayBuffer.prototype._finish = _.prototype._finish, _.ArrayBuffer.hash = function(y, m) {
        var g = c(new Uint8Array(y)), T = d(g);
        return m ? b(T) : T;
      }, _;
    });
  }(KE)), KE.exports;
}
var jC;
function Ule() {
  if (jC) return i_;
  jC = 1, Object.defineProperty(i_, "__esModule", { value: !0 }), i_.TermFunctionMd5 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = $le();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.MD5,
        overloads: (0, r.declare)(r.SparqlOperator.MD5).onString1Typed(() => (e) => (0, r.string)((0, o.hash)(e))).collect()
      });
    }
  };
  return i_.TermFunctionMd5 = a, i_;
}
var MC;
function Vle() {
  if (MC) return n_;
  MC = 1, Object.defineProperty(n_, "__esModule", { value: !0 }), n_.ActorFunctionFactoryTermMd5 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ule();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.MD5],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionMd5();
    }
  };
  return n_.ActorFunctionFactoryTermMd5 = a, n_;
}
var CC;
function Qle() {
  return CC || (CC = 1, function(u) {
    var r = dc && dc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = dc && dc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Vle(), u);
  }(dc)), dc;
}
var lc = {}, a_ = {}, u_ = {}, qC;
function Hle() {
  if (qC) return u_;
  qC = 1, Object.defineProperty(u_, "__esModule", { value: !0 }), u_.TermFunctionMinutes = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.MINUTES,
        overloads: (0, r.declare)(r.SparqlOperator.MINUTES).onDateTime1(() => (t) => (0, r.integer)(t.typedValue.minutes)).set([r.TypeURL.XSD_TIME], () => ([t]) => (0, r.integer)(t.typedValue.minutes)).collect()
      });
    }
  };
  return u_.TermFunctionMinutes = o, u_;
}
var BC;
function Gle() {
  if (BC) return a_;
  BC = 1, Object.defineProperty(a_, "__esModule", { value: !0 }), a_.ActorFunctionFactoryTermMinutes = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Hle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.MINUTES],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionMinutes();
    }
  };
  return a_.ActorFunctionFactoryTermMinutes = a, a_;
}
var $C;
function zle() {
  return $C || ($C = 1, function(u) {
    var r = lc && lc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = lc && lc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Gle(), u);
  }(lc)), lc;
}
var fc = {}, o_ = {}, s_ = {}, UC;
function kle() {
  if (UC) return s_;
  UC = 1, Object.defineProperty(s_, "__esModule", { value: !0 }), s_.TermFunctionMonth = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.MONTH,
        overloads: (0, r.declare)(r.SparqlOperator.MONTH).onDateTime1(() => (t) => (0, r.integer)(t.typedValue.month)).set([r.TypeURL.XSD_DATE], () => ([t]) => (0, r.integer)(t.typedValue.month)).collect()
      });
    }
  };
  return s_.TermFunctionMonth = o, s_;
}
var VC;
function Xle() {
  if (VC) return o_;
  VC = 1, Object.defineProperty(o_, "__esModule", { value: !0 }), o_.ActorFunctionFactoryTermMonth = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ kle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.MONTH],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionMonth();
    }
  };
  return o_.ActorFunctionFactoryTermMonth = a, o_;
}
var QC;
function Jle() {
  return QC || (QC = 1, function(u) {
    var r = fc && fc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = fc && fc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Xle(), u);
  }(fc)), fc;
}
var hc = {}, c_ = {}, d_ = {}, HC;
function Kle() {
  if (HC) return d_;
  HC = 1, Object.defineProperty(d_, "__esModule", { value: !0 }), d_.TermFunctionMultiplication = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = u4();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.MULTIPLICATION,
        overloads: (0, r.declare)(r.SparqlOperator.MULTIPLICATION).arithmetic(() => (e, n) => new o.BigNumber(e).times(n).toNumber()).collect()
      });
    }
  };
  return d_.TermFunctionMultiplication = a, d_;
}
var GC;
function Wle() {
  if (GC) return c_;
  GC = 1, Object.defineProperty(c_, "__esModule", { value: !0 }), c_.ActorFunctionFactoryTermMultiplication = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Kle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.MULTIPLICATION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionMultiplication();
    }
  };
  return c_.ActorFunctionFactoryTermMultiplication = a, c_;
}
var zC;
function Yle() {
  return zC || (zC = 1, function(u) {
    var r = hc && hc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = hc && hc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Wle(), u);
  }(hc)), hc;
}
var pc = {}, l_ = {}, f_ = {}, kC;
function Zle() {
  if (kC) return f_;
  kC = 1, Object.defineProperty(f_, "__esModule", { value: !0 }), f_.TermFunctionNot = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.NOT,
        overloads: (0, r.declare)(r.SparqlOperator.NOT).onTerm1(() => (t) => (0, r.bool)(!t.coerceEBV())).collect()
      });
    }
  };
  return f_.TermFunctionNot = o, f_;
}
var XC;
function efe() {
  if (XC) return l_;
  XC = 1, Object.defineProperty(l_, "__esModule", { value: !0 }), l_.ActorFunctionFactoryTermNot = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Zle();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.NOT],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionNot();
    }
  };
  return l_.ActorFunctionFactoryTermNot = a, l_;
}
var JC;
function tfe() {
  return JC || (JC = 1, function(u) {
    var r = pc && pc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = pc && pc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ efe(), u);
  }(pc)), pc;
}
var bc = {}, h_ = {}, p_ = {}, KC;
function rfe() {
  if (KC) return p_;
  KC = 1, Object.defineProperty(p_, "__esModule", { value: !0 }), p_.TermFunctionNow = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 0,
        operator: o.SparqlOperator.NOW,
        overloads: (0, o.declare)(o.SparqlOperator.NOW).set([], (e) => () => new o.DateTimeLiteral((0, o.toDateTimeRepresentation)({
          date: e.context.getSafe(r.KeysInitQuery.queryTimestamp),
          timeZone: e.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)
        }))).collect()
      });
    }
  };
  return p_.TermFunctionNow = a, p_;
}
var WC;
function nfe() {
  if (WC) return h_;
  WC = 1, Object.defineProperty(h_, "__esModule", { value: !0 }), h_.ActorFunctionFactoryTermNow = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ rfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.NOW],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionNow();
    }
  };
  return h_.ActorFunctionFactoryTermNow = a, h_;
}
var YC;
function ife() {
  return YC || (YC = 1, function(u) {
    var r = bc && bc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bc && bc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ nfe(), u);
  }(bc)), bc;
}
var yc = {}, b_ = {}, y_ = {}, ZC;
function afe() {
  if (ZC) return y_;
  ZC = 1, Object.defineProperty(y_, "__esModule", { value: !0 }), y_.TermFunctionObject = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.OBJECT,
        overloads: (0, r.declare)(r.SparqlOperator.OBJECT).onQuad1(() => (t) => t.object).collect()
      });
    }
  };
  return y_.TermFunctionObject = o, y_;
}
var eq;
function ufe() {
  if (eq) return b_;
  eq = 1, Object.defineProperty(b_, "__esModule", { value: !0 }), b_.ActorFunctionFactoryTermObject = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ afe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.OBJECT],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionObject();
    }
  };
  return b_.ActorFunctionFactoryTermObject = a, b_;
}
var tq;
function ofe() {
  return tq || (tq = 1, function(u) {
    var r = yc && yc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = yc && yc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ufe(), u);
  }(yc)), yc;
}
var _c = {}, __ = {}, g_ = {}, rq;
function sfe() {
  if (rq) return g_;
  rq = 1, Object.defineProperty(g_, "__esModule", { value: !0 }), g_.TermFunctionPredicate = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.PREDICATE,
        overloads: (0, r.declare)(r.SparqlOperator.PREDICATE).onQuad1(() => (t) => t.predicate).collect()
      });
    }
  };
  return g_.TermFunctionPredicate = o, g_;
}
var nq;
function cfe() {
  if (nq) return __;
  nq = 1, Object.defineProperty(__, "__esModule", { value: !0 }), __.ActorFunctionFactoryTermPredicate = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ sfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.PREDICATE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionPredicate();
    }
  };
  return __.ActorFunctionFactoryTermPredicate = a, __;
}
var iq;
function dfe() {
  return iq || (iq = 1, function(u) {
    var r = _c && _c.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _c && _c.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ cfe(), u);
  }(_c)), _c;
}
var gc = {}, m_ = {}, v_ = {}, aq;
function lfe() {
  if (aq) return v_;
  aq = 1, Object.defineProperty(v_, "__esModule", { value: !0 }), v_.TermFunctionRand = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 0,
        operator: r.SparqlOperator.RAND,
        overloads: (0, r.declare)(r.SparqlOperator.RAND).set([], () => () => (0, r.double)(Math.random())).collect()
      });
    }
  };
  return v_.TermFunctionRand = o, v_;
}
var uq;
function ffe() {
  if (uq) return m_;
  uq = 1, Object.defineProperty(m_, "__esModule", { value: !0 }), m_.ActorFunctionFactoryTermRand = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ lfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.RAND],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionRand();
    }
  };
  return m_.ActorFunctionFactoryTermRand = a, m_;
}
var oq;
function hfe() {
  return oq || (oq = 1, function(u) {
    var r = gc && gc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = gc && gc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ffe(), u);
  }(gc)), gc;
}
var mc = {}, T_ = {}, w_ = {}, sq;
function NY() {
  if (sq) return w_;
  sq = 1, Object.defineProperty(w_, "__esModule", { value: !0 }), w_.TermFunctionRegex = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class Ma extends u.TermFunctionBase {
    constructor() {
      super({
        arity: [2, 3],
        operator: r.SparqlOperator.REGEX,
        overloads: (0, r.declare)(r.SparqlOperator.REGEX).onBinaryTyped([r.TypeAlias.SPARQL_STRINGLY, r.TypeURL.XSD_STRING], Ma.regex2).onTernaryTyped([r.TypeAlias.SPARQL_STRINGLY, r.TypeURL.XSD_STRING, r.TypeURL.XSD_STRING], Ma.regex3).collect()
      });
    }
    static regex2() {
      return (t, e) => (0, r.bool)(Ma.matches(t, e));
    }
    static regex3() {
      return (t, e, n) => (0, r.bool)(Ma.matches(t, e, n));
    }
    // https://www.w3.org/TR/xpath-functions/#func-matches
    // https://www.w3.org/TR/xpath-functions/#flags
    static matches(t, e, n = "") {
      return n = Ma.cleanFlags(n), n.includes("x") && (e = Ma.flagX(e)), n.includes("q") && (e = Ma.flagQ(e)), new RegExp(e, n.replaceAll(/[qx]/gu, "")).test(t);
    }
    static cleanFlags(t) {
      if (!/^[imsxq]*$/u.test(t))
        throw new Error("Invalid flags");
      const e = [...t].find((n, i, c) => c.indexOf(n) !== i);
      if (e)
        throw new Error(`Duplicate flag: ${e}`);
      return t != null && t.includes("q") && (t = t.replaceAll(/[msx]/gu, "")), `${t}u`;
    }
    static flagX(t) {
      if (!t)
        return t;
      let e = t[0];
      for (; ["	", `
`, "\r", " "].includes(e); )
        t = t.slice(1), e = t[0];
      let n = e === "[";
      for (let i = 1; i < t.length; i++) {
        const c = t[i];
        ["	", `
`, "\r", " "].includes(c) && !n ? (t = t.slice(0, i) + t.slice(i + 1), i--) : c === "[" && e !== "\\" ? n = !0 : c === "]" && e !== "\\" && (n = !1), e = c;
      }
      return t;
    }
    static flagQ(t) {
      return t.replaceAll(/([?+*.{}()[\]\\|])/gu, "\\$1").replaceAll(/^\^/gu, "\\^").replaceAll(/\$$/gu, "\\$");
    }
  };
  return w_.TermFunctionRegex = o, w_;
}
var cq;
function pfe() {
  if (cq) return T_;
  cq = 1, Object.defineProperty(T_, "__esModule", { value: !0 }), T_.ActorFunctionFactoryTermRegex = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ NY();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.REGEX],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionRegex();
    }
  };
  return T_.ActorFunctionFactoryTermRegex = a, T_;
}
var dq;
function PY() {
  return dq || (dq = 1, function(u) {
    var r = mc && mc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = mc && mc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ pfe(), u), o(/* @__PURE__ */ NY(), u);
  }(mc)), mc;
}
var vc = {}, S_ = {}, A_ = {}, lq;
function bfe() {
  if (lq) return A_;
  lq = 1, Object.defineProperty(A_, "__esModule", { value: !0 }), A_.TermFunctionReplace = void 0;
  const u = /* @__PURE__ */ PY(), r = /* @__PURE__ */ Ae(), o = /* @__PURE__ */ ve();
  let a = class TT extends r.TermFunctionBase {
    constructor() {
      super({
        arity: [3, 4],
        operator: o.SparqlOperator.REPLACE,
        overloads: (0, o.declare)(o.SparqlOperator.REPLACE).onTernaryTyped([o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING], () => (e, n, i) => (0, o.string)(TT.replace(e, n, i))).set([o.TypeURL.RDF_LANG_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING], () => ([e, n, i]) => {
          const c = TT.replace(e.typedValue, n.typedValue, i.typedValue);
          return (0, o.langString)(c, e.language);
        }).onQuaternaryTyped([o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING], () => (e, n, i, c) => (0, o.string)(TT.replace(e, n, i, c))).set([o.TypeURL.RDF_LANG_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING, o.TypeURL.XSD_STRING], () => ([e, n, i, c]) => {
          const s = TT.replace(e.typedValue, n.typedValue, i.typedValue, c.typedValue);
          return (0, o.langString)(s, e.language);
        }).collect()
      });
    }
    // https://www.w3.org/TR/xpath-functions/#func-replace
    static replace(e, n, i, c = "") {
      return c = u.TermFunctionRegex.cleanFlags(c), c.includes("x") && (n = u.TermFunctionRegex.flagX(n)), c.includes("q") ? n = u.TermFunctionRegex.flagQ(n) : i = i.replaceAll("$0", () => "$&"), c = `${c.replaceAll(/[qx]/gu, "")}g`, e.replaceAll(new RegExp(n, c), i);
    }
  };
  return A_.TermFunctionReplace = a, A_;
}
var fq;
function yfe() {
  if (fq) return S_;
  fq = 1, Object.defineProperty(S_, "__esModule", { value: !0 }), S_.ActorFunctionFactoryTermReplace = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ bfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.REPLACE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionReplace();
    }
  };
  return S_.ActorFunctionFactoryTermReplace = a, S_;
}
var hq;
function _fe() {
  return hq || (hq = 1, function(u) {
    var r = vc && vc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vc && vc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ yfe(), u);
  }(vc)), vc;
}
var Tc = {}, E_ = {}, O_ = {}, pq;
function gfe() {
  if (pq) return O_;
  pq = 1, Object.defineProperty(O_, "__esModule", { value: !0 }), O_.TermFunctionRound = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.ROUND,
        overloads: (0, r.declare)(r.SparqlOperator.ROUND).numericConverter(() => (t) => Math.round(t)).collect()
      });
    }
  };
  return O_.TermFunctionRound = o, O_;
}
var bq;
function mfe() {
  if (bq) return E_;
  bq = 1, Object.defineProperty(E_, "__esModule", { value: !0 }), E_.ActorFunctionFactoryTermRound = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ gfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.ROUND],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionRound();
    }
  };
  return E_.ActorFunctionFactoryTermRound = a, E_;
}
var yq;
function vfe() {
  return yq || (yq = 1, function(u) {
    var r = Tc && Tc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Tc && Tc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ mfe(), u);
  }(Tc)), Tc;
}
var wc = {}, x_ = {}, I_ = {}, _q;
function Tfe() {
  if (_q) return I_;
  _q = 1, Object.defineProperty(I_, "__esModule", { value: !0 }), I_.TermFunctionSeconds = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SECONDS,
        overloads: (0, r.declare)(r.SparqlOperator.SECONDS).onDateTime1(() => (t) => (0, r.decimal)(t.typedValue.seconds)).set([r.TypeURL.XSD_TIME], () => ([t]) => (0, r.integer)(t.typedValue.seconds)).collect()
      });
    }
  };
  return I_.TermFunctionSeconds = o, I_;
}
var gq;
function wfe() {
  if (gq) return x_;
  gq = 1, Object.defineProperty(x_, "__esModule", { value: !0 }), x_.ActorFunctionFactoryTermSeconds = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Tfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SECONDS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSeconds();
    }
  };
  return x_.ActorFunctionFactoryTermSeconds = a, x_;
}
var mq;
function Sfe() {
  return mq || (mq = 1, function(u) {
    var r = wc && wc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = wc && wc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ wfe(), u);
  }(wc)), wc;
}
var Sc = {}, R_ = {}, F_ = {}, vq;
function Afe() {
  if (vq) return F_;
  vq = 1, Object.defineProperty(F_, "__esModule", { value: !0 }), F_.TermFunctionSha1 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = vw();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SHA1,
        overloads: (0, r.declare)(r.SparqlOperator.SHA1).onString1Typed(() => (e) => (0, r.string)((0, o.sha1)().update(e).digest("hex"))).collect()
      });
    }
  };
  return F_.TermFunctionSha1 = a, F_;
}
var Tq;
function Efe() {
  if (Tq) return R_;
  Tq = 1, Object.defineProperty(R_, "__esModule", { value: !0 }), R_.ActorFunctionFactoryTermSha1 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Afe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SHA1],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSha1();
    }
  };
  return R_.ActorFunctionFactoryTermSha1 = a, R_;
}
var wq;
function Ofe() {
  return wq || (wq = 1, function(u) {
    var r = Sc && Sc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Sc && Sc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Efe(), u);
  }(Sc)), Sc;
}
var Ac = {}, N_ = {}, P_ = {}, Sq;
function xfe() {
  if (Sq) return P_;
  Sq = 1, Object.defineProperty(P_, "__esModule", { value: !0 }), P_.TermFunctionSha256 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = vw();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SHA256,
        overloads: (0, r.declare)(r.SparqlOperator.SHA256).onString1Typed(() => (e) => (0, r.string)((0, o.sha256)().update(e).digest("hex"))).collect()
      });
    }
  };
  return P_.TermFunctionSha256 = a, P_;
}
var Aq;
function Ife() {
  if (Aq) return N_;
  Aq = 1, Object.defineProperty(N_, "__esModule", { value: !0 }), N_.ActorFunctionFactoryTermSha256 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ xfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SHA256],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSha256();
    }
  };
  return N_.ActorFunctionFactoryTermSha256 = a, N_;
}
var Eq;
function Rfe() {
  return Eq || (Eq = 1, function(u) {
    var r = Ac && Ac.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ac && Ac.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ife(), u);
  }(Ac)), Ac;
}
var Ec = {}, D_ = {}, L_ = {}, Oq;
function Ffe() {
  if (Oq) return L_;
  Oq = 1, Object.defineProperty(L_, "__esModule", { value: !0 }), L_.TermFunctionSha384 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = vw();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SHA384,
        overloads: (0, r.declare)(r.SparqlOperator.SHA384).onString1Typed(() => (e) => (0, r.string)((0, o.sha384)().update(e).digest("hex"))).collect()
      });
    }
  };
  return L_.TermFunctionSha384 = a, L_;
}
var xq;
function Nfe() {
  if (xq) return D_;
  xq = 1, Object.defineProperty(D_, "__esModule", { value: !0 }), D_.ActorFunctionFactoryTermSha384 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ffe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SHA384],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSha384();
    }
  };
  return D_.ActorFunctionFactoryTermSha384 = a, D_;
}
var Iq;
function Pfe() {
  return Iq || (Iq = 1, function(u) {
    var r = Ec && Ec.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ec && Ec.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Nfe(), u);
  }(Ec)), Ec;
}
var Oc = {}, j_ = {}, M_ = {}, Rq;
function Dfe() {
  if (Rq) return M_;
  Rq = 1, Object.defineProperty(M_, "__esModule", { value: !0 }), M_.TermFunctionSha512 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = vw();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SHA512,
        overloads: (0, r.declare)(r.SparqlOperator.SHA512).onString1Typed(() => (e) => (0, r.string)((0, o.sha512)().update(e).digest("hex"))).collect()
      });
    }
  };
  return M_.TermFunctionSha512 = a, M_;
}
var Fq;
function Lfe() {
  if (Fq) return j_;
  Fq = 1, Object.defineProperty(j_, "__esModule", { value: !0 }), j_.ActorFunctionFactoryTermSha512 = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Dfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SHA512],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSha512();
    }
  };
  return j_.ActorFunctionFactoryTermSha512 = a, j_;
}
var Nq;
function jfe() {
  return Nq || (Nq = 1, function(u) {
    var r = Oc && Oc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Oc && Oc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Lfe(), u);
  }(Oc)), Oc;
}
var xc = {}, C_ = {}, q_ = {}, Pq;
function Mfe() {
  if (Pq) return q_;
  Pq = 1, Object.defineProperty(q_, "__esModule", { value: !0 }), q_.TermFunctionStrAfter = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.STRAFTER,
        overloads: (0, r.declare)(r.SparqlOperator.STRAFTER).onBinaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.string)(t.slice(t.indexOf(e)).slice(e.length))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.XSD_STRING], () => (t, e) => {
          const [n, i] = [t.typedValue, e.typedValue], c = n.slice(n.indexOf(i)).slice(i.length);
          return c || !i ? (0, r.langString)(c, t.language) : (0, r.string)(c);
        }).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.RDF_LANG_STRING], () => (t, e) => {
          if (t.language !== e.language)
            throw new r.IncompatibleLanguageOperation(t, e);
          const [n, i] = [t.typedValue, e.typedValue], c = n.slice(n.indexOf(i)).slice(i.length);
          return c || !i ? (0, r.langString)(c, t.language) : (0, r.string)(c);
        }).collect()
      });
    }
  };
  return q_.TermFunctionStrAfter = o, q_;
}
var Dq;
function Cfe() {
  if (Dq) return C_;
  Dq = 1, Object.defineProperty(C_, "__esModule", { value: !0 }), C_.ActorFunctionFactoryTermStrAfter = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Mfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRAFTER],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrAfter();
    }
  };
  return C_.ActorFunctionFactoryTermStrAfter = a, C_;
}
var Lq;
function qfe() {
  return Lq || (Lq = 1, function(u) {
    var r = xc && xc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xc && xc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Cfe(), u);
  }(xc)), xc;
}
var Ic = {}, B_ = {}, $_ = {}, jq;
function Bfe() {
  if (jq) return $_;
  jq = 1, Object.defineProperty($_, "__esModule", { value: !0 }), $_.TermFunctionStrBefore = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.STRBEFORE,
        overloads: (0, r.declare)(r.SparqlOperator.STRBEFORE).onBinaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.string)(t.slice(0, Math.max(0, t.indexOf(e))))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.XSD_STRING], () => (t, e) => {
          const [n, i] = [t.typedValue, e.typedValue], c = t.typedValue.slice(0, Math.max(0, n.indexOf(i)));
          return c || !i ? (0, r.langString)(c, t.language) : (0, r.string)(c);
        }).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.RDF_LANG_STRING], () => (t, e) => {
          if (t.language !== e.language)
            throw new r.IncompatibleLanguageOperation(t, e);
          const [n, i] = [t.typedValue, e.typedValue], c = t.typedValue.slice(0, Math.max(0, n.indexOf(i)));
          return c || !i ? (0, r.langString)(c, t.language) : (0, r.string)(c);
        }).collect()
      });
    }
  };
  return $_.TermFunctionStrBefore = o, $_;
}
var Mq;
function $fe() {
  if (Mq) return B_;
  Mq = 1, Object.defineProperty(B_, "__esModule", { value: !0 }), B_.ActorFunctionFactoryTermStrBefore = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Bfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRBEFORE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrBefore();
    }
  };
  return B_.ActorFunctionFactoryTermStrBefore = a, B_;
}
var Cq;
function Ufe() {
  return Cq || (Cq = 1, function(u) {
    var r = Ic && Ic.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ic && Ic.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ $fe(), u);
  }(Ic)), Ic;
}
var Rc = {}, U_ = {}, V_ = {}, qq;
function Vfe() {
  if (qq) return V_;
  qq = 1, Object.defineProperty(V_, "__esModule", { value: !0 }), V_.TermFunctionStrDt = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: o.SparqlOperator.STRDT,
        overloads: (0, o.declare)(o.SparqlOperator.STRDT).set([o.TypeURL.XSD_STRING, "namedNode"], (e) => ([n, i]) => {
          const c = e.context.getSafe(r.KeysInitQuery.dataFactory), s = c.literal(n.typedValue, c.namedNode(i.value));
          return new o.TermTransformer(e.context.getSafe(r.KeysExpressionEvaluator.superTypeProvider)).transformLiteral(s);
        }).collect()
      });
    }
  };
  return V_.TermFunctionStrDt = a, V_;
}
var Bq;
function Qfe() {
  if (Bq) return U_;
  Bq = 1, Object.defineProperty(U_, "__esModule", { value: !0 }), U_.ActorFunctionFactoryTermStrDt = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Vfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRDT],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrDt();
    }
  };
  return U_.ActorFunctionFactoryTermStrDt = a, U_;
}
var $q;
function Hfe() {
  return $q || ($q = 1, function(u) {
    var r = Rc && Rc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Rc && Rc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Qfe(), u);
  }(Rc)), Rc;
}
var Fc = {}, Q_ = {}, H_ = {}, Uq;
function Gfe() {
  if (Uq) return H_;
  Uq = 1, Object.defineProperty(H_, "__esModule", { value: !0 }), H_.TermFunctionStrEnds = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.STRENDS,
        overloads: (0, r.declare)(r.SparqlOperator.STRENDS).onBinaryTyped([r.TypeAlias.SPARQL_STRINGLY, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.bool)(t.endsWith(e))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.RDF_LANG_STRING], () => (t, e) => {
          if (t.language !== e.language)
            throw new r.IncompatibleLanguageOperation(t, e);
          return (0, r.bool)(t.typedValue.endsWith(e.typedValue));
        }).collect()
      });
    }
  };
  return H_.TermFunctionStrEnds = o, H_;
}
var Vq;
function zfe() {
  if (Vq) return Q_;
  Vq = 1, Object.defineProperty(Q_, "__esModule", { value: !0 }), Q_.ActorFunctionFactoryTermStrEnds = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Gfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRENDS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrEnds();
    }
  };
  return Q_.ActorFunctionFactoryTermStrEnds = a, Q_;
}
var Qq;
function kfe() {
  return Qq || (Qq = 1, function(u) {
    var r = Fc && Fc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Fc && Fc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ zfe(), u);
  }(Fc)), Fc;
}
var Nc = {}, G_ = {}, z_ = {}, Hq;
function Xfe() {
  if (Hq) return z_;
  Hq = 1, Object.defineProperty(z_, "__esModule", { value: !0 }), z_.TermFunctionStrLang = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.STRLANG,
        overloads: (0, r.declare)(r.SparqlOperator.STRLANG).onBinaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_STRING], () => (t, e) => new r.LangStringLiteral(t, e.toLowerCase())).collect()
      });
    }
  };
  return z_.TermFunctionStrLang = o, z_;
}
var Gq;
function Jfe() {
  if (Gq) return G_;
  Gq = 1, Object.defineProperty(G_, "__esModule", { value: !0 }), G_.ActorFunctionFactoryTermStrLang = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Xfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRLANG],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrLang();
    }
  };
  return G_.ActorFunctionFactoryTermStrLang = a, G_;
}
var zq;
function Kfe() {
  return zq || (zq = 1, function(u) {
    var r = Nc && Nc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Nc && Nc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Jfe(), u);
  }(Nc)), Nc;
}
var Pc = {}, k_ = {}, X_ = {}, kq;
function Wfe() {
  if (kq) return X_;
  kq = 1, Object.defineProperty(X_, "__esModule", { value: !0 }), X_.TermFunctionStrLen = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.STRLEN,
        overloads: (0, r.declare)(r.SparqlOperator.STRLEN).onStringly1(() => (t) => (0, r.integer)([...t.typedValue].length)).collect()
      });
    }
  };
  return X_.TermFunctionStrLen = o, X_;
}
var Xq;
function Yfe() {
  if (Xq) return k_;
  Xq = 1, Object.defineProperty(k_, "__esModule", { value: !0 }), k_.ActorFunctionFactoryTermStrLen = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Wfe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRLEN],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrLen();
    }
  };
  return k_.ActorFunctionFactoryTermStrLen = a, k_;
}
var Jq;
function Zfe() {
  return Jq || (Jq = 1, function(u) {
    var r = Pc && Pc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Pc && Pc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Yfe(), u);
  }(Pc)), Pc;
}
var Dc = {}, J_ = {}, K_ = {}, Kq;
function e0e() {
  if (Kq) return K_;
  Kq = 1, Object.defineProperty(K_, "__esModule", { value: !0 }), K_.TermFunctionStrStarts = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: r.SparqlOperator.STRSTARTS,
        overloads: (0, r.declare)(r.SparqlOperator.STRSTARTS).onBinaryTyped([r.TypeAlias.SPARQL_STRINGLY, r.TypeURL.XSD_STRING], () => (t, e) => (0, r.bool)(t.startsWith(e))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.RDF_LANG_STRING], () => (t, e) => {
          if (t.language !== e.language)
            throw new r.IncompatibleLanguageOperation(t, e);
          return (0, r.bool)(t.typedValue.startsWith(e.typedValue));
        }).collect()
      });
    }
  };
  return K_.TermFunctionStrStarts = o, K_;
}
var Wq;
function t0e() {
  if (Wq) return J_;
  Wq = 1, Object.defineProperty(J_, "__esModule", { value: !0 }), J_.ActorFunctionFactoryTermStrStarts = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ e0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRSTARTS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrStarts();
    }
  };
  return J_.ActorFunctionFactoryTermStrStarts = a, J_;
}
var Yq;
function r0e() {
  return Yq || (Yq = 1, function(u) {
    var r = Dc && Dc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Dc && Dc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ t0e(), u);
  }(Dc)), Dc;
}
var Lc = {}, W_ = {}, Y_ = {}, WE = {}, N6 = {}, Zq;
function n0e() {
  return Zq || (Zq = 1, Object.defineProperty(N6, "__esModule", { value: !0 }), N6.default = "ffffffff-ffff-ffff-ffff-ffffffffffff"), N6;
}
var P6 = {}, eB;
function i0e() {
  return eB || (eB = 1, Object.defineProperty(P6, "__esModule", { value: !0 }), P6.default = "00000000-0000-0000-0000-000000000000"), P6;
}
var D6 = {}, L6 = {}, j6 = {}, tB;
function a0e() {
  return tB || (tB = 1, Object.defineProperty(j6, "__esModule", { value: !0 }), j6.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i), j6;
}
var rB;
function o4() {
  if (rB) return L6;
  rB = 1, Object.defineProperty(L6, "__esModule", { value: !0 });
  const u = a0e();
  function r(o) {
    return typeof o == "string" && u.default.test(o);
  }
  return L6.default = r, L6;
}
var nB;
function s4() {
  if (nB) return D6;
  nB = 1, Object.defineProperty(D6, "__esModule", { value: !0 });
  const u = o4();
  function r(o) {
    if (!(0, u.default)(o))
      throw TypeError("Invalid UUID");
    let a;
    return Uint8Array.of((a = parseInt(o.slice(0, 8), 16)) >>> 24, a >>> 16 & 255, a >>> 8 & 255, a & 255, (a = parseInt(o.slice(9, 13), 16)) >>> 8, a & 255, (a = parseInt(o.slice(14, 18), 16)) >>> 8, a & 255, (a = parseInt(o.slice(19, 23), 16)) >>> 8, a & 255, (a = parseInt(o.slice(24, 36), 16)) / 1099511627776 & 255, a / 4294967296 & 255, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a & 255);
  }
  return D6.default = r, D6;
}
var S0 = {}, iB;
function au() {
  if (iB) return S0;
  iB = 1, Object.defineProperty(S0, "__esModule", { value: !0 }), S0.unsafeStringify = void 0;
  const u = o4(), r = [];
  for (let t = 0; t < 256; ++t)
    r.push((t + 256).toString(16).slice(1));
  function o(t, e = 0) {
    return (r[t[e + 0]] + r[t[e + 1]] + r[t[e + 2]] + r[t[e + 3]] + "-" + r[t[e + 4]] + r[t[e + 5]] + "-" + r[t[e + 6]] + r[t[e + 7]] + "-" + r[t[e + 8]] + r[t[e + 9]] + "-" + r[t[e + 10]] + r[t[e + 11]] + r[t[e + 12]] + r[t[e + 13]] + r[t[e + 14]] + r[t[e + 15]]).toLowerCase();
  }
  S0.unsafeStringify = o;
  function a(t, e = 0) {
    const n = o(t, e);
    if (!(0, u.default)(n))
      throw TypeError("Stringified UUID is invalid");
    return n;
  }
  return S0.default = a, S0;
}
var A0 = {}, M6 = {}, aB;
function Q8() {
  if (aB) return M6;
  aB = 1, Object.defineProperty(M6, "__esModule", { value: !0 });
  let u;
  const r = new Uint8Array(16);
  function o() {
    if (!u) {
      if (typeof crypto > "u" || !crypto.getRandomValues)
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      u = crypto.getRandomValues.bind(crypto);
    }
    return u(r);
  }
  return M6.default = o, M6;
}
var uB;
function DY() {
  if (uB) return A0;
  uB = 1, Object.defineProperty(A0, "__esModule", { value: !0 }), A0.updateV1State = void 0;
  const u = Q8(), r = au(), o = {};
  function a(n, i, c) {
    var l;
    let s;
    const d = (n == null ? void 0 : n._v6) ?? !1;
    if (n) {
      const f = Object.keys(n);
      f.length === 1 && f[0] === "_v6" && (n = void 0);
    }
    if (n)
      s = e(n.random ?? ((l = n.rng) == null ? void 0 : l.call(n)) ?? (0, u.default)(), n.msecs, n.nsecs, n.clockseq, n.node, i, c);
    else {
      const f = Date.now(), h = (0, u.default)();
      t(o, f, h), s = e(h, o.msecs, o.nsecs, d ? void 0 : o.clockseq, d ? void 0 : o.node, i, c);
    }
    return i ?? (0, r.unsafeStringify)(s);
  }
  function t(n, i, c) {
    return n.msecs ?? (n.msecs = -1 / 0), n.nsecs ?? (n.nsecs = 0), i === n.msecs ? (n.nsecs++, n.nsecs >= 1e4 && (n.node = void 0, n.nsecs = 0)) : i > n.msecs ? n.nsecs = 0 : i < n.msecs && (n.node = void 0), n.node || (n.node = c.slice(10, 16), n.node[0] |= 1, n.clockseq = (c[8] << 8 | c[9]) & 16383), n.msecs = i, n;
  }
  A0.updateV1State = t;
  function e(n, i, c, s, d, l, f = 0) {
    if (n.length < 16)
      throw new Error("Random bytes length must be >= 16");
    if (!l)
      l = new Uint8Array(16), f = 0;
    else if (f < 0 || f + 16 > l.length)
      throw new RangeError(`UUID byte range ${f}:${f + 15} is out of buffer bounds`);
    i ?? (i = Date.now()), c ?? (c = 0), s ?? (s = (n[8] << 8 | n[9]) & 16383), d ?? (d = n.slice(10, 16)), i += 122192928e5;
    const h = ((i & 268435455) * 1e4 + c) % 4294967296;
    l[f++] = h >>> 24 & 255, l[f++] = h >>> 16 & 255, l[f++] = h >>> 8 & 255, l[f++] = h & 255;
    const p = i / 4294967296 * 1e4 & 268435455;
    l[f++] = p >>> 8 & 255, l[f++] = p & 255, l[f++] = p >>> 24 & 15 | 16, l[f++] = p >>> 16 & 255, l[f++] = s >>> 8 | 128, l[f++] = s & 255;
    for (let b = 0; b < 6; ++b)
      l[f++] = d[b];
    return l;
  }
  return A0.default = a, A0;
}
var C6 = {}, oB;
function LY() {
  if (oB) return C6;
  oB = 1, Object.defineProperty(C6, "__esModule", { value: !0 });
  const u = s4(), r = au();
  function o(t) {
    const e = typeof t == "string" ? (0, u.default)(t) : t, n = a(e);
    return typeof t == "string" ? (0, r.unsafeStringify)(n) : n;
  }
  C6.default = o;
  function a(t) {
    return Uint8Array.of((t[6] & 15) << 4 | t[7] >> 4 & 15, (t[7] & 15) << 4 | (t[4] & 240) >> 4, (t[4] & 15) << 4 | (t[5] & 240) >> 4, (t[5] & 15) << 4 | (t[0] & 240) >> 4, (t[0] & 15) << 4 | (t[1] & 240) >> 4, (t[1] & 15) << 4 | (t[2] & 240) >> 4, 96 | t[2] & 15, t[3], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
  }
  return C6;
}
var YE = {}, q6 = {}, sB;
function u0e() {
  if (sB) return q6;
  sB = 1, Object.defineProperty(q6, "__esModule", { value: !0 });
  function u(f) {
    const h = t(f), p = a(h, f.length * 8);
    return r(p);
  }
  function r(f) {
    const h = new Uint8Array(f.length * 4);
    for (let p = 0; p < f.length * 4; p++)
      h[p] = f[p >> 2] >>> p % 4 * 8 & 255;
    return h;
  }
  function o(f) {
    return (f + 64 >>> 9 << 4) + 14 + 1;
  }
  function a(f, h) {
    const p = new Uint32Array(o(h)).fill(0);
    p.set(f), p[h >> 5] |= 128 << h % 32, p[p.length - 1] = h, f = p;
    let b = 1732584193, _ = -271733879, y = -1732584194, m = 271733878;
    for (let g = 0; g < f.length; g += 16) {
      const T = b, v = _, E = y, R = m;
      b = c(b, _, y, m, f[g], 7, -680876936), m = c(m, b, _, y, f[g + 1], 12, -389564586), y = c(y, m, b, _, f[g + 2], 17, 606105819), _ = c(_, y, m, b, f[g + 3], 22, -1044525330), b = c(b, _, y, m, f[g + 4], 7, -176418897), m = c(m, b, _, y, f[g + 5], 12, 1200080426), y = c(y, m, b, _, f[g + 6], 17, -1473231341), _ = c(_, y, m, b, f[g + 7], 22, -45705983), b = c(b, _, y, m, f[g + 8], 7, 1770035416), m = c(m, b, _, y, f[g + 9], 12, -1958414417), y = c(y, m, b, _, f[g + 10], 17, -42063), _ = c(_, y, m, b, f[g + 11], 22, -1990404162), b = c(b, _, y, m, f[g + 12], 7, 1804603682), m = c(m, b, _, y, f[g + 13], 12, -40341101), y = c(y, m, b, _, f[g + 14], 17, -1502002290), _ = c(_, y, m, b, f[g + 15], 22, 1236535329), b = s(b, _, y, m, f[g + 1], 5, -165796510), m = s(m, b, _, y, f[g + 6], 9, -1069501632), y = s(y, m, b, _, f[g + 11], 14, 643717713), _ = s(_, y, m, b, f[g], 20, -373897302), b = s(b, _, y, m, f[g + 5], 5, -701558691), m = s(m, b, _, y, f[g + 10], 9, 38016083), y = s(y, m, b, _, f[g + 15], 14, -660478335), _ = s(_, y, m, b, f[g + 4], 20, -405537848), b = s(b, _, y, m, f[g + 9], 5, 568446438), m = s(m, b, _, y, f[g + 14], 9, -1019803690), y = s(y, m, b, _, f[g + 3], 14, -187363961), _ = s(_, y, m, b, f[g + 8], 20, 1163531501), b = s(b, _, y, m, f[g + 13], 5, -1444681467), m = s(m, b, _, y, f[g + 2], 9, -51403784), y = s(y, m, b, _, f[g + 7], 14, 1735328473), _ = s(_, y, m, b, f[g + 12], 20, -1926607734), b = d(b, _, y, m, f[g + 5], 4, -378558), m = d(m, b, _, y, f[g + 8], 11, -2022574463), y = d(y, m, b, _, f[g + 11], 16, 1839030562), _ = d(_, y, m, b, f[g + 14], 23, -35309556), b = d(b, _, y, m, f[g + 1], 4, -1530992060), m = d(m, b, _, y, f[g + 4], 11, 1272893353), y = d(y, m, b, _, f[g + 7], 16, -155497632), _ = d(_, y, m, b, f[g + 10], 23, -1094730640), b = d(b, _, y, m, f[g + 13], 4, 681279174), m = d(m, b, _, y, f[g], 11, -358537222), y = d(y, m, b, _, f[g + 3], 16, -722521979), _ = d(_, y, m, b, f[g + 6], 23, 76029189), b = d(b, _, y, m, f[g + 9], 4, -640364487), m = d(m, b, _, y, f[g + 12], 11, -421815835), y = d(y, m, b, _, f[g + 15], 16, 530742520), _ = d(_, y, m, b, f[g + 2], 23, -995338651), b = l(b, _, y, m, f[g], 6, -198630844), m = l(m, b, _, y, f[g + 7], 10, 1126891415), y = l(y, m, b, _, f[g + 14], 15, -1416354905), _ = l(_, y, m, b, f[g + 5], 21, -57434055), b = l(b, _, y, m, f[g + 12], 6, 1700485571), m = l(m, b, _, y, f[g + 3], 10, -1894986606), y = l(y, m, b, _, f[g + 10], 15, -1051523), _ = l(_, y, m, b, f[g + 1], 21, -2054922799), b = l(b, _, y, m, f[g + 8], 6, 1873313359), m = l(m, b, _, y, f[g + 15], 10, -30611744), y = l(y, m, b, _, f[g + 6], 15, -1560198380), _ = l(_, y, m, b, f[g + 13], 21, 1309151649), b = l(b, _, y, m, f[g + 4], 6, -145523070), m = l(m, b, _, y, f[g + 11], 10, -1120210379), y = l(y, m, b, _, f[g + 2], 15, 718787259), _ = l(_, y, m, b, f[g + 9], 21, -343485551), b = e(b, T), _ = e(_, v), y = e(y, E), m = e(m, R);
    }
    return Uint32Array.of(b, _, y, m);
  }
  function t(f) {
    if (f.length === 0)
      return new Uint32Array();
    const h = new Uint32Array(o(f.length * 8)).fill(0);
    for (let p = 0; p < f.length; p++)
      h[p >> 2] |= (f[p] & 255) << p % 4 * 8;
    return h;
  }
  function e(f, h) {
    const p = (f & 65535) + (h & 65535);
    return (f >> 16) + (h >> 16) + (p >> 16) << 16 | p & 65535;
  }
  function n(f, h) {
    return f << h | f >>> 32 - h;
  }
  function i(f, h, p, b, _, y) {
    return e(n(e(e(h, f), e(b, y)), _), p);
  }
  function c(f, h, p, b, _, y, m) {
    return i(h & p | ~h & b, f, h, _, y, m);
  }
  function s(f, h, p, b, _, y, m) {
    return i(h & b | p & ~b, f, h, _, y, m);
  }
  function d(f, h, p, b, _, y, m) {
    return i(h ^ p ^ b, f, h, _, y, m);
  }
  function l(f, h, p, b, _, y, m) {
    return i(p ^ (h | ~b), f, h, _, y, m);
  }
  return q6.default = u, q6;
}
var xi = {}, cB;
function xS() {
  if (cB) return xi;
  cB = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.URL = xi.DNS = xi.stringToBytes = void 0;
  const u = s4(), r = au();
  function o(t) {
    t = unescape(encodeURIComponent(t));
    const e = new Uint8Array(t.length);
    for (let n = 0; n < t.length; ++n)
      e[n] = t.charCodeAt(n);
    return e;
  }
  xi.stringToBytes = o, xi.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", xi.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function a(t, e, n, i, c, s) {
    const d = typeof n == "string" ? o(n) : n, l = typeof i == "string" ? (0, u.default)(i) : i;
    if (typeof i == "string" && (i = (0, u.default)(i)), (i == null ? void 0 : i.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let f = new Uint8Array(16 + d.length);
    if (f.set(l), f.set(d, l.length), f = e(f), f[6] = f[6] & 15 | t, f[8] = f[8] & 63 | 128, c) {
      s = s || 0;
      for (let h = 0; h < 16; ++h)
        c[s + h] = f[h];
      return c;
    }
    return (0, r.unsafeStringify)(f);
  }
  return xi.default = a, xi;
}
var dB;
function o0e() {
  return dB || (dB = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.URL = u.DNS = void 0;
    const r = u0e(), o = xS();
    var a = xS();
    Object.defineProperty(u, "DNS", { enumerable: !0, get: function() {
      return a.DNS;
    } }), Object.defineProperty(u, "URL", { enumerable: !0, get: function() {
      return a.URL;
    } });
    function t(e, n, i, c) {
      return (0, o.default)(48, r.default, e, n, i, c);
    }
    t.DNS = o.DNS, t.URL = o.URL, u.default = t;
  }(YE)), YE;
}
var B6 = {}, $6 = {}, lB;
function s0e() {
  if (lB) return $6;
  lB = 1, Object.defineProperty($6, "__esModule", { value: !0 });
  const u = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  return $6.default = { randomUUID: u }, $6;
}
var fB;
function c0e() {
  if (fB) return B6;
  fB = 1, Object.defineProperty(B6, "__esModule", { value: !0 });
  const u = s0e(), r = Q8(), o = au();
  function a(t, e, n) {
    var c;
    if (u.default.randomUUID && !e && !t)
      return u.default.randomUUID();
    t = t || {};
    const i = t.random ?? ((c = t.rng) == null ? void 0 : c.call(t)) ?? (0, r.default)();
    if (i.length < 16)
      throw new Error("Random bytes length must be >= 16");
    if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, e) {
      if (n = n || 0, n < 0 || n + 16 > e.length)
        throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`);
      for (let s = 0; s < 16; ++s)
        e[n + s] = i[s];
      return e;
    }
    return (0, o.unsafeStringify)(i);
  }
  return B6.default = a, B6;
}
var ZE = {}, U6 = {}, hB;
function d0e() {
  if (hB) return U6;
  hB = 1, Object.defineProperty(U6, "__esModule", { value: !0 });
  function u(a, t, e, n) {
    switch (a) {
      case 0:
        return t & e ^ ~t & n;
      case 1:
        return t ^ e ^ n;
      case 2:
        return t & e ^ t & n ^ e & n;
      case 3:
        return t ^ e ^ n;
    }
  }
  function r(a, t) {
    return a << t | a >>> 32 - t;
  }
  function o(a) {
    const t = [1518500249, 1859775393, 2400959708, 3395469782], e = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], n = new Uint8Array(a.length + 1);
    n.set(a), n[a.length] = 128, a = n;
    const i = a.length / 4 + 2, c = Math.ceil(i / 16), s = new Array(c);
    for (let d = 0; d < c; ++d) {
      const l = new Uint32Array(16);
      for (let f = 0; f < 16; ++f)
        l[f] = a[d * 64 + f * 4] << 24 | a[d * 64 + f * 4 + 1] << 16 | a[d * 64 + f * 4 + 2] << 8 | a[d * 64 + f * 4 + 3];
      s[d] = l;
    }
    s[c - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), s[c - 1][14] = Math.floor(s[c - 1][14]), s[c - 1][15] = (a.length - 1) * 8 & 4294967295;
    for (let d = 0; d < c; ++d) {
      const l = new Uint32Array(80);
      for (let y = 0; y < 16; ++y)
        l[y] = s[d][y];
      for (let y = 16; y < 80; ++y)
        l[y] = r(l[y - 3] ^ l[y - 8] ^ l[y - 14] ^ l[y - 16], 1);
      let f = e[0], h = e[1], p = e[2], b = e[3], _ = e[4];
      for (let y = 0; y < 80; ++y) {
        const m = Math.floor(y / 20), g = r(f, 5) + u(m, h, p, b) + _ + t[m] + l[y] >>> 0;
        _ = b, b = p, p = r(h, 30) >>> 0, h = f, f = g;
      }
      e[0] = e[0] + f >>> 0, e[1] = e[1] + h >>> 0, e[2] = e[2] + p >>> 0, e[3] = e[3] + b >>> 0, e[4] = e[4] + _ >>> 0;
    }
    return Uint8Array.of(e[0] >> 24, e[0] >> 16, e[0] >> 8, e[0], e[1] >> 24, e[1] >> 16, e[1] >> 8, e[1], e[2] >> 24, e[2] >> 16, e[2] >> 8, e[2], e[3] >> 24, e[3] >> 16, e[3] >> 8, e[3], e[4] >> 24, e[4] >> 16, e[4] >> 8, e[4]);
  }
  return U6.default = o, U6;
}
var pB;
function l0e() {
  return pB || (pB = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.URL = u.DNS = void 0;
    const r = d0e(), o = xS();
    var a = xS();
    Object.defineProperty(u, "DNS", { enumerable: !0, get: function() {
      return a.DNS;
    } }), Object.defineProperty(u, "URL", { enumerable: !0, get: function() {
      return a.URL;
    } });
    function t(e, n, i, c) {
      return (0, o.default)(80, r.default, e, n, i, c);
    }
    t.DNS = o.DNS, t.URL = o.URL, u.default = t;
  }(ZE)), ZE;
}
var V6 = {}, bB;
function f0e() {
  if (bB) return V6;
  bB = 1, Object.defineProperty(V6, "__esModule", { value: !0 });
  const u = au(), r = DY(), o = LY();
  function a(t, e, n) {
    t ?? (t = {}), n ?? (n = 0);
    let i = (0, r.default)({ ...t, _v6: !0 }, new Uint8Array(16));
    if (i = (0, o.default)(i), e) {
      for (let c = 0; c < 16; c++)
        e[n + c] = i[c];
      return e;
    }
    return (0, u.unsafeStringify)(i);
  }
  return V6.default = a, V6;
}
var Q6 = {}, yB;
function h0e() {
  if (yB) return Q6;
  yB = 1, Object.defineProperty(Q6, "__esModule", { value: !0 });
  const u = s4(), r = au();
  function o(t) {
    const e = typeof t == "string" ? (0, u.default)(t) : t, n = a(e);
    return typeof t == "string" ? (0, r.unsafeStringify)(n) : n;
  }
  Q6.default = o;
  function a(t) {
    return Uint8Array.of((t[3] & 15) << 4 | t[4] >> 4 & 15, (t[4] & 15) << 4 | (t[5] & 240) >> 4, (t[5] & 15) << 4 | t[6] & 15, t[7], (t[1] & 15) << 4 | (t[2] & 240) >> 4, (t[2] & 15) << 4 | (t[3] & 240) >> 4, 16 | (t[0] & 240) >> 4, (t[0] & 15) << 4 | (t[1] & 240) >> 4, t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
  }
  return Q6;
}
var E0 = {}, _B;
function p0e() {
  if (_B) return E0;
  _B = 1, Object.defineProperty(E0, "__esModule", { value: !0 }), E0.updateV7State = void 0;
  const u = Q8(), r = au(), o = {};
  function a(n, i, c) {
    var d;
    let s;
    if (n)
      s = e(n.random ?? ((d = n.rng) == null ? void 0 : d.call(n)) ?? (0, u.default)(), n.msecs, n.seq, i, c);
    else {
      const l = Date.now(), f = (0, u.default)();
      t(o, l, f), s = e(f, o.msecs, o.seq, i, c);
    }
    return i ?? (0, r.unsafeStringify)(s);
  }
  function t(n, i, c) {
    return n.msecs ?? (n.msecs = -1 / 0), n.seq ?? (n.seq = 0), i > n.msecs ? (n.seq = c[6] << 23 | c[7] << 16 | c[8] << 8 | c[9], n.msecs = i) : (n.seq = n.seq + 1 | 0, n.seq === 0 && n.msecs++), n;
  }
  E0.updateV7State = t;
  function e(n, i, c, s, d = 0) {
    if (n.length < 16)
      throw new Error("Random bytes length must be >= 16");
    if (!s)
      s = new Uint8Array(16), d = 0;
    else if (d < 0 || d + 16 > s.length)
      throw new RangeError(`UUID byte range ${d}:${d + 15} is out of buffer bounds`);
    return i ?? (i = Date.now()), c ?? (c = n[6] * 127 << 24 | n[7] << 16 | n[8] << 8 | n[9]), s[d++] = i / 1099511627776 & 255, s[d++] = i / 4294967296 & 255, s[d++] = i / 16777216 & 255, s[d++] = i / 65536 & 255, s[d++] = i / 256 & 255, s[d++] = i & 255, s[d++] = 112 | c >>> 28 & 15, s[d++] = c >>> 20 & 255, s[d++] = 128 | c >>> 14 & 63, s[d++] = c >>> 6 & 255, s[d++] = c << 2 & 255 | n[10] & 3, s[d++] = n[11], s[d++] = n[12], s[d++] = n[13], s[d++] = n[14], s[d++] = n[15], s;
  }
  return E0.default = a, E0;
}
var H6 = {}, gB;
function b0e() {
  if (gB) return H6;
  gB = 1, Object.defineProperty(H6, "__esModule", { value: !0 });
  const u = o4();
  function r(o) {
    if (!(0, u.default)(o))
      throw TypeError("Invalid UUID");
    return parseInt(o.slice(14, 15), 16);
  }
  return H6.default = r, H6;
}
var mB;
function jY() {
  return mB || (mB = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.version = u.validate = u.v7 = u.v6ToV1 = u.v6 = u.v5 = u.v4 = u.v3 = u.v1ToV6 = u.v1 = u.stringify = u.parse = u.NIL = u.MAX = void 0;
    var r = n0e();
    Object.defineProperty(u, "MAX", { enumerable: !0, get: function() {
      return r.default;
    } });
    var o = i0e();
    Object.defineProperty(u, "NIL", { enumerable: !0, get: function() {
      return o.default;
    } });
    var a = s4();
    Object.defineProperty(u, "parse", { enumerable: !0, get: function() {
      return a.default;
    } });
    var t = au();
    Object.defineProperty(u, "stringify", { enumerable: !0, get: function() {
      return t.default;
    } });
    var e = DY();
    Object.defineProperty(u, "v1", { enumerable: !0, get: function() {
      return e.default;
    } });
    var n = LY();
    Object.defineProperty(u, "v1ToV6", { enumerable: !0, get: function() {
      return n.default;
    } });
    var i = o0e();
    Object.defineProperty(u, "v3", { enumerable: !0, get: function() {
      return i.default;
    } });
    var c = c0e();
    Object.defineProperty(u, "v4", { enumerable: !0, get: function() {
      return c.default;
    } });
    var s = l0e();
    Object.defineProperty(u, "v5", { enumerable: !0, get: function() {
      return s.default;
    } });
    var d = f0e();
    Object.defineProperty(u, "v6", { enumerable: !0, get: function() {
      return d.default;
    } });
    var l = h0e();
    Object.defineProperty(u, "v6ToV1", { enumerable: !0, get: function() {
      return l.default;
    } });
    var f = p0e();
    Object.defineProperty(u, "v7", { enumerable: !0, get: function() {
      return f.default;
    } });
    var h = o4();
    Object.defineProperty(u, "validate", { enumerable: !0, get: function() {
      return h.default;
    } });
    var p = b0e();
    Object.defineProperty(u, "version", { enumerable: !0, get: function() {
      return p.default;
    } });
  }(WE)), WE;
}
var vB;
function y0e() {
  if (vB) return Y_;
  vB = 1, Object.defineProperty(Y_, "__esModule", { value: !0 }), Y_.TermFunctionStrUuid = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ jY();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 0,
        operator: r.SparqlOperator.STRUUID,
        overloads: (0, r.declare)(r.SparqlOperator.STRUUID).set([], () => () => (0, r.string)(o.v4())).collect()
      });
    }
  };
  return Y_.TermFunctionStrUuid = a, Y_;
}
var TB;
function _0e() {
  if (TB) return W_;
  TB = 1, Object.defineProperty(W_, "__esModule", { value: !0 }), W_.ActorFunctionFactoryTermStrUuid = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ y0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STRUUID],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStrUuid();
    }
  };
  return W_.ActorFunctionFactoryTermStrUuid = a, W_;
}
var wB;
function g0e() {
  return wB || (wB = 1, function(u) {
    var r = Lc && Lc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Lc && Lc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _0e(), u);
  }(Lc)), Lc;
}
var jc = {}, Z_ = {}, eg = {}, SB;
function m0e() {
  if (SB) return eg;
  SB = 1, Object.defineProperty(eg, "__esModule", { value: !0 }), eg.TermFunctionStr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.STR,
        overloads: (0, r.declare)(r.SparqlOperator.STR).onTerm1(() => (t) => (0, r.string)(t.str())).collect()
      });
    }
  };
  return eg.TermFunctionStr = o, eg;
}
var AB;
function v0e() {
  if (AB) return Z_;
  AB = 1, Object.defineProperty(Z_, "__esModule", { value: !0 }), Z_.ActorFunctionFactoryTermStr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ m0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.STR],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionStr();
    }
  };
  return Z_.ActorFunctionFactoryTermStr = a, Z_;
}
var EB;
function T0e() {
  return EB || (EB = 1, function(u) {
    var r = jc && jc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = jc && jc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ v0e(), u);
  }(jc)), jc;
}
var Mc = {}, tg = {}, rg = {}, OB;
function w0e() {
  if (OB) return rg;
  OB = 1, Object.defineProperty(rg, "__esModule", { value: !0 }), rg.TermFunctionSubStr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: [2, 3],
        operator: r.SparqlOperator.SUBSTR,
        overloads: (0, r.declare)(r.SparqlOperator.SUBSTR).onBinaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_INTEGER], () => (t, e) => (0, r.string)([...t].slice(e - 1).join(""))).onBinary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.XSD_INTEGER], () => (t, e) => {
          const n = [...t.typedValue].slice(e.typedValue - 1).join("");
          return (0, r.langString)(n, t.language);
        }).onTernaryTyped([r.TypeURL.XSD_STRING, r.TypeURL.XSD_INTEGER, r.TypeURL.XSD_INTEGER], () => (t, e, n) => (0, r.string)([...t].slice(e - 1, n + e - 1).join(""))).onTernary([r.TypeURL.RDF_LANG_STRING, r.TypeURL.XSD_INTEGER, r.TypeURL.XSD_INTEGER], () => (t, e, n) => {
          const i = [...t.typedValue].slice(e.typedValue - 1, n.typedValue + e.typedValue - 1).join("");
          return (0, r.langString)(i, t.language);
        }).collect()
      });
    }
  };
  return rg.TermFunctionSubStr = o, rg;
}
var xB;
function S0e() {
  if (xB) return tg;
  xB = 1, Object.defineProperty(tg, "__esModule", { value: !0 }), tg.ActorFunctionFactoryTermSubStr = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ w0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SUBSTR],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSubStr();
    }
  };
  return tg.ActorFunctionFactoryTermSubStr = a, tg;
}
var IB;
function A0e() {
  return IB || (IB = 1, function(u) {
    var r = Mc && Mc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Mc && Mc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ S0e(), u);
  }(Mc)), Mc;
}
var Cc = {}, ng = {}, ig = {}, RB;
function E0e() {
  if (RB) return ig;
  RB = 1, Object.defineProperty(ig, "__esModule", { value: !0 }), ig.TermFunctionSubject = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.SUBJECT,
        overloads: (0, r.declare)(r.SparqlOperator.SUBJECT).onQuad1(() => (t) => t.subject).collect()
      });
    }
  };
  return ig.TermFunctionSubject = o, ig;
}
var FB;
function O0e() {
  if (FB) return ng;
  FB = 1, Object.defineProperty(ng, "__esModule", { value: !0 }), ng.ActorFunctionFactoryTermSubject = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ E0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SUBJECT],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSubject();
    }
  };
  return ng.ActorFunctionFactoryTermSubject = a, ng;
}
var NB;
function x0e() {
  return NB || (NB = 1, function(u) {
    var r = Cc && Cc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Cc && Cc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ O0e(), u);
  }(Cc)), Cc;
}
var qc = {}, ag = {}, ug = {}, PB;
function I0e() {
  if (PB) return ug;
  PB = 1, Object.defineProperty(ug, "__esModule", { value: !0 }), ug.TermFunctionSubtraction = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve(), a = u4();
  let t = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 2,
        operator: o.SparqlOperator.SUBTRACTION,
        overloads: (0, o.declare)(o.SparqlOperator.SUBTRACTION).arithmetic(() => (n, i) => new a.BigNumber(n).minus(i).toNumber()).set([o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DATE_TIME], (n) => ([i, c]) => (
          // https://www.w3.org/TR/xpath-functions/#func-subtract-dateTimes;
          new o.DayTimeDurationLiteral((0, o.elapsedDuration)(i.typedValue, c.typedValue, n.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)))
        )).copy({ from: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DATE_TIME], to: [o.TypeURL.XSD_DATE, o.TypeURL.XSD_DATE] }).copy({ from: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DATE_TIME], to: [o.TypeURL.XSD_TIME, o.TypeURL.XSD_TIME] }).set([o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DAY_TIME_DURATION], () => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-dateTime
          new o.DateTimeLiteral((0, o.addDurationToDateTime)(n.typedValue, (0, o.defaultedDurationRepresentation)((0, o.negateDuration)(i.typedValue))))
        )).copy({
          from: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DAY_TIME_DURATION],
          to: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_YEAR_MONTH_DURATION]
        }).set([o.TypeURL.XSD_DATE, o.TypeURL.XSD_DAY_TIME_DURATION], () => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-date
          new o.DateLiteral((0, o.addDurationToDateTime)((0, o.defaultedDateTimeRepresentation)(n.typedValue), (0, o.defaultedDurationRepresentation)((0, o.negateDuration)(i.typedValue))))
        )).copy({
          from: [o.TypeURL.XSD_DATE, o.TypeURL.XSD_DAY_TIME_DURATION],
          to: [o.TypeURL.XSD_DATE, o.TypeURL.XSD_YEAR_MONTH_DURATION]
        }).set([o.TypeURL.XSD_TIME, o.TypeURL.XSD_DAY_TIME_DURATION], () => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-date
          new o.TimeLiteral((0, o.addDurationToDateTime)((0, o.defaultedDateTimeRepresentation)(n.typedValue), (0, o.defaultedDurationRepresentation)((0, o.negateDuration)(i.typedValue))))
        )).collect()
      });
    }
  };
  return ug.TermFunctionSubtraction = t, ug;
}
var DB;
function R0e() {
  if (DB) return ag;
  DB = 1, Object.defineProperty(ag, "__esModule", { value: !0 }), ag.ActorFunctionFactoryTermSubtraction = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ I0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.SUBTRACTION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionSubtraction();
    }
  };
  return ag.ActorFunctionFactoryTermSubtraction = a, ag;
}
var LB;
function F0e() {
  return LB || (LB = 1, function(u) {
    var r = qc && qc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = qc && qc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ R0e(), u);
  }(qc)), qc;
}
var Bc = {}, og = {}, sg = {}, jB;
function N0e() {
  if (jB) return sg;
  jB = 1, Object.defineProperty(sg, "__esModule", { value: !0 }), sg.TermFunctionTimezone = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.TIMEZONE,
        overloads: (0, r.declare)(r.SparqlOperator.TIMEZONE).onDateTime1(() => (t) => {
          const e = {
            hours: t.typedValue.zoneHours,
            minutes: t.typedValue.zoneMinutes
          };
          if (e.hours === void 0 && e.minutes === void 0)
            throw new r.InvalidTimezoneCall(t.str());
          return new r.DayTimeDurationLiteral(e);
        }).copy({ from: [r.TypeURL.XSD_DATE_TIME], to: [r.TypeURL.XSD_DATE] }).copy({ from: [r.TypeURL.XSD_DATE_TIME], to: [r.TypeURL.XSD_TIME] }).collect()
      });
    }
  };
  return sg.TermFunctionTimezone = o, sg;
}
var MB;
function P0e() {
  if (MB) return og;
  MB = 1, Object.defineProperty(og, "__esModule", { value: !0 }), og.ActorFunctionFactoryTermTimezone = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ N0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.TIMEZONE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionTimezone();
    }
  };
  return og.ActorFunctionFactoryTermTimezone = a, og;
}
var CB;
function D0e() {
  return CB || (CB = 1, function(u) {
    var r = Bc && Bc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bc && Bc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ P0e(), u);
  }(Bc)), Bc;
}
var $c = {}, cg = {}, dg = {}, qB;
function L0e() {
  if (qB) return dg;
  qB = 1, Object.defineProperty(dg, "__esModule", { value: !0 }), dg.TermFunctionTriple = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 3,
        operator: r.SparqlOperator.TRIPLE,
        overloads: (0, r.declare)(r.SparqlOperator.TRIPLE).onTerm3((t) => (...e) => new r.Quad(e[0], e[1], e[2], new r.DefaultGraph())).collect()
      });
    }
  };
  return dg.TermFunctionTriple = o, dg;
}
var BB;
function j0e() {
  if (BB) return cg;
  BB = 1, Object.defineProperty(cg, "__esModule", { value: !0 }), cg.ActorFunctionFactoryTermTriple = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ L0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.TRIPLE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionTriple();
    }
  };
  return cg.ActorFunctionFactoryTermTriple = a, cg;
}
var $B;
function M0e() {
  return $B || ($B = 1, function(u) {
    var r = $c && $c.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $c && $c.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ j0e(), u);
  }($c)), $c;
}
var Uc = {}, lg = {}, fg = {}, UB;
function C0e() {
  if (UB) return fg;
  UB = 1, Object.defineProperty(fg, "__esModule", { value: !0 }), fg.TermFunctionTz = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.TZ,
        overloads: (0, r.declare)(r.SparqlOperator.TZ).onDateTime1(() => (t) => (0, r.string)((0, r.extractRawTimeZone)(t.str()))).copy({ from: [r.TypeURL.XSD_DATE_TIME], to: [r.TypeURL.XSD_DATE] }).copy({ from: [r.TypeURL.XSD_DATE_TIME], to: [r.TypeURL.XSD_TIME] }).collect()
      });
    }
  };
  return fg.TermFunctionTz = o, fg;
}
var VB;
function q0e() {
  if (VB) return lg;
  VB = 1, Object.defineProperty(lg, "__esModule", { value: !0 }), lg.ActorFunctionFactoryTermTz = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ C0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.TZ],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionTz();
    }
  };
  return lg.ActorFunctionFactoryTermTz = a, lg;
}
var QB;
function B0e() {
  return QB || (QB = 1, function(u) {
    var r = Uc && Uc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Uc && Uc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ q0e(), u);
  }(Uc)), Uc;
}
var Vc = {}, hg = {}, pg = {}, HB;
function $0e() {
  if (HB) return pg;
  HB = 1, Object.defineProperty(pg, "__esModule", { value: !0 }), pg.TermFunctionUcase = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.UCASE,
        overloads: (0, r.declare)(r.SparqlOperator.UCASE).onString1Typed(() => (t) => (0, r.string)(t.toUpperCase())).onLangString1(() => (t) => (0, r.langString)(t.typedValue.toUpperCase(), t.language)).collect()
      });
    }
  };
  return pg.TermFunctionUcase = o, pg;
}
var GB;
function U0e() {
  if (GB) return hg;
  GB = 1, Object.defineProperty(hg, "__esModule", { value: !0 }), hg.ActorFunctionFactoryTermUcase = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ $0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.UCASE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionUcase();
    }
  };
  return hg.ActorFunctionFactoryTermUcase = a, hg;
}
var zB;
function V0e() {
  return zB || (zB = 1, function(u) {
    var r = Vc && Vc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vc && Vc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ U0e(), u);
  }(Vc)), Vc;
}
var Qc = {}, bg = {}, yg = {}, kB;
function Q0e() {
  if (kB) return yg;
  kB = 1, Object.defineProperty(yg, "__esModule", { value: !0 }), yg.TermFunctionUnaryMinus = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.UMINUS,
        overloads: (0, r.declare)(r.SparqlOperator.UMINUS).numericConverter(() => (t) => -t).collect()
      });
    }
  };
  return yg.TermFunctionUnaryMinus = o, yg;
}
var XB;
function H0e() {
  if (XB) return bg;
  XB = 1, Object.defineProperty(bg, "__esModule", { value: !0 }), bg.ActorFunctionFactoryTermUnaryMinus = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Q0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.UMINUS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionUnaryMinus();
    }
  };
  return bg.ActorFunctionFactoryTermUnaryMinus = a, bg;
}
var JB;
function G0e() {
  return JB || (JB = 1, function(u) {
    var r = Qc && Qc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Qc && Qc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ H0e(), u);
  }(Qc)), Qc;
}
var Hc = {}, _g = {}, gg = {}, KB;
function z0e() {
  if (KB) return gg;
  KB = 1, Object.defineProperty(gg, "__esModule", { value: !0 }), gg.TermFunctionUnaryPlus = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.UPLUS,
        overloads: (0, r.declare)(r.SparqlOperator.UPLUS).numericConverter(() => (t) => t).collect()
      });
    }
  };
  return gg.TermFunctionUnaryPlus = o, gg;
}
var WB;
function k0e() {
  if (WB) return _g;
  WB = 1, Object.defineProperty(_g, "__esModule", { value: !0 }), _g.ActorFunctionFactoryTermUnaryPlus = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ z0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.UPLUS],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionUnaryPlus();
    }
  };
  return _g.ActorFunctionFactoryTermUnaryPlus = a, _g;
}
var YB;
function X0e() {
  return YB || (YB = 1, function(u) {
    var r = Hc && Hc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Hc && Hc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ k0e(), u);
  }(Hc)), Hc;
}
var Gc = {}, mg = {}, vg = {}, ZB;
function J0e() {
  if (ZB) return vg;
  ZB = 1, Object.defineProperty(vg, "__esModule", { value: !0 }), vg.TermFunctionUuid = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ jY();
  let a = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 0,
        operator: r.SparqlOperator.UUID,
        overloads: (0, r.declare)(r.SparqlOperator.UUID).set([], () => () => new r.NamedNode(`urn:uuid:${o.v4()}`)).collect()
      });
    }
  };
  return vg.TermFunctionUuid = a, vg;
}
var e$;
function K0e() {
  if (e$) return mg;
  e$ = 1, Object.defineProperty(mg, "__esModule", { value: !0 }), mg.ActorFunctionFactoryTermUuid = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ J0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.UUID],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionUuid();
    }
  };
  return mg.ActorFunctionFactoryTermUuid = a, mg;
}
var t$;
function W0e() {
  return t$ || (t$ = 1, function(u) {
    var r = Gc && Gc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Gc && Gc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ K0e(), u);
  }(Gc)), Gc;
}
var zc = {}, Tg = {}, wg = {}, r$;
function Y0e() {
  if (r$) return wg;
  r$ = 1, Object.defineProperty(wg, "__esModule", { value: !0 }), wg.TermFunctionXsdToBoolean = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_BOOLEAN,
        overloads: (0, r.declare)(r.TypeURL.XSD_BOOLEAN).onNumeric1(() => (t) => (0, r.bool)(t.coerceEBV()), !0).onUnary(r.TypeURL.XSD_BOOLEAN, () => (t) => (0, r.bool)(t.coerceEBV()), !0).onUnary(r.TypeURL.XSD_STRING, () => (t) => {
          switch (t.str()) {
            case "true":
              return (0, r.bool)(!0);
            case "false":
              return (0, r.bool)(!1);
            case "1":
              return (0, r.bool)(!0);
            case "0":
              return (0, r.bool)(!1);
            default:
              throw new r.CastError(t, r.TypeURL.XSD_BOOLEAN);
          }
        }, !1).collect()
      });
    }
  };
  return wg.TermFunctionXsdToBoolean = o, wg;
}
var n$;
function Z0e() {
  if (n$) return Tg;
  n$ = 1, Object.defineProperty(Tg, "__esModule", { value: !0 }), Tg.ActorFunctionFactoryTermXsdToBoolean = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Y0e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_BOOLEAN],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToBoolean();
    }
  };
  return Tg.ActorFunctionFactoryTermXsdToBoolean = a, Tg;
}
var i$;
function ehe() {
  return i$ || (i$ = 1, function(u) {
    var r = zc && zc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zc && zc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Z0e(), u);
  }(zc)), zc;
}
var kc = {}, Sg = {}, Ag = {}, a$;
function the() {
  if (a$) return Ag;
  a$ = 1, Object.defineProperty(Ag, "__esModule", { value: !0 }), Ag.TermFunctionXsdToDate = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DATE,
        overloads: (0, r.declare)(r.TypeURL.XSD_DATE).onUnary(r.TypeURL.XSD_DATE, () => (t) => new r.DateLiteral(t.typedValue, t.strValue)).onUnary(r.TypeURL.XSD_DATE_TIME, () => (t) => new r.DateLiteral(t.typedValue)).onStringly1(() => (t) => new r.DateLiteral((0, r.parseDate)(t.str()))).collect()
      });
    }
  };
  return Ag.TermFunctionXsdToDate = o, Ag;
}
var u$;
function rhe() {
  if (u$) return Sg;
  u$ = 1, Object.defineProperty(Sg, "__esModule", { value: !0 }), Sg.ActorFunctionFactoryTermXsdToDate = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ the();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DATE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDate();
    }
  };
  return Sg.ActorFunctionFactoryTermXsdToDate = a, Sg;
}
var o$;
function nhe() {
  return o$ || (o$ = 1, function(u) {
    var r = kc && kc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = kc && kc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rhe(), u);
  }(kc)), kc;
}
var Xc = {}, Eg = {}, Og = {}, s$;
function ihe() {
  if (s$) return Og;
  s$ = 1, Object.defineProperty(Og, "__esModule", { value: !0 }), Og.TermFunctionXsdToDatetime = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DATE_TIME,
        overloads: (0, r.declare)(r.TypeURL.XSD_DATE_TIME).onUnary(r.TypeURL.XSD_DATE_TIME, () => (t) => t).onUnary(r.TypeURL.XSD_STRING, () => (t) => (0, r.dateTime)((0, r.parseDateTime)(t.str()), t.str()), !1).onUnary(r.TypeURL.XSD_DATE, () => (t) => new r.DateTimeLiteral({ ...t.typedValue, hours: 0, minutes: 0, seconds: 0 })).collect()
      });
    }
  };
  return Og.TermFunctionXsdToDatetime = o, Og;
}
var c$;
function ahe() {
  if (c$) return Eg;
  c$ = 1, Object.defineProperty(Eg, "__esModule", { value: !0 }), Eg.ActorFunctionFactoryTermXsdToDatetime = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ ihe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DATE_TIME],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDatetime();
    }
  };
  return Eg.ActorFunctionFactoryTermXsdToDatetime = a, Eg;
}
var d$;
function uhe() {
  return d$ || (d$ = 1, function(u) {
    var r = Xc && Xc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xc && Xc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ahe(), u);
  }(Xc)), Xc;
}
var Jc = {}, xg = {}, Ig = {}, l$;
function ohe() {
  if (l$) return Ig;
  l$ = 1, Object.defineProperty(Ig, "__esModule", { value: !0 }), Ig.TermFunctionXsdToDayTimeDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DAY_TIME_DURATION,
        overloads: (0, r.declare)(r.TypeURL.XSD_DAY_TIME_DURATION).onUnary(r.TypeURL.XSD_DURATION, () => (t) => (
          // Copy is needed to make sure the dataType is changed, even when the provided type was a subtype
          new r.DayTimeDurationLiteral((0, r.trimToDayTimeDuration)(t.typedValue))
        )).onStringly1(() => (t) => new r.DayTimeDurationLiteral((0, r.parseDayTimeDuration)(t.str()))).collect()
      });
    }
  };
  return Ig.TermFunctionXsdToDayTimeDuration = o, Ig;
}
var f$;
function she() {
  if (f$) return xg;
  f$ = 1, Object.defineProperty(xg, "__esModule", { value: !0 }), xg.ActorFunctionFactoryTermXsdToDayTimeDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ ohe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DAY_TIME_DURATION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDayTimeDuration();
    }
  };
  return xg.ActorFunctionFactoryTermXsdToDayTimeDuration = a, xg;
}
var h$;
function che() {
  return h$ || (h$ = 1, function(u) {
    var r = Jc && Jc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Jc && Jc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ she(), u);
  }(Jc)), Jc;
}
var Kc = {}, Rg = {}, Fg = {}, p$;
function dhe() {
  if (p$) return Fg;
  p$ = 1, Object.defineProperty(Fg, "__esModule", { value: !0 }), Fg.TermFunctionXsdToDecimal = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DECIMAL,
        overloads: (0, r.declare)(r.TypeURL.XSD_DECIMAL).onNumeric1(() => (t) => {
          const e = (0, r.parseXSDDecimal)(t.str());
          if (e === void 0)
            throw new r.CastError(t, r.TypeURL.XSD_DECIMAL);
          return (0, r.decimal)(e);
        }).onString1(() => (t) => {
          const e = t.str(), n = /^([+-])?(\d+(\.\d+)?)$/u.test(e) ? (0, r.parseXSDDecimal)(e) : void 0;
          if (n === void 0)
            throw new r.CastError(t, r.TypeURL.XSD_DECIMAL);
          return (0, r.decimal)(n);
        }, !1).onBoolean1Typed(() => (t) => (0, r.decimal)(t ? 1 : 0)).collect()
      });
    }
  };
  return Fg.TermFunctionXsdToDecimal = o, Fg;
}
var b$;
function lhe() {
  if (b$) return Rg;
  b$ = 1, Object.defineProperty(Rg, "__esModule", { value: !0 }), Rg.ActorFunctionFactoryTermXsdToDecimal = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ dhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DECIMAL],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDecimal();
    }
  };
  return Rg.ActorFunctionFactoryTermXsdToDecimal = a, Rg;
}
var y$;
function fhe() {
  return y$ || (y$ = 1, function(u) {
    var r = Kc && Kc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Kc && Kc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ lhe(), u);
  }(Kc)), Kc;
}
var Wc = {}, Ng = {}, Pg = {}, _$;
function hhe() {
  if (_$) return Pg;
  _$ = 1, Object.defineProperty(Pg, "__esModule", { value: !0 }), Pg.TermFunctionXsdToDouble = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DOUBLE,
        overloads: (0, r.declare)(r.TypeURL.XSD_DOUBLE).onNumeric1(() => (t) => (0, r.double)(t.typedValue)).onBoolean1Typed(() => (t) => (0, r.double)(t ? 1 : 0)).onUnary(r.TypeURL.XSD_STRING, () => (t) => {
          const e = (0, r.parseXSDFloat)(t.str());
          if (e === void 0)
            throw new r.CastError(t, r.TypeURL.XSD_DOUBLE);
          return (0, r.double)(e);
        }, !1).collect()
      });
    }
  };
  return Pg.TermFunctionXsdToDouble = o, Pg;
}
var g$;
function phe() {
  if (g$) return Ng;
  g$ = 1, Object.defineProperty(Ng, "__esModule", { value: !0 }), Ng.ActorFunctionFactoryTermXsdToDouble = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ hhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DOUBLE],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDouble();
    }
  };
  return Ng.ActorFunctionFactoryTermXsdToDouble = a, Ng;
}
var m$;
function bhe() {
  return m$ || (m$ = 1, function(u) {
    var r = Wc && Wc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Wc && Wc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ phe(), u);
  }(Wc)), Wc;
}
var Yc = {}, Dg = {}, Lg = {}, v$;
function yhe() {
  if (v$) return Lg;
  v$ = 1, Object.defineProperty(Lg, "__esModule", { value: !0 }), Lg.TermFunctionXsdToDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_DAY_TIME_DURATION,
        overloads: (0, r.declare)(r.TypeURL.XSD_DURATION).onUnary(r.TypeURL.XSD_DURATION, () => (t) => (
          // Copy is needed to make sure the dataType is changed, even when the provided type was a subtype
          new r.DurationLiteral(t.typedValue, t.strValue)
        )).onStringly1(() => (t) => new r.DurationLiteral((0, r.parseDuration)(t.str()))).collect()
      });
    }
  };
  return Lg.TermFunctionXsdToDuration = o, Lg;
}
var T$;
function _he() {
  if (T$) return Dg;
  T$ = 1, Object.defineProperty(Dg, "__esModule", { value: !0 }), Dg.ActorFunctionFactoryTermXsdToDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ yhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_DURATION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToDuration();
    }
  };
  return Dg.ActorFunctionFactoryTermXsdToDuration = a, Dg;
}
var w$;
function ghe() {
  return w$ || (w$ = 1, function(u) {
    var r = Yc && Yc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Yc && Yc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _he(), u);
  }(Yc)), Yc;
}
var Zc = {}, jg = {}, Mg = {}, S$;
function mhe() {
  if (S$) return Mg;
  S$ = 1, Object.defineProperty(Mg, "__esModule", { value: !0 }), Mg.TermFunctionXsdToFloat = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_FLOAT,
        overloads: (0, r.declare)(r.TypeURL.XSD_FLOAT).onNumeric1(() => (t) => (0, r.float)(t.typedValue)).onBoolean1Typed(() => (t) => (0, r.float)(t ? 1 : 0)).onUnary(r.TypeURL.XSD_STRING, () => (t) => {
          const e = (0, r.parseXSDFloat)(t.str());
          if (e === void 0)
            throw new r.CastError(t, r.TypeURL.XSD_FLOAT);
          return (0, r.float)(e);
        }, !1).collect()
      });
    }
  };
  return Mg.TermFunctionXsdToFloat = o, Mg;
}
var A$;
function vhe() {
  if (A$) return jg;
  A$ = 1, Object.defineProperty(jg, "__esModule", { value: !0 }), jg.ActorFunctionFactoryTermXsdToFloat = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ mhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_FLOAT],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToFloat();
    }
  };
  return jg.ActorFunctionFactoryTermXsdToFloat = a, jg;
}
var E$;
function The() {
  return E$ || (E$ = 1, function(u) {
    var r = Zc && Zc.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zc && Zc.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ vhe(), u);
  }(Zc)), Zc;
}
var ed = {}, Cg = {}, qg = {}, O$;
function whe() {
  if (O$) return qg;
  O$ = 1, Object.defineProperty(qg, "__esModule", { value: !0 }), qg.TermFunctionXsdToInteger = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_INTEGER,
        overloads: (0, r.declare)(r.TypeURL.XSD_INTEGER).onBoolean1Typed(() => (t) => (0, r.integer)(t ? 1 : 0)).onNumeric1(() => (t) => {
          if (!Number.isFinite(t.typedValue))
            throw new r.CastError(t, r.TypeURL.XSD_INTEGER);
          return (0, r.integer)(Math.trunc(t.typedValue));
        }).onString1(() => (t) => {
          const e = t.str(), n = /^\d+$/u.test(e) ? Number.parseInt(e, 10) : void 0;
          if (n === void 0)
            throw new r.CastError(t, r.TypeURL.XSD_INTEGER);
          return (0, r.integer)(n);
        }).collect()
      });
    }
  };
  return qg.TermFunctionXsdToInteger = o, qg;
}
var x$;
function She() {
  if (x$) return Cg;
  x$ = 1, Object.defineProperty(Cg, "__esModule", { value: !0 }), Cg.ActorFunctionFactoryTermXsdToInteger = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ whe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_INTEGER],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToInteger();
    }
  };
  return Cg.ActorFunctionFactoryTermXsdToInteger = a, Cg;
}
var I$;
function Ahe() {
  return I$ || (I$ = 1, function(u) {
    var r = ed && ed.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ed && ed.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ She(), u);
  }(ed)), ed;
}
var td = {}, Bg = {}, $g = {}, R$;
function Ehe() {
  if (R$) return $g;
  R$ = 1, Object.defineProperty($g, "__esModule", { value: !0 }), $g.TermFunctionXsdToString = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_STRING,
        overloads: (0, r.declare)(r.TypeURL.XSD_STRING).onNumeric1(() => (t) => (0, r.string)((0, r.float)(t.typedValue).str())).onBoolean1Typed(() => (t) => (0, r.string)((0, r.bool)(t).str())).onTerm1(() => (t) => (0, r.string)(t.str())).collect()
      });
    }
  };
  return $g.TermFunctionXsdToString = o, $g;
}
var F$;
function Ohe() {
  if (F$) return Bg;
  F$ = 1, Object.defineProperty(Bg, "__esModule", { value: !0 }), Bg.ActorFunctionFactoryTermXsdToString = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ehe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_STRING],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToString();
    }
  };
  return Bg.ActorFunctionFactoryTermXsdToString = a, Bg;
}
var N$;
function xhe() {
  return N$ || (N$ = 1, function(u) {
    var r = td && td.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = td && td.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ohe(), u);
  }(td)), td;
}
var rd = {}, Ug = {}, Vg = {}, P$;
function Ihe() {
  if (P$) return Vg;
  P$ = 1, Object.defineProperty(Vg, "__esModule", { value: !0 }), Vg.TermFunctionXsdToTime = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_TIME,
        overloads: (0, r.declare)(r.TypeURL.XSD_TIME).onUnary(r.TypeURL.XSD_TIME, () => (t) => new r.TimeLiteral(t.typedValue, t.strValue)).onUnary(r.TypeURL.XSD_DATE_TIME, () => (t) => new r.TimeLiteral(t.typedValue)).onStringly1(() => (t) => new r.TimeLiteral((0, r.parseTime)(t.str()))).collect()
      });
    }
  };
  return Vg.TermFunctionXsdToTime = o, Vg;
}
var D$;
function Rhe() {
  if (D$) return Ug;
  D$ = 1, Object.defineProperty(Ug, "__esModule", { value: !0 }), Ug.ActorFunctionFactoryTermXsdToTime = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Ihe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_TIME],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToTime();
    }
  };
  return Ug.ActorFunctionFactoryTermXsdToTime = a, Ug;
}
var L$;
function Fhe() {
  return L$ || (L$ = 1, function(u) {
    var r = rd && rd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = rd && rd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rhe(), u);
  }(rd)), rd;
}
var nd = {}, Qg = {}, Hg = {}, j$;
function Nhe() {
  if (j$) return Hg;
  j$ = 1, Object.defineProperty(Hg, "__esModule", { value: !0 }), Hg.TermFunctionXsdToYearMonthDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.TypeURL.XSD_YEAR_MONTH_DURATION,
        overloads: (0, r.declare)(r.TypeURL.XSD_YEAR_MONTH_DURATION).onUnary(r.TypeURL.XSD_DURATION, () => (t) => (
          // Copy is needed to make sure the dataType is changed, even when the provided type was a subtype
          new r.YearMonthDurationLiteral((0, r.trimToYearMonthDuration)(t.typedValue))
        )).onStringly1(() => (t) => new r.YearMonthDurationLiteral((0, r.parseYearMonthDuration)(t.str()))).collect()
      });
    }
  };
  return Hg.TermFunctionXsdToYearMonthDuration = o, Hg;
}
var M$;
function Phe() {
  if (M$) return Qg;
  M$ = 1, Object.defineProperty(Qg, "__esModule", { value: !0 }), Qg.ActorFunctionFactoryTermXsdToYearMonthDuration = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Nhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.TypeURL.XSD_YEAR_MONTH_DURATION],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionXsdToYearMonthDuration();
    }
  };
  return Qg.ActorFunctionFactoryTermXsdToYearMonthDuration = a, Qg;
}
var C$;
function Dhe() {
  return C$ || (C$ = 1, function(u) {
    var r = nd && nd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = nd && nd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Phe(), u);
  }(nd)), nd;
}
var id = {}, Gg = {}, zg = {}, q$;
function Lhe() {
  if (q$) return zg;
  q$ = 1, Object.defineProperty(zg, "__esModule", { value: !0 }), zg.TermFunctionYear = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor() {
      super({
        arity: 1,
        operator: r.SparqlOperator.YEAR,
        overloads: (0, r.declare)(r.SparqlOperator.YEAR).onDateTime1(() => (t) => (0, r.integer)(t.typedValue.year)).set([r.TypeURL.XSD_DATE], () => ([t]) => (0, r.integer)(t.typedValue.year)).collect()
      });
    }
  };
  return zg.TermFunctionYear = o, zg;
}
var B$;
function jhe() {
  if (B$) return Gg;
  B$ = 1, Object.defineProperty(Gg, "__esModule", { value: !0 }), Gg.ActorFunctionFactoryTermYear = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Lhe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.YEAR],
        termFunction: !0
      });
    }
    async run(e) {
      return new o.TermFunctionYear();
    }
  };
  return Gg.ActorFunctionFactoryTermYear = a, Gg;
}
var $$;
function Mhe() {
  return $$ || ($$ = 1, function(u) {
    var r = id && id.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = id && id.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ jhe(), u);
  }(id)), id;
}
var ad = {}, kg = {}, ud = {}, Xg = {}, eO = {}, od = {}, U$;
function Che() {
  if (U$) return od;
  U$ = 1, Object.defineProperty(od, "__esModule", { value: !0 }), od.readableFromWeb = od.ReadableFromWeb = void 0;
  const u = Bt();
  let r = class extends u.Readable {
    constructor(t, e) {
      super(e), this.reader = t.getReader(), this.readerClosed = !1, this.reader.closed.then(() => {
        this.readerClosed = !0;
      }).catch((n) => {
        this.readerClosed = !0, this.destroy(n);
      });
    }
    // eslint-disable-next-line ts/naming-convention
    _read() {
      this.reader.read().then((t) => this.push(t.done ? null : t.value)).catch((t) => this.destroy(t));
    }
    destroy(t) {
      return this.readerClosed || this.reader.cancel(t).then().catch(() => {
      }), super.destroy(t);
    }
  };
  od.ReadableFromWeb = r;
  function o(a, t) {
    return new r(a, t);
  }
  return od.readableFromWeb = o, od;
}
var V$;
function MY() {
  return V$ || (V$ = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.readableFromWeb = void 0;
    var r = Che();
    Object.defineProperty(u, "readableFromWeb", { enumerable: !0, get: function() {
      return r.readableFromWeb;
    } });
  }(eO)), eO;
}
var tO, Q$;
function CY() {
  if (Q$) return tO;
  Q$ = 1;
  const u = (r) => r !== null && typeof r == "object" && typeof r.pipe == "function";
  return u.writable = (r) => u(r) && r.writable !== !1 && typeof r._write == "function" && typeof r._writableState == "object", u.readable = (r) => u(r) && r.readable !== !1 && typeof r._read == "function" && typeof r._readableState == "object", u.duplex = (r) => u.writable(r) && u.readable(r), u.transform = (r) => u.duplex(r) && typeof r._transform == "function", tO = u, tO;
}
var rO = { exports: {} }, H$;
function qhe() {
  return H$ || (H$ = 1, function(u) {
    u.exports = r, u.exports.WEBSTREAM_SUPPORT = typeof ReadableStream < "u";
    function r(o) {
      if (!u.exports.WEBSTREAM_SUPPORT) throw new Error("No web ReadableStream support");
      var a = !1, t = {};
      function e(c) {
        t.data = d, t.end = d, t.end = l, t.close = l, t.error = l;
        for (var s in t) o.on(s, t[s]);
        o.pause();
        function d(f) {
          a || (c.enqueue(f), o.pause());
        }
        function l(f) {
          if (!a) {
            a = !0;
            for (var h in t) o.removeListener(h, t[h]);
            f ? c.error(f) : c.close();
          }
        }
      }
      function n() {
        a || o.resume();
      }
      function i() {
        a = !0;
        for (var c in t) o.removeListener(c, t[c]);
        o.push(null), o.pause(), o.destroy ? o.destroy() : o.close && o.close();
      }
      return new ReadableStream({ start: e, pull: n, cancel: i });
    }
  }(rO)), rO.exports;
}
var G$;
function BY() {
  if (G$) return Xg;
  G$ = 1, Object.defineProperty(Xg, "__esModule", { value: !0 }), Xg.ActorHttp = void 0;
  const u = /* @__PURE__ */ _e(), r = MY(), o = CY(), a = qhe();
  let t = class qY extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {HTTP request failed: none of the configured actors were able to handle ${action.input}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(n) {
      super(n);
    }
    /**
     * Converts WhatWG streams to Node streams if required.
     * Returns the input in case the stream already is a Node stream.
     * @param {ReadableStream} body
     * @returns {NodeJS.ReadableStream} A node stream.
     */
    static toNodeReadable(n) {
      return o(n) || n === null ? n : (0, r.readableFromWeb)(n);
    }
    /**
     * Converts Node streams to WhatWG streams.
     * @param {NodeJS.ReadableStream} body
     * @returns {ReadableStream} A web stream.
     */
    static toWebReadableStream(n) {
      return a(n);
    }
    /**
     * Convert the given headers object into a raw hash.
     * @param headers A headers object.
     */
    static headersToHash(n) {
      const i = {};
      return n.forEach((c, s) => {
        i[s] = c;
      }), i;
    }
    /**
     * Extract the requested URL from the action input.
     * @param {RequestInfo | URL} input The request input.
     * @returns {URL} The extracted URL.
     */
    static getInputUrl(n) {
      return new URL(n instanceof Request ? n.url : n);
    }
    /**
     * Creates an appropriate User-Agent header string for Node.js or other environments.
     * Within browsers, returns undefined, because the value should not be overridden due to potential CORS issues.
     */
    static createUserAgent(n, i) {
      if (!qY.isBrowser()) {
        const c = [
          `Comunica/${i.split(".")[0]}.0`,
          `${n}/${i}`
        ];
        return typeof globalThis.navigator == "object" && typeof globalThis.navigator.userAgent == "string" ? c.push(globalThis.navigator.userAgent) : typeof globalThis.process == "object" && typeof globalThis.process.versions == "object" && typeof globalThis.process.versions.node == "string" && c.push(`Node.js/${globalThis.process.versions.node.split(".")[0]}`), typeof globalThis.process == "object" && typeof globalThis.process.platform == "string" && typeof globalThis.process.arch == "string" && c.splice(1, 0, `(${globalThis.process.platform}; ${globalThis.process.arch})`), c.join(" ");
      }
    }
    /**
     * Attempts to determine whether the current environment is a browser or not.
     * @returns {boolean} True for browsers and web workers, false for other runtimes.
     */
    static isBrowser() {
      return (
        // The window global and the document are available in browsers, but not in web workers
        // https://developer.mozilla.org/en-US/docs/Glossary/Global_object
        typeof globalThis.window == "object" && typeof globalThis.window.document == "object" || // The importScripts function is only available in Web Workers
        // https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts
        typeof globalThis.importScripts == "function"
      );
    }
  };
  return Xg.ActorHttp = t, Xg;
}
var Jg = {}, z$;
function Bhe() {
  if (z$) return Jg;
  z$ = 1, Object.defineProperty(Jg, "__esModule", { value: !0 }), Jg.validateAndCloseHttpResponse = void 0;
  const u = gh(), r = /* @__PURE__ */ BY();
  async function o(a, t) {
    var e;
    if (t.status >= 400) {
      let n = "empty response";
      if (t.body) {
        const i = r.ActorHttp.toNodeReadable(t.body);
        n = await (0, u.stringify)(i);
      }
      throw new Error(`Could not update ${a} (HTTP status ${t.status}):
${n}`);
    }
    await ((e = t.body) == null ? void 0 : e.cancel());
  }
  return Jg.validateAndCloseHttpResponse = o, Jg;
}
var k$;
function Aa() {
  return k$ || (k$ = 1, function(u) {
    var r = ud && ud.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ud && ud.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ BY(), u), o(/* @__PURE__ */ Bhe(), u);
  }(ud)), ud;
}
const $he = "4.2.0", Uhe = {
  version: $he
};
var Kg = {}, X$;
function Vhe() {
  if (X$) return Kg;
  X$ = 1, Object.defineProperty(Kg, "__esModule", { value: !0 }), Kg.FetchInitPreprocessor = void 0;
  class u {
    async handle(o) {
      if (o.body && typeof o.body != "string" && "getReader" in o.body) {
        const a = o.body.getReader(), t = [];
        for (; ; ) {
          const { done: e, value: n } = await a.read();
          if (e)
            break;
          t.push(n);
        }
        o.body = t.join("");
      }
      return { ...o, keepalive: !o.body };
    }
  }
  return Kg.FetchInitPreprocessor = u, Kg;
}
var J$;
function Qhe() {
  if (J$) return kg;
  J$ = 1, Object.defineProperty(kg, "__esModule", { value: !0 }), kg.ActorHttpFetch = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = Uhe, t = /* @__PURE__ */ Vhe();
  let e = class bx extends u.ActorHttp {
    constructor(i) {
      super(i), this.fetchInitPreprocessor = new t.FetchInitPreprocessor(i.agentOptions);
    }
    async test(i) {
      return (0, o.passTest)({ time: Number.POSITIVE_INFINITY });
    }
    async run(i) {
      const c = this.prepareRequestHeaders(i), s = { method: "GET", ...i.init, headers: c };
      this.logInfo(i.context, `Requesting ${u.ActorHttp.getInputUrl(i.input).href}`, () => ({
        headers: u.ActorHttp.headersToHash(c),
        method: s.method
      })), i.context.has(r.KeysHttp.fetch) && (s.headers = u.ActorHttp.headersToHash(c)), i.context.get(r.KeysHttp.includeCredentials) && (s.credentials = "include");
      const d = i.context.get(r.KeysHttp.httpTimeout), l = i.context.get(r.KeysHttp.httpBodyTimeout), f = i.context.get(r.KeysHttp.fetch) ?? fetch, h = await this.fetchInitPreprocessor.handle(s);
      let p, b;
      if (d) {
        const y = new AbortController();
        h.signal = y.signal, p = () => y.abort(new Error(`Fetch timed out for ${u.ActorHttp.getInputUrl(i.input).href} after ${d} ms`)), b = setTimeout(() => p(), d);
      }
      const _ = await f(i.input, h);
      return d && (!l || !_.body) && clearTimeout(b), _;
    }
    /**
     * Prepares the request headers, taking into account the environment.
     * @param {IActionHttp} action The HTTP action
     * @returns {Headers} Headers
     */
    prepareRequestHeaders(i) {
      var d;
      const c = new Headers((d = i.init) == null ? void 0 : d.headers);
      u.ActorHttp.isBrowser() ? c.delete("user-agent") : c.has("user-agent") || c.set("user-agent", bx.userAgent);
      const s = i.context.get(r.KeysHttp.auth);
      return s && c.set("Authorization", `Basic ${bx.stringToBase64(s)}`), c;
    }
    /**
     * Converts a string, including ones with Unicode symbols, to Base64 encoding.
     * This function was adapted from the MDN example function here:
     * https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
     * @param {string} value The string value to encode
     * @returns {string} The Base64-encoded value
     */
    static stringToBase64(i) {
      const c = new TextEncoder().encode(i), s = Array.from(c, (d) => String.fromCodePoint(d)).join("");
      return btoa(s);
    }
  };
  return kg.ActorHttpFetch = e, e.userAgent = u.ActorHttp.createUserAgent("ActorHttpFetch", a.version), kg;
}
var K$;
function Hhe() {
  return K$ || (K$ = 1, function(u) {
    var r = ad && ad.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ad && ad.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Qhe(), u);
  }(ad)), ad;
}
var sd = {}, Wg = {}, W$;
function Ghe() {
  if (W$) return Wg;
  W$ = 1, Object.defineProperty(Wg, "__esModule", { value: !0 }), Wg.ActorQueryOperationSource = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Rr(), t = /* @__PURE__ */ vt(), e = ft();
  let n = class extends u.ActorQueryOperation {
    constructor(c) {
      super(c);
    }
    async test(c) {
      return (0, t.getOperationSource)(c.operation) ? (0, o.passTest)({ httpRequests: 1 }) : (0, o.failTest)(`Actor ${this.name} requires an operation with source annotation.`);
    }
    async run(c) {
      const s = c.context.get(r.KeysInitQuery.physicalQueryPlanLogger);
      s && (s.logOperation(c.operation.type, void 0, c.operation, c.context.get(r.KeysInitQuery.physicalQueryPlanNode), this.name, {}), c.context = c.context.set(r.KeysInitQuery.physicalQueryPlanNode, c.operation));
      const d = (0, t.getOperationSource)(c.operation), l = d.context ? c.context.merge(d.context) : c.context;
      let f = !1;
      if (e.Util.recurseOperation(c.operation, {
        construct() {
          return f = !0, !1;
        }
      }), f) {
        const b = d.source.queryQuads(c.operation, l), _ = (0, a.getMetadataQuads)(b);
        return {
          type: "quads",
          quadStream: b,
          metadata: _
        };
      }
      switch (c.operation.type) {
        case e.Algebra.types.ASK:
          return {
            type: "boolean",
            execute: () => d.source.queryBoolean(c.operation, l)
          };
        case e.Algebra.types.COMPOSITE_UPDATE:
        case e.Algebra.types.DELETE_INSERT:
        case e.Algebra.types.LOAD:
        case e.Algebra.types.CLEAR:
        case e.Algebra.types.CREATE:
        case e.Algebra.types.DROP:
        case e.Algebra.types.ADD:
        case e.Algebra.types.MOVE:
        case e.Algebra.types.COPY:
          return {
            type: "void",
            execute: () => d.source.queryVoid(c.operation, l)
          };
      }
      const h = d.source.queryBindings(c.operation, l), p = (0, a.getMetadataBindings)(h);
      return {
        type: "bindings",
        bindingsStream: h,
        metadata: p
      };
    }
  };
  return Wg.ActorQueryOperationSource = n, Wg;
}
var Y$;
function zhe() {
  return Y$ || (Y$ = 1, function(u) {
    var r = sd && sd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = sd && sd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ghe(), u);
  }(sd)), sd;
}
var cd = {}, Yg = {}, Z$;
function khe() {
  if (Z$) return Yg;
  Z$ = 1, Object.defineProperty(Yg, "__esModule", { value: !0 }), Yg.MediatorJoinCoefficientsFixed = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e();
  let o = class extends r.Mediator {
    constructor(t) {
      super(t);
    }
    async mediateWith(t, e) {
      var b;
      const n = [], i = e.map(({ reply: _ }) => _), c = (await Promise.all(i)).map((_) => {
        if (_.isFailed()) {
          n.push(_.getFailMessage());
          return;
        }
        return { value: _.get(), sideData: _.getSideData() };
      });
      let s = c.map((_) => {
        if (_)
          return _.value.iterations * this.cpuWeight + _.value.persistedItems * this.memoryWeight + _.value.blockingItems * this.timeWeight + _.value.requestTime * this.ioWeight;
      });
      const d = Math.max(...s.filter((_) => _ !== void 0)), l = t.context.get(u.KeysQueryOperation.limitIndicator);
      l && (s = s.map((_, y) => {
        var m, g;
        return _ !== void 0 && ((m = c[y]) == null ? void 0 : m.value).blockingItems > 0 && ((g = c[y]) == null ? void 0 : g.value).iterations > l ? _ + d : _;
      }));
      let f = -1, h = Number.POSITIVE_INFINITY;
      for (const [_, y] of s.entries())
        y !== void 0 && (f === -1 || y < h) && (f = _, h = y);
      if (f < 0)
        return (0, r.failTest)(this.constructFailureMessage(t, n));
      const p = e[f].actor;
      return p.includeInLogs && ((b = r.Actor.getContextLogger(t.context)) == null || b.debug(`Determined physical join operator '${p.logicalType}-${p.physicalName}'`, {
        entries: t.entries.length,
        variables: await Promise.all(t.entries.map(async (_) => (await _.output.metadata()).variables.map((y) => y.variable.value))),
        costs: Object.fromEntries(s.map((_, y) => [
          `${e[y].actor.logicalType}-${e[y].actor.physicalName}`,
          _
        ]).filter((_) => _[1] !== void 0)),
        coefficients: Object.fromEntries(c.map((_, y) => [
          `${e[y].actor.logicalType}-${e[y].actor.physicalName}`,
          _ == null ? void 0 : _.value
        ]).filter((_) => _[1] !== void 0))
      })), (0, r.passTestWithSideData)(p, c[f].sideData);
    }
  };
  return Yg.MediatorJoinCoefficientsFixed = o, Yg;
}
var eU;
function Xhe() {
  return eU || (eU = 1, function(u) {
    var r = cd && cd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = cd && cd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ khe(), u);
  }(cd)), cd;
}
var dd = {}, Zg = {}, tU;
function $Y() {
  if (tU) return Zg;
  tU = 1, Object.defineProperty(Zg, "__esModule", { value: !0 }), Zg.ActorHttpInvalidate = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Zg.ActorHttpInvalidate = r, Zg;
}
var em = {}, rU;
function Jhe() {
  if (rU) return em;
  rU = 1, Object.defineProperty(em, "__esModule", { value: !0 }), em.ActorHttpInvalidateListenable = void 0;
  const u = /* @__PURE__ */ _e(), r = /* @__PURE__ */ $Y();
  let o = class extends r.ActorHttpInvalidate {
    constructor(t) {
      super(t), this.invalidateListeners = [], this.invalidateListeners = [];
    }
    addInvalidateListener(t) {
      this.invalidateListeners.push(t);
    }
    async test(t) {
      return (0, u.passTestVoid)();
    }
    async run(t) {
      for (const e of this.invalidateListeners)
        e(t);
      return {};
    }
  };
  return em.ActorHttpInvalidateListenable = o, em;
}
var nU;
function O0() {
  return nU || (nU = 1, function(u) {
    var r = dd && dd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = dd && dd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ $Y(), u), o(/* @__PURE__ */ Jhe(), u);
  }(dd)), dd;
}
var ld = {}, tm = {}, iU;
function Khe() {
  if (iU) return tm;
  iU = 1, Object.defineProperty(tm, "__esModule", { value: !0 }), tm.MediatorAll = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Mediator {
    constructor(a) {
      super(a);
    }
    async mediate(a) {
      const t = [];
      let e;
      try {
        e = this.publish(a);
      } catch {
        e = [];
      }
      for (const i of e) {
        const c = await i.reply;
        c.isPassed() && t.push({ actor: i.actor, sideData: c.getSideData() });
      }
      return (await Promise.all(t.map((i) => i.actor.runObservable(a, i.sideData))))[0];
    }
    async mediateWith() {
      throw new Error("Unsupported operation: MediatorAll#mediateWith");
    }
  };
  return tm.MediatorAll = r, tm;
}
var aU;
function Whe() {
  return aU || (aU = 1, function(u) {
    var r = ld && ld.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ld && ld.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Khe(), u);
  }(ld)), ld;
}
var fd = {}, rm = {}, uU;
function Yhe() {
  if (uU) return rm;
  uU = 1, Object.defineProperty(rm, "__esModule", { value: !0 }), rm.ActorRdfJoinEntriesSortSelectivity = void 0;
  const u = /* @__PURE__ */ $W(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfJoinEntriesSort {
    constructor(t) {
      super(t);
    }
    async test(t) {
      return (0, r.passTest)({ accuracy: 0.501 });
    }
    async run(t) {
      const e = [...t.entries], n = [];
      for (; e.length > 0; ) {
        let i = Number.MAX_VALUE, c = -1;
        for (const [s, d] of e.entries()) {
          const { selectivity: l } = await this.mediatorJoinSelectivity.mediate({
            entries: [d, ...n],
            context: t.context
          });
          l < i && (i = l, c = s);
        }
        n.push(e[c]), e.splice(c, 1);
      }
      return { entries: n };
    }
  };
  return rm.ActorRdfJoinEntriesSortSelectivity = o, rm;
}
var oU;
function Zhe() {
  return oU || (oU = 1, function(u) {
    var r = fd && fd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = fd && fd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Yhe(), u);
  }(fd)), fd;
}
var hd = {}, nm = {}, pd = {}, im = {}, bd = {}, am = {}, sU;
function epe() {
  if (sU) return am;
  sU = 1, Object.defineProperty(am, "__esModule", { value: !0 }), am.ChunkedIterator = void 0;
  const u = /* @__PURE__ */ yt();
  let r = class extends u.TransformIterator {
    constructor(a, t, e) {
      super(a, e), this.chunk = [], this.blockSize = t;
    }
    consumeChunkAsIterator() {
      const a = new u.ArrayIterator(this.chunk, { autoStart: !1 });
      return this.chunk = [], a;
    }
    _transform(a, t, e) {
      this.chunk.push(a), this.chunk.length >= this.blockSize && e(this.consumeChunkAsIterator()), t();
    }
    _flush(a) {
      this.chunk.length > 0 && this._push(this.consumeChunkAsIterator()), super._flush(a);
    }
  };
  return am.ChunkedIterator = r, am;
}
var um = {}, cU;
function tpe() {
  if (cU) return um;
  cU = 1, Object.defineProperty(um, "__esModule", { value: !0 }), um.ClosableIterator = void 0;
  const u = /* @__PURE__ */ yt();
  let r = class extends u.AsyncIterator {
    constructor(n, i) {
      super(), this.onClose = i.onClose, this._source = n, this._source[u.DESTINATION] = this, this._source.on("end", t), this._source.on("error", a), this._source.on("readable", o), this.readable = this._source.readable;
    }
    read() {
      const n = this._source.read();
      return n || (this.readable = !1, this._source.done && this.close()), n;
    }
    _end(n) {
      this.onClose(), this._source.removeListener("end", t), this._source.removeListener("error", a), this._source.removeListener("readable", o), delete this._source[u.DESTINATION], this._source.destroy(), super._end(n);
    }
  };
  um.ClosableIterator = r;
  function o() {
    this[u.DESTINATION].readable = !0;
  }
  function a(e) {
    this[u.DESTINATION].emit("error", e);
  }
  function t() {
    this[u.DESTINATION].close();
  }
  return um;
}
var om = {}, dU;
function rpe() {
  if (dU) return om;
  dU = 1, Object.defineProperty(om, "__esModule", { value: !0 }), om.ClosableTransformIterator = void 0;
  const u = /* @__PURE__ */ yt();
  let r = class extends u.TransformIterator {
    constructor(a, t) {
      super(a, t), this.onClose = t.onClose;
    }
    _end(a) {
      this.onClose(), super._end(a);
    }
  };
  return om.ClosableTransformIterator = r, om;
}
var sm = {}, lU;
function npe() {
  if (lU) return sm;
  lU = 1, Object.defineProperty(sm, "__esModule", { value: !0 }), sm.instrumentIterator = void 0;
  function u(o) {
    const a = {
      count: 0,
      timeSelf: 0,
      timeLife: 0
    };
    return r(o, a, !0), new Promise((t) => {
      o.on("end", () => {
        t(a);
      });
    });
  }
  sm.instrumentIterator = u;
  function r(o, a, t) {
    if (!("_profileInstrumented" in o)) {
      if (o._profileInstrumented = !0, "_read" in o) {
        const e = o._read;
        o._read = (n, i) => {
          const c = performance.now();
          e.call(o, n, () => {
            a.timeSelf += performance.now() - c, i();
          });
        };
      }
      if ("read" in o) {
        const e = o.read;
        o.read = () => {
          const n = performance.now(), i = e.call(o);
          return t && i && a.count++, a.timeSelf += performance.now() - n, i;
        };
      }
      if (t) {
        const e = performance.now();
        o.on("end", () => {
          a.timeLife = performance.now() - e;
        });
      }
      "_source" in o && r(o._source, a, !1);
    }
  }
  return sm;
}
var fU;
function uu() {
  return fU || (fU = 1, function(u) {
    var r = bd && bd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bd && bd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ epe(), u), o(/* @__PURE__ */ tpe(), u), o(/* @__PURE__ */ rpe(), u), o(/* @__PURE__ */ npe(), u);
  }(bd)), bd;
}
var hU;
function ipe() {
  if (hU) return im;
  hU = 1, Object.defineProperty(im, "__esModule", { value: !0 }), im.ActorRdfJoin = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ uu(), a = /* @__PURE__ */ Rr();
  let t = class Ca extends r.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF joining failed: none of the configured actors were able to handle the join type ${action.type}} busFailMessage
     * @param options - Actor-specific join options.
     */
    /* eslint-enable max-len */
    constructor(n, i) {
      super(n), this.includeInLogs = !0, this.logicalType = i.logicalType, this.physicalName = i.physicalName, this.limitEntries = i.limitEntries ?? Number.POSITIVE_INFINITY, this.limitEntriesMin = i.limitEntriesMin ?? !1, this.canHandleUndefs = i.canHandleUndefs ?? !1, this.isLeaf = i.isLeaf ?? !0, this.requiresVariableOverlap = i.requiresVariableOverlap ?? !1;
    }
    /**
     * Returns an array containing all the variable names that occur in all bindings streams.
     * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.
     * @returns {RDF.Variable[]} An array of variables.
     */
    static overlappingVariables(n) {
      const i = {};
      for (const c of n)
        for (const s of c.variables) {
          i[s.variable.value] || (i[s.variable.value] = {
            variable: s.variable,
            canBeUndef: s.canBeUndef,
            occurrences: 0
          });
          const d = i[s.variable.value];
          d.canBeUndef = d.canBeUndef || s.canBeUndef, d.occurrences++;
        }
      return Object.values(i).filter((c) => c.occurrences === n.length).map((c) => ({ variable: c.variable, canBeUndef: c.canBeUndef }));
    }
    /**
     * Returns the variables that will occur in the joined bindings.
     * @param dataFactory The data factory.
     * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.
     * @param optional If an optional join is being performed.
     * @returns {RDF.Variable[]} An array of joined variables.
     */
    static joinVariables(n, i, c = !1) {
      const s = {};
      let d = !0;
      for (const l of i) {
        for (const f of l.variables)
          s[f.variable.value] = s[f.variable.value] || f.canBeUndef || !d && c && !(f.variable.value in s);
        d = !1;
      }
      return Object.entries(s).map(([l, f]) => ({ variable: n.variable(l), canBeUndef: f }));
    }
    /**
     * Returns the result of joining bindings, or `null` if no join is possible.
     * @param {Bindings[]} bindings
     * @returns {Bindings}
     */
    static joinBindings(...n) {
      if (n.length === 0)
        return null;
      if (n.length === 1)
        return n[0];
      let i = n[0];
      for (const c of n.slice(1)) {
        const s = i.merge(c);
        if (!s)
          return null;
        i = s;
      }
      return i;
    }
    /**
     * Get the estimated number of items from the given metadata.
     * @param {Record<string, any>} metadata A metadata object.
     * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.
     */
    static getCardinality(n) {
      return n.cardinality;
    }
    /**
     * Obtain the metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getMetadatas(n) {
      return await Promise.all(n.map((i) => i.output.metadata()));
    }
    /**
     * Obtain the join entries witt metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getEntriesWithMetadatas(n) {
      const i = await Ca.getMetadatas(n);
      return n.map((c, s) => ({ ...c, metadata: i[s] }));
    }
    /**
     * Calculate the time to initiate a request for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestInitialTimes(n) {
      return n.map((i) => i.pageSize ? 0 : i.requestTime ?? 0);
    }
    /**
     * Calculate the time to receive a single item for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestItemTimes(n) {
      return n.map((i) => i.pageSize ? (i.requestTime ?? 0) / i.pageSize : 0);
    }
    /**
     * Construct a metadata validation state for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    constructState(n) {
      const i = new a.MetadataValidationState(), c = () => i.invalidate();
      for (const s of n)
        s.state.addInvalidateListener(c);
      return i;
    }
    /**
     * Helper function to create a new metadata object for the join result.
     * For required metadata entries that are not provided, sane defaults are calculated.
     * @param entries Join entries.
     * @param metadatas Metadata of the join entries.
     * @param context The action context.
     * @param partialMetadata Partial metadata entries.
     * @param optional If metadata for an optional operation must be calculated.
     */
    async constructResultMetadata(n, i, c, s = {}, d = !1) {
      let l;
      if (s.cardinality)
        l = s.cardinality;
      else {
        let f = !1;
        l = i.reduce((h, p) => {
          const b = Ca.getCardinality(p);
          return b.value === 0 && (f = !0), {
            type: b.type === "estimate" ? "estimate" : h.type,
            value: h.value * (d ? Math.max(1, b.value) : b.value)
          };
        }, { type: "exact", value: 1 }), (!f || d) && (l.value *= (await this.mediatorJoinSelectivity.mediate({ entries: n, context: c })).selectivity, l.value === 0 && (l.value = Number.MIN_VALUE));
      }
      return {
        state: this.constructState(i),
        ...s,
        cardinality: {
          type: l.type,
          value: l.value
        },
        variables: Ca.joinVariables(c.getSafe(u.KeysInitQuery.dataFactory), i, d)
      };
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {MediatorRdfJoinEntriesSort} mediatorJoinEntriesSort A mediator for sorting join entries.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    static async sortJoinEntries(n, i, c) {
      if (i.some((f) => f.metadata.variables.some((h) => h.canBeUndef)))
        return (0, r.passTest)(i);
      const d = {};
      for (const f of i)
        for (const h of f.metadata.variables) {
          let p = d[h.variable.value];
          p || (p = 0), d[h.variable.value] = ++p;
        }
      const l = [];
      for (const [f, h] of Object.entries(d))
        h >= 2 && l.push(f);
      return l.length === 0 ? (0, r.failTest)("Bind join can only join entries with at least one common variable") : (0, r.passTest)((await n.mediate({ entries: i, context: c })).entries);
    }
    /**
     * Default test function for join actors.
     * Checks whether all iterators have metadata.
     * If yes: call the abstract getIterations method, if not: return Infinity.
     * @param {IActionRdfJoin} action The input action containing the relevant iterators
     * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.
     */
    async test(n) {
      if (n.type !== this.logicalType)
        return (0, r.failTest)(`${this.name} can only handle logical joins of type '${this.logicalType}', while '${n.type}' was given.`);
      if (n.entries.length <= 1)
        return (0, r.failTest)(`${this.name} requires at least two join entries.`);
      if (this.limitEntriesMin ? n.entries.length < this.limitEntries : n.entries.length > this.limitEntries)
        return (0, r.failTest)(`${this.name} requires ${this.limitEntries} join entries at ${this.limitEntriesMin ? "least" : "most"}. The input contained ${n.entries.length}.`);
      for (const s of n.entries)
        if (s.output.type !== "bindings")
          return (0, r.failTest)(`Invalid type of a join entry: Expected 'bindings' but got '${s.output.type}'`);
      const i = await Ca.getMetadatas(n.entries);
      let c;
      return !this.canHandleUndefs && (c = Ca.overlappingVariables(i), c.some((s) => s.canBeUndef)) ? (0, r.failTest)(`Actor ${this.name} can not join streams containing undefs`) : this.requiresVariableOverlap && (c ?? Ca.overlappingVariables(i)).length === 0 ? (0, r.failTest)(`Actor ${this.name} can only join entries with at least one common variable`) : await this.getJoinCoefficients(n, { metadatas: i });
    }
    /**
     * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise
     * @param {IActionRdfJoin} action
     * @param sideData Side data from the test method
     * @returns {Promise<IQueryOperationResultBindings>} A bindings result.
     */
    async run(n, i) {
      let c;
      n.context.has(u.KeysInitQuery.physicalQueryPlanLogger) && (c = n.context.get(u.KeysInitQuery.physicalQueryPlanNode), n.context = n.context.set(u.KeysInitQuery.physicalQueryPlanNode, n));
      const s = n.context.get(u.KeysInitQuery.physicalQueryPlanLogger);
      let d;
      this.includeInLogs && s && (d = {}, s.stashChildren(c, (h) => h.logicalOperator.startsWith("join")), s.logOperation(`join-${this.logicalType}`, this.physicalName, n, c, this.name, d));
      const { result: l, physicalPlanMetadata: f } = await this.getOutput(n, i);
      if (d) {
        (0, o.instrumentIterator)(l.bindingsStream).then((p) => {
          s.appendMetadata(n, {
            cardinalityReal: p.count,
            timeSelf: p.timeSelf,
            timeLife: p.timeLife
          });
        }), Object.assign(d, f);
        const h = i.metadatas.map(Ca.getCardinality);
        if (d.cardinalities = h, d.joinCoefficients = (await this.getJoinCoefficients(n, i)).getOrThrow(), this.isLeaf)
          for (let p = 0; p < n.entries.length; p++) {
            const b = n.entries[p];
            s.unstashChild(b.operation, n), s.appendMetadata(b.operation, { cardinality: h[p] });
          }
      }
      return l.metadata = (0, a.cachifyMetadata)(l.metadata), l;
    }
  };
  return im.ActorRdfJoin = t, im;
}
var pU;
function cn() {
  return pU || (pU = 1, function(u) {
    var r = pd && pd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = pd && pd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ipe(), u);
  }(pd)), pd;
}
var bU;
function ape() {
  if (bU) return nm;
  bU = 1, Object.defineProperty(nm, "__esModule", { value: !0 }), nm.ActorRdfJoinSingle = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorRdfJoin {
    constructor(t) {
      super(t, {
        logicalType: "inner",
        physicalName: "single",
        limitEntries: 1
      }), this.includeInLogs = !1;
    }
    async test(t) {
      return t.entries.length !== 1 ? (0, r.failTest)(`Actor ${this.name} can only join a single entry`) : await this.getJoinCoefficients(t, void 0);
    }
    async getOutput(t) {
      return {
        result: t.entries[0].output
      };
    }
    async getJoinCoefficients(t, e) {
      return (0, r.passTestWithSideData)({
        iterations: 0,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: 0
      }, e);
    }
  };
  return nm.ActorRdfJoinSingle = o, nm;
}
var yU;
function upe() {
  return yU || (yU = 1, function(u) {
    var r = hd && hd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = hd && hd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ape(), u);
  }(hd)), hd;
}
var yd = {}, cm = {}, _U;
function ope() {
  if (_U) return cm;
  _U = 1, Object.defineProperty(cm, "__esModule", { value: !0 }), cm.ActorRdfJoinMultiEmpty = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Rr(), t = /* @__PURE__ */ yt();
  let e = class extends u.ActorRdfJoin {
    constructor(i) {
      super(i, {
        logicalType: "inner",
        physicalName: "multi-empty",
        canHandleUndefs: !0
      });
    }
    async test(i) {
      return (await u.ActorRdfJoin.getMetadatas(i.entries)).every((c) => u.ActorRdfJoin.getCardinality(c).value > 0) ? (0, o.failTest)(`Actor ${this.name} can only join entries where at least one is empty`) : super.test(i);
    }
    async getOutput(i) {
      for (const s of i.entries)
        s.output.bindingsStream.close();
      const c = i.context.getSafe(r.KeysInitQuery.dataFactory);
      return {
        result: {
          bindingsStream: new t.ArrayIterator([], { autoStart: !1 }),
          metadata: async () => ({
            state: new a.MetadataValidationState(),
            cardinality: { type: "exact", value: 0 },
            variables: u.ActorRdfJoin.joinVariables(c, await u.ActorRdfJoin.getMetadatas(i.entries))
          }),
          type: "bindings"
        }
      };
    }
    async getJoinCoefficients(i, c) {
      return (0, o.passTestWithSideData)({
        iterations: 0,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: 0
      }, c);
    }
  };
  return cm.ActorRdfJoinMultiEmpty = e, cm;
}
var gU;
function spe() {
  return gU || (gU = 1, function(u) {
    var r = yd && yd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = yd && yd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ope(), u);
  }(yd)), yd;
}
var _d = {}, dm = {}, gd = {}, lm = {}, mU;
function cpe() {
  if (mU) return lm;
  mU = 1, Object.defineProperty(lm, "__esModule", { value: !0 }), lm.BindingsIndexDef = void 0;
  let u = class {
    constructor(o, a) {
      this.keys = o.map((t) => t.variable), this.hashFn = a, this.index = {};
    }
    put(o, a) {
      return this.index[this.hashFn(o, this.keys)] = a;
    }
    get(o) {
      const a = this.getFirst(o);
      return a ? [a] : [];
    }
    getFirst(o) {
      return this.index[this.hashFn(o, this.keys)];
    }
    values() {
      return Object.values(this.index);
    }
  };
  return lm.BindingsIndexDef = u, lm;
}
var fm = {}, vU;
function dpe() {
  if (vU) return fm;
  vU = 1, Object.defineProperty(fm, "__esModule", { value: !0 }), fm.BindingsIndexUndef = void 0;
  let u = class {
    constructor(o, a, t) {
      this.data = {}, this.keys = o.map((e) => e.variable), this.hashFn = a, this.allowDisjointDomains = t && this.keys.length > 0;
    }
    /**
     * Add the given bindings to the index.
     * @param {Bindings} bindings A bindings.
     * @param {V} value The value to put.
     */
    put(o, a) {
      if (this.allowDisjointDomains || this.isBindingsValid(o)) {
        let t = this.data;
        for (let e = 0; e < this.keys.length; e++) {
          const n = this.keys[e], i = this.hashFn(o.get(n));
          let c = t[i];
          c || (c = t[i] = e === this.keys.length - 1 ? a : {}), t = c;
        }
      }
      return a;
    }
    isBindingsValid(o) {
      let a = !1;
      for (const t of this.keys)
        if (o.has(t)) {
          a = !0;
          break;
        }
      return a;
    }
    /**
     * Get the value of the given bindings is contained in this index.
     * @param {Bindings} bindings A bindings.
     * @return {V[]} The values.
     */
    get(o) {
      return this.allowDisjointDomains || this.isBindingsValid(o) ? this.getRecursive(o, this.keys, [this.data]) : [];
    }
    getRecursive(o, a, t) {
      if (a.length === 0)
        return t;
      let e;
      [e, ...a] = a;
      const n = [];
      for (const i of t) {
        const c = this.hashFn(o == null ? void 0 : o.get(e));
        if (c) {
          const s = [i[c], i[""]].filter(Boolean);
          if (s.length === 0)
            continue;
          n.push(this.getRecursive(o, a, s));
        } else {
          const s = Object.values(i);
          if (s.length === 0)
            continue;
          n.push(this.getRecursive(o, a, s));
        }
      }
      return n.flat();
    }
    /**
     * Get the first value of the given bindings is contained in this index.
     * @param {Bindings} bindings A bindings.
     * @param matchUndefsAsWildcard If undefs in the given bindings should match with any existing values.
     *                              Otherwise, undefs will only match values that were inserted as undefs.
     * @return {V | undefined} The value.
     */
    getFirst(o, a = !0) {
      if (this.allowDisjointDomains || this.isBindingsValid(o))
        return this.getRecursiveFirst(o, this.keys, [this.data], a);
    }
    getRecursiveFirst(o, a, t, e) {
      if (a.length === 0)
        return t[0];
      let n;
      [n, ...a] = a;
      for (const i of t) {
        const c = this.hashFn(o.get(n));
        if (c || !e) {
          const s = [i[c], i[""]].filter(Boolean);
          if (s.length === 0)
            continue;
          const d = this.getRecursiveFirst(o, a, s, e);
          if (d)
            return d;
        } else {
          const s = Object.values(i);
          if (s.length === 0)
            continue;
          const d = this.getRecursiveFirst(o, a, s, e);
          if (d)
            return d;
        }
      }
    }
    values() {
      return this.keys.length === 0 ? [] : this.getRecursive(void 0, this.keys, [this.data]);
    }
  };
  return fm.BindingsIndexUndef = u, fm;
}
var nO = {}, TU;
function lpe() {
  return TU || (TU = 1, Object.defineProperty(nO, "__esModule", { value: !0 })), nO;
}
var wU;
function H8() {
  return wU || (wU = 1, function(u) {
    var r = gd && gd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = gd && gd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ cpe(), u), o(/* @__PURE__ */ dpe(), u), o(/* @__PURE__ */ lpe(), u);
  }(gd)), gd;
}
var iO, SU;
function fpe() {
  if (SU) return iO;
  SU = 1;
  let u = /* @__PURE__ */ yt(), r = u.MultiTransformIterator, o = u.SimpleTransformIterator;
  class a extends r {
    constructor(e, n, i, c) {
      super(e, c), this.funRight = n, this.funJoin = i;
    }
    _createTransformer(e) {
      return new o(this.funRight(e), { transform: (n, i, c) => {
        let s = this.funJoin(e, n);
        s !== null && c(s), i();
      } });
    }
  }
  return iO = a, iO;
}
var aO, AU;
function hpe() {
  if (AU) return aO;
  AU = 1;
  let u = yt().AsyncIterator;
  class r extends u {
    constructor(a, t, e, n) {
      super(), this.addedDataListener = !1, this.left = a, this.right = t, this.funHash = e, this.funJoin = n, this.leftMap = /* @__PURE__ */ new Map(), this.match = null, this.matches = [], this.matchIdx = 0, this.left.on("error", (c) => this.destroy(c)), this.right.on("error", (c) => this.destroy(c)), this.readable = !1, this.left.on("end", i.bind(this));
      function i() {
        this.readable = !0, this.right.on("readable", () => this.readable = !0), this.right.on("end", () => {
          this.hasResults() || this._end();
        });
      }
      this.on("newListener", (c) => {
        c === "data" && this._addDataListenerIfNeeded();
      }), this.left.readable && this._addDataListenerIfNeeded(), this.left.on("readable", () => this._addDataListenerIfNeeded());
    }
    hasResults() {
      return !this.right.ended || this.matchIdx < this.matches.length;
    }
    _end() {
      super._end(), this.left.destroy(), this.right.destroy();
    }
    read() {
      for (this._addDataListenerIfNeeded(); ; ) {
        if (this.ended || !this.readable)
          return null;
        for (; this.matchIdx < this.matches.length; ) {
          let t = this.matches[this.matchIdx++], e = this.funJoin(t, this.match);
          if (e !== null)
            return e;
        }
        if (this.hasResults() || this._end(), this.match = this.right.read(), this.match === null)
          return this.readable = !1, null;
        let a = this.funHash(this.match);
        this.matches = this.leftMap.get(a) || [], this.matchIdx = 0;
      }
    }
    _addDataListenerIfNeeded() {
      this.addedDataListener || (this.addedDataListener = !0, this._addDataListener());
    }
    _addDataListener() {
      this.left.on("data", a.bind(this));
      function a(t) {
        let e = this.funHash(t), n = this.leftMap.get(e);
        n || (n = [], this.leftMap.set(e, n)), n.push(t);
      }
    }
  }
  return aO = r, aO;
}
var uO, EU;
function ppe() {
  if (EU) return uO;
  EU = 1;
  const { MultiTransformIterator: u, SimpleTransformIterator: r, scheduleTask: o } = /* @__PURE__ */ yt();
  class a extends u {
    constructor(e, n, i, c) {
      super(e, c), this.right = n, this.funJoin = i, this.on("end", () => this.right.close());
    }
    _end() {
      super._end(), o(() => this.right.destroy());
    }
    _createTransformer(e) {
      return new r(this.right.clone(), { transform: (n, i, c) => {
        let s = this.funJoin(e, n);
        s !== null && c(s), i();
      } });
    }
  }
  return uO = a, uO;
}
var oO, OU;
function bpe() {
  if (OU) return oO;
  OU = 1;
  let u = yt().AsyncIterator;
  class r extends u {
    constructor(a, t, e, n) {
      super(), this.left = a, this.right = t, this.funHash = e, this.funJoin = n, this.usedLeft = !1, this.leftMap = /* @__PURE__ */ new Map(), this.rightMap = /* @__PURE__ */ new Map(), this.on("end", () => this._cleanup()), this.match = null, this.matches = [], this.matchIdx = 0, (this.left.readable || this.right.readable) && (this.readable = !0), this.left.on("error", (i) => this.destroy(i)), this.right.on("error", (i) => this.destroy(i)), this.left.on("readable", () => this.readable = !0), this.right.on("readable", () => this.readable = !0), this.left.on("end", () => {
        this.hasResults() || this._end();
      }), this.right.on("end", () => {
        this.hasResults() || this._end();
      });
    }
    hasResults() {
      return !this.left.ended || !this.right.ended || !!this.matches && this.matchIdx < this.matches.length;
    }
    _cleanup() {
      this.leftMap = null, this.rightMap = null, this.matches = null;
    }
    _end() {
      super._end(), this.left.destroy(), this.right.destroy();
    }
    read() {
      for (; ; ) {
        if (this.ended)
          return null;
        for (; this.matchIdx < this.matches.length; ) {
          let e = this.matches[this.matchIdx++], n = this.usedLeft ? this.funJoin(this.match, e) : this.funJoin(e, this.match);
          if (n !== null)
            return n;
        }
        this.hasResults() || this._end();
        let a = null;
        for (let e = 0; e < 2 && (a = this.usedLeft ? this.right.read() : this.left.read(), this.usedLeft = !this.usedLeft, a === null); ++e)
          ;
        if (this.done || a === null)
          return this.readable = !1, null;
        let t = this.funHash(a);
        if (this.usedLeft && this.right.done)
          this.leftMap = null;
        else if (this.left.done)
          this.rightMap = null;
        else {
          let e = this.usedLeft ? this.leftMap : this.rightMap;
          e.has(t) || e.set(t, []);
          let n = e.get(t);
          n || (n = [], e.set(t, n)), n.push(a);
        }
        this.match = a, this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(t) || [], this.matchIdx = 0;
      }
    }
  }
  return oO = r, oO;
}
var sO, xU;
function ype() {
  if (xU) return sO;
  xU = 1;
  let u = yt().AsyncIterator;
  class r extends u {
    constructor(a) {
      super(), Array.isArray(a) || (a = Array.prototype.slice.call(arguments)), this.streams = a;
      for (let t of a)
        t.on("readable", () => this.emit("readable")), t.on("end", () => this._removeStream(t));
      this.streams.length === 0 && this.close(), this.idx = this.streams.length - 1;
    }
    _removeStream(a) {
      let t = this.streams.indexOf(a);
      t < 0 || (this.streams.splice(t, 1), this.idx >= this.streams.length && --this.idx, this.streams.length === 0 && this._end());
    }
    close() {
      super.close();
      for (let a of this.streams)
        a.close();
    }
    read() {
      for (let a = 0; a < this.streams.length; ++a) {
        this.idx = (this.idx + 1) % this.streams.length;
        let t = this.streams[this.idx].read();
        if (t !== null)
          return t;
      }
      return null;
    }
  }
  return sO = r, sO;
}
var cO, IU;
function c4() {
  if (IU) return cO;
  IU = 1;
  const u = fpe(), r = hpe(), o = ppe(), a = bpe(), t = ype();
  return cO = {
    DynamicNestedLoopJoin: u,
    HashJoin: r,
    NestedLoopJoin: o,
    SymmetricHashJoin: a,
    MergeStream: t
  }, cO;
}
var RU;
function _pe() {
  if (RU) return dm;
  RU = 1, Object.defineProperty(dm, "__esModule", { value: !0 }), dm.ActorRdfJoinHash = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ H8(), a = /* @__PURE__ */ uu(), t = /* @__PURE__ */ yt(), e = c4(), n = lr();
  let i = class extends u.ActorRdfJoin {
    constructor(s) {
      super(s, {
        logicalType: "inner",
        physicalName: `hash-${s.canHandleUndefs ? "undef" : "def"}`,
        limitEntries: 2,
        requiresVariableOverlap: !0,
        canHandleUndefs: s.canHandleUndefs
      });
    }
    async getOutput(s, d) {
      const l = d.metadatas;
      let f;
      const h = u.ActorRdfJoin.overlappingVariables(l);
      if (this.canHandleUndefs) {
        const p = d.entriesSorted[0].output, b = d.entriesSorted[1].output;
        f = new a.ClosableTransformIterator(async () => {
          const _ = new o.BindingsIndexUndef(h, (y) => y && y.termType !== "Variable" ? (0, n.termToString)(y) : "", !0);
          return await new Promise((y) => {
            p.bindingsStream.on("data", (m) => {
              (_.getFirst(m, !1) ?? _.put(m, [])).push(m);
            }), p.bindingsStream.on("end", y), p.bindingsStream.on("error", (m) => {
              f.emit("error", m);
            });
          }), new t.MultiTransformIterator(b.bindingsStream, {
            multiTransform: (y) => new t.ArrayIterator(_.get(y).flat().map((m) => u.ActorRdfJoin.joinBindings(y, m)).filter((m) => m !== null), { autoStart: !1 }),
            autoStart: !1
          });
        }, {
          autoStart: !1,
          onClose() {
            p.bindingsStream.destroy(), b.bindingsStream.destroy();
          }
        });
      } else {
        const { hashFunction: p } = await this.mediatorHashBindings.mediate({ context: s.context }), b = h.map((_) => _.variable);
        f = new e.HashJoin(d.entriesSorted[0].output.bindingsStream, d.entriesSorted[1].output.bindingsStream, (_) => p(_, b), u.ActorRdfJoin.joinBindings);
      }
      return {
        result: {
          type: "bindings",
          bindingsStream: f,
          metadata: async () => await this.constructResultMetadata(d.entriesSorted, l, s.context)
        }
      };
    }
    async getJoinCoefficients(s, d) {
      let l = s.entries;
      d.metadatas[1].cardinality.value < d.metadatas[0].cardinality.value && (d.metadatas = [d.metadatas[1], d.metadatas[0]], l = [s.entries[1], s.entries[0]]);
      const { metadatas: f } = d, h = u.ActorRdfJoin.getRequestInitialTimes(f), p = u.ActorRdfJoin.getRequestItemTimes(f);
      let b = f[0].cardinality.value + f[1].cardinality.value;
      return this.canHandleUndefs || (b *= 0.8), (0, r.passTestWithSideData)({
        iterations: b,
        persistedItems: f[0].cardinality.value,
        blockingItems: f[0].cardinality.value,
        requestTime: h[0] + f[0].cardinality.value * p[0] + h[1] + f[1].cardinality.value * p[1]
      }, { ...d, entriesSorted: l });
    }
  };
  return dm.ActorRdfJoinHash = i, dm;
}
var FU;
function NU() {
  return FU || (FU = 1, function(u) {
    var r = _d && _d.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _d && _d.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _pe(), u);
  }(_d)), _d;
}
var md = {}, hm = {}, PU;
function gpe() {
  if (PU) return hm;
  PU = 1, Object.defineProperty(hm, "__esModule", { value: !0 }), hm.ActorRdfJoinSymmetricHash = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = c4();
  let a = class extends u.ActorRdfJoin {
    constructor(e) {
      super(e, {
        logicalType: "inner",
        physicalName: "symmetric-hash",
        limitEntries: 2,
        requiresVariableOverlap: !0
      });
    }
    async getOutput(e) {
      const n = await u.ActorRdfJoin.getMetadatas(e.entries), i = u.ActorRdfJoin.overlappingVariables(n), { hashFunction: c } = await this.mediatorHashBindings.mediate({ context: e.context }), s = i.map((l) => l.variable);
      return {
        result: {
          type: "bindings",
          bindingsStream: new o.SymmetricHashJoin(e.entries[0].output.bindingsStream, e.entries[1].output.bindingsStream, (l) => c(l, s), u.ActorRdfJoin.joinBindings),
          metadata: async () => await this.constructResultMetadata(e.entries, n, e.context)
        }
      };
    }
    async getJoinCoefficients(e, n) {
      const { metadatas: i } = n, c = u.ActorRdfJoin.getRequestInitialTimes(i), s = u.ActorRdfJoin.getRequestItemTimes(i);
      return (0, r.passTestWithSideData)({
        iterations: i[0].cardinality.value + i[1].cardinality.value,
        persistedItems: i[0].cardinality.value + i[1].cardinality.value,
        blockingItems: 0,
        requestTime: c[0] + i[0].cardinality.value * s[0] + c[1] + i[1].cardinality.value * s[1]
      }, n);
    }
  };
  return hm.ActorRdfJoinSymmetricHash = a, hm;
}
var DU;
function mpe() {
  return DU || (DU = 1, function(u) {
    var r = md && md.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = md && md.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ gpe(), u);
  }(md)), md;
}
var vd = {}, pm = {}, LU;
function vpe() {
  if (LU) return pm;
  LU = 1, Object.defineProperty(pm, "__esModule", { value: !0 }), pm.ActorRdfJoinNestedLoop = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = c4();
  let a = class extends u.ActorRdfJoin {
    constructor(e) {
      super(e, {
        logicalType: "inner",
        physicalName: "nested-loop",
        limitEntries: 2,
        canHandleUndefs: !0
      });
    }
    async getOutput(e) {
      return {
        result: {
          type: "bindings",
          bindingsStream: new o.NestedLoopJoin(e.entries[0].output.bindingsStream, e.entries[1].output.bindingsStream, u.ActorRdfJoin.joinBindings, { autoStart: !1 }),
          metadata: async () => await this.constructResultMetadata(e.entries, await u.ActorRdfJoin.getMetadatas(e.entries), e.context)
        }
      };
    }
    async getJoinCoefficients(e, n) {
      const { metadatas: i } = n, c = u.ActorRdfJoin.getRequestInitialTimes(i), s = u.ActorRdfJoin.getRequestItemTimes(i);
      return (0, r.passTestWithSideData)({
        iterations: i[0].cardinality.value * i[1].cardinality.value,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: c[0] + i[0].cardinality.value * s[0] + c[1] + i[1].cardinality.value * s[1]
      }, n);
    }
  };
  return pm.ActorRdfJoinNestedLoop = a, pm;
}
var jU;
function Tpe() {
  return jU || (jU = 1, function(u) {
    var r = vd && vd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vd && vd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ vpe(), u);
  }(vd)), vd;
}
var Td = {}, bm = {}, wd = {}, ym = {}, Sd = {}, MU;
function UY() {
  if (MU) return Sd;
  MU = 1, Object.defineProperty(Sd, "__esModule", { value: !0 }), Sd.bindingsToCompactString = Sd.bindingsToString = void 0;
  const u = lr();
  function r(a) {
    const t = {};
    for (const e of a.keys())
      t[e.value] = (0, u.termToString)(a.get(e));
    return JSON.stringify(t, null, "  ");
  }
  Sd.bindingsToString = r;
  function o(a, t) {
    return t.map((e) => {
      const n = a.get(e);
      return n ? (0, u.termToString)(n) : "";
    }).join("");
  }
  return Sd.bindingsToCompactString = o, Sd;
}
var CU;
function VY() {
  if (CU) return ym;
  CU = 1, Object.defineProperty(ym, "__esModule", { value: !0 }), ym.Bindings = void 0;
  const u = /* @__PURE__ */ _e(), r = b8, o = /* @__PURE__ */ UY();
  let a = class Hr {
    constructor(e, n, i) {
      this.type = "bindings", this.dataFactory = e, this.entries = n, this.contextHolder = i;
    }
    has(e) {
      return this.entries.has(typeof e == "string" ? e : e.value);
    }
    get(e) {
      return this.entries.get(typeof e == "string" ? e : e.value);
    }
    set(e, n) {
      return new Hr(this.dataFactory, this.entries.set(typeof e == "string" ? e : e.value, n), this.contextHolder);
    }
    delete(e) {
      return new Hr(this.dataFactory, this.entries.delete(typeof e == "string" ? e : e.value), this.contextHolder);
    }
    keys() {
      return this.mapIterable(this.iteratorToIterable(this.entries.keys()), (e) => this.dataFactory.variable(e));
    }
    values() {
      return this.iteratorToIterable(this.entries.values());
    }
    forEach(e) {
      for (const [n, i] of this.entries.entries())
        e(i, this.dataFactory.variable(n));
    }
    get size() {
      return this.entries.size;
    }
    [Symbol.iterator]() {
      return this.mapIterable(this.iteratorToIterable(this.entries.entries()), ([e, n]) => [this.dataFactory.variable(e), n])[Symbol.iterator]();
    }
    equals(e) {
      var n;
      if (!e)
        return !1;
      if (this === e)
        return !0;
      if (this.size !== e.size)
        return !1;
      for (const i of this.keys())
        if (!((n = this.get(i)) != null && n.equals(e.get(i))))
          return !1;
      return !0;
    }
    filter(e) {
      return new Hr(this.dataFactory, (0, r.Map)(this.entries.filter((n, i) => e(n, this.dataFactory.variable(i)))), this.contextHolder);
    }
    map(e) {
      return new Hr(this.dataFactory, (0, r.Map)(this.entries.map((n, i) => e(n, this.dataFactory.variable(i)))), this.contextHolder);
    }
    merge(e) {
      if (this.size < e.size && e instanceof Hr)
        return e.merge(this);
      let n = this.entries;
      if (e instanceof Hr)
        for (const [i, c] of e.entries) {
          const s = this.entries.get(i);
          if (s && !s.equals(c))
            return;
          n = n.set(i, c);
        }
      else
        for (const [i, c] of e) {
          const s = this.entries.get(i.value);
          if (s && !s.equals(c))
            return;
          n = n.set(i.value, c);
        }
      return this.createBindingsWithContexts(n, e);
    }
    mergeWith(e, n) {
      if (this.size < n.size && n instanceof Hr)
        return n.mergeWith(e, this);
      let i = this.entries;
      if (n instanceof Hr)
        for (const [c, s] of n.entries) {
          const d = this.entries.get(c);
          let l;
          d && !d.equals(s) ? l = e(d, s, this.dataFactory.variable(c)) : l = s, i = i.set(c, l);
        }
      else
        for (const [c, s] of n) {
          const d = this.entries.get(c.value);
          let l;
          d && !d.equals(s) ? l = e(d, s, c) : l = s, i = i.set(c.value, l);
        }
      return this.createBindingsWithContexts(i, n);
    }
    createBindingsWithContexts(e, n) {
      if (this.contextHolder && this.contextHolder.context) {
        let i = this.contextHolder.context;
        return "contextHolder" in n && n.contextHolder && n.contextHolder.context && (i = Hr.mergeContext(this.contextHolder.contextMergeHandlers, i, n.contextHolder.context)), new Hr(this.dataFactory, e, { contextMergeHandlers: this.contextHolder.contextMergeHandlers, context: i });
      }
      return new Hr(this.dataFactory, e, n.contextHolder);
    }
    static mergeContext(e, n, i) {
      const c = [...n.keys(), ...i.keys()], s = {}, d = {}, l = new Set(i.keys().map((h) => h.name)), f = n.keys().filter((h) => l.has(h.name));
      for (const h of c) {
        if (d[h.name] === 1)
          continue;
        d[h.name] = 1;
        const p = f.some((b) => b.name === h.name);
        if (e[h.name] && p) {
          s[h.name] = e[h.name].run(n.get(h), i.get(h));
          continue;
        }
        if (!(!e[h.name] && p)) {
          if (!n.get(h)) {
            s[h.name] = i.get(h);
            continue;
          }
          i.get(h) || (s[h.name] = n.get(h));
        }
      }
      return new u.ActionContext(s);
    }
    setContextEntry(e, n) {
      return this.setContextEntryRaw(e, n);
    }
    setContextEntryRaw(e, n) {
      var i;
      return this.contextHolder && this.contextHolder.context ? new Hr(this.dataFactory, this.entries, {
        contextMergeHandlers: this.contextHolder.contextMergeHandlers,
        context: this.contextHolder.context.set(e, n)
      }) : new Hr(this.dataFactory, this.entries, {
        contextMergeHandlers: ((i = this.contextHolder) == null ? void 0 : i.contextMergeHandlers) ?? {},
        context: new u.ActionContext().set(e, n)
      });
    }
    deleteContextEntry(e) {
      return this.deleteContextEntryRaw(e);
    }
    deleteContextEntryRaw(e) {
      var n;
      return this.contextHolder ? new Hr(this.dataFactory, this.entries, {
        contextMergeHandlers: this.contextHolder.contextMergeHandlers,
        context: (n = this.contextHolder.context) == null ? void 0 : n.delete(e)
      }) : new Hr(this.dataFactory, this.entries);
    }
    getContext() {
      var e;
      return (e = this.contextHolder) == null ? void 0 : e.context;
    }
    getContextEntry(e) {
      var n;
      return (n = this.getContext()) == null ? void 0 : n.get(e);
    }
    toString() {
      return (0, o.bindingsToString)(this);
    }
    *mapIterable(e, n) {
      for (const i of e)
        yield n(i);
    }
    iteratorToIterable(e) {
      return {
        [Symbol.iterator]: () => e
      };
    }
  };
  return ym.Bindings = a, ym;
}
var _m = {}, qU;
function wpe() {
  if (qU) return _m;
  qU = 1, Object.defineProperty(_m, "__esModule", { value: !0 }), _m.BindingsFactory = void 0;
  const u = b8, r = /* @__PURE__ */ VY();
  let o = class QY {
    constructor(t, e) {
      this.dataFactory = t, this.contextMergeHandlers = e;
    }
    static async create(t, e, n) {
      return new QY(n, (await t.mediate({ context: e })).mergeHandlers);
    }
    bindings(t = []) {
      return new r.Bindings(this.dataFactory, (0, u.Map)(t.map(([e, n]) => [e.value, n])), this.contextMergeHandlers ? { contextMergeHandlers: this.contextMergeHandlers } : void 0);
    }
    fromBindings(t) {
      return this.bindings([...t]);
    }
    fromRecord(t) {
      return this.bindings(Object.entries(t).map(([e, n]) => [this.dataFactory.variable(e), n]));
    }
  };
  return _m.BindingsFactory = o, _m;
}
var BU;
function Jt() {
  return BU || (BU = 1, function(u) {
    var r = wd && wd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = wd && wd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ VY(), u), o(/* @__PURE__ */ wpe(), u), o(/* @__PURE__ */ UY(), u);
  }(wd)), wd;
}
var $U;
function Spe() {
  if ($U) return bm;
  $U = 1, Object.defineProperty(bm, "__esModule", { value: !0 }), bm.ActorRdfJoinOptionalHash = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ H8(), t = /* @__PURE__ */ uu(), e = /* @__PURE__ */ yt(), n = lr();
  let i = class yx extends u.ActorRdfJoin {
    constructor(s) {
      super(s, {
        logicalType: "optional",
        physicalName: `hash-${s.canHandleUndefs ? "undef" : "def"}-${s.blocking ? "blocking" : "nonblocking"}`,
        limitEntries: 2,
        canHandleUndefs: s.canHandleUndefs,
        requiresVariableOverlap: !0
      });
    }
    static constructIndex(s, d) {
      return s ? new a.BindingsIndexUndef(d, (l) => l && l.termType !== "Variable" ? (0, n.termToString)(l) : "", !0) : new a.BindingsIndexDef(d, o.bindingsToCompactString);
    }
    async getOutput(s) {
      const d = s.entries[1].output, l = s.entries[0].output, f = await u.ActorRdfJoin.getMetadatas(s.entries), h = u.ActorRdfJoin.overlappingVariables(f);
      let p;
      return this.blocking ? p = new t.ClosableTransformIterator(async () => {
        const b = yx.constructIndex(this.canHandleUndefs, h);
        return await new Promise((_) => {
          d.bindingsStream.on("data", (y) => {
            (b.getFirst(y, !0) ?? b.put(y, [])).push(y);
          }), d.bindingsStream.on("end", _), d.bindingsStream.on("error", (y) => {
            p.emit("error", y);
          });
        }), new e.MultiTransformIterator(l.bindingsStream, {
          multiTransform: (_) => new e.ArrayIterator(b.get(_).flat().map((y) => u.ActorRdfJoin.joinBindings(_, y)).filter((y) => y !== null), { autoStart: !1 }),
          optional: !0,
          autoStart: !1
        });
      }, {
        autoStart: !1,
        onClose() {
          d.bindingsStream.destroy(), l.bindingsStream.destroy();
        }
      }) : p = new t.ClosableTransformIterator(async () => {
        const b = yx.constructIndex(this.canHandleUndefs, h);
        let _ = !0;
        return d.bindingsStream.on("data", (y) => {
          (b.getFirst(y, !0) ?? b.put(y, new e.BufferedIterator({ autoStart: !1 })))._push(y);
        }), d.bindingsStream.on("end", () => {
          for (const y of b.values())
            y.close();
          _ = !1;
        }), d.bindingsStream.on("error", (y) => {
          p.emit("error", y);
        }), new e.MultiTransformIterator(l.bindingsStream, {
          multiTransform: (y) => {
            let m = b.get(y);
            return m.length === 0 && (_ ? m = [b.put(y, new e.BufferedIterator({ autoStart: !1 }))] : m = []), new e.UnionIterator(m.map((T) => T.clone()), { autoStart: !1 }).map((T) => u.ActorRdfJoin.joinBindings(y, T));
          },
          optional: !0,
          autoStart: !1
        });
      }, {
        autoStart: !1,
        onClose() {
          d.bindingsStream.destroy(), l.bindingsStream.destroy();
        }
      }), {
        result: {
          type: "bindings",
          bindingsStream: p,
          metadata: async () => await this.constructResultMetadata(s.entries, f, s.context, {}, !0)
        }
      };
    }
    async getJoinCoefficients(s, d) {
      const { metadatas: l } = d, f = u.ActorRdfJoin.getRequestInitialTimes(l), h = u.ActorRdfJoin.getRequestItemTimes(l);
      let p = l[0].cardinality.value + l[1].cardinality.value;
      return this.canHandleUndefs || (p *= 0.8), this.blocking && (p *= 0.9), (0, r.passTestWithSideData)({
        iterations: p,
        persistedItems: l[0].cardinality.value,
        blockingItems: this.blocking ? l[0].cardinality.value : 0,
        requestTime: f[0] + l[0].cardinality.value * h[0] + f[1] + l[1].cardinality.value * h[1]
      }, d);
    }
  };
  return bm.ActorRdfJoinOptionalHash = i, bm;
}
var UU;
function G6() {
  return UU || (UU = 1, function(u) {
    var r = Td && Td.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Td && Td.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Spe(), u);
  }(Td)), Td;
}
var Ad = {}, gm = {}, VU;
function Ape() {
  if (VU) return gm;
  VU = 1, Object.defineProperty(gm, "__esModule", { value: !0 }), gm.ActorRdfJoinOptionalNestedLoop = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = c4();
  let a = class extends u.ActorRdfJoin {
    constructor(e) {
      super(e, {
        logicalType: "optional",
        physicalName: "nested-loop",
        limitEntries: 2,
        canHandleUndefs: !0
      });
    }
    async getOutput(e) {
      return {
        result: {
          type: "bindings",
          bindingsStream: new o.NestedLoopJoin(e.entries[0].output.bindingsStream, e.entries[1].output.bindingsStream, u.ActorRdfJoin.joinBindings, { optional: !0, autoStart: !1 }),
          metadata: async () => await this.constructResultMetadata(e.entries, await u.ActorRdfJoin.getMetadatas(e.entries), e.context, {}, !0)
        }
      };
    }
    async getJoinCoefficients(e, n) {
      const { metadatas: i } = n, c = u.ActorRdfJoin.getRequestInitialTimes(i), s = u.ActorRdfJoin.getRequestItemTimes(i);
      return (0, r.passTestWithSideData)({
        iterations: i[0].cardinality.value * i[1].cardinality.value,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: c[0] + i[0].cardinality.value * s[0] + c[1] + i[1].cardinality.value * s[1]
      }, n);
    }
  };
  return gm.ActorRdfJoinOptionalNestedLoop = a, gm;
}
var QU;
function Epe() {
  return QU || (QU = 1, function(u) {
    var r = Ad && Ad.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ad && Ad.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ape(), u);
  }(Ad)), Ad;
}
var Ed = {}, mm = {}, HU;
function Ope() {
  if (HU) return mm;
  HU = 1, Object.defineProperty(mm, "__esModule", { value: !0 }), mm.ActorRdfJoinMinusHash = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ H8(), t = /* @__PURE__ */ uu(), e = lr();
  let n = class HY extends u.ActorRdfJoin {
    constructor(c) {
      super(c, {
        logicalType: "minus",
        physicalName: `hash-${c.canHandleUndefs ? "undef" : "def"}`,
        limitEntries: 2,
        canHandleUndefs: c.canHandleUndefs
      });
    }
    static constructIndex(c, s) {
      return c ? new a.BindingsIndexUndef(s, (d) => d && d.termType !== "Variable" ? (0, e.termToString)(d) : "", !1) : new a.BindingsIndexDef(s, o.bindingsToCompactString);
    }
    async getOutput(c) {
      const s = c.entries[1].output, d = c.entries[0].output, l = await u.ActorRdfJoin.getMetadatas(c.entries), f = u.ActorRdfJoin.overlappingVariables(l);
      if (f.length === 0)
        return s.bindingsStream.destroy(), { result: d };
      const h = new t.ClosableTransformIterator(async () => {
        const p = HY.constructIndex(this.canHandleUndefs, f);
        return await new Promise((b) => {
          s.bindingsStream.on("data", (_) => p.put(_, !0)), s.bindingsStream.on("end", b), s.bindingsStream.on("error", (_) => h.emit("error", _));
        }), d.bindingsStream.filter((b) => !p.getFirst(b, !0));
      }, {
        autoStart: !1,
        onClose() {
          s.bindingsStream.destroy(), d.bindingsStream.destroy();
        }
      });
      return {
        result: {
          type: "bindings",
          bindingsStream: h,
          metadata: d.metadata
        }
      };
    }
    async getJoinCoefficients(c, s) {
      const { metadatas: d } = s, l = u.ActorRdfJoin.getRequestInitialTimes(d), f = u.ActorRdfJoin.getRequestItemTimes(d);
      let h = d[0].cardinality.value + d[1].cardinality.value;
      return this.canHandleUndefs || (h *= 0.8), (0, r.passTestWithSideData)({
        iterations: h,
        persistedItems: d[0].cardinality.value,
        blockingItems: d[0].cardinality.value,
        requestTime: l[0] + d[0].cardinality.value * f[0] + l[1] + d[1].cardinality.value * f[1]
      }, s);
    }
  };
  return mm.ActorRdfJoinMinusHash = n, mm;
}
var GU;
function zU() {
  return GU || (GU = 1, function(u) {
    var r = Ed && Ed.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ed && Ed.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ope(), u);
  }(Ed)), Ed;
}
var Od = {}, vm = {}, xd = {}, Tm = {}, kU;
function xpe() {
  if (kU) return Tm;
  kU = 1, Object.defineProperty(Tm, "__esModule", { value: !0 }), Tm.ActorDereferenceRdf = void 0;
  const u = /* @__PURE__ */ F8();
  let r = class extends u.ActorDereferenceParse {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF dereferencing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return Tm.ActorDereferenceRdf = r, Tm;
}
var XU;
function Ipe() {
  return XU || (XU = 1, function(u) {
    var r = xd && xd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xd && xd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ xpe(), u);
  }(xd)), xd;
}
var JU;
function Rpe() {
  if (JU) return vm;
  JU = 1, Object.defineProperty(vm, "__esModule", { value: !0 }), vm.ActorDereferenceRdfParse = void 0;
  const u = /* @__PURE__ */ Ipe();
  let r = class extends u.ActorDereferenceRdf {
    /**
     * @param args - @defaultNested {{
     *   "ttl":      "text/turtle",
     *   "turtle":   "text/turtle",
     *   "shaclc":   "text/shaclc",
     *   "shc":      "text/shaclc",
     *   "shaclce":  "text/shaclc-ext",
     *   "shce":     "text/shaclc-ext",
     *   "nt":       "application/n-triples",
     *   "ntriples": "application/n-triples",
     *   "nq":       "application/n-quads",
     *   "nquads":   "application/n-quads",
     *   "rdf":      "application/rdf+xml",
     *   "rdfxml":   "application/rdf+xml",
     *   "owl":      "application/rdf+xml",
     *   "n3":       "text/n3",
     *   "trig":     "application/trig",
     *   "jsonld":   "application/ld+json",
     *   "json":     "application/json",
     *   "html":     "text/html",
     *   "htm":      "text/html",
     *   "xhtml":    "application/xhtml+xml",
     *   "xht":      "application/xhtml+xml",
     *   "xml":      "application/xml",
     *   "svg":      "image/svg+xml",
     *   "svgz":     "image/svg+xml"
     * }} mediaMappings
     */
    constructor(a) {
      super(a);
    }
    async getMetadata(a) {
      return { baseIRI: a.url };
    }
  };
  return vm.ActorDereferenceRdfParse = r, vm;
}
var KU;
function Fpe() {
  return KU || (KU = 1, function(u) {
    var r = Od && Od.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Od && Od.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rpe(), u);
  }(Od)), Od;
}
var Id = {}, wm = {}, Sm = {}, WU;
function Npe() {
  if (WU) return Sm;
  WU = 1, Object.defineProperty(Sm, "__esModule", { value: !0 }), Sm.HtmlScriptListener = void 0;
  const u = /* @__PURE__ */ Be(), r = Bt(), o = Tr();
  let a = class wT {
    constructor(e, n, i, c, s, d, l, f) {
      this.textChunksJsonLd = [], this.endBarrier = 1, this.passedScripts = 0, this.isFinalJsonLdProcessing = !1, this.mediatorRdfParseHandle = e, this.cbQuad = n, this.cbError = i, this.cbEnd = c, this.supportedTypes = s, this.context = d.set(u.KeysRdfParseHtmlScript.processingHtmlScript, !0), this.baseIRI = l, this.headers = f, this.onlyFirstScript = d.get(u.KeysRdfParseHtmlScript.extractAllScripts) === !1;
      const h = this.baseIRI.indexOf("#");
      this.targetScriptId = h > 0 ? this.baseIRI.slice(h + 1, this.baseIRI.length) : null;
    }
    static newErrorCoded(e, n) {
      const i = new Error(e);
      return i.code = n, i;
    }
    onEnd() {
      --this.endBarrier === 0 && (this.textChunksJsonLd.length > 0 ? (this.handleMediaType = "application/ld+json", this.textChunks = this.textChunksJsonLd, this.textChunks.push("]"), this.textChunksJsonLd = [], this.isFinalJsonLdProcessing = !0, this.endBarrier++, this.onTagClose()) : (this.passedScripts === 0 && this.targetScriptId && this.cbError(wT.newErrorCoded(`Failed to find targeted script id "${this.targetScriptId}"`, "loading document failed")), this.cbEnd()), this.isFinalJsonLdProcessing = !1);
    }
    onTagClose() {
      if (this.handleMediaType)
        if (this.requiresCustomJsonLdHandling(this.handleMediaType) && !this.isFinalJsonLdProcessing)
          this.handleMediaType = void 0, this.textChunks = void 0, this.onEnd();
        else {
          const e = new r.Readable({ objectMode: !0 });
          e._read = () => {
          };
          const n = this.textChunks, i = {
            context: this.context,
            handle: {
              metadata: { baseIRI: this.baseIRI },
              data: e,
              headers: this.headers,
              context: this.context
            },
            handleMediaType: this.handleMediaType
          };
          this.mediatorRdfParseHandle.mediate(i).then(({ handle: c }) => {
            c.data.on("error", (s) => this.cbError(wT.newErrorCoded(s.message, "invalid script element"))).on("data", this.cbQuad).on("end", () => this.onEnd());
            for (const s of n)
              e.push(s);
            e.push(null);
          }).catch((c) => {
            this.targetScriptId ? this.cbError(wT.newErrorCoded(c.message, "loading document failed")) : this.onEnd();
          }), this.handleMediaType = void 0, this.textChunks = void 0;
        }
    }
    onTagOpen(e, n) {
      e === "base" && n.href && (this.baseIRI = (0, o.resolve)(n.href, this.baseIRI)), e === "script" && (!this.targetScriptId || n.id === this.targetScriptId) ? this.supportedTypes[n.type] ? this.onlyFirstScript && this.passedScripts > 0 ? this.handleMediaType = void 0 : (this.passedScripts++, this.handleMediaType = n.type, this.endBarrier++, this.requiresCustomJsonLdHandling(this.handleMediaType) ? (this.textChunks = this.textChunksJsonLd, this.textChunks.push(this.textChunks.length === 0 ? "[" : ",")) : this.textChunks = []) : this.targetScriptId && this.cbError(wT.newErrorCoded(`Targeted script "${this.targetScriptId}" does not have a supported type`, "loading document failed")) : this.handleMediaType = void 0;
    }
    onText(e) {
      this.handleMediaType && this.textChunks.push(e);
    }
    /**
     * If we require custom JSON-LD handling for the given media type.
     *
     * The JSON-LD spec requires JSON-LD within script tags to be seen as a single document.
     * As such, we have to buffer all JSON-LD until the end of HTML processing,
     * and encapsulate all found contents in an array.
     *
     * @param mediaType A: IActionRdfParseHtml media type.
     */
    requiresCustomJsonLdHandling(e) {
      return !this.onlyFirstScript && !this.targetScriptId && e === "application/ld+json";
    }
  };
  return Sm.HtmlScriptListener = a, Sm;
}
var YU;
function Ppe() {
  if (YU) return wm;
  YU = 1, Object.defineProperty(wm, "__esModule", { value: !0 }), wm.ActorRdfParseHtmlScript = void 0;
  const u = /* @__PURE__ */ q8(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Npe();
  let a = class extends u.ActorRdfParseHtml {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (0, r.passTestVoid)();
    }
    async run(e) {
      const n = (await this.mediatorRdfParseMediatypes.mediate({ context: e.context, mediaTypes: !0 })).mediaTypes;
      return { htmlParseListener: new o.HtmlScriptListener(this.mediatorRdfParseHandle, e.emit, e.error, e.end, n, e.context, e.baseIRI, e.headers) };
    }
  };
  return wm.ActorRdfParseHtmlScript = a, wm;
}
var ZU;
function Dpe() {
  return ZU || (ZU = 1, function(u) {
    var r = Id && Id.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Id && Id.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ppe(), u);
  }(Id)), Id;
}
var Rd = {}, Am = {}, eV;
function Lpe() {
  if (eV) return Am;
  eV = 1, Object.defineProperty(Am, "__esModule", { value: !0 }), Am.ActorQueryResultSerializeRdf = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e();
  let o = class extends u.ActorQueryResultSerialize {
    constructor(t) {
      super(t);
    }
    async testHandle(t, e, n) {
      if (t.type !== "quads")
        return (0, r.failTest)(`Actor ${this.name} can only handle quad streams`);
      const { mediaTypes: i } = await this.mediatorMediaTypeCombiner.mediate({ context: n, mediaTypes: !0 });
      return e in i ? (0, r.passTestVoid)() : (0, r.failTest)(`Actor ${this.name} can not handle media type ${e}. All available types: ${// eslint-disable-next-line ts/restrict-template-expressions
      Object.keys(i)}`);
    }
    async runHandle(t, e, n) {
      return (await this.mediatorRdfSerialize.mediate({
        context: n,
        handle: {
          context: n,
          quadStream: t.quadStream
        },
        handleMediaType: e
      })).handle;
    }
    async testMediaType(t) {
      return (0, r.passTestVoid)();
    }
    async getMediaTypes(t) {
      return (await this.mediatorMediaTypeCombiner.mediate({ context: t, mediaTypes: !0 })).mediaTypes;
    }
    async testMediaTypeFormats(t) {
      return (0, r.passTestVoid)();
    }
    async getMediaTypeFormats(t) {
      return (await this.mediatorMediaTypeFormatCombiner.mediate({ context: t, mediaTypeFormats: !0 })).mediaTypeFormats;
    }
  };
  return Am.ActorQueryResultSerializeRdf = o, Am;
}
var tV;
function jpe() {
  return tV || (tV = 1, function(u) {
    var r = Rd && Rd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Rd && Rd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Lpe(), u);
  }(Rd)), Rd;
}
var Fd = {}, Em = {}, Nd = {}, Om = {}, rV;
function Mpe() {
  if (rV) return Om;
  rV = 1, Object.defineProperty(Om, "__esModule", { value: !0 }), Om.ActorBindingsAggregatorFactory = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *  \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *  \ @defaultNested {Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a), this.mediatorExpressionEvaluatorFactory = a.mediatorExpressionEvaluatorFactory;
    }
  };
  return Om.ActorBindingsAggregatorFactory = r, Om;
}
var xm = {}, nV;
function Cpe() {
  if (nV) return xm;
  nV = 1, Object.defineProperty(xm, "__esModule", { value: !0 }), xm.AggregateEvaluator = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ ve(), o = lr();
  let a = class {
    constructor(e, n, i = !1) {
      this.evaluator = e, this.distinct = n, this.throwError = i, this.errorOccurred = !1, this.errorOccurred = !1, this.superTypeProvider = e.context.getSafe(u.KeysExpressionEvaluator.superTypeProvider), this.termTransformer = new r.TermTransformer(this.superTypeProvider), this.variableValues = /* @__PURE__ */ new Set();
    }
    emptyValueTerm() {
    }
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     */
    emptyValue() {
      const e = this.emptyValueTerm();
      if (e === void 0 && this.throwError)
        throw new r.EmptyAggregateError();
      return e;
    }
    /**
     * Base implementation of putBindings, that evaluates to a term and then calls putTerm.
     * The WildcardCountAggregator will completely discard this implementation.
     * @param bindings
     */
    async putBindings(e) {
      if (!this.errorOccurred)
        try {
          const n = await this.evaluator.evaluate(e);
          if (!n || this.errorOccurred)
            return;
          (!this.distinct || !this.variableValues.has(o.termToString(n))) && (this.putTerm(n), this.distinct && this.variableValues.add(o.termToString(n)));
        } catch (n) {
          this.safeThrow(n);
        }
    }
    async result() {
      if (!this.errorOccurred)
        return this.termResult();
    }
    safeThrow(e) {
      if (this.throwError)
        throw e;
      this.errorOccurred = !0;
    }
    termToNumericOrError(e) {
      if (e.termType !== "Literal")
        throw new Error(`Term with value ${e.value} has type ${e.termType} and is not a numeric literal`);
      if (!r.isSubTypeOf(e.datatype.value, r.TypeAlias.SPARQL_NUMERIC, this.superTypeProvider))
        throw new Error(`Term datatype ${e.datatype.value} with value ${e.value} has type ${e.termType} and is not a numeric literal`);
      return this.termTransformer.transformLiteral(e);
    }
  };
  return xm.AggregateEvaluator = a, xm;
}
var iV;
function Wr() {
  return iV || (iV = 1, function(u) {
    var r = Nd && Nd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Nd && Nd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Mpe(), u), o(/* @__PURE__ */ Cpe(), u);
  }(Nd)), Nd;
}
var Im = {}, aV;
function GY() {
  if (aV) return Im;
  aV = 1, Object.defineProperty(Im, "__esModule", { value: !0 }), Im.GroupConcatAggregator = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ ve();
  let o = class extends u.AggregateEvaluator {
    constructor(t, e, n, i, c) {
      super(t, e, c), this.dataFactory = n, this.state = void 0, this.lastLanguageValid = !0, this.lastLanguage = void 0, this.separator = i ?? " ";
    }
    emptyValueTerm() {
      return r.typedLiteral("", r.TypeURL.XSD_STRING);
    }
    putTerm(t) {
      this.state === void 0 ? (this.state = t.value, t.termType === "Literal" && (this.lastLanguage = t.language)) : (this.state += this.separator + t.value, this.lastLanguageValid && t.termType === "Literal" && this.lastLanguage !== t.language && (this.lastLanguageValid = !1, this.lastLanguage = void 0));
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : this.lastLanguageValid && this.lastLanguage ? r.langString(this.state, this.lastLanguage).toRDF(this.dataFactory) : r.typedLiteral(this.state, r.TypeURL.XSD_STRING);
    }
  };
  return Im.GroupConcatAggregator = o, Im;
}
var uV;
function qpe() {
  if (uV) return Em;
  uV = 1, Object.defineProperty(Em, "__esModule", { value: !0 }), Em.ActorBindingsAggregatorFactoryGroupConcat = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ GY();
  let t = class extends u.ActorBindingsAggregatorFactory {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return n.expr.aggregator !== "group_concat" ? (0, o.failTest)("This actor only supports the 'group_concat' aggregator.") : (0, o.passTestVoid)();
    }
    async run({ context: n, expr: i }) {
      return new a.GroupConcatAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: i.expression, context: n }), i.distinct, n.getSafe(r.KeysInitQuery.dataFactory), i.separator);
    }
  };
  return Em.ActorBindingsAggregatorFactoryGroupConcat = t, Em;
}
var oV;
function Bpe() {
  return oV || (oV = 1, function(u) {
    var r = Fd && Fd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Fd && Fd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qpe(), u), o(/* @__PURE__ */ GY(), u);
  }(Fd)), Fd;
}
var Pd = {}, Rm = {}, Fm = {}, sV;
function zY() {
  if (sV) return Fm;
  sV = 1, Object.defineProperty(Fm, "__esModule", { value: !0 }), Fm.CountAggregator = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ ve();
  let o = class extends u.AggregateEvaluator {
    constructor(t, e, n) {
      super(t, e, n), this.state = void 0;
    }
    emptyValueTerm() {
      return (0, r.typedLiteral)("0", r.TypeURL.XSD_INTEGER);
    }
    putTerm(t) {
      this.state === void 0 && (this.state = 0), this.state++;
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : (0, r.typedLiteral)(String(this.state), r.TypeURL.XSD_INTEGER);
    }
  };
  return Fm.CountAggregator = o, Fm;
}
var cV;
function $pe() {
  if (cV) return Rm;
  cV = 1, Object.defineProperty(Rm, "__esModule", { value: !0 }), Rm.ActorBindingsAggregatorFactoryCount = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ _e(), o = ft(), a = /* @__PURE__ */ zY();
  let t = class extends u.ActorBindingsAggregatorFactory {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return n.expr.aggregator !== "count" || n.expr.expression.expressionType === o.Algebra.expressionTypes.WILDCARD ? (0, r.failTest)("This actor only supports the 'count' aggregator without wildcard.") : (0, r.passTestVoid)();
    }
    async run({ context: n, expr: i }) {
      return new a.CountAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: i.expression, context: n }), i.distinct);
    }
  };
  return Rm.ActorBindingsAggregatorFactoryCount = t, Rm;
}
var dV;
function Upe() {
  return dV || (dV = 1, function(u) {
    var r = Pd && Pd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Pd && Pd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ $pe(), u), o(/* @__PURE__ */ zY(), u);
  }(Pd)), Pd;
}
var Dd = {}, Nm = {}, Pm = {}, lV;
function kY() {
  if (lV) return Pm;
  lV = 1, Object.defineProperty(Pm, "__esModule", { value: !0 }), Pm.SampleAggregator = void 0;
  const u = /* @__PURE__ */ Wr();
  let r = class extends u.AggregateEvaluator {
    constructor(a, t, e) {
      super(a, t, e), this.state = void 0;
    }
    putTerm(a) {
      this.state === void 0 && (this.state = a);
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : this.state;
    }
  };
  return Pm.SampleAggregator = r, Pm;
}
var fV;
function Vpe() {
  if (fV) return Nm;
  fV = 1, Object.defineProperty(Nm, "__esModule", { value: !0 }), Nm.ActorBindingsAggregatorFactorySample = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ kY();
  let a = class extends u.ActorBindingsAggregatorFactory {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return e.expr.aggregator !== "sample" ? (0, r.failTest)("This actor only supports the 'sample' aggregator.") : (0, r.passTestVoid)();
    }
    async run({ context: e, expr: n }) {
      return new o.SampleAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: n.expression, context: e }), n.distinct);
    }
  };
  return Nm.ActorBindingsAggregatorFactorySample = a, Nm;
}
var hV;
function Qpe() {
  return hV || (hV = 1, function(u) {
    var r = Dd && Dd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Dd && Dd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Vpe(), u), o(/* @__PURE__ */ kY(), u);
  }(Dd)), Dd;
}
var Ld = {}, Dm = {}, Lm = {}, pV;
function XY() {
  if (pV) return Lm;
  pV = 1, Object.defineProperty(Lm, "__esModule", { value: !0 }), Lm.WildcardCountAggregator = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ ve(), o = lr();
  let a = class extends u.AggregateEvaluator {
    constructor(e, n, i) {
      super(e, n, i), this.bindingValues = /* @__PURE__ */ new Map(), this.state = void 0;
    }
    putTerm(e) {
    }
    async putBindings(e) {
      this.handleDistinct(e) || (this.state === void 0 && (this.state = 0), this.state += 1);
    }
    emptyValueTerm() {
      return (0, r.typedLiteral)("0", r.TypeURL.XSD_INTEGER);
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : (0, r.typedLiteral)(String(this.state), r.TypeURL.XSD_INTEGER);
    }
    /**
     * Returns true if the given bindings should be skipped.
     * @param bindings
     * @private
     */
    handleDistinct(e) {
      if (this.distinct) {
        const n = [...e];
        n.sort((l, f) => l[0].value.localeCompare(f[0].value));
        const i = n.map(([l]) => l.value).join(","), c = n.map(([, l]) => o.termToString(l)).join(","), s = this.bindingValues.get(i), d = s !== void 0 && s.has(c);
        return s || this.bindingValues.set(i, /* @__PURE__ */ new Set()), this.bindingValues.get(i).add(c), d;
      }
      return !1;
    }
  };
  return Lm.WildcardCountAggregator = a, Lm;
}
var bV;
function Hpe() {
  if (bV) return Dm;
  bV = 1, Object.defineProperty(Dm, "__esModule", { value: !0 }), Dm.ActorBindingsAggregatorFactoryWildcardCount = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ XY();
  let a = class extends u.ActorBindingsAggregatorFactory {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return e.expr.aggregator !== "count" || e.expr.expression.expressionType !== "wildcard" ? (0, r.failTest)("This actor only supports the 'count' aggregator with wildcard.") : (0, r.passTestVoid)();
    }
    async run({ context: e, expr: n }) {
      return new o.WildcardCountAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: n.expression, context: e }), n.distinct);
    }
  };
  return Dm.ActorBindingsAggregatorFactoryWildcardCount = a, Dm;
}
var yV;
function Gpe() {
  return yV || (yV = 1, function(u) {
    var r = Ld && Ld.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ld && Ld.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Hpe(), u), o(/* @__PURE__ */ XY(), u);
  }(Ld)), Ld;
}
var jd = {}, jm = {}, Mm = {}, _V;
function JY() {
  if (_V) return Mm;
  _V = 1, Object.defineProperty(Mm, "__esModule", { value: !0 }), Mm.AverageAggregator = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ ve();
  let o = class extends u.AggregateEvaluator {
    constructor(t, e, n, i, c, s) {
      super(t, e, s), this.dataFactory = n, this.additionFunction = i, this.divisionFunction = c, this.state = void 0;
    }
    emptyValueTerm() {
      return r.typedLiteral("0", r.TypeURL.XSD_INTEGER);
    }
    putTerm(t) {
      if (this.state === void 0) {
        const e = this.termToNumericOrError(t);
        this.state = { sum: e, count: 1 };
      } else {
        const e = this.termToNumericOrError(t);
        this.state.sum = this.additionFunction.applyOnTerms([this.state.sum, e], this.evaluator), this.state.count++;
      }
    }
    termResult() {
      if (this.state === void 0)
        return this.emptyValue();
      const t = new r.IntegerLiteral(this.state.count);
      return this.divisionFunction.applyOnTerms([this.state.sum, t], this.evaluator).toRDF(this.dataFactory);
    }
  };
  return Mm.AverageAggregator = o, Mm;
}
var gV;
function zpe() {
  if (gV) return jm;
  gV = 1, Object.defineProperty(jm, "__esModule", { value: !0 }), jm.ActorBindingsAggregatorFactoryAverage = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ ve(), t = /* @__PURE__ */ JY();
  let e = class extends u.ActorBindingsAggregatorFactory {
    constructor(i) {
      super(i), this.mediatorFunctionFactory = i.mediatorFunctionFactory;
    }
    async test(i) {
      return i.expr.aggregator !== "avg" ? (0, o.failTest)("This actor only supports the 'avg' aggregator.") : (0, o.passTestVoid)();
    }
    async run({ context: i, expr: c }) {
      return new t.AverageAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: c.expression, context: i }), c.distinct, i.getSafe(r.KeysInitQuery.dataFactory), await this.mediatorFunctionFactory.mediate({
        functionName: a.SparqlOperator.ADDITION,
        context: i,
        requireTermExpression: !0
      }), await this.mediatorFunctionFactory.mediate({
        functionName: a.SparqlOperator.DIVISION,
        context: i,
        requireTermExpression: !0
      }));
    }
  };
  return jm.ActorBindingsAggregatorFactoryAverage = e, jm;
}
var mV;
function kpe() {
  return mV || (mV = 1, function(u) {
    var r = jd && jd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = jd && jd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ zpe(), u), o(/* @__PURE__ */ JY(), u);
  }(jd)), jd;
}
var Md = {}, Cm = {}, qm = {}, vV;
function KY() {
  if (vV) return qm;
  vV = 1, Object.defineProperty(qm, "__esModule", { value: !0 }), qm.SumAggregator = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ ve();
  let o = class extends u.AggregateEvaluator {
    constructor(t, e, n, i, c) {
      super(t, e, c), this.dataFactory = n, this.additionFunction = i, this.state = void 0;
    }
    emptyValueTerm() {
      return (0, r.typedLiteral)("0", r.TypeURL.XSD_INTEGER);
    }
    putTerm(t) {
      if (this.state === void 0)
        this.state = this.termToNumericOrError(t);
      else {
        const e = this.termToNumericOrError(t);
        this.state = this.additionFunction.applyOnTerms([this.state, e], this.evaluator);
      }
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : this.state.toRDF(this.dataFactory);
    }
  };
  return qm.SumAggregator = o, qm;
}
var TV;
function Xpe() {
  if (TV) return Cm;
  TV = 1, Object.defineProperty(Cm, "__esModule", { value: !0 }), Cm.ActorBindingsAggregatorFactorySum = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ ve(), t = /* @__PURE__ */ KY();
  let e = class extends u.ActorBindingsAggregatorFactory {
    constructor(i) {
      super(i), this.mediatorFunctionFactory = i.mediatorFunctionFactory;
    }
    async test(i) {
      return i.expr.aggregator !== "sum" ? (0, o.failTest)("This actor only supports the 'sum' aggregator.") : (0, o.passTestVoid)();
    }
    async run({ expr: i, context: c }) {
      return new t.SumAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: i.expression, context: c }), i.distinct, c.getSafe(r.KeysInitQuery.dataFactory), await this.mediatorFunctionFactory.mediate({
        functionName: a.SparqlOperator.ADDITION,
        context: c,
        requireTermExpression: !0
      }));
    }
  };
  return Cm.ActorBindingsAggregatorFactorySum = e, Cm;
}
var wV;
function Jpe() {
  return wV || (wV = 1, function(u) {
    var r = Md && Md.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Md && Md.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Xpe(), u), o(/* @__PURE__ */ KY(), u);
  }(Md)), Md;
}
var Cd = {}, Bm = {}, $m = {}, SV;
function Kpe() {
  if (SV) return $m;
  SV = 1, Object.defineProperty($m, "__esModule", { value: !0 }), $m.ExpressionFunctionIn = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor(t) {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: r.SparqlOperator.IN,
        apply: async (e) => {
          const { args: n, mapping: i, exprEval: c } = e, [s, ...d] = n, l = await c.evaluatorExpressionEvaluation(s, i);
          return await this.inRecursive(l, { ...e, args: d }, []);
        }
      }), this.equalityFunction = t;
    }
    checkArity(t) {
      return t.length > 0;
    }
    async inRecursive(t, e, n) {
      const { args: i, mapping: c, exprEval: s } = e;
      if (i.length === 0)
        return n.every((l) => !l) ? (0, r.bool)(!1) : Promise.reject(new r.InError(n));
      try {
        const d = i.shift(), l = await s.evaluatorExpressionEvaluation(d, c);
        return this.equalityFunction.applyOnTerms([t, l], s).typedValue ? (0, r.bool)(!0) : this.inRecursive(t, e, [...n, !1]);
      } catch (d) {
        return this.inRecursive(t, e, [...n, d]);
      }
    }
  };
  return $m.ExpressionFunctionIn = o, $m;
}
var AV;
function Wpe() {
  if (AV) return Bm;
  AV = 1, Object.defineProperty(Bm, "__esModule", { value: !0 }), Bm.ActorFunctionFactoryExpressionIn = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Kpe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.IN],
        termFunction: !1
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.EQUAL,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.ExpressionFunctionIn(n);
    }
  };
  return Bm.ActorFunctionFactoryExpressionIn = a, Bm;
}
var EV;
function Ype() {
  return EV || (EV = 1, function(u) {
    var r = Cd && Cd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Cd && Cd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Wpe(), u);
  }(Cd)), Cd;
}
var qd = {}, Um = {}, Vm = {}, OV;
function Zpe() {
  if (OV) return Vm;
  OV = 1, Object.defineProperty(Vm, "__esModule", { value: !0 }), Vm.ExpressionFunctionNotIn = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.ExpressionFunctionBase {
    constructor(t) {
      super({
        arity: Number.POSITIVE_INFINITY,
        operator: r.SparqlOperator.NOT_IN,
        apply: async (e) => {
          const n = await this.inFunction.apply(e);
          return (0, r.bool)(!n.typedValue);
        }
      }), this.inFunction = t;
    }
    checkArity(t) {
      return t.length > 0;
    }
  };
  return Vm.ExpressionFunctionNotIn = o, Vm;
}
var xV;
function e1e() {
  if (xV) return Um;
  xV = 1, Object.defineProperty(Um, "__esModule", { value: !0 }), Um.ActorFunctionFactoryExpressionNotIn = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ Zpe();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.NOT_IN],
        termFunction: !1
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.IN,
        context: e.context,
        arguments: e.arguments
      });
      return new o.ExpressionFunctionNotIn(n);
    }
  };
  return Um.ActorFunctionFactoryExpressionNotIn = a, Um;
}
var IV;
function t1e() {
  return IV || (IV = 1, function(u) {
    var r = qd && qd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = qd && qd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ e1e(), u);
  }(qd)), qd;
}
var Bd = {}, Qm = {}, Hm = {}, RV;
function r1e() {
  if (RV) return Hm;
  RV = 1, Object.defineProperty(Hm, "__esModule", { value: !0 }), Hm.TermFunctionGreaterThanEqual = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor(t) {
      super({
        arity: 2,
        operator: r.SparqlOperator.GTE,
        overloads: (0, r.declare)(r.SparqlOperator.GTE).set(["term", "term"], (e) => ([n, i]) => (
          // X >= Y -> Y <= X
          this.lessThanEqualFunction.applyOnTerms([i, n], e)
        )).collect()
      }), this.lessThanEqualFunction = t;
    }
  };
  return Hm.TermFunctionGreaterThanEqual = o, Hm;
}
var FV;
function n1e() {
  if (FV) return Qm;
  FV = 1, Object.defineProperty(Qm, "__esModule", { value: !0 }), Qm.ActorFunctionFactoryTermGreaterThanEqual = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ r1e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.GTE],
        termFunction: !0
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.LTE,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.TermFunctionGreaterThanEqual(n);
    }
  };
  return Qm.ActorFunctionFactoryTermGreaterThanEqual = a, Qm;
}
var NV;
function i1e() {
  return NV || (NV = 1, function(u) {
    var r = Bd && Bd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bd && Bd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ n1e(), u);
  }(Bd)), Bd;
}
var $d = {}, Gm = {}, zm = {}, PV;
function a1e() {
  if (PV) return zm;
  PV = 1, Object.defineProperty(zm, "__esModule", { value: !0 }), zm.TermFunctionGreaterThan = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor(t) {
      super({
        arity: 2,
        operator: r.SparqlOperator.GT,
        overloads: (0, r.declare)(r.SparqlOperator.GT).set(["term", "term"], (e) => ([n, i]) => (
          // X < Y -> Y > X
          this.lessThanFunction.applyOnTerms([i, n], e)
        )).collect()
      }), this.lessThanFunction = t;
    }
  };
  return zm.TermFunctionGreaterThan = o, zm;
}
var DV;
function u1e() {
  if (DV) return Gm;
  DV = 1, Object.defineProperty(Gm, "__esModule", { value: !0 }), Gm.ActorFunctionFactoryTermGreaterThan = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ a1e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.GT],
        termFunction: !0
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.LT,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.TermFunctionGreaterThan(n);
    }
  };
  return Gm.ActorFunctionFactoryTermGreaterThan = a, Gm;
}
var LV;
function o1e() {
  return LV || (LV = 1, function(u) {
    var r = $d && $d.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $d && $d.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ u1e(), u);
  }($d)), $d;
}
var Ud = {}, km = {}, Xm = {}, jV;
function s1e() {
  if (jV) return Xm;
  jV = 1, Object.defineProperty(Xm, "__esModule", { value: !0 }), Xm.TermFunctionInequality = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor(t) {
      super({
        arity: 2,
        operator: r.SparqlOperator.NOT_EQUAL,
        overloads: (0, r.declare)(r.SparqlOperator.NOT_EQUAL).set(["term", "term"], (e) => ([n, i]) => (0, r.bool)(!this.equalityFunction.applyOnTerms([n, i], e).typedValue)).collect()
      }), this.equalityFunction = t;
    }
  };
  return Xm.TermFunctionInequality = o, Xm;
}
var MV;
function c1e() {
  if (MV) return km;
  MV = 1, Object.defineProperty(km, "__esModule", { value: !0 }), km.ActorFunctionFactoryTermInequality = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ s1e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.NOT_EQUAL],
        termFunction: !0
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.EQUAL,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.TermFunctionInequality(n);
    }
  };
  return km.ActorFunctionFactoryTermInequality = a, km;
}
var CV;
function d1e() {
  return CV || (CV = 1, function(u) {
    var r = Ud && Ud.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ud && Ud.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ c1e(), u);
  }(Ud)), Ud;
}
var Vd = {}, Jm = {}, Km = {}, qV;
function l1e() {
  if (qV) return Km;
  qV = 1, Object.defineProperty(Km, "__esModule", { value: !0 }), Km.TermFunctionLesserThanEqual = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve();
  let o = class extends u.TermFunctionBase {
    constructor(t, e) {
      super({
        arity: 2,
        operator: r.SparqlOperator.LTE,
        overloads: (0, r.declare)(r.SparqlOperator.LTE).set(["term", "term"], (n) => ([i, c]) => (
          // X <= Y -> X < Y || X = Y
          // First check if the first is lesser than the second, then check if they are equal.
          // Doing this, the correct error will be thrown,
          // each type that has a lesserThanEqual has a matching lesserThan.
          (0, r.bool)(this.lessThanFunction.applyOnTerms([i, c], n).typedValue || this.equalityFunction.applyOnTerms([i, c], n).typedValue)
        )).collect()
      }), this.equalityFunction = t, this.lessThanFunction = e;
    }
  };
  return Km.TermFunctionLesserThanEqual = o, Km;
}
var BV;
function f1e() {
  if (BV) return Jm;
  BV = 1, Object.defineProperty(Jm, "__esModule", { value: !0 }), Jm.ActorFunctionFactoryTermLesserThanEqual = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ l1e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LTE],
        termFunction: !0
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.EQUAL,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      }), i = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.LT,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.TermFunctionLesserThanEqual(n, i);
    }
  };
  return Jm.ActorFunctionFactoryTermLesserThanEqual = a, Jm;
}
var $V;
function h1e() {
  return $V || ($V = 1, function(u) {
    var r = Vd && Vd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vd && Vd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ f1e(), u);
  }(Vd)), Vd;
}
var Qd = {}, Wm = {}, Ym = {}, UV;
function p1e() {
  if (UV) return Ym;
  UV = 1, Object.defineProperty(Ym, "__esModule", { value: !0 }), Ym.TermFunctionLesserThan = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ ve();
  let a = class extends u.TermFunctionBase {
    constructor(e) {
      super({
        arity: 2,
        operator: o.SparqlOperator.LT,
        overloads: (0, o.declare)(o.SparqlOperator.LT).numberTest(() => (n, i) => n < i).stringTest(() => (n, i) => n.localeCompare(i) === -1).booleanTest(() => (n, i) => n < i).dateTimeTest((n) => (i, c) => (0, o.toUTCDate)(i, n.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime() < (0, o.toUTCDate)(c, n.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime()).copy({
          // https://www.w3.org/TR/xpath-functions/#func-date-less-than
          from: [o.TypeURL.XSD_DATE_TIME, o.TypeURL.XSD_DATE_TIME],
          to: [o.TypeURL.XSD_DATE, o.TypeURL.XSD_DATE]
        }).set([o.TypeURL.XSD_YEAR_MONTH_DURATION, o.TypeURL.XSD_YEAR_MONTH_DURATION], () => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than
          (0, o.bool)((0, o.yearMonthDurationsToMonths)((0, o.defaultedYearMonthDurationRepresentation)(n.typedValue)) < (0, o.yearMonthDurationsToMonths)((0, o.defaultedYearMonthDurationRepresentation)(i.typedValue)))
        )).set([o.TypeURL.XSD_DAY_TIME_DURATION, o.TypeURL.XSD_DAY_TIME_DURATION], () => ([n, i]) => (
          // https://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-greater-than
          (0, o.bool)((0, o.dayTimeDurationsToSeconds)((0, o.defaultedDayTimeDurationRepresentation)(n.typedValue)) < (0, o.dayTimeDurationsToSeconds)((0, o.defaultedDayTimeDurationRepresentation)(i.typedValue)))
        )).set([o.TypeURL.XSD_TIME, o.TypeURL.XSD_TIME], (n) => ([i, c]) => (
          // https://www.w3.org/TR/xpath-functions/#func-time-less-than
          (0, o.bool)((0, o.toUTCDate)((0, o.defaultedDateTimeRepresentation)(i.typedValue), n.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime() < (0, o.toUTCDate)((0, o.defaultedDateTimeRepresentation)(c.typedValue), n.context.getSafe(r.KeysExpressionEvaluator.defaultTimeZone)).getTime())
        )).set(["quad", "quad"], (n) => ([i, c]) => {
          const s = this.quadComponentTest(i.subject, c.subject, n);
          if (s !== void 0)
            return (0, o.bool)(s);
          const d = this.quadComponentTest(i.predicate, c.predicate, n);
          if (d !== void 0)
            return (0, o.bool)(d);
          const l = this.quadComponentTest(i.object, c.object, n);
          return l !== void 0 ? (0, o.bool)(l) : (0, o.bool)(this.quadComponentTest(i.graph, c.graph, n) ?? !1);
        }, !1).collect()
      }), this.equalityFunction = e;
    }
    quadComponentTest(e, n, i) {
      return this.equalityFunction.applyOnTerms([e, n], i).typedValue ? void 0 : this.applyOnTerms([e, n], i).typedValue;
    }
  };
  return Ym.TermFunctionLesserThan = a, Ym;
}
var VV;
function b1e() {
  if (VV) return Wm;
  VV = 1, Object.defineProperty(Wm, "__esModule", { value: !0 }), Wm.ActorFunctionFactoryTermLesserThan = void 0;
  const u = /* @__PURE__ */ Ae(), r = /* @__PURE__ */ ve(), o = /* @__PURE__ */ p1e();
  let a = class extends u.ActorFunctionFactoryDedicated {
    constructor(e) {
      super({
        ...e,
        functionNames: [r.SparqlOperator.LT],
        termFunction: !0
      }), this.mediatorFunctionFactory = e.mediatorFunctionFactory;
    }
    async run(e) {
      const n = await this.mediatorFunctionFactory.mediate({
        functionName: r.SparqlOperator.EQUAL,
        requireTermExpression: !0,
        context: e.context,
        arguments: e.arguments
      });
      return new o.TermFunctionLesserThan(n);
    }
  };
  return Wm.ActorFunctionFactoryTermLesserThan = a, Wm;
}
var QV;
function y1e() {
  return QV || (QV = 1, function(u) {
    var r = Qd && Qd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Qd && Qd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ b1e(), u);
  }(Qd)), Qd;
}
var Hd = {}, Zm = {}, HV;
function _1e() {
  if (HV) return Zm;
  HV = 1, Object.defineProperty(Zm, "__esModule", { value: !0 }), Zm.ActorHttpWayback = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = gh(), t = "http://wayback.archive-it.org/";
  function e(c) {
    const s = new Request(c.input, c.init);
    return {
      input: new Request(new URL(`/${s.url}`, t), s)
    };
  }
  function n(c) {
    const s = c.get(r.KeysHttpProxy.httpProxyHandler);
    return s ? (d) => s.getProxy(e(d)) : (d) => Promise.resolve(e(d));
  }
  let i = class extends u.ActorHttp {
    constructor(s) {
      super(s);
    }
    async test(s) {
      return (0, o.passTestVoid)();
    }
    async run(s) {
      let d = await this.mediatorHttp.mediate(s);
      if (d.status === 404 && s.context.get(r.KeysHttpWayback.recoverBrokenLinks)) {
        let l = await this.mediatorHttp.mediate({
          ...s,
          context: s.context.set(r.KeysHttpWayback.recoverBrokenLinks, !1).set(r.KeysHttpProxy.httpProxyHandler, { getProxy: n(s.context) })
        });
        l.status === 200 && ([d, l] = [l, d]);
        const { body: f } = l;
        f && ("cancel" in f && typeof f.cancel == "function" ? await f.cancel() : "destroy" in f && typeof f.destroy == "function" ? f.destroy() : await (0, a.stringify)(u.ActorHttp.toNodeReadable(f)));
      }
      return d;
    }
  };
  return Zm.ActorHttpWayback = i, Zm;
}
var GV;
function g1e() {
  return GV || (GV = 1, function(u) {
    var r = Hd && Hd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Hd && Hd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ _1e(), u);
  }(Hd)), Hd;
}
var Gd = {}, e2 = {}, zd = {}, t2 = {}, kd = {}, r2 = {}, dO = {}, zV;
function Rw() {
  return zV || (zV = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.ERROR_CODES = u.ErrorCoded = void 0;
    class r extends Error {
      /* istanbul ignore next */
      constructor(a, t) {
        super(a), this.code = t;
      }
    }
    u.ErrorCoded = r, function(o) {
      o.COLLIDING_KEYWORDS = "colliding keywords", o.CONFLICTING_INDEXES = "conflicting indexes", o.CYCLIC_IRI_MAPPING = "cyclic IRI mapping", o.INVALID_ID_VALUE = "invalid @id value", o.INVALID_INDEX_VALUE = "invalid @index value", o.INVALID_NEST_VALUE = "invalid @nest value", o.INVALID_PREFIX_VALUE = "invalid @prefix value", o.INVALID_PROPAGATE_VALUE = "invalid @propagate value", o.INVALID_REVERSE_VALUE = "invalid @reverse value", o.INVALID_IMPORT_VALUE = "invalid @import value", o.INVALID_VERSION_VALUE = "invalid @version value", o.INVALID_BASE_IRI = "invalid base IRI", o.INVALID_CONTAINER_MAPPING = "invalid container mapping", o.INVALID_CONTEXT_ENTRY = "invalid context entry", o.INVALID_CONTEXT_NULLIFICATION = "invalid context nullification", o.INVALID_DEFAULT_LANGUAGE = "invalid default language", o.INVALID_INCLUDED_VALUE = "invalid @included value", o.INVALID_IRI_MAPPING = "invalid IRI mapping", o.INVALID_JSON_LITERAL = "invalid JSON literal", o.INVALID_KEYWORD_ALIAS = "invalid keyword alias", o.INVALID_LANGUAGE_MAP_VALUE = "invalid language map value", o.INVALID_LANGUAGE_MAPPING = "invalid language mapping", o.INVALID_LANGUAGE_TAGGED_STRING = "invalid language-tagged string", o.INVALID_LANGUAGE_TAGGED_VALUE = "invalid language-tagged value", o.INVALID_LOCAL_CONTEXT = "invalid local context", o.INVALID_REMOTE_CONTEXT = "invalid remote context", o.INVALID_REVERSE_PROPERTY = "invalid reverse property", o.INVALID_REVERSE_PROPERTY_MAP = "invalid reverse property map", o.INVALID_REVERSE_PROPERTY_VALUE = "invalid reverse property value", o.INVALID_SCOPED_CONTEXT = "invalid scoped context", o.INVALID_SCRIPT_ELEMENT = "invalid script element", o.INVALID_SET_OR_LIST_OBJECT = "invalid set or list object", o.INVALID_TERM_DEFINITION = "invalid term definition", o.INVALID_TYPE_MAPPING = "invalid type mapping", o.INVALID_TYPE_VALUE = "invalid type value", o.INVALID_TYPED_VALUE = "invalid typed value", o.INVALID_VALUE_OBJECT = "invalid value object", o.INVALID_VALUE_OBJECT_VALUE = "invalid value object value", o.INVALID_VOCAB_MAPPING = "invalid vocab mapping", o.IRI_CONFUSED_WITH_PREFIX = "IRI confused with prefix", o.KEYWORD_REDEFINITION = "keyword redefinition", o.LOADING_DOCUMENT_FAILED = "loading document failed", o.LOADING_REMOTE_CONTEXT_FAILED = "loading remote context failed", o.MULTIPLE_CONTEXT_LINK_HEADERS = "multiple context link headers", o.PROCESSING_MODE_CONFLICT = "processing mode conflict", o.PROTECTED_TERM_REDEFINITION = "protected term redefinition", o.CONTEXT_OVERFLOW = "context overflow", o.INVALID_BASE_DIRECTION = "invalid base direction", o.RECURSIVE_CONTEXT_INCLUSION = "recursive context inclusion", o.INVALID_STREAMING_KEY_ORDER = "invalid streaming key order", o.INVALID_EMBEDDED_NODE = "invalid embedded node", o.INVALID_ANNOTATION = "invalid annotation";
    }(u.ERROR_CODES || (u.ERROR_CODES = {}));
  }(dO)), dO;
}
var n2 = {}, kV;
function WY() {
  if (kV) return n2;
  kV = 1, Object.defineProperty(n2, "__esModule", { value: !0 }), n2.FetchDocumentLoader = void 0;
  const u = /* @__PURE__ */ Rw(), r = Aw(), o = Tr();
  class a {
    constructor(e) {
      this.fetcher = e;
    }
    async load(e) {
      const n = await (this.fetcher || fetch)(e, { headers: new Headers({ accept: "application/ld+json" }) });
      if (n.ok && n.headers) {
        let i = n.headers.get("Content-Type");
        if (i) {
          const c = i.indexOf(";");
          c > 0 && (i = i.substr(0, c));
        }
        if (i === "application/ld+json")
          return await n.json();
        if (n.headers.has("Link")) {
          let c;
          if (n.headers.forEach((s, d) => {
            if (d === "link") {
              const l = (0, r.parse)(s);
              for (const f of l.get("type", "application/ld+json"))
                if (f.rel === "alternate") {
                  if (c)
                    throw new Error("Multiple JSON-LD alternate links were found on " + e);
                  c = (0, o.resolve)(f.uri, e);
                }
            }
          }), c)
            return this.load(c);
        }
        throw new u.ErrorCoded(`Unsupported JSON-LD media type ${i}`, u.ERROR_CODES.LOADING_DOCUMENT_FAILED);
      } else
        throw new Error(n.statusText || `Status code: ${n.status}`);
    }
  }
  return n2.FetchDocumentLoader = a, n2;
}
var lO = {}, i2 = {}, XV;
function G8() {
  if (XV) return i2;
  XV = 1, Object.defineProperty(i2, "__esModule", { value: !0 }), i2.Util = void 0;
  class u {
    /**
     * Check if the given term is a valid compact IRI.
     * Otherwise, it may be an IRI.
     * @param {string} term A term.
     * @return {boolean} If it is a compact IRI.
     */
    static isCompactIri(o) {
      return o.indexOf(":") > 0 && !(o && o[0] === "#");
    }
    /**
     * Get the prefix from the given term.
     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {string} The prefix or null.
     */
    static getPrefix(o, a) {
      if (o && o[0] === "#")
        return null;
      const t = o.indexOf(":");
      if (t >= 0) {
        if (o.length > t + 1 && o.charAt(t + 1) === "/" && o.charAt(t + 2) === "/")
          return null;
        const e = o.substr(0, t);
        if (e === "_")
          return null;
        if (a[e])
          return e;
      }
      return null;
    }
    /**
     * From a given context entry value, get the string value, or the @id field.
     * @param contextValue A value for a term in a context.
     * @return {string} The id value, or null.
     */
    static getContextValueId(o) {
      if (o === null || typeof o == "string")
        return o;
      const a = o["@id"];
      return a || null;
    }
    /**
     * Check if the given simple term definition (string-based value of a context term)
     * should be considered a prefix.
     * @param value A simple term definition value.
     * @param options Options that define the way how expansion must be done.
     */
    static isSimpleTermDefinitionPrefix(o, a) {
      return !u.isPotentialKeyword(o) && (a.allowPrefixNonGenDelims || typeof o == "string" && (o[0] === "_" || u.isPrefixIriEndingWithGenDelim(o)));
    }
    /**
     * Check if the given keyword is of the keyword format "@"1*ALPHA.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is of the keyword format.
     */
    static isPotentialKeyword(o) {
      return typeof o == "string" && u.KEYWORD_REGEX.test(o);
    }
    /**
     * Check if the given prefix ends with a gen-delim character.
     * @param {string} prefixIri A prefix IRI.
     * @return {boolean} If the given prefix IRI is valid.
     */
    static isPrefixIriEndingWithGenDelim(o) {
      return u.ENDS_WITH_GEN_DELIM.test(o);
    }
    /**
     * Check if the given context value can be a prefix value.
     * @param value A context value.
     * @return {boolean} If it can be a prefix value.
     */
    static isPrefixValue(o) {
      return o && (typeof o == "string" || o && typeof o == "object");
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(o) {
      return !!(o && u.IRI_REGEX.test(o));
    }
    /**
     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIriWeak(o) {
      return !!o && o[0] !== ":" && u.IRI_REGEX_WEAK.test(o);
    }
    /**
     * Check if the given keyword is a defined according to the JSON-LD specification.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is valid.
     */
    static isValidKeyword(o) {
      return u.VALID_KEYWORDS[o];
    }
    /**
     * Check if the given term is protected in the context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {string} key A context term.
     * @return {boolean} If the given term has an @protected flag.
     */
    static isTermProtected(o, a) {
      const t = o[a];
      return typeof t != "string" && t && t["@protected"];
    }
    /**
     * Check if the given context has at least one protected term.
     * @param context A context.
     * @return If the context has a protected term.
     */
    static hasProtectedTerms(o) {
      for (const a of Object.keys(o))
        if (u.isTermProtected(o, a))
          return !0;
      return !1;
    }
    /**
     * Check if the given key is an internal reserved keyword.
     * @param key A context key.
     */
    static isReservedInternalKeyword(o) {
      return o.startsWith("@__");
    }
    /**
     * Check if two objects are deepEqual to on another.
     * @param object1 The first object to test.
     * @param object2 The second object to test.
     */
    static deepEqual(o, a) {
      const t = Object.keys(o), e = Object.keys(a);
      return t.length !== e.length ? !1 : t.every((n) => {
        const i = o[n], c = a[n];
        return i === c || i !== null && c !== null && typeof i == "object" && typeof c == "object" && this.deepEqual(i, c);
      });
    }
  }
  return u.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/, u.IRI_REGEX_WEAK = /(?::[^:])|\//, u.KEYWORD_REGEX = /^@[a-z]+$/i, u.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/, u.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/, u.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/, u.VALID_KEYWORDS = {
    "@annotation": !0,
    "@base": !0,
    "@container": !0,
    "@context": !0,
    "@direction": !0,
    "@graph": !0,
    "@id": !0,
    "@import": !0,
    "@included": !0,
    "@index": !0,
    "@json": !0,
    "@language": !0,
    "@list": !0,
    "@nest": !0,
    "@none": !0,
    "@prefix": !0,
    "@propagate": !0,
    "@protected": !0,
    "@reverse": !0,
    "@set": !0,
    "@type": !0,
    "@value": !0,
    "@version": !0,
    "@vocab": !0
  }, u.EXPAND_KEYS_BLACKLIST = [
    "@base",
    "@vocab",
    "@language",
    "@version",
    "@direction"
  ], u.ALIAS_DOMAIN_BLACKLIST = [
    "@container",
    "@graph",
    "@id",
    "@index",
    "@list",
    "@nest",
    "@none",
    "@prefix",
    "@reverse",
    "@set",
    "@type",
    "@value",
    "@version"
  ], u.ALIAS_RANGE_BLACKLIST = [
    "@context",
    "@preserve"
  ], u.CONTAINERS = [
    "@list",
    "@set",
    "@index",
    "@language",
    "@graph",
    "@id",
    "@type"
  ], u.CONTAINERS_1_0 = [
    "@list",
    "@set",
    "@index"
  ], i2.Util = u, i2;
}
var JV;
function YY() {
  return JV || (JV = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.defaultExpandOptions = u.JsonLdContextNormalized = void 0;
    const r = Tr(), o = /* @__PURE__ */ Rw(), a = /* @__PURE__ */ G8();
    class t {
      constructor(n) {
        this.contextRaw = n;
      }
      /**
       * @return The raw inner context.
       */
      getContextRaw() {
        return this.contextRaw;
      }
      /**
       * Expand the term or prefix of the given term if it has one,
       * otherwise return the term as-is.
       *
       * This will try to expand the IRI as much as possible.
       *
       * Iff in vocab-mode, then other references to other terms in the context can be used,
       * such as to `myTerm`:
       * ```
       * {
       *   "myTerm": "http://example.org/myLongTerm"
       * }
       * ```
       *
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,
       *                              otherwise it is considered a regular term that is expanded based on @base.
       * @param {IExpandOptions} options Options that define the way how expansion must be done.
       * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
       * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).
       */
      expandTerm(n, i, c = u.defaultExpandOptions) {
        const s = this.contextRaw[n];
        if (s === null || s && s["@id"] === null)
          return null;
        let d = !0;
        if (s && i) {
          const _ = a.Util.getContextValueId(s);
          if (_ && _ !== n)
            if (typeof _ != "string" || !a.Util.isValidIri(_) && !a.Util.isValidKeyword(_))
              a.Util.isPotentialKeyword(_) || (d = !1);
            else
              return _;
        }
        const l = a.Util.getPrefix(n, this.contextRaw), f = this.contextRaw["@vocab"], h = (!!f || f === "") && f.indexOf(":") < 0, p = this.contextRaw["@base"], b = a.Util.isPotentialKeyword(n);
        if (l) {
          const _ = this.contextRaw[l], y = a.Util.getContextValueId(_);
          if (y) {
            if (typeof _ == "string" || !c.allowPrefixForcing) {
              if (!a.Util.isSimpleTermDefinitionPrefix(y, c))
                return n;
            } else if (y[0] !== "_" && !b && !_["@prefix"] && !(n in this.contextRaw))
              return n;
            return y + n.substr(l.length + 1);
          }
        } else if (i && (f || f === "" || c.allowVocabRelativeToBase && p && h) && !b && !a.Util.isCompactIri(n))
          if (h) {
            if (c.allowVocabRelativeToBase)
              return (f || p ? (0, r.resolve)(f, p) : "") + n;
            throw new o.ErrorCoded(`Relative vocab expansion for term '${n}' with vocab '${f}' is not allowed.`, o.ERROR_CODES.INVALID_VOCAB_MAPPING);
          } else
            return f + n;
        else if (!i && p && !b && !a.Util.isCompactIri(n))
          return (0, r.resolve)(n, p);
        if (d)
          return n;
        throw new o.ErrorCoded(`Invalid IRI mapping found for context entry '${n}': '${JSON.stringify(s)}'`, o.ERROR_CODES.INVALID_IRI_MAPPING);
      }
      /**
       * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
       *
       * This will try to compact the IRI as much as possible.
       *
       * @param {string} iri An IRI to compact.
       * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
       *                        otherwise it is considered a regular term that is compacted based on @base.
       * @return {string} The compacted term or the IRI as-is.
       */
      compactIri(n, i) {
        if (i && this.contextRaw["@vocab"] && n.startsWith(this.contextRaw["@vocab"]))
          return n.substr(this.contextRaw["@vocab"].length);
        if (!i && this.contextRaw["@base"] && n.startsWith(this.contextRaw["@base"]))
          return n.substr(this.contextRaw["@base"].length);
        const c = { prefix: "", suffix: n };
        for (const s in this.contextRaw) {
          const d = this.contextRaw[s];
          if (d && !a.Util.isPotentialKeyword(s)) {
            const l = a.Util.getContextValueId(d);
            if (n.startsWith(l)) {
              const f = n.substr(l.length);
              if (f)
                f.length < c.suffix.length && (c.prefix = s, c.suffix = f);
              else if (i)
                return s;
            }
          }
        }
        return c.prefix ? c.prefix + ":" + c.suffix : n;
      }
    }
    u.JsonLdContextNormalized = t, u.defaultExpandOptions = {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    };
  }(lO)), lO;
}
var KV;
function m1e() {
  if (KV) return r2;
  KV = 1, Object.defineProperty(r2, "__esModule", { value: !0 }), r2.ContextParser = void 0;
  const u = Tr(), r = /* @__PURE__ */ Rw(), o = /* @__PURE__ */ WY(), a = /* @__PURE__ */ YY(), t = /* @__PURE__ */ G8();
  class e {
    constructor(i) {
      i = i || {}, this.documentLoader = i.documentLoader || new o.FetchDocumentLoader(), this.documentCache = {}, this.validateContext = !i.skipValidation, this.expandContentTypeToBase = !!i.expandContentTypeToBase, this.remoteContextsDepthLimit = i.remoteContextsDepthLimit || 32, this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in i ? !!i.redirectSchemaOrgHttps : !0;
    }
    /**
     * Validate the given @language value.
     * An error will be thrown if it is invalid.
     * @param value An @language value.
     * @param {boolean} strictRange If the string value should be strictly checked against a regex.
     * @param {string} errorCode The error code to emit on errors.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateLanguage(i, c, s) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(i)}'`, s);
      if (!t.Util.REGEX_LANGUAGE_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(i)}'`, s);
        return !1;
      }
      return !0;
    }
    /**
     * Validate the given @direction value.
     * An error will be thrown if it is invalid.
     * @param value An @direction value.
     * @param {boolean} strictValues If the string value should be strictly checked against a regex.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateDirection(i, c) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
      if (!t.Util.REGEX_DIRECTION_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
        return !1;
      }
      return !0;
    }
    /**
     * Add an @id term for all @reverse terms.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     */
    idifyReverseTerms(i) {
      for (const c of Object.keys(i)) {
        let s = i[c];
        if (s && typeof s == "object" && s["@reverse"] && !s["@id"]) {
          if (typeof s["@reverse"] != "string" || t.Util.isValidKeyword(s["@reverse"]))
            throw new r.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${s["@reverse"]}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
          s = i[c] = Object.assign(Object.assign({}, s), { "@id": s["@reverse"] }), s["@id"] = s["@reverse"], t.Util.isPotentialKeyword(s["@reverse"]) ? delete s["@reverse"] : s["@reverse"] = !0;
        }
      }
      return i;
    }
    /**
     * Expand all prefixed terms in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
     *                                          via @base if @vocab is set to null.
     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all
     * keys in the context will be expanded.
     */
    expandPrefixedTerms(i, c, s) {
      const d = i.getContextRaw();
      for (const l of s || Object.keys(d))
        if (t.Util.EXPAND_KEYS_BLACKLIST.indexOf(l) < 0 && !t.Util.isReservedInternalKeyword(l)) {
          const f = d[l];
          if (t.Util.isPotentialKeyword(l) && t.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(l) >= 0 && (l !== "@type" || typeof d[l] == "object" && !(d[l]["@protected"] || d[l]["@container"] === "@set")))
            throw new r.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          if (t.Util.ALIAS_RANGE_BLACKLIST.indexOf(t.Util.getContextValueId(f)) >= 0)
            throw new r.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.INVALID_KEYWORD_ALIAS);
          if (f && t.Util.isPotentialKeyword(t.Util.getContextValueId(f)) && f["@prefix"] === !0)
            throw new r.ErrorCoded(`Tried to use keyword aliases as prefix: '${l}': '${JSON.stringify(f)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          for (; t.Util.isPrefixValue(d[l]); ) {
            const h = d[l];
            let p = !1;
            if (typeof h == "string")
              d[l] = i.expandTerm(h, !0), p = p || h !== d[l];
            else {
              const b = h["@id"], _ = h["@type"], y = !("@prefix" in h) || t.Util.isValidIri(l);
              if ("@id" in h)
                b != null && typeof b == "string" && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": i.expandTerm(b, !0) }), p = p || b !== d[l]["@id"]);
              else if (!t.Util.isPotentialKeyword(l) && y) {
                const m = i.expandTerm(l, !0);
                m !== l && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": m }), p = !0);
              }
              if (_ && typeof _ == "string" && _ !== "@vocab" && (!h["@container"] || !h["@container"]["@type"]) && y) {
                let m = i.expandTerm(_, !0);
                c && _ === m && (m = i.expandTerm(_, !1)), m !== _ && (p = !0, d[l] = Object.assign(Object.assign({}, d[l]), { "@type": m }));
              }
            }
            if (!p)
              break;
          }
        }
    }
    /**
     * Normalize the @language entries in the given context to lowercase.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} parseOptions The parsing options.
     */
    normalize(i, { processingMode: c, normalizeLanguageTags: s }) {
      if (s || c === 1)
        for (const d of Object.keys(i))
          if (d === "@language" && typeof i[d] == "string")
            i[d] = i[d].toLowerCase();
          else {
            const l = i[d];
            if (l && typeof l == "object" && typeof l["@language"] == "string") {
              const f = l["@language"].toLowerCase();
              f !== l["@language"] && (i[d] = Object.assign(Object.assign({}, l), { "@language": f }));
            }
          }
    }
    /**
     * Convert all @container strings and array values to hash-based values.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     */
    containersToHash(i) {
      for (const c of Object.keys(i)) {
        const s = i[c];
        if (s && typeof s == "object") {
          if (typeof s["@container"] == "string")
            i[c] = Object.assign(Object.assign({}, s), { "@container": { [s["@container"]]: !0 } });
          else if (Array.isArray(s["@container"])) {
            const d = {};
            for (const l of s["@container"])
              d[l] = !0;
            i[c] = Object.assign(Object.assign({}, s), { "@container": d });
          }
        }
      }
    }
    /**
     * Normalize and apply context-level @protected terms onto each term separately.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {number} processingMode The processing mode.
     */
    applyScopedProtected(i, { processingMode: c }, s) {
      if (c && c >= 1.1 && i["@protected"]) {
        for (const d of Object.keys(i))
          if (!t.Util.isReservedInternalKeyword(d) && !t.Util.isPotentialKeyword(d) && !t.Util.isTermProtected(i, d)) {
            const l = i[d];
            l && typeof l == "object" ? "@protected" in i[d] || (i[d] = Object.assign(Object.assign({}, i[d]), { "@protected": !0 })) : (i[d] = {
              "@id": l,
              "@protected": !0
            }, t.Util.isSimpleTermDefinitionPrefix(l, s) && (i[d] = Object.assign(Object.assign({}, i[d]), { "@prefix": !0 })));
          }
        delete i["@protected"];
      }
    }
    /**
     * Check if the given context inheritance does not contain any overrides of protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.
     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.
     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all
     * keys defined in contextAfter will be checked.
     */
    validateKeywordRedefinitions(i, c, s, d) {
      for (const l of d ?? Object.keys(c))
        if (t.Util.isTermProtected(i, l) && (typeof c[l] == "string" ? c[l] = { "@id": c[l], "@protected": !0 } : c[l] = Object.assign(Object.assign({}, c[l]), { "@protected": !0 }), !t.Util.deepEqual(i[l], c[l])))
          throw new r.ErrorCoded(`Attempted to override the protected keyword ${l} from ${JSON.stringify(t.Util.getContextValueId(i[l]))} to ${JSON.stringify(t.Util.getContextValueId(c[l]))}`, r.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
    }
    /**
     * Validate the entries of the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options The parse options.
     */
    validate(i, { processingMode: c }) {
      for (const s of Object.keys(i)) {
        if (t.Util.isReservedInternalKeyword(s))
          continue;
        if (s === "")
          throw new r.ErrorCoded(`The empty term is not allowed, got: '${s}': '${JSON.stringify(i[s])}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
        const d = i[s], l = typeof d;
        if (t.Util.isPotentialKeyword(s)) {
          switch (s.substr(1)) {
            case "vocab":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @vocab IRI: ${d}`, r.ERROR_CODES.INVALID_VOCAB_MAPPING);
              break;
            case "base":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @base IRI: ${i[s]}`, r.ERROR_CODES.INVALID_BASE_IRI);
              break;
            case "language":
              d !== null && e.validateLanguage(d, !0, r.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
              break;
            case "version":
              if (d !== null && l !== "number")
                throw new r.ErrorCoded(`Found an invalid @version number: ${d}`, r.ERROR_CODES.INVALID_VERSION_VALUE);
              break;
            case "direction":
              d !== null && e.validateDirection(d, !0);
              break;
            case "propagate":
              if (c === 1)
                throw new r.ErrorCoded(`Found an illegal @propagate keyword: ${d}`, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              if (d !== null && l !== "boolean")
                throw new r.ErrorCoded(`Found an invalid @propagate value: ${d}`, r.ERROR_CODES.INVALID_PROPAGATE_VALUE);
              break;
          }
          if (t.Util.isValidKeyword(s) && t.Util.isValidKeyword(t.Util.getContextValueId(d)))
            throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${t.Util.getContextValueId(d)}'`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          continue;
        }
        if (d !== null)
          switch (l) {
            case "string":
              if (t.Util.getPrefix(d, i) === s)
                throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
              if (t.Util.isValidIriWeak(s)) {
                if (d === "@type")
                  throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                if (t.Util.isValidIri(d) && d !== new a.JsonLdContextNormalized(i).expandTerm(s))
                  throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              }
              break;
            case "object":
              if (!t.Util.isCompactIri(s) && !("@id" in d) && (d["@type"] === "@id" ? !i["@base"] : !i["@vocab"]))
                throw new r.ErrorCoded(`Missing @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              for (const f of Object.keys(d)) {
                const h = d[f];
                if (h)
                  switch (f) {
                    case "@id":
                      if (t.Util.isValidKeyword(h) && h !== "@type" && h !== "@id" && h !== "@graph" && h !== "@nest")
                        throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.isValidIriWeak(s)) {
                        if (h === "@type")
                          throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                        if (t.Util.isValidIri(h) && h !== new a.JsonLdContextNormalized(i).expandTerm(s))
                          throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`Detected non-string @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.getPrefix(h, i) === s)
                        throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
                      break;
                    case "@type":
                      if (d["@container"] === "@type" && h !== "@id" && h !== "@vocab")
                        throw new r.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(l)}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (h !== "@id" && h !== "@vocab" && (c === 1 || h !== "@json") && (c === 1 || h !== "@none") && (h[0] === "_" || !t.Util.isValidIri(h)))
                        throw new r.ErrorCoded(`A context @type must be an absolute IRI, found: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      break;
                    case "@reverse":
                      if (typeof h == "string" && d["@id"] && d["@id"] !== h)
                        throw new r.ErrorCoded(`Found non-matching @id and @reverse term values in '${s}':'${h}' and '${d["@id"]}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      if ("@nest" in d)
                        throw new r.ErrorCoded(`@nest is not allowed in the reverse property '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      break;
                    case "@container":
                      if (c === 1 && (Object.keys(h).length > 1 || t.Util.CONTAINERS_1_0.indexOf(Object.keys(h)[0]) < 0))
                        throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${Object.keys(h)}') in 1.0, must be only one of ${t.Util.CONTAINERS_1_0.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      for (const p of Object.keys(h)) {
                        if (p === "@list" && d["@reverse"])
                          throw new r.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        if (t.Util.CONTAINERS.indexOf(p) < 0)
                          throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${p}'), must be one of ${t.Util.CONTAINERS.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      }
                      break;
                    case "@language":
                      e.validateLanguage(h, !0, r.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                      break;
                    case "@direction":
                      e.validateDirection(h, !0);
                      break;
                    case "@prefix":
                      if (h !== null && typeof h != "boolean")
                        throw new r.ErrorCoded(`Found an invalid term @prefix boolean in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_PREFIX_VALUE);
                      if (!("@id" in d) && !t.Util.isValidIri(s))
                        throw new r.ErrorCoded(`Invalid @prefix definition for '${s}' ('${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@index":
                      if (c === 1 || !d["@container"] || !d["@container"]["@index"])
                        throw new r.ErrorCoded(`Attempt to add illegal key to value object: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@nest":
                      if (t.Util.isPotentialKeyword(h) && h !== "@nest")
                        throw new r.ErrorCoded(`Found an invalid term @nest value in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_NEST_VALUE);
                  }
              }
              break;
            default:
              throw new r.ErrorCoded(`Found an invalid term value: '${s}': '${d}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          }
      }
    }
    /**
     * Apply the @base context entry to the given context under certain circumstances.
     * @param context A context.
     * @param options Parsing options.
     * @param inheritFromParent If the @base value from the parent context can be inherited.
     * @return The given context.
     */
    applyBaseEntry(i, c, s) {
      return typeof i == "string" || (s && !("@base" in i) && c.parentContext && typeof c.parentContext == "object" && "@base" in c.parentContext && (i["@base"] = c.parentContext["@base"], c.parentContext["@__baseDocument"] && (i["@__baseDocument"] = !0)), c.baseIRI && !c.external && ("@base" in i ? i["@base"] !== null && typeof i["@base"] == "string" && !t.Util.isValidIri(i["@base"]) && (i["@base"] = (0, u.resolve)(i["@base"], c.parentContext && c.parentContext["@base"] || c.baseIRI)) : (i["@base"] = c.baseIRI, i["@__baseDocument"] = !0))), i;
    }
    /**
     * Resolve relative context IRIs, or return full IRIs as-is.
     * @param {string} contextIri A context IRI.
     * @param {string} baseIRI A base IRI.
     * @return {string} The normalized context IRI.
     */
    normalizeContextIri(i, c) {
      if (!t.Util.isValidIri(i))
        try {
          i = (0, u.resolve)(i, c);
        } catch {
          throw new Error(`Invalid context IRI: ${i}`);
        }
      return this.redirectSchemaOrgHttps && i.startsWith("http://schema.org") && (i = "https://schema.org/"), i;
    }
    /**
     * Parse scoped contexts in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options Parsing options.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all
     * keys in the context will be iterated over.
     */
    async parseInnerContexts(i, c, s) {
      for (const d of s ?? Object.keys(i)) {
        const l = i[d];
        if (l && typeof l == "object" && "@context" in l && l["@context"] !== null && !c.ignoreScopedContexts) {
          if (this.validateContext)
            try {
              const f = Object.assign(Object.assign({}, i), { [d]: Object.assign({}, i[d]) });
              delete f[d]["@context"], await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, parentContext: f, ignoreProtection: !0, ignoreRemoteScopedContexts: !0, ignoreScopedContexts: !0 }));
            } catch (f) {
              throw new r.ErrorCoded(f.message, r.ERROR_CODES.INVALID_SCOPED_CONTEXT);
            }
          i[d] = Object.assign(Object.assign({}, l), { "@context": (await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, minimalProcessing: !0, ignoreRemoteScopedContexts: !0, parentContext: i }))).getContextRaw() });
        }
      }
      return i;
    }
    async parse(i, c = {}, s = {}) {
      const { baseIRI: d, parentContext: l, external: f, processingMode: h = e.DEFAULT_PROCESSING_MODE, normalizeLanguageTags: p, ignoreProtection: b, minimalProcessing: _ } = c, y = c.remoteContexts || {};
      if (Object.keys(y).length >= this.remoteContextsDepthLimit)
        throw new r.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(y), r.ERROR_CODES.CONTEXT_OVERFLOW);
      if (i == null) {
        if (!b && l && t.Util.hasProtectedTerms(l))
          throw new r.ErrorCoded("Illegal context nullification when terms are protected", r.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
        return new a.JsonLdContextNormalized(this.applyBaseEntry({}, c, !1));
      } else if (typeof i == "string") {
        const m = this.normalizeContextIri(i, d), g = this.getOverriddenLoad(m, c);
        if (g)
          return new a.JsonLdContextNormalized(g);
        const T = await this.parse(await this.load(m), Object.assign(Object.assign({}, c), { baseIRI: m, external: !0, remoteContexts: Object.assign(Object.assign({}, y), { [m]: !0 }) }));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (Array.isArray(i)) {
        const m = [], g = await Promise.all(i.map((v, E) => {
          if (typeof v == "string") {
            const R = this.normalizeContextIri(v, d);
            m[E] = R;
            const L = this.getOverriddenLoad(R, c);
            return L || this.load(R);
          } else
            return v;
        }));
        if (_)
          return new a.JsonLdContextNormalized(g);
        const T = await g.reduce((v, E, R) => v.then((L) => this.parse(
          E,
          Object.assign(Object.assign({}, c), { baseIRI: m[R] || c.baseIRI, external: !!m[R] || c.external, parentContext: L.getContextRaw(), remoteContexts: m[R] ? Object.assign(Object.assign({}, y), { [m[R]]: !0 }) : y }),
          // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers
          {
            skipValidation: R < g.length - 1
          }
        )), Promise.resolve(new a.JsonLdContextNormalized(l || {})));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (typeof i == "object") {
        if ("@context" in i)
          return await this.parse(i["@context"], c);
        if (i = Object.assign({}, i), f && delete i["@base"], this.applyBaseEntry(i, c, !0), this.containersToHash(i), _)
          return new a.JsonLdContextNormalized(i);
        let m = {};
        if ("@import" in i)
          if (h >= 1.1) {
            if (typeof i["@import"] != "string")
              throw new r.ErrorCoded("An @import value must be a string, but got " + typeof i["@import"], r.ERROR_CODES.INVALID_IMPORT_VALUE);
            m = await this.loadImportContext(this.normalizeContextIri(i["@import"], d)), delete i["@import"];
          } else
            throw new r.ErrorCoded("Context importing is not supported in JSON-LD 1.0", r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        this.applyScopedProtected(m, { processingMode: h }, a.defaultExpandOptions);
        const g = Object.assign(m, i);
        this.idifyReverseTerms(g), this.normalize(g, { processingMode: h, normalizeLanguageTags: p }), this.applyScopedProtected(g, { processingMode: h }, a.defaultExpandOptions);
        const T = Object.keys(g), v = [];
        if (typeof l == "object")
          for (const R in l)
            R in g ? v.push(R) : g[R] = l[R];
        await this.parseInnerContexts(g, c, T);
        const E = new a.JsonLdContextNormalized(g);
        return (g && g["@version"] || e.DEFAULT_PROCESSING_MODE) >= 1.1 && (i["@vocab"] && typeof i["@vocab"] == "string" || i["@vocab"] === "") && (l && "@vocab" in l && i["@vocab"].indexOf(":") < 0 ? g["@vocab"] = l["@vocab"] + i["@vocab"] : (t.Util.isCompactIri(i["@vocab"]) || i["@vocab"] in g) && (g["@vocab"] = E.expandTerm(i["@vocab"], !0))), this.expandPrefixedTerms(E, this.expandContentTypeToBase, T), !b && l && h >= 1.1 && this.validateKeywordRedefinitions(l, g, a.defaultExpandOptions, v), this.validateContext && !s.skipValidation && this.validate(g, { processingMode: h }), E;
      } else
        throw new r.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${i}`, r.ERROR_CODES.INVALID_LOCAL_CONTEXT);
    }
    /**
     * Fetch the given URL as a raw JSON-LD context.
     * @param url An URL.
     * @return A promise resolving to a raw JSON-LD context.
     */
    async load(i) {
      const c = this.documentCache[i];
      if (c)
        return c;
      let s;
      try {
        s = await this.documentLoader.load(i);
      } catch (d) {
        throw new r.ErrorCoded(`Failed to load remote context ${i}: ${d.message}`, r.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
      }
      if (!("@context" in s))
        throw new r.ErrorCoded(`Missing @context in remote context at ${i}`, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      return this.documentCache[i] = s["@context"];
    }
    /**
     * Override the given context that may be loaded.
     *
     * This will check whether or not the url is recursively being loaded.
     * @param url An URL.
     * @param options Parsing options.
     * @return An overridden context, or null.
     *         Optionally an error can be thrown if a cyclic context is detected.
     */
    getOverriddenLoad(i, c) {
      if (i in (c.remoteContexts || {})) {
        if (c.ignoreRemoteScopedContexts)
          return i;
        throw new r.ErrorCoded("Detected a cyclic context inclusion of " + i, r.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
      }
      return null;
    }
    /**
     * Load an @import'ed context.
     * @param importContextIri The full URI of an @import value.
     */
    async loadImportContext(i) {
      let c = await this.load(i);
      if (typeof c != "object" || Array.isArray(c))
        throw new r.ErrorCoded("An imported context must be a single object: " + i, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      if ("@import" in c)
        throw new r.ErrorCoded("An imported context can not import another context: " + i, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
      return c = Object.assign({}, c), this.containersToHash(c), c;
    }
  }
  return e.DEFAULT_PROCESSING_MODE = 1.1, r2.ContextParser = e, r2;
}
var fO = {}, WV;
function v1e() {
  return WV || (WV = 1, Object.defineProperty(fO, "__esModule", { value: !0 })), fO;
}
var hO = {}, YV;
function T1e() {
  return YV || (YV = 1, Object.defineProperty(hO, "__esModule", { value: !0 })), hO;
}
var ZV;
function bn() {
  return ZV || (ZV = 1, function(u) {
    var r = kd && kd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = kd && kd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ m1e(), u), o(/* @__PURE__ */ Rw(), u), o(/* @__PURE__ */ WY(), u), o(/* @__PURE__ */ v1e(), u), o(/* @__PURE__ */ T1e(), u), o(/* @__PURE__ */ YY(), u), o(/* @__PURE__ */ G8(), u);
  }(kd)), kd;
}
var a2 = {}, u2 = {}, o2 = {}, s2 = {}, eQ;
function w1e() {
  if (eQ) return s2;
  eQ = 1, Object.defineProperty(s2, "__esModule", { value: !0 }), s2.ContainerHandlerIdentifier = void 0;
  let u = class {
    canCombineWithGraph() {
      return !0;
    }
    async handle(o, a, t, e, n, i) {
      let c;
      if (a.emittedStack[i + 1] && a.idStack[i + 1])
        c = a.idStack[i + 1][0];
      else {
        const l = await t.getContainerKey(e[i], e, i) !== null ? await t.resourceToTerm(await a.getContext(e), e[i]) : t.dataFactory.blankNode();
        if (!l) {
          a.emittedStack[i] = !1;
          return;
        }
        c = l, a.idStack[i + 1] = [c];
      }
      let s = a.idStack[i];
      s || (s = a.idStack[i] = []), s.some((d) => d.equals(c)) || s.push(c), await a.handlePendingContainerFlushBuffers() || (a.emittedStack[i] = !1);
    }
  };
  return s2.ContainerHandlerIdentifier = u, s2;
}
var c2 = {}, d2 = {}, tQ;
function d4() {
  if (tQ) return d2;
  tQ = 1, Object.defineProperty(d2, "__esModule", { value: !0 }), d2.EntryHandlerPredicate = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ a0();
  let o = class ZY {
    /**
     * Handle the given predicate-object by either emitting it,
     * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.
     * @param {ParsingContext} parsingContext A parsing context.
     * @param {Util} util A utility instance.
     * @param {any[]} keys A stack of keys.
     * @param {number} depth The current depth.
     * @param {Term} predicate The predicate.
     * @param {Term} object The object.
     * @param {boolean} reverse If the property is reversed.
     * @param {boolean} isEmbedded If the property exists in an embedded node as direct child.
     * @param {boolean} isAnnotation If the property exists in an annotation object.
     * @return {Promise<void>} A promise resolving when handling is done.
     */
    static async handlePredicateObject(t, e, n, i, c, s, d, l, f) {
      const h = await e.getPropertiesDepth(n, i), p = await e.getDepthOffsetGraph(i, n), b = i - p, _ = t.idStack[h];
      if (_ && !f)
        for (const y of _)
          if (p >= 0) {
            const g = t.idStack[b - 1];
            if (g)
              for (const T of g)
                e.emitQuadChecked(i, y, c, s, T, d, l);
            else
              d ? (e.validateReverseSubject(s), t.getUnidentifiedGraphBufferSafe(b - 1).push({ subject: s, predicate: c, object: y, isEmbedded: l })) : t.getUnidentifiedGraphBufferSafe(b - 1).push({ subject: y, predicate: c, object: s, isEmbedded: l });
          } else {
            const g = await e.getGraphContainerValue(n, h);
            e.emitQuadChecked(i, y, c, s, g, d, l);
          }
      else if (d && e.validateReverseSubject(s), f) {
        if (t.rdfstar) {
          t.idStack[i] && t.emitError(new u.ErrorCoded(`Found an illegal @id inside an annotation: ${t.idStack[i][0].value}`, u.ERROR_CODES.INVALID_ANNOTATION));
          for (let g = 0; g < i; g++)
            await e.unaliasKeyword(n[g], n, g) === "@id" && t.emitError(new u.ErrorCoded("Found an illegal annotation inside an embedded node", u.ERROR_CODES.INVALID_ANNOTATION));
          const y = t.getAnnotationsBufferSafe(h), m = { predicate: c, object: s, reverse: d, nestedAnnotations: [], depth: h };
          y.push(m);
          for (let g = y.length - 2; g >= 0; g--) {
            const T = y[g];
            T.depth > h && (m.nestedAnnotations.push(T), y.splice(g, 1));
          }
        }
      } else
        t.getUnidentifiedValueBufferSafe(h).push({ predicate: c, object: s, reverse: d, isEmbedded: l });
    }
    isPropertyHandler() {
      return !0;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(t, e, n, i, c) {
      const s = n[i];
      if (s) {
        const d = await t.getContext(n);
        if (!t.jsonLiteralStack[i] && await e.predicateToTerm(d, n[i]))
          return r.Util.getContextValueType(d, s) === "@json" && (t.jsonLiteralStack[i + 1] = !0), !0;
      }
      return !1;
    }
    async test(t, e, n, i, c) {
      return i[c];
    }
    async handle(t, e, n, i, c, s, d) {
      const l = i[s], f = await t.getContext(i), h = await e.predicateToTerm(f, n);
      if (h) {
        const p = await e.valueToTerm(f, n, c, s, i);
        if (p.length)
          for (let b of p) {
            let _ = await e.unaliasKeywordParent(i, s);
            const y = r.Util.isPropertyReverse(f, l, _);
            let m = 0;
            for (; _ === "@reverse" || typeof _ == "number"; )
              typeof _ == "number" ? m++ : s--, _ = await e.unaliasKeywordParent(i, s - m);
            const g = r.Util.isPropertyInEmbeddedNode(_);
            e.validateReverseInEmbeddedNode(n, y, g);
            const T = r.Util.isPropertyInAnnotationObject(_);
            if (c) {
              const v = "@list" in r.Util.getContextValueContainer(f, n);
              if (v || c["@list"]) {
                if ((v && !Array.isArray(c) && !c["@list"] || c["@list"] && !Array.isArray(c["@list"])) && b !== e.rdfNil) {
                  const E = e.dataFactory.blankNode();
                  t.emitQuad(s, e.dataFactory.quad(E, e.rdfRest, e.rdfNil, e.getDefaultGraph())), t.emitQuad(s, e.dataFactory.quad(E, e.rdfFirst, b, e.getDefaultGraph())), b = E;
                }
                if (y && !t.allowSubjectList)
                  throw new u.ErrorCoded(`Found illegal list value in subject position at ${n}`, u.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
              }
            }
            await ZY.handlePredicateObject(t, e, i, s, h, b, y, g, T);
          }
      }
    }
  };
  return d2.EntryHandlerPredicate = o, d2;
}
var rQ;
function S1e() {
  if (rQ) return c2;
  rQ = 1, Object.defineProperty(c2, "__esModule", { value: !0 }), c2.ContainerHandlerIndex = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ d4(), o = /* @__PURE__ */ a0();
  let a = class {
    canCombineWithGraph() {
      return !0;
    }
    async handle(e, n, i, c, s, d) {
      if (!Array.isArray(s)) {
        const l = "@graph" in e, f = await n.getContext(c), h = c[d - 1], p = o.Util.getContextValueIndex(f, h);
        if (p) {
          if (u.Util.isPotentialKeyword(p))
            throw new u.ErrorCoded(`Keywords can not be used as @index value, got: ${p}`, u.ERROR_CODES.INVALID_TERM_DEFINITION);
          if (typeof p != "string")
            throw new u.ErrorCoded(`@index values must be strings, got: ${p}`, u.ERROR_CODES.INVALID_TERM_DEFINITION);
          if (typeof s != "object") {
            if (o.Util.getContextValueType(f, h) !== "@id")
              throw new u.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${s}`, u.ERROR_CODES.INVALID_VALUE_OBJECT);
            const y = i.resourceToTerm(f, s);
            y && (n.idStack[d + 1] = [y]);
          }
          const _ = i.createVocabOrBaseTerm(f, p);
          if (_) {
            const y = await i.valueToTerm(f, p, await i.getContainerKey(c[d], c, d), d, c);
            if (l) {
              const m = await i.getGraphContainerValue(c, d + 1);
              for (const g of y)
                n.emitQuad(d, i.dataFactory.quad(m, _, g, i.getDefaultGraph()));
            } else
              for (const m of y)
                await r.EntryHandlerPredicate.handlePredicateObject(n, i, c, d + 1, _, m, !1, !1, !1);
          }
        }
        const b = l ? 2 : 1;
        await n.newOnValueJob(c.slice(0, c.length - b), s, d - b, !0), await n.handlePendingContainerFlushBuffers();
      }
      n.emittedStack[d] = !1;
    }
  };
  return c2.ContainerHandlerIndex = a, c2;
}
var l2 = {}, nQ;
function A1e() {
  if (nQ) return l2;
  nQ = 1, Object.defineProperty(l2, "__esModule", { value: !0 }), l2.ContainerHandlerLanguage = void 0;
  const u = /* @__PURE__ */ bn();
  let r = class {
    canCombineWithGraph() {
      return !1;
    }
    async handle(a, t, e, n, i, c) {
      const s = await e.getContainerKey(n[c], n, c);
      if (Array.isArray(i))
        i = i.map((d) => ({ "@value": d, "@language": s }));
      else {
        if (typeof i != "string")
          throw new u.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(i)}', but expected string`, u.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);
        i = { "@value": i, "@language": s };
      }
      await t.newOnValueJob(n.slice(0, n.length - 1), i, c - 1, !0), t.emittedStack[c] = !1;
    }
  };
  return l2.ContainerHandlerLanguage = r, l2;
}
var f2 = {}, iQ;
function E1e() {
  if (iQ) return f2;
  iQ = 1, Object.defineProperty(f2, "__esModule", { value: !0 }), f2.ContainerHandlerType = void 0;
  const u = /* @__PURE__ */ d4(), r = /* @__PURE__ */ a0();
  let o = class {
    canCombineWithGraph() {
      return !1;
    }
    async handle(t, e, n, i, c, s) {
      if (!Array.isArray(c)) {
        if (typeof c == "string") {
          const f = await e.getContext(i), p = r.Util.getContextValueType(f, i[s - 1]) === "@vocab" ? await n.createVocabOrBaseTerm(f, c) : await n.resourceToTerm(f, c);
          if (p) {
            const b = { "@id": p.termType === "NamedNode" ? p.value : c };
            await e.newOnValueJob(i.slice(0, i.length - 1), b, s - 1, !0), e.idStack[s + 1] = [p];
          }
        } else {
          const f = !!e.idStack[s + 1];
          f || delete e.idStack[s], await e.newOnValueJob(i.slice(0, i.length - 1), c, s - 1, !0), f || (e.idStack[s + 1] = e.idStack[s]);
        }
        const d = await n.getContainerKey(i[s], i, s), l = d !== null ? n.createVocabOrBaseTerm(await e.getContext(i), d) : null;
        l && await u.EntryHandlerPredicate.handlePredicateObject(e, n, i, s + 1, n.rdfType, l, !1, !1, !1), await e.handlePendingContainerFlushBuffers();
      }
      e.emittedStack[s] = !1;
    }
  };
  return f2.ContainerHandlerType = o, f2;
}
var aQ;
function eZ() {
  if (aQ) return o2;
  aQ = 1, Object.defineProperty(o2, "__esModule", { value: !0 }), o2.EntryHandlerContainer = void 0;
  const u = /* @__PURE__ */ w1e(), r = /* @__PURE__ */ S1e(), o = /* @__PURE__ */ A1e(), a = /* @__PURE__ */ E1e(), t = /* @__PURE__ */ a0();
  let e = class qa {
    /**
     * Check fit the given container is a simple @graph container.
     * Concretely, it will check if no @index or @id is active as well.
     * @param containers A container hash.
     */
    static isSimpleGraphContainer(i) {
      return "@graph" in i && ("@set" in i && Object.keys(i).length === 2 || Object.keys(i).length === 1);
    }
    /**
     * Check fit the given container is a complex @graph container.
     * Concretely, it will check if @index or @id is active as well next to @graph.
     * @param containers A container hash.
     */
    static isComplexGraphContainer(i) {
      return "@graph" in i && ("@set" in i && Object.keys(i).length > 2 || !("@set" in i) && Object.keys(i).length > 1);
    }
    /**
     * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.
     * @param containers The applicable containers.
     * @param depth The container depth.
     * @param keys The array of keys.
     * @return The graph index.
     */
    static getContainerGraphIndex(i, c, s) {
      let d = qa.isSimpleGraphContainer(i), l = "";
      for (let f = c; f < s.length; f++)
        (!d || typeof s[f] == "number") && (l += ":" + s[f]), !d && typeof s[f] != "number" && (d = !0);
      return l;
    }
    /**
     * Return the applicable container type at the given depth.
     *
     * This will ignore any arrays in the key chain.
     *
     * @param {ParsingContext} parsingContext A parsing context.
     * @param {any[]} keys The array of keys.
     * @param {number} depth The current depth.
     * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}
     *          All applicable containers for the given depth,
     *          the `depth` of the container root (can change when arrays are in the key chain),
     *          and the `fallback` flag that indicates if the default container type was returned
     *            (i.e., no dedicated container type is defined).
     */
    static async getContainerHandler(i, c, s) {
      const d = {
        containers: { "@set": !0 },
        depth: s,
        fallback: !0
      };
      let l = !1;
      const f = await i.getContext(c, 2);
      for (let h = s - 1; h >= 0; h--)
        if (typeof c[h] != "number") {
          const p = t.Util.getContextValue(f, "@container", c[h], !1);
          if (p && qa.isSimpleGraphContainer(p))
            return {
              containers: p,
              depth: h + 1,
              fallback: !1
            };
          const b = t.Util.getContextValue(f, "@container", c[h - 1], !1);
          if (b) {
            const _ = "@graph" in b;
            for (const y in qa.CONTAINER_HANDLERS)
              if (b[y])
                return _ ? qa.CONTAINER_HANDLERS[y].canCombineWithGraph() ? {
                  containers: b,
                  depth: h,
                  fallback: !1
                } : d : l ? d : {
                  containers: b,
                  depth: h,
                  fallback: !1
                };
            return d;
          } else {
            if (l)
              return d;
            l = !0;
          }
        }
      return d;
    }
    /**
     * Check if we are handling a value at the given depth
     * that is part of something that should be handled as a container,
     * AND if this container should be buffered, so that it can be handled by a dedicated container handler.
     *
     * For instance, any container with @graph will NOT be buffered.
     *
     * This will ignore any arrays in the key chain.
     *
     * @param {ParsingContext} parsingContext A parsing context.
     * @param {any[]} keys The array of keys.
     * @param {number} depth The current depth.
     * @return {Promise<boolean>} If we are in the scope of a container handler.
     */
    static async isBufferableContainerHandler(i, c, s) {
      const d = await qa.getContainerHandler(i, c, s);
      return !d.fallback && !("@graph" in d.containers);
    }
    isPropertyHandler() {
      return !1;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(i, c, s, d, l) {
      return !!await this.test(i, c, null, s, d);
    }
    async test(i, c, s, d, l) {
      const f = t.Util.getContextValueContainer(await i.getContext(d, 2), d[l - 1]);
      for (const h in qa.CONTAINER_HANDLERS)
        if (f[h])
          return {
            containers: f,
            handler: qa.CONTAINER_HANDLERS[h]
          };
      return null;
    }
    async handle(i, c, s, d, l, f, h) {
      return h.handler.handle(h.containers, i, c, d, l, f);
    }
  };
  return e.CONTAINER_HANDLERS = {
    "@id": new u.ContainerHandlerIdentifier(),
    "@index": new r.ContainerHandlerIndex(),
    "@language": new o.ContainerHandlerLanguage(),
    "@type": new a.ContainerHandlerType()
  }, o2.EntryHandlerContainer = e, o2;
}
var pO, uQ;
function O1e() {
  return uQ || (uQ = 1, pO = function u(r) {
    return r === null || typeof r != "object" || r.toJSON != null ? JSON.stringify(r) : Array.isArray(r) ? "[" + r.reduce((o, a, t) => {
      const e = t === 0 ? "" : ",", n = a === void 0 || typeof a == "symbol" ? null : a;
      return o + e + u(n);
    }, "") + "]" : "{" + Object.keys(r).sort().reduce((o, a, t) => {
      if (r[a] === void 0 || typeof r[a] == "symbol")
        return o;
      const e = o.length === 0 ? "" : ",";
      return o + e + u(a) + ":" + u(r[a]);
    }, "") + "}";
  }), pO;
}
var oQ;
function a0() {
  if (oQ) return u2;
  oQ = 1, Object.defineProperty(u2, "__esModule", { value: !0 }), u2.Util = void 0;
  const u = /* @__PURE__ */ bn(), r = Or(), o = /* @__PURE__ */ eZ(), a = O1e();
  class t {
    constructor(n) {
      this.parsingContext = n.parsingContext, this.dataFactory = n.dataFactory || new r.DataFactory(), this.rdfFirst = this.dataFactory.namedNode(t.RDF + "first"), this.rdfRest = this.dataFactory.namedNode(t.RDF + "rest"), this.rdfNil = this.dataFactory.namedNode(t.RDF + "nil"), this.rdfType = this.dataFactory.namedNode(t.RDF + "type"), this.rdfJson = this.dataFactory.namedNode(t.RDF + "JSON");
    }
    /**
     * Helper function to get the value of a context entry,
     * or fallback to a certain value.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} contextKey A pre-defined JSON-LD key in context entries.
     * @param {string} key A context entry key.
     * @param {string} fallback A fallback value for when the given contextKey
     *                          could not be found in the value with the given key.
     * @return {string} The value of the given contextKey in the entry behind key in the given context,
     *                  or the given fallback value.
     */
    static getContextValue(n, i, c, s) {
      const d = n.getContextRaw()[c];
      if (!d)
        return s;
      const l = d[i];
      return l === void 0 ? s : l;
    }
    /**
     * Get the container type of the given key in the context.
     *
     * Should any context-scoping bugs should occur related to this in the future,
     * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).
     * This is because containers act 2 levels deep.
     *
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {string} The container type.
     */
    static getContextValueContainer(n, i) {
      return t.getContextValue(n, "@container", i, { "@set": !0 });
    }
    /**
     * Get the value type of the given key in the context.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {string} The node type.
     */
    static getContextValueType(n, i) {
      const c = t.getContextValue(n, "@type", i, null);
      return c === "@none" ? null : c;
    }
    /**
     * Get the language of the given key in the context.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {string} The node type.
     */
    static getContextValueLanguage(n, i) {
      return t.getContextValue(n, "@language", i, n.getContextRaw()["@language"] || null);
    }
    /**
     * Get the direction of the given key in the context.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {string} The node type.
     */
    static getContextValueDirection(n, i) {
      return t.getContextValue(n, "@direction", i, n.getContextRaw()["@direction"] || null);
    }
    /**
     * Check if the given key in the context is a reversed property.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {boolean} If the context value has a @reverse key.
     */
    static isContextValueReverse(n, i) {
      return !!t.getContextValue(n, "@reverse", i, null);
    }
    /**
     * Get the @index of the given key in the context.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key A context entry key.
     * @return {string} The index.
     */
    static getContextValueIndex(n, i) {
      return t.getContextValue(n, "@index", i, n.getContextRaw()["@index"] || null);
    }
    /**
     * Check if the given key refers to a reversed property.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key The property key.
     * @param {string} parentKey The parent key.
     * @return {boolean} If the property must be reversed.
     */
    static isPropertyReverse(n, i, c) {
      return c === "@reverse" !== t.isContextValueReverse(n, i);
    }
    /**
     * Check if the given key exists inside an embedded node as direct child.
     * @param {string} parentKey The parent key.
     * @return {boolean} If the property is embedded.
     */
    static isPropertyInEmbeddedNode(n) {
      return n === "@id";
    }
    /**
     * Check if the given key exists inside an annotation object as direct child.
     * @param {string} parentKey The parent key.
     * @return {boolean} If the property is an annotation.
     */
    static isPropertyInAnnotationObject(n) {
      return n === "@annotation";
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(n) {
      return n !== null && u.Util.isValidIri(n);
    }
    /**
     * Check if the given first array (needle) is a prefix of the given second array (haystack).
     * @param needle An array to check if it is a prefix.
     * @param haystack An array to look in.
     */
    static isPrefixArray(n, i) {
      if (n.length > i.length)
        return !1;
      for (let c = 0; c < n.length; c++)
        if (n[c] !== i[c])
          return !1;
      return !0;
    }
    /**
     * Make sure that @id-@index pairs are equal over all array values.
     * Reject otherwise.
     * @param {any[]} value An array value.
     * @return {Promise<void>} A promise rejecting if conflicts are present.
     */
    async validateValueIndexes(n) {
      if (this.parsingContext.validateValueIndexes) {
        const i = {};
        for (const c of n)
          if (c && typeof c == "object") {
            const s = c["@id"], d = c["@index"];
            if (s && d) {
              const l = i[s];
              if (l && l !== d)
                throw new u.ErrorCoded(`Conflicting @index value for ${s}`, u.ERROR_CODES.CONFLICTING_INDEXES);
              i[s] = d;
            }
          }
      }
    }
    /**
     * Convert a given JSON value to an RDF term.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key The current JSON key.
     * @param value A JSON value.
     * @param {number} depth The depth the value is at.
     * @param {string[]} keys The path of keys.
     * @return {Promise<RDF.Term[]>} An RDF term array.
     */
    async valueToTerm(n, i, c, s, d) {
      if (t.getContextValueType(n, i) === "@json")
        return [this.dataFactory.literal(this.valueToJsonString(c), this.rdfJson)];
      const l = typeof c;
      switch (l) {
        case "object":
          if (c == null)
            return [];
          if (Array.isArray(c))
            return "@list" in t.getContextValueContainer(n, i) ? c.length === 0 ? [this.rdfNil] : this.parsingContext.idStack[s + 1] || [] : (await this.validateValueIndexes(c), []);
          if (n = await this.getContextSelfOrPropertyScoped(n, i), "@context" in c && (n = await this.parsingContext.parseContext(c["@context"], (await this.parsingContext.getContext(d, 0)).getContextRaw())), c = await this.unaliasKeywords(c, d, s, n), "@value" in c) {
            let f, h, p, b, _;
            for (i in c) {
              const y = c[i];
              switch (i) {
                case "@value":
                  f = y;
                  break;
                case "@language":
                  h = y;
                  break;
                case "@direction":
                  p = y;
                  break;
                case "@type":
                  b = y;
                  break;
                case "@index":
                  _ = y;
                  break;
                case "@annotation":
                  break;
                default:
                  throw new u.ErrorCoded(`Unknown value entry '${i}' in @value: ${JSON.stringify(c)}`, u.ERROR_CODES.INVALID_VALUE_OBJECT);
              }
            }
            if (await this.unaliasKeyword(b, d, s, !0, n) === "@json")
              return [this.dataFactory.literal(this.valueToJsonString(f), this.rdfJson)];
            if (f === null)
              return [];
            if (typeof f == "object")
              throw new u.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(f)}'`, u.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);
            if (this.parsingContext.validateValueIndexes && _ && typeof _ != "string")
              throw new u.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(_)}'`, u.ERROR_CODES.INVALID_INDEX_VALUE);
            if (h) {
              if (typeof f != "string")
                throw new u.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(f)}'`, u.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);
              if (!u.ContextParser.validateLanguage(h, this.parsingContext.strictValues, u.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING))
                return [];
              (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1) && (h = h.toLowerCase());
            }
            if (p) {
              if (typeof f != "string")
                throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(f)}'`);
              if (!u.ContextParser.validateDirection(p, this.parsingContext.strictValues))
                return [];
            }
            if (h && p && this.parsingContext.rdfDirection) {
              if (b)
                throw new u.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON.stringify(c)}'`, u.ERROR_CODES.INVALID_VALUE_OBJECT);
              return this.nullableTermToArray(this.createLanguageDirectionLiteral(s, f, h, p));
            } else if (h) {
              if (b)
                throw new u.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(c)}'`, u.ERROR_CODES.INVALID_VALUE_OBJECT);
              return [this.dataFactory.literal(f, h)];
            } else if (p && this.parsingContext.rdfDirection) {
              if (b)
                throw new u.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(c)}'`, u.ERROR_CODES.INVALID_VALUE_OBJECT);
              return this.nullableTermToArray(this.createLanguageDirectionLiteral(s, f, h, p));
            } else if (b) {
              if (typeof b != "string")
                throw new u.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(b)}'`, u.ERROR_CODES.INVALID_TYPED_VALUE);
              const y = this.createVocabOrBaseTerm(n, b);
              if (!y)
                throw new u.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(b)}'`, u.ERROR_CODES.INVALID_TYPED_VALUE);
              if (y.termType !== "NamedNode")
                throw new u.ErrorCoded(`Illegal value type (${y.termType}): ${b}`, u.ERROR_CODES.INVALID_TYPED_VALUE);
              return [this.dataFactory.literal(f, y)];
            }
            return await this.valueToTerm(new u.JsonLdContextNormalized({}), i, f, s, d);
          } else if ("@set" in c) {
            if (Object.keys(c).length > 1)
              throw new u.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${i}'`, u.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
            return [];
          } else if ("@list" in c) {
            if (Object.keys(c).length > 1)
              throw new u.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${i}'`, u.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
            const f = c["@list"];
            return Array.isArray(f) ? f.length === 0 ? [this.rdfNil] : this.parsingContext.idStack[s + 1] || [] : await this.valueToTerm(await this.parsingContext.getContext(d), i, f, s - 1, d.slice(0, -1));
          } else {
            if ("@reverse" in c && typeof c["@reverse"] == "boolean")
              return [];
            if ("@graph" in t.getContextValueContainer(await this.parsingContext.getContext(d), i)) {
              const f = this.parsingContext.graphContainerTermStack[s + 1];
              return f ? Object.values(f) : [this.dataFactory.blankNode()];
            } else if ("@id" in c) {
              if (Object.keys(c).length > 1 && (n = await this.parsingContext.getContext(d, 0)), "@context" in c && (n = await this.parsingContext.parseContext(c["@context"], n.getContextRaw())), c["@type"] === "@vocab")
                return this.nullableTermToArray(this.createVocabOrBaseTerm(n, c["@id"]));
              {
                const f = c["@id"];
                let h;
                if (typeof f == "object")
                  if (this.parsingContext.rdfstar)
                    h = this.parsingContext.idStack[s + 1][0];
                  else
                    throw new u.ErrorCoded(`Found illegal @id '${c}'`, u.ERROR_CODES.INVALID_ID_VALUE);
                else
                  h = this.resourceToTerm(n, f);
                return this.nullableTermToArray(h);
              }
            } else
              return this.parsingContext.emittedStack[s + 1] || c && typeof c == "object" && Object.keys(c).length === 0 ? this.parsingContext.idStack[s + 1] || (this.parsingContext.idStack[s + 1] = [this.dataFactory.blankNode()]) : [];
          }
        case "string":
          return this.nullableTermToArray(this.stringValueToTerm(s, await this.getContextSelfOrPropertyScoped(n, i), i, c, null));
        case "boolean":
          return this.nullableTermToArray(this.stringValueToTerm(s, await this.getContextSelfOrPropertyScoped(n, i), i, (!!c).toString(), this.dataFactory.namedNode(t.XSD_BOOLEAN)));
        case "number":
          return this.nullableTermToArray(this.stringValueToTerm(s, await this.getContextSelfOrPropertyScoped(n, i), i, c, this.dataFactory.namedNode(c % 1 === 0 && c < 1e21 ? t.XSD_INTEGER : t.XSD_DOUBLE)));
        default:
          return this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${l}`)), [];
      }
    }
    /**
     * If the context defines a property-scoped context for the given key,
     * that context will be returned.
     * Otherwise, the given context will be returned as-is.
     *
     * This should be used for valueToTerm cases that are not objects.
     * @param context A context.
     * @param key A JSON key.
     */
    async getContextSelfOrPropertyScoped(n, i) {
      const c = n.getContextRaw()[i];
      return c && typeof c == "object" && "@context" in c && (n = await this.parsingContext.parseContext(c, n.getContextRaw(), !0)), n;
    }
    /**
     * If the given term is null, return an empty array, otherwise return an array with the single given term.
     * @param term A term.
     */
    nullableTermToArray(n) {
      return n ? [n] : [];
    }
    /**
     * Convert a given JSON key to an RDF predicate term,
     * based on @vocab.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param key A JSON key.
     * @return {RDF.NamedNode} An RDF named node.
     */
    predicateToTerm(n, i) {
      const c = n.expandTerm(i, !0, this.parsingContext.getExpandOptions());
      if (!c)
        return null;
      if (c[0] === "_" && c[1] === ":")
        return this.parsingContext.produceGeneralizedRdf ? this.dataFactory.blankNode(c.substr(2)) : null;
      if (t.isValidIri(c))
        return this.dataFactory.namedNode(c);
      if (c && this.parsingContext.strictValues)
        this.parsingContext.emitError(new u.ErrorCoded(`Invalid predicate IRI: ${c}`, u.ERROR_CODES.INVALID_IRI_MAPPING));
      else
        return null;
      return null;
    }
    /**
     * Convert a given JSON key to an RDF resource term or blank node,
     * based on @base.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param key A JSON key.
     * @return {RDF.NamedNode} An RDF named node or null.
     */
    resourceToTerm(n, i) {
      if (i.startsWith("_:"))
        return this.dataFactory.blankNode(i.substr(2));
      const c = n.expandTerm(i, !1, this.parsingContext.getExpandOptions());
      if (!t.isValidIri(c))
        if (c && this.parsingContext.strictValues)
          this.parsingContext.emitError(new Error(`Invalid resource IRI: ${c}`));
        else
          return null;
      return this.dataFactory.namedNode(c);
    }
    /**
     * Convert a given JSON key to an RDF resource term.
     * It will do this based on the @vocab,
     * and fallback to @base.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param key A JSON key.
     * @return {RDF.NamedNode} An RDF named node or null.
     */
    createVocabOrBaseTerm(n, i) {
      if (i.startsWith("_:"))
        return this.dataFactory.blankNode(i.substr(2));
      const c = this.parsingContext.getExpandOptions();
      let s = n.expandTerm(i, !0, c);
      if (s === i && (s = n.expandTerm(i, !1, c)), !t.isValidIri(s))
        if (s && this.parsingContext.strictValues && !s.startsWith("@"))
          this.parsingContext.emitError(new Error(`Invalid term IRI: ${s}`));
        else
          return null;
      return this.dataFactory.namedNode(s);
    }
    /**
     * Ensure that the given value becomes a string.
     * @param {string | number} value A string or number.
     * @param {NamedNode} datatype The intended datatype.
     * @return {string} The returned string.
     */
    intToString(n, i) {
      return typeof n == "number" ? Number.isFinite(n) ? n % 1 === 0 && (!i || i.value !== t.XSD_DOUBLE) ? Number(n).toString() : n.toExponential(15).replace(/(\d)0*e\+?/, "$1E") : n > 0 ? "INF" : "-INF" : n;
    }
    /**
     * Convert a given JSON string value to an RDF term.
     * @param {number} depth The current stack depth.
     * @param {JsonLdContextNormalized} context A JSON-LD context.
     * @param {string} key The current JSON key.
     * @param {string} value A JSON value.
     * @param {NamedNode} defaultDatatype The default datatype for the given value.
     * @return {RDF.Term} An RDF term or null.
     */
    stringValueToTerm(n, i, c, s, d) {
      const l = t.getContextValueType(i, c);
      if (l)
        if (l === "@id") {
          if (!d)
            return this.resourceToTerm(i, this.intToString(s, d));
        } else if (l === "@vocab") {
          if (!d)
            return this.createVocabOrBaseTerm(i, this.intToString(s, d));
        } else
          d = this.dataFactory.namedNode(l);
      if (!d) {
        const f = t.getContextValueLanguage(i, c), h = t.getContextValueDirection(i, c);
        return h && this.parsingContext.rdfDirection ? this.createLanguageDirectionLiteral(n, this.intToString(s, d), f, h) : this.dataFactory.literal(this.intToString(s, d), f);
      }
      return this.dataFactory.literal(this.intToString(s, d), d);
    }
    /**
     * Create a literal for the given value with the given language and direction.
     * Auxiliary quads may be emitted.
     * @param {number} depth The current stack depth.
     * @param {string} value A string value.
     * @param {string} language A language tag.
     * @param {string} direction A direction.
     * @return {Term} An RDF term.
     */
    createLanguageDirectionLiteral(n, i, c, s) {
      if (this.parsingContext.rdfDirection === "i18n-datatype")
        return c || (c = ""), this.dataFactory.literal(i, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${c}_${s}`));
      {
        const d = this.dataFactory.blankNode(), l = this.getDefaultGraph();
        return this.parsingContext.emitQuad(n, this.dataFactory.quad(d, this.dataFactory.namedNode(t.RDF + "value"), this.dataFactory.literal(i), l)), c && this.parsingContext.emitQuad(n, this.dataFactory.quad(d, this.dataFactory.namedNode(t.RDF + "language"), this.dataFactory.literal(c), l)), this.parsingContext.emitQuad(n, this.dataFactory.quad(d, this.dataFactory.namedNode(t.RDF + "direction"), this.dataFactory.literal(s), l)), d;
      }
    }
    /**
     * Stringify the given JSON object to a canonical JSON string.
     * @param value Any valid JSON value.
     * @return {string} A canonical JSON string.
     */
    valueToJsonString(n) {
      return a(n);
    }
    /**
     * If the key is not a keyword, try to check if it is an alias for a keyword,
     * and if so, un-alias it.
     * @param {string} key A key, can be falsy.
     * @param {string[]} keys The path of keys.
     * @param {number} depth The depth to
     * @param {boolean} disableCache If the cache should be disabled
     * @param {JsonLdContextNormalized} context A context to unalias with,
     *                                           will fallback to retrieving the context for the given keys.
     * @return {Promise<string>} A promise resolving to the key itself, or another key.
     */
    async unaliasKeyword(n, i, c, s, d) {
      if (Number.isInteger(n))
        return n;
      if (!s) {
        const l = this.parsingContext.unaliasedKeywordCacheStack[c];
        if (l)
          return l;
      }
      if (!u.Util.isPotentialKeyword(n)) {
        d = d || await this.parsingContext.getContext(i);
        let l = d.getContextRaw()[n];
        l && typeof l == "object" && (l = l["@id"]), u.Util.isValidKeyword(l) && (n = l);
      }
      return s ? n : this.parsingContext.unaliasedKeywordCacheStack[c] = n;
    }
    /**
     * Unalias the keyword of the parent.
     * This adds a safety check if no parent exist.
     * @param {any[]} keys A stack of keys.
     * @param {number} depth The current depth.
     * @return {Promise<any>} A promise resolving to the parent key, or another key.
     */
    async unaliasKeywordParent(n, i) {
      return await this.unaliasKeyword(i > 0 && n[i - 1], n, i - 1);
    }
    /**
     * Un-alias all keywords in the given hash.
     * @param {{[p: string]: any}} hash A hash object.
     * @param {string[]} keys The path of keys.
     * @param {number} depth The depth.
     * @param {JsonLdContextNormalized} context A context to unalias with,
     *                                           will fallback to retrieving the context for the given keys.
     * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.
     */
    async unaliasKeywords(n, i, c, s) {
      const d = {};
      for (const l in n)
        d[await this.unaliasKeyword(l, i, c + 1, !0, s)] = n[l];
      return d;
    }
    /**
     * Check if we are processing a literal (including JSON literals) at the given depth.
     * This will also check higher levels,
     * because if a parent is a literal,
     * then the deeper levels are definitely a literal as well.
     * @param {any[]} keys The keys.
     * @param {number} depth The depth.
     * @return {boolean} If we are processing a literal.
     */
    async isLiteral(n, i) {
      for (let c = i; c >= 0; c--) {
        if (await this.unaliasKeyword(n[c], n, c) === "@annotation")
          return !1;
        if (this.parsingContext.literalStack[c] || this.parsingContext.jsonLiteralStack[c])
          return !0;
      }
      return !1;
    }
    /**
     * Check how many parents should be skipped for checking the @graph for the given node.
     *
     * @param {number} depth The depth of the node.
     * @param {any[]} keys An array of keys.
     * @return {number} The graph depth offset.
     */
    async getDepthOffsetGraph(n, i) {
      for (let c = n - 1; c > 0; c--)
        if (await this.unaliasKeyword(i[c], i, c) === "@graph") {
          const s = (await o.EntryHandlerContainer.getContainerHandler(this.parsingContext, i, c)).containers;
          return o.EntryHandlerContainer.isComplexGraphContainer(s) ? -1 : n - c - 1;
        }
      return -1;
    }
    /**
     * Check if the given subject is of a valid type.
     * This should be called when applying @reverse'd properties.
     * @param {Term} subject A subject.
     */
    validateReverseSubject(n) {
      if (n.termType === "Literal")
        throw new u.ErrorCoded(`Found illegal literal in subject position: ${n.value}`, u.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
    }
    /**
     * Get the default graph.
     * @return {Term} An RDF term.
     */
    getDefaultGraph() {
      return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();
    }
    /**
     * Get the current graph, while taking into account a graph that can be defined via @container: @graph.
     * If not within a graph container, the default graph will be returned.
     * @param keys The current keys.
     * @param depth The current depth.
     */
    async getGraphContainerValue(n, i) {
      let c = this.getDefaultGraph();
      const { containers: s, depth: d } = await o.EntryHandlerContainer.getContainerHandler(this.parsingContext, n, i);
      if ("@graph" in s) {
        const l = o.EntryHandlerContainer.getContainerGraphIndex(s, d, n), f = this.parsingContext.graphContainerTermStack[d];
        if (c = f ? f[l] : null, !c) {
          let h = null;
          if ("@id" in s) {
            const p = await this.getContainerKey(n[d], n, d);
            p !== null && (h = await this.resourceToTerm(await this.parsingContext.getContext(n), p));
          }
          h || (h = this.dataFactory.blankNode()), this.parsingContext.graphContainerTermStack[d] || (this.parsingContext.graphContainerTermStack[d] = {}), c = this.parsingContext.graphContainerTermStack[d][l] = h;
        }
      }
      return c;
    }
    /**
     * Get the properties depth for retrieving properties.
     *
     * Typically, the properties depth will be identical to the given depth.
     *
     * The following exceptions apply:
     * * When the parent is @reverse, the depth is decremented by one.
     * * When @nest parents are found, the depth is decremented by the number of @nest parents.
     * If in combination with the exceptions above an intermediary array is discovered,
     * the depth is also decremented by this number of arrays.
     *
     * @param keys The current key chain.
     * @param depth The current depth.
     */
    async getPropertiesDepth(n, i) {
      let c = i;
      for (let s = i - 1; s > 0; s--)
        if (typeof n[s] != "number") {
          const d = await this.unaliasKeyword(n[s], n, s);
          if (d === "@reverse")
            return s;
          if (d === "@nest")
            c = s;
          else
            return c;
        }
      return c;
    }
    /**
     * Get the key for the current container entry.
     * @param key A key, can be falsy.
     * @param keys The key chain.
     * @param depth The current depth to get the key from.
     * @return Promise resolving to the key.
     *         Null will be returned for @none entries, with aliasing taken into account.
     */
    async getContainerKey(n, i, c) {
      const s = await this.unaliasKeyword(n, i, c);
      return s === "@none" ? null : s;
    }
    /**
     * Check if no reverse properties are present in embedded nodes.
     * @param key The current key.
     * @param reverse If a reverse property is active.
     * @param isEmbedded If we're in an embedded node.
     */
    validateReverseInEmbeddedNode(n, i, c) {
      if (c && i && !this.parsingContext.rdfstarReverseInEmbedded)
        throw new u.ErrorCoded(`Illegal reverse property in embedded node in ${n}`, u.ERROR_CODES.INVALID_EMBEDDED_NODE);
    }
    /**
     * Emit a quad, with checks.
     * @param depth The current depth.
     * @param subject S
     * @param predicate P
     * @param object O
     * @param graph G
     * @param reverse If a reverse property is active.
     * @param isEmbedded If we're in an embedded node.
     */
    emitQuadChecked(n, i, c, s, d, l, f) {
      let h;
      if (l ? (this.validateReverseSubject(s), h = this.dataFactory.quad(s, c, i, d)) : h = this.dataFactory.quad(i, c, s, d), f) {
        if (h.graph.termType !== "DefaultGraph" && (h = this.dataFactory.quad(h.subject, h.predicate, h.object)), this.parsingContext.idStack[n - 1])
          throw new u.ErrorCoded("Illegal multiple properties in an embedded node", u.ERROR_CODES.INVALID_EMBEDDED_NODE);
        this.parsingContext.idStack[n - 1] = [h];
      } else
        this.parsingContext.emitQuad(n, h);
      const p = this.parsingContext.annotationsBuffer[n];
      if (p) {
        for (const b of p)
          this.emitAnnotation(n, h, b);
        delete this.parsingContext.annotationsBuffer[n];
      }
    }
    // This is a separate function to enable recursion
    emitAnnotation(n, i, c) {
      let s;
      c.reverse ? (this.validateReverseSubject(c.object), s = this.dataFactory.quad(c.object, c.predicate, i)) : s = this.dataFactory.quad(i, c.predicate, c.object), this.parsingContext.emitQuad(n, s);
      for (const d of c.nestedAnnotations)
        this.emitAnnotation(n, s, d);
    }
  }
  return t.XSD = "http://www.w3.org/2001/XMLSchema#", t.XSD_BOOLEAN = t.XSD + "boolean", t.XSD_INTEGER = t.XSD + "integer", t.XSD_DOUBLE = t.XSD + "double", t.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", u2.Util = t, u2;
}
var sQ;
function x1e() {
  if (sQ) return a2;
  sQ = 1, Object.defineProperty(a2, "__esModule", { value: !0 }), a2.EntryHandlerArrayValue = void 0;
  const u = /* @__PURE__ */ a0(), r = /* @__PURE__ */ bn();
  let o = class {
    isPropertyHandler() {
      return !1;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(t, e, n, i, c) {
      return this.test(t, e, null, n, i);
    }
    async test(t, e, n, i, c) {
      return typeof i[c] == "number";
    }
    async handle(t, e, n, i, c, s) {
      let d = await e.unaliasKeywordParent(i, s);
      if (d === "@list") {
        let l = null, f = 0;
        for (let h = s - 2; h > 0; h--) {
          const p = i[h];
          if (typeof p == "string" || typeof p == "number") {
            f = h, l = p;
            break;
          }
        }
        if (l !== null) {
          const h = await e.valueToTerm(await t.getContext(i), l, c, s, i);
          for (const p of h)
            await this.handleListElement(t, e, p, c, s, i.slice(0, f), f);
          h.length === 0 && await this.handleListElement(t, e, null, c, s, i.slice(0, f), f);
        }
      } else if (d === "@set")
        await t.newOnValueJob(i.slice(0, -2), c, s - 2, !1);
      else if (d !== void 0 && d !== "@type") {
        for (let f = s - 1; f > 0; f--)
          if (typeof i[f] != "number") {
            d = await e.unaliasKeyword(i[f], i, f);
            break;
          }
        const l = await t.getContext(i.slice(0, -1));
        if ("@list" in u.Util.getContextValueContainer(l, d)) {
          t.emittedStack[s + 1] = !0;
          const f = await e.valueToTerm(await t.getContext(i), d, c, s, i);
          for (const h of f)
            await this.handleListElement(t, e, h, c, s, i.slice(0, -1), s - 1);
          f.length === 0 && await this.handleListElement(t, e, null, c, s, i.slice(0, -1), s - 1);
        } else
          t.shiftStack(s, 1), await t.newOnValueJob(i.slice(0, -1), c, s - 1, !1), t.contextTree.removeContext(i.slice(0, -1));
      }
    }
    async handleListElement(t, e, n, i, c, s, d) {
      let l = t.listPointerStack[c];
      if (i !== null && (await e.unaliasKeywords(i, s, c))["@value"] !== null) {
        if (!l || !l.value) {
          const f = e.dataFactory.blankNode();
          l = { value: f, listRootDepth: d, listId: f };
        } else {
          const f = e.dataFactory.blankNode();
          t.emitQuad(c, e.dataFactory.quad(l.value, e.rdfRest, f, e.getDefaultGraph())), l.value = f;
        }
        n && t.emitQuad(c, e.dataFactory.quad(l.value, e.rdfFirst, n, e.getDefaultGraph()));
      } else
        l || (l = { listRootDepth: d, listId: e.rdfNil });
      t.listPointerStack[c] = l, t.rdfstar && t.annotationsBuffer[c] && t.emitError(new r.ErrorCoded("Found an illegal annotation inside a list", r.ERROR_CODES.INVALID_ANNOTATION));
    }
  };
  return a2.EntryHandlerArrayValue = o, a2;
}
var h2 = {}, cQ;
function I1e() {
  if (cQ) return h2;
  cQ = 1, Object.defineProperty(h2, "__esModule", { value: !0 }), h2.EntryHandlerInvalidFallback = void 0;
  let u = class {
    isPropertyHandler() {
      return !1;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(o, a, t, e, n) {
      return !1;
    }
    async test(o, a, t, e, n) {
      return !0;
    }
    async handle(o, a, t, e, n, i) {
      o.emittedStack[i] = !1;
    }
  };
  return h2.EntryHandlerInvalidFallback = u, h2;
}
var p2 = {}, b2 = {}, dQ;
function ou() {
  if (dQ) return b2;
  dQ = 1, Object.defineProperty(b2, "__esModule", { value: !0 }), b2.EntryHandlerKeyword = void 0;
  let u = class {
    constructor(o) {
      this.keyword = o;
    }
    isPropertyHandler() {
      return !1;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(o, a, t, e, n) {
      return !1;
    }
    async test(o, a, t, e, n) {
      return t === this.keyword;
    }
  };
  return b2.EntryHandlerKeyword = u, b2;
}
var lQ;
function R1e() {
  if (lQ) return p2;
  lQ = 1, Object.defineProperty(p2, "__esModule", { value: !0 }), p2.EntryHandlerKeywordContext = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ ou();
  let o = class extends r.EntryHandlerKeyword {
    constructor() {
      super("@context");
    }
    isStackProcessor() {
      return !1;
    }
    async handle(t, e, n, i, c, s) {
      t.streamingProfile && (t.processingStack[s] || t.processingType[s] || t.idStack[s] !== void 0) && t.emitError(new u.ErrorCoded("Found an out-of-order context, while streaming is enabled.(disable `streamingProfile`)", u.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
      const d = t.getContext(i), l = t.parseContext(c, (await d).getContextRaw());
      t.contextTree.setContext(i.slice(0, -1), l), t.emitContext(c), await t.validateContext(await l);
    }
  };
  return p2.EntryHandlerKeywordContext = o, p2;
}
var y2 = {}, fQ;
function F1e() {
  if (fQ) return y2;
  fQ = 1, Object.defineProperty(y2, "__esModule", { value: !0 }), y2.EntryHandlerKeywordGraph = void 0;
  const u = /* @__PURE__ */ ou();
  let r = class extends u.EntryHandlerKeyword {
    constructor() {
      super("@graph");
    }
    async handle(a, t, e, n, i, c) {
      a.graphStack[c + 1] = !0;
    }
  };
  return y2.EntryHandlerKeywordGraph = r, y2;
}
var _2 = {}, hQ;
function N1e() {
  if (hQ) return _2;
  hQ = 1, Object.defineProperty(_2, "__esModule", { value: !0 }), _2.EntryHandlerKeywordId = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ ou();
  let o = class extends r.EntryHandlerKeyword {
    constructor() {
      super("@id");
    }
    isStackProcessor() {
      return !1;
    }
    async handle(t, e, n, i, c, s) {
      if (typeof c != "string") {
        if (t.rdfstar && typeof c == "object") {
          const l = Object.keys(c);
          l.length === 1 && l[0] === "@id" && t.emitError(new u.ErrorCoded(`Invalid embedded node without property with @id ${c["@id"]}`, u.ERROR_CODES.INVALID_EMBEDDED_NODE));
        } else
          t.emitError(new u.ErrorCoded(`Found illegal @id '${c}'`, u.ERROR_CODES.INVALID_ID_VALUE));
        return;
      }
      const d = await e.getPropertiesDepth(i, s);
      if (t.idStack[d] !== void 0 && (t.idStack[d][0].listHead ? t.emitError(new u.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${i[s - 1]}'`, u.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT)) : t.emitError(new u.ErrorCoded(`Found duplicate @ids '${t.idStack[d][0].value}' and '${c}'`, u.ERROR_CODES.COLLIDING_KEYWORDS))), t.rdfstar && t.annotationsBuffer[s])
        for (const l of t.annotationsBuffer[s])
          l.depth === s && t.emitError(new u.ErrorCoded(`Found an illegal @id inside an annotation: ${c}`, u.ERROR_CODES.INVALID_ANNOTATION));
      t.idStack[d] = e.nullableTermToArray(await e.resourceToTerm(await t.getContext(i), c));
    }
  };
  return _2.EntryHandlerKeywordId = o, _2;
}
var g2 = {}, pQ;
function P1e() {
  if (pQ) return g2;
  pQ = 1, Object.defineProperty(g2, "__esModule", { value: !0 }), g2.EntryHandlerKeywordIncluded = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ ou();
  let o = class extends r.EntryHandlerKeyword {
    constructor() {
      super("@included");
    }
    async handle(t, e, n, i, c, s) {
      typeof c != "object" && t.emitError(new u.ErrorCoded(`Found illegal @included '${c}'`, u.ERROR_CODES.INVALID_INCLUDED_VALUE));
      const d = await e.unaliasKeywords(c, i, s, await t.getContext(i));
      "@value" in d && t.emitError(new u.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(c)}'`, u.ERROR_CODES.INVALID_INCLUDED_VALUE)), "@list" in d && t.emitError(new u.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(c)}'`, u.ERROR_CODES.INVALID_INCLUDED_VALUE)), t.emittedStack[s] = !1;
    }
  };
  return g2.EntryHandlerKeywordIncluded = o, g2;
}
var m2 = {}, bQ;
function D1e() {
  if (bQ) return m2;
  bQ = 1, Object.defineProperty(m2, "__esModule", { value: !0 }), m2.EntryHandlerKeywordNest = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ ou();
  let o = class extends r.EntryHandlerKeyword {
    constructor() {
      super("@nest");
    }
    async handle(t, e, n, i, c, s) {
      typeof c != "object" && t.emitError(new u.ErrorCoded(`Found invalid @nest entry for '${n}': '${c}'`, u.ERROR_CODES.INVALID_NEST_VALUE)), "@value" in await e.unaliasKeywords(c, i, s, await t.getContext(i)) && t.emitError(new u.ErrorCoded(`Found an invalid @value node for '${n}'`, u.ERROR_CODES.INVALID_NEST_VALUE)), t.emittedStack[s] = !1;
    }
  };
  return m2.EntryHandlerKeywordNest = o, m2;
}
var v2 = {}, yQ;
function L1e() {
  if (yQ) return v2;
  yQ = 1, Object.defineProperty(v2, "__esModule", { value: !0 }), v2.EntryHandlerKeywordType = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ a0(), o = /* @__PURE__ */ d4(), a = /* @__PURE__ */ ou();
  let t = class extends a.EntryHandlerKeyword {
    constructor() {
      super("@type");
    }
    isStackProcessor() {
      return !1;
    }
    async handle(n, i, c, s, d, l) {
      const f = s[l], h = await n.getContext(s), p = i.rdfType, b = await i.unaliasKeywordParent(s, l), _ = r.Util.isPropertyReverse(h, f, b), y = r.Util.isPropertyInEmbeddedNode(b);
      i.validateReverseInEmbeddedNode(c, _, y);
      const m = r.Util.isPropertyInAnnotationObject(b), g = Array.isArray(d) ? d : [d];
      for (const E of g) {
        typeof E != "string" && n.emitError(new u.ErrorCoded(`Found illegal @type '${E}'`, u.ERROR_CODES.INVALID_TYPE_VALUE));
        const R = i.createVocabOrBaseTerm(h, E);
        R && await o.EntryHandlerPredicate.handlePredicateObject(n, i, s, l, p, R, _, y, m);
      }
      let T = Promise.resolve(h), v = !1;
      for (const E of g.sort()) {
        const R = r.Util.getContextValue(h, "@context", E, null);
        R && (v = !0, T = T.then((L) => n.parseContext(R, L.getContextRaw())));
      }
      n.streamingProfile && (v || !n.streamingProfileAllowOutOfOrderPlainType) && (n.processingStack[l] || n.idStack[l]) && n.emitError(new u.ErrorCoded("Found an out-of-order type-scoped context, while streaming is enabled.(disable `streamingProfile`)", u.ERROR_CODES.INVALID_STREAMING_KEY_ORDER)), v && (T = T.then((E) => E.getContextRaw()["@propagate"] !== !0 ? new u.JsonLdContextNormalized(Object.assign(Object.assign({}, E.getContextRaw()), { "@propagate": !1, "@__propagateFallback": h.getContextRaw() })) : E), n.contextTree.setContext(s.slice(0, s.length - 1), T)), n.processingType[l] = !0;
    }
  };
  return v2.EntryHandlerKeywordType = t, v2;
}
var T2 = {}, _Q;
function j1e() {
  if (_Q) return T2;
  _Q = 1, Object.defineProperty(T2, "__esModule", { value: !0 }), T2.EntryHandlerKeywordUnknownFallback = void 0;
  const u = /* @__PURE__ */ bn();
  let r = class tZ {
    isPropertyHandler() {
      return !1;
    }
    isStackProcessor() {
      return !0;
    }
    async validate(a, t, e, n, i) {
      const c = await t.unaliasKeyword(e[n], e, n);
      return u.Util.isPotentialKeyword(c) ? !(!i && c === "@list") : !1;
    }
    async test(a, t, e, n, i) {
      return u.Util.isPotentialKeyword(e);
    }
    async handle(a, t, e, n, i, c) {
      const s = tZ.VALID_KEYWORDS_TYPES[e];
      s !== void 0 ? s && typeof i !== s.type && a.emitError(new u.ErrorCoded(`Invalid value type for '${e}' with value '${i}'`, s.errorCode)) : a.strictValues && a.emitError(new Error(`Unknown keyword '${e}' with value '${i}'`)), a.emittedStack[c] = !1;
    }
  };
  return r.VALID_KEYWORDS_TYPES = {
    "@index": { type: "string", errorCode: u.ERROR_CODES.INVALID_INDEX_VALUE },
    "@list": null,
    "@reverse": { type: "object", errorCode: u.ERROR_CODES.INVALID_REVERSE_VALUE },
    "@set": null,
    "@value": null
  }, T2.EntryHandlerKeywordUnknownFallback = r, T2;
}
var w2 = {}, gQ;
function M1e() {
  if (gQ) return w2;
  gQ = 1, Object.defineProperty(w2, "__esModule", { value: !0 }), w2.EntryHandlerKeywordValue = void 0;
  const u = /* @__PURE__ */ ou();
  let r = class extends u.EntryHandlerKeyword {
    constructor() {
      super("@value");
    }
    async validate(a, t, e, n, i) {
      const c = e[n];
      return c && !a.literalStack[n] && await this.test(a, t, c, e, n) && (a.literalStack[n] = !0), super.validate(a, t, e, n, i);
    }
    async test(a, t, e, n, i) {
      return await t.unaliasKeyword(n[i], n.slice(0, n.length - 1), i - 1, !0) === "@value";
    }
    async handle(a, t, e, n, i, c) {
      a.literalStack[c] = !0, delete a.unidentifiedValuesBuffer[c], delete a.unidentifiedGraphsBuffer[c], a.emittedStack[c] = !1;
    }
  };
  return w2.EntryHandlerKeywordValue = r, w2;
}
var S2 = {}, A2 = {}, mQ;
function C1e() {
  if (mQ) return A2;
  mQ = 1, Object.defineProperty(A2, "__esModule", { value: !0 }), A2.ContextTree = void 0;
  let u = class rZ {
    constructor() {
      this.subTrees = {};
    }
    getContext(o) {
      if (o.length > 0) {
        const [a, ...t] = o, e = this.subTrees[a];
        if (e) {
          const n = e.getContext(t);
          if (n)
            return n.then(({ context: i, depth: c }) => ({ context: i, depth: c + 1 }));
        }
      }
      return this.context ? this.context.then((a) => ({ context: a, depth: 0 })) : null;
    }
    setContext(o, a) {
      if (o.length === 0)
        this.context = a;
      else {
        const [t, ...e] = o;
        let n = this.subTrees[t];
        n || (n = this.subTrees[t] = new rZ()), n.setContext(e, a);
      }
    }
    removeContext(o) {
      this.setContext(o, null);
    }
  };
  return A2.ContextTree = u, A2;
}
var vQ;
function q1e() {
  if (vQ) return S2;
  vQ = 1, Object.defineProperty(S2, "__esModule", { value: !0 }), S2.ParsingContext = void 0;
  const u = /* @__PURE__ */ bn(), r = /* @__PURE__ */ Rw(), o = /* @__PURE__ */ C1e(), a = /* @__PURE__ */ iZ();
  let t = class nZ {
    constructor(n) {
      this.contextParser = new u.ContextParser({ documentLoader: n.documentLoader, skipValidation: n.skipContextValidation }), this.streamingProfile = !!n.streamingProfile, this.baseIRI = n.baseIRI, this.produceGeneralizedRdf = !!n.produceGeneralizedRdf, this.allowSubjectList = !!n.allowSubjectList, this.processingMode = n.processingMode || a.JsonLdParser.DEFAULT_PROCESSING_MODE, this.strictValues = !!n.strictValues, this.validateValueIndexes = !!n.validateValueIndexes, this.defaultGraph = n.defaultGraph, this.rdfDirection = n.rdfDirection, this.normalizeLanguageTags = n.normalizeLanguageTags, this.streamingProfileAllowOutOfOrderPlainType = n.streamingProfileAllowOutOfOrderPlainType, this.rdfstar = n.rdfstar !== !1, this.rdfstarReverseInEmbedded = n.rdfstarReverseInEmbedded, this.topLevelProperties = !1, this.activeProcessingMode = parseFloat(this.processingMode), this.processingStack = [], this.processingType = [], this.emittedStack = [], this.idStack = [], this.graphStack = [], this.graphContainerTermStack = [], this.listPointerStack = [], this.contextTree = new o.ContextTree(), this.literalStack = [], this.validationStack = [], this.unaliasedKeywordCacheStack = [], this.jsonLiteralStack = [], this.unidentifiedValuesBuffer = [], this.unidentifiedGraphsBuffer = [], this.annotationsBuffer = [], this.pendingContainerFlushBuffers = [], this.parser = n.parser, n.context ? (this.rootContext = this.parseContext(n.context), this.rootContext.then((i) => this.validateContext(i))) : this.rootContext = Promise.resolve(new u.JsonLdContextNormalized(this.baseIRI ? { "@base": this.baseIRI, "@__baseDocument": !0 } : {}));
    }
    /**
     * Parse the given context with the configured options.
     * @param {JsonLdContext} context A context to parse.
     * @param {JsonLdContextNormalized} parentContext An optional parent context.
     * @param {boolean} ignoreProtection If @protected term checks should be ignored.
     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.
     */
    async parseContext(n, i, c) {
      return this.contextParser.parse(n, {
        baseIRI: this.baseIRI,
        ignoreProtection: c,
        normalizeLanguageTags: this.normalizeLanguageTags,
        parentContext: i,
        processingMode: this.activeProcessingMode
      });
    }
    /**
     * Check if the given context is valid.
     * If not, an error will be thrown.
     * @param {JsonLdContextNormalized} context A context.
     */
    validateContext(n) {
      const i = n.getContextRaw()["@version"];
      if (i) {
        if (this.activeProcessingMode && i > this.activeProcessingMode)
          throw new r.ErrorCoded(`Unsupported JSON-LD version '${i}' under active processing mode ${this.activeProcessingMode}.`, r.ERROR_CODES.PROCESSING_MODE_CONFLICT);
        if (this.activeProcessingMode && i < this.activeProcessingMode)
          throw new r.ErrorCoded(`Invalid JSON-LD version ${i} under active processing mode ${this.activeProcessingMode}.`, r.ERROR_CODES.INVALID_VERSION_VALUE);
        this.activeProcessingMode = i;
      }
    }
    /**
     * Get the context at the given path.
     * @param {keys} keys The path of keys to get the context at.
     * @param {number} offset The path offset, defaults to 1.
     * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.
     */
    async getContext(n, i = 1) {
      const c = n;
      for (; typeof n[n.length - 1] == "number"; )
        n = n.slice(0, n.length - 1);
      i && (n = n.slice(0, -i));
      const s = await this.getContextPropagationAware(n);
      let l = s.context.getContextRaw();
      for (let f = s.depth; f < c.length - i; f++) {
        const h = c[f], p = l[h];
        if (p && typeof p == "object" && "@context" in p) {
          const b = (await this.parseContext(p, l, !0)).getContextRaw(), _ = !(h in b) || b[h]["@context"]["@propagate"];
          (_ !== !1 || f === c.length - 1 - i) && (l = Object.assign({}, b), delete l["@propagate"], l[h] = Object.assign({}, l[h]), "@id" in p && (l[h]["@id"] = p["@id"]), delete l[h]["@context"], _ !== !1 && this.contextTree.setContext(c.slice(0, f + i), Promise.resolve(new u.JsonLdContextNormalized(l))));
        }
      }
      return new u.JsonLdContextNormalized(l);
    }
    /**
     * Get the context at the given path.
     * Non-propagating contexts will be skipped,
     * unless the context at that exact depth is retrieved.
     *
     * This ONLY takes into account context propagation logic,
     * so this should usually not be called directly,
     * call {@link #getContext} instead.
     *
     * @param keys The path of keys to get the context at.
     * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.
     */
    async getContextPropagationAware(n) {
      const i = n.length;
      let c = null, s;
      do {
        s = !1, c && "@__propagateFallback" in c.context.getContextRaw() ? c.context = new u.JsonLdContextNormalized(c.context.getContextRaw()["@__propagateFallback"]) : (c && (n = n.slice(0, c.depth - 1)), c = await this.contextTree.getContext(n) || { context: await this.rootContext, depth: 0 });
        const d = n[n.length - 1];
        if (d in c.context.getContextRaw()) {
          const l = c.context.getContextRaw()[d];
          l && typeof l == "object" && "@context" in l && (s = !0);
        }
      } while (c.depth > 0 && c.context.getContextRaw()["@propagate"] === !1 && c.depth !== i && !s);
      return c.depth === 0 && c.context.getContextRaw()["@propagate"] === !1 && c.depth !== i && (c.context = new u.JsonLdContextNormalized({})), c;
    }
    /**
     * Start a new job for parsing the given value.
     * @param {any[]} keys The stack of keys.
     * @param value The value to parse.
     * @param {number} depth The depth to parse at.
     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.
     * @return {Promise<void>} A promise resolving when the job is done.
     */
    async newOnValueJob(n, i, c, s) {
      await this.parser.newOnValueJob(n, i, c, s);
    }
    /**
     * Flush the pending container flush buffers
     * @return {boolean} If any pending buffers were flushed.
     */
    async handlePendingContainerFlushBuffers() {
      if (this.pendingContainerFlushBuffers.length > 0) {
        for (const n of this.pendingContainerFlushBuffers)
          await this.parser.flushBuffer(n.depth, n.keys), this.parser.flushStacks(n.depth);
        return this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length), !0;
      } else
        return !1;
    }
    /**
     * Emit the given quad into the output stream.
     * @param {number} depth The depth the quad was generated at.
     * @param {Quad} quad A quad to emit.
     */
    emitQuad(n, i) {
      n === 1 && (this.topLevelProperties = !0), this.parser.push(i);
    }
    /**
     * Emit the given error into the output stream.
     * @param {Error} error An error to emit.
     */
    emitError(n) {
      this.parser.emit("error", n);
    }
    /**
     * Emit the given context into the output stream under the 'context' event.
     * @param {JsonLdContext} context A context to emit.
     */
    emitContext(n) {
      this.parser.emit("context", n);
    }
    /**
     * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.
     * @param {number} depth A depth.
     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
     *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.
     */
    getUnidentifiedValueBufferSafe(n) {
      let i = this.unidentifiedValuesBuffer[n];
      return i || (i = [], this.unidentifiedValuesBuffer[n] = i), i;
    }
    /**
     * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.
     * @param {number} depth A depth.
     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
     *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.
     */
    getUnidentifiedGraphBufferSafe(n) {
      let i = this.unidentifiedGraphsBuffer[n];
      return i || (i = [], this.unidentifiedGraphsBuffer[n] = i), i;
    }
    /**
     * Safely get or create the depth value of {@link ParsingContext.annotationsBuffer}.
     * @param {number} depth A depth.
     * @return {} An element of {@link ParsingContext.annotationsBuffer}.
     */
    getAnnotationsBufferSafe(n) {
      let i = this.annotationsBuffer[n];
      return i || (i = [], this.annotationsBuffer[n] = i), i;
    }
    /**
     * @return IExpandOptions The expand options for the active processing mode.
     */
    getExpandOptions() {
      return nZ.EXPAND_OPTIONS[this.activeProcessingMode];
    }
    /**
     * Shift the stack at the given offset to the given depth.
     *
     * This will override anything in the stack at `depth`,
     * and this will remove anything at `depth + depthOffset`
     *
     * @param depth The target depth.
     * @param depthOffset The origin depth, relative to `depth`.
     */
    shiftStack(n, i) {
      const c = this.idStack[n + i];
      if (c && (this.idStack[n] = c, this.emittedStack[n] = !0, delete this.idStack[n + i]), this.pendingContainerFlushBuffers.length)
        for (const s of this.pendingContainerFlushBuffers)
          s.depth >= n + i && (s.depth -= i, s.keys.splice(n, i));
      this.unidentifiedValuesBuffer[n + i] && (this.unidentifiedValuesBuffer[n] = this.unidentifiedValuesBuffer[n + i], delete this.unidentifiedValuesBuffer[n + i]), this.annotationsBuffer[n + i - 1] && (this.annotationsBuffer[n - 1] || (this.annotationsBuffer[n - 1] = []), this.annotationsBuffer[n - 1] = [
        ...this.annotationsBuffer[n - 1],
        ...this.annotationsBuffer[n + i - 1]
      ], delete this.annotationsBuffer[n + i - 1]);
    }
  };
  return t.EXPAND_OPTIONS = {
    1: {
      allowPrefixForcing: !1,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !1
    },
    1.1: {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    }
  }, S2.ParsingContext = t, S2;
}
var E2 = {}, TQ;
function B1e() {
  if (TQ) return E2;
  TQ = 1, Object.defineProperty(E2, "__esModule", { value: !0 }), E2.EntryHandlerKeywordAnnotation = void 0;
  const u = /* @__PURE__ */ ou(), r = /* @__PURE__ */ bn();
  let o = class extends u.EntryHandlerKeyword {
    constructor() {
      super("@annotation");
    }
    async handle(t, e, n, i, c, s) {
      (typeof c == "string" || typeof c == "object" && c["@value"]) && t.emitError(new r.ErrorCoded(`Found illegal annotation value: ${JSON.stringify(c)}`, r.ERROR_CODES.INVALID_ANNOTATION));
    }
  };
  return E2.EntryHandlerKeywordAnnotation = o, E2;
}
var wQ;
function iZ() {
  if (wQ) return t2;
  wQ = 1, Object.defineProperty(t2, "__esModule", { value: !0 }), t2.JsonLdParser = void 0;
  const u = CW(), r = /* @__PURE__ */ bn(), o = Bt(), a = /* @__PURE__ */ x1e(), t = /* @__PURE__ */ eZ(), e = /* @__PURE__ */ I1e(), n = /* @__PURE__ */ d4(), i = /* @__PURE__ */ R1e(), c = /* @__PURE__ */ F1e(), s = /* @__PURE__ */ N1e(), d = /* @__PURE__ */ P1e(), l = /* @__PURE__ */ D1e(), f = /* @__PURE__ */ L1e(), h = /* @__PURE__ */ j1e(), p = /* @__PURE__ */ M1e(), b = /* @__PURE__ */ q1e(), _ = /* @__PURE__ */ a0(), y = Aw(), m = /* @__PURE__ */ B1e();
  let g = class P0 extends o.Transform {
    constructor(v) {
      super({ readableObjectMode: !0 }), v = v || {}, this.options = v, this.parsingContext = new b.ParsingContext(Object.assign({ parser: this }, v)), this.util = new _.Util({ dataFactory: v.dataFactory, parsingContext: this.parsingContext }), this.jsonParser = new u(), this.contextJobs = [], this.typeJobs = [], this.contextAwaitingJobs = [], this.lastDepth = 0, this.lastKeys = [], this.lastOnValueJob = Promise.resolve(), this.attachJsonParserListeners(), this.on("end", () => {
        typeof this.jsonParser.mode < "u" && this.emit("error", new Error("Unclosed document"));
      });
    }
    /**
     * Construct a JsonLdParser from the given HTTP response.
     *
     * This will throw an error if no valid JSON response is received
     * (application/ld+json, application/json, or something+json).
     *
     * For raw JSON responses, exactly one link header pointing to a JSON-LD context is required.
     *
     * This method is not responsible for handling redirects.
     *
     * @param baseIRI The URI of the received response.
     * @param mediaType The received content type.
     * @param headers Optional HTTP headers.
     * @param options Optional parser options.
     */
    static fromHttpResponse(v, E, R, L) {
      let A, w = ["application/activity+json"];
      if (L && L.wellKnownMediaTypes && (w = L.wellKnownMediaTypes), E !== "application/ld+json" && !w.includes(E)) {
        if (E !== "application/json" && !E.endsWith("+json"))
          throw new r.ErrorCoded(`Unsupported JSON-LD media type ${E}`, r.ERROR_CODES.LOADING_DOCUMENT_FAILED);
        if (R && R.has("Link") && R.forEach((O, x) => {
          if (x === "link") {
            const F = (0, y.parse)(O);
            for (const j of F.get("rel", "http://www.w3.org/ns/json-ld#context")) {
              if (A)
                throw new r.ErrorCoded("Multiple JSON-LD context link headers were found on " + v, r.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);
              A = j.uri;
            }
          }
        }), !A && !(L != null && L.ignoreMissingContextLinkHeader))
          throw new r.ErrorCoded(`Missing context link header for media type ${E} on ${v}`, r.ERROR_CODES.LOADING_DOCUMENT_FAILED);
      }
      let S;
      if (R && R.has("Content-Type")) {
        const O = R.get("Content-Type"), x = /; *profile=([^"]*)/.exec(O);
        x && x[1] === "http://www.w3.org/ns/json-ld#streaming" && (S = !0);
      }
      return new P0(Object.assign({
        baseIRI: v,
        context: A,
        streamingProfile: S
      }, L || {}));
    }
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {RDF.Stream} A quad stream.
     */
    import(v) {
      if ("pipe" in v) {
        v.on("error", (R) => E.emit("error", R));
        const E = v.pipe(new P0(this.options));
        return E;
      } else {
        const E = new o.PassThrough({ readableObjectMode: !0 });
        v.on("error", (L) => R.emit("error", L)), v.on("data", (L) => E.push(L)), v.on("end", () => E.push(null));
        const R = E.pipe(new P0(this.options));
        return R;
      }
    }
    _transform(v, E, R) {
      this.jsonParser.write(v), this.lastOnValueJob.then(() => R(), (L) => R(L));
    }
    /**
     * Start a new job for parsing the given value.
     *
     * This will let the first valid {@link IEntryHandler} handle the entry.
     *
     * @param {any[]} keys The stack of keys.
     * @param value The value to parse.
     * @param {number} depth The depth to parse at.
     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.
     * @return {Promise<void>} A promise resolving when the job is done.
     */
    async newOnValueJob(v, E, R, L) {
      let A = !0;
      if (L && R < this.lastDepth) {
        const F = this.parsingContext.listPointerStack[this.lastDepth];
        F && (F.value && this.push(this.util.dataFactory.quad(F.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph())), F.listId.listHead = !0, this.parsingContext.idStack[F.listRootDepth + 1] = [F.listId], this.parsingContext.listPointerStack.splice(this.lastDepth, 1)), await t.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth) ? (this.parsingContext.pendingContainerFlushBuffers.push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) }), A = !1) : await this.flushBuffer(this.lastDepth, this.lastKeys);
      }
      const w = await this.util.unaliasKeyword(v[R], v, R), S = await this.util.unaliasKeywordParent(v, R);
      this.parsingContext.emittedStack[R] = !0;
      let O = !0;
      r.Util.isValidKeyword(w) && S === "@reverse" && w !== "@context" && this.emit("error", new r.ErrorCoded(`Found the @id '${E}' inside an @reverse property`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));
      let x = !1;
      this.parsingContext.validationStack.length > 1 && (x = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property);
      for (let F = Math.max(1, this.parsingContext.validationStack.length - 1); F < v.length - 1; F++) {
        const j = this.parsingContext.validationStack[F] || (this.parsingContext.validationStack[F] = await this.validateKey(v.slice(0, F + 1), F, x));
        if (j.valid)
          !x && j.property && (x = !0);
        else {
          this.parsingContext.emittedStack[R] = !1, O = !1;
          break;
        }
      }
      if (await this.util.isLiteral(v, R) && (O = !1), O)
        for (const F of P0.ENTRY_HANDLERS) {
          const j = await F.test(this.parsingContext, this.util, w, v, R);
          if (j) {
            await F.handle(this.parsingContext, this.util, w, v, E, R, j), F.isStackProcessor() && (this.parsingContext.processingStack[R] = !0);
            break;
          }
        }
      R === 0 && Array.isArray(E) && await this.util.validateValueIndexes(E), A && R < this.lastDepth && this.flushStacks(this.lastDepth), this.lastDepth = R, this.lastKeys = v, this.parsingContext.unaliasedKeywordCacheStack.splice(R - 1);
    }
    /**
     * Flush the processing stacks at the given depth.
     * @param {number} depth A depth.
     */
    flushStacks(v) {
      this.parsingContext.processingStack.splice(v, 1), this.parsingContext.processingType.splice(v, 1), this.parsingContext.emittedStack.splice(v, 1), this.parsingContext.idStack.splice(v, 1), this.parsingContext.graphStack.splice(v + 1, 1), this.parsingContext.graphContainerTermStack.splice(v, 1), this.parsingContext.jsonLiteralStack.splice(v, 1), this.parsingContext.validationStack.splice(v - 1, 2), this.parsingContext.literalStack.splice(v, this.parsingContext.literalStack.length - v), this.parsingContext.annotationsBuffer.splice(v, 1);
    }
    /**
     * Flush buffers for the given depth.
     *
     * This should be called after the last entry at a given depth was processed.
     *
     * @param {number} depth A depth.
     * @param {any[]} keys A stack of keys.
     * @return {Promise<void>} A promise resolving if flushing is done.
     */
    async flushBuffer(v, E) {
      let R = this.parsingContext.idStack[v];
      !!R || (R = this.parsingContext.idStack[v] = [this.util.dataFactory.blankNode()]);
      const A = this.parsingContext.unidentifiedValuesBuffer[v];
      if (A) {
        for (const O of R) {
          const x = await this.util.getDepthOffsetGraph(v, E), F = this.parsingContext.graphStack[v] || x >= 0 ? this.parsingContext.idStack[v - x - 1] : [await this.util.getGraphContainerValue(E, v)];
          if (F)
            for (const j of F) {
              this.parsingContext.emittedStack[v] = !0;
              for (const q of A)
                this.util.emitQuadChecked(v, O, q.predicate, q.object, j, q.reverse, q.isEmbedded);
            }
          else {
            const j = this.parsingContext.getUnidentifiedGraphBufferSafe(v - await this.util.getDepthOffsetGraph(v, E) - 1);
            for (const q of A)
              q.reverse ? j.push({
                object: O,
                predicate: q.predicate,
                subject: q.object,
                isEmbedded: q.isEmbedded
              }) : j.push({
                object: q.object,
                predicate: q.predicate,
                subject: O,
                isEmbedded: q.isEmbedded
              });
          }
        }
        this.parsingContext.unidentifiedValuesBuffer.splice(v, 1), this.parsingContext.literalStack.splice(v, 1), this.parsingContext.jsonLiteralStack.splice(v, 1);
      }
      const w = this.parsingContext.unidentifiedGraphsBuffer[v];
      if (w) {
        for (const O of R) {
          const x = v === 1 && O.termType === "BlankNode" && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : O;
          this.parsingContext.emittedStack[v] = !0;
          for (const F of w)
            this.parsingContext.emitQuad(v, this.util.dataFactory.quad(F.subject, F.predicate, F.object, x));
        }
        this.parsingContext.unidentifiedGraphsBuffer.splice(v, 1);
      }
      const S = this.parsingContext.annotationsBuffer[v];
      if (S) {
        S.length > 0 && v === 1 && this.parsingContext.emitError(new r.ErrorCoded("Annotations can not be made on top-level nodes", r.ERROR_CODES.INVALID_ANNOTATION));
        const O = this.parsingContext.getAnnotationsBufferSafe(v - 1);
        for (const x of S)
          O.push(x);
        delete this.parsingContext.annotationsBuffer[v];
      }
    }
    /**
     * Check if at least one {@link IEntryHandler} validates the entry to true.
     * @param {any[]} keys A stack of keys.
     * @param {number} depth A depth.
     * @param {boolean} inProperty If the current depth is part of a valid property node.
     * @return {Promise<{ valid: boolean, property: boolean }>} A promise resolving to true or false.
     */
    async validateKey(v, E, R) {
      for (const L of P0.ENTRY_HANDLERS)
        if (await L.validate(this.parsingContext, this.util, v, E, R))
          return { valid: !0, property: R || L.isPropertyHandler() };
      return { valid: !1, property: !1 };
    }
    /**
     * Attach all required listeners to the JSON parser.
     *
     * This should only be called once.
     */
    attachJsonParserListeners() {
      this.jsonParser.onValue = (v) => {
        const E = this.jsonParser.stack.length, R = new Array(E + 1).fill(0).map((L, A) => A === E ? this.jsonParser.key : this.jsonParser.stack[A].key);
        if (!this.isParsingContextInner(E)) {
          const L = () => this.newOnValueJob(R, v, E, !0);
          if (!this.parsingContext.streamingProfile && !this.parsingContext.contextTree.getContext(R.slice(0, -1)))
            if (R[E] === "@context") {
              let A = this.contextJobs[E];
              A || (A = this.contextJobs[E] = []), A.push(L);
            } else
              this.contextAwaitingJobs.push({ job: L, keys: R, depth: E });
          else
            this.lastOnValueJob = this.lastOnValueJob.then(L);
          !this.parsingContext.streamingProfile && E === 0 && (this.lastOnValueJob = this.lastOnValueJob.then(() => this.executeBufferedJobs()));
        }
      }, this.jsonParser.onError = (v) => {
        this.emit("error", v);
      };
    }
    /**
     * Check if the parser is currently parsing an element that is part of an @context entry.
     * @param {number} depth A depth.
     * @return {boolean} A boolean.
     */
    isParsingContextInner(v) {
      for (let E = v; E > 0; E--)
        if (this.jsonParser.stack[E - 1].key === "@context")
          return !0;
      return !1;
    }
    /**
     * Execute all buffered jobs.
     * @return {Promise<void>} A promise resolving if all jobs are finished.
     */
    async executeBufferedJobs() {
      for (const E of this.contextJobs)
        if (E)
          for (const R of E)
            await R();
      this.parsingContext.unaliasedKeywordCacheStack.splice(0);
      const v = [];
      for (const E of this.contextAwaitingJobs)
        await this.util.unaliasKeyword(E.keys[E.depth], E.keys, E.depth, !0) === "@type" || typeof E.keys[E.depth] == "number" && await this.util.unaliasKeyword(E.keys[E.depth - 1], E.keys, E.depth - 1, !0) === "@type" ? this.typeJobs.push({ job: E.job, keys: E.keys.slice(0, E.keys.length - 1) }) : v.push(E);
      for (const E of v) {
        if (this.typeJobs.length > 0) {
          const R = [], L = [];
          for (let S = 0; S < this.typeJobs.length; S++) {
            const O = this.typeJobs[S];
            _.Util.isPrefixArray(O.keys, E.keys) && (R.push(O), L.push(S));
          }
          const A = R.sort((S, O) => S.keys.length - O.keys.length);
          for (const S of A)
            await S.job();
          const w = L.sort().reverse();
          for (const S of w)
            this.typeJobs.splice(S, 1);
        }
        await E.job();
      }
    }
  };
  return g.DEFAULT_PROCESSING_MODE = "1.1", g.ENTRY_HANDLERS = [
    new a.EntryHandlerArrayValue(),
    new i.EntryHandlerKeywordContext(),
    new s.EntryHandlerKeywordId(),
    new d.EntryHandlerKeywordIncluded(),
    new c.EntryHandlerKeywordGraph(),
    new l.EntryHandlerKeywordNest(),
    new f.EntryHandlerKeywordType(),
    new p.EntryHandlerKeywordValue(),
    new m.EntryHandlerKeywordAnnotation(),
    new t.EntryHandlerContainer(),
    new h.EntryHandlerKeywordUnknownFallback(),
    new n.EntryHandlerPredicate(),
    new e.EntryHandlerInvalidFallback()
  ], t2.JsonLdParser = g, t2;
}
var SQ;
function $1e() {
  return SQ || (SQ = 1, function(u) {
    var r = zd && zd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zd && zd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ iZ(), u);
  }(zd)), zd;
}
var O2 = {}, Xd = {}, x2 = {}, bO = {}, AQ;
function aZ() {
  return AQ || (AQ = 1, function() {
    (function(u) {
      (function(r) {
        var o = typeof globalThis < "u" && globalThis || typeof u < "u" && u || // eslint-disable-next-line no-undef
        typeof zf < "u" && zf || {}, a = {
          searchParams: "URLSearchParams" in o,
          iterable: "Symbol" in o && "iterator" in Symbol,
          blob: "FileReader" in o && "Blob" in o && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in o,
          arrayBuffer: "ArrayBuffer" in o
        };
        function t(w) {
          return w && DataView.prototype.isPrototypeOf(w);
        }
        if (a.arrayBuffer)
          var e = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], n = ArrayBuffer.isView || function(w) {
            return w && e.indexOf(Object.prototype.toString.call(w)) > -1;
          };
        function i(w) {
          if (typeof w != "string" && (w = String(w)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(w) || w === "")
            throw new TypeError('Invalid character in header field name: "' + w + '"');
          return w.toLowerCase();
        }
        function c(w) {
          return typeof w != "string" && (w = String(w)), w;
        }
        function s(w) {
          var S = {
            next: function() {
              var O = w.shift();
              return { done: O === void 0, value: O };
            }
          };
          return a.iterable && (S[Symbol.iterator] = function() {
            return S;
          }), S;
        }
        function d(w) {
          this.map = {}, w instanceof d ? w.forEach(function(S, O) {
            this.append(O, S);
          }, this) : Array.isArray(w) ? w.forEach(function(S) {
            if (S.length != 2)
              throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + S.length);
            this.append(S[0], S[1]);
          }, this) : w && Object.getOwnPropertyNames(w).forEach(function(S) {
            this.append(S, w[S]);
          }, this);
        }
        d.prototype.append = function(w, S) {
          w = i(w), S = c(S);
          var O = this.map[w];
          this.map[w] = O ? O + ", " + S : S;
        }, d.prototype.delete = function(w) {
          delete this.map[i(w)];
        }, d.prototype.get = function(w) {
          return w = i(w), this.has(w) ? this.map[w] : null;
        }, d.prototype.has = function(w) {
          return this.map.hasOwnProperty(i(w));
        }, d.prototype.set = function(w, S) {
          this.map[i(w)] = c(S);
        }, d.prototype.forEach = function(w, S) {
          for (var O in this.map)
            this.map.hasOwnProperty(O) && w.call(S, this.map[O], O, this);
        }, d.prototype.keys = function() {
          var w = [];
          return this.forEach(function(S, O) {
            w.push(O);
          }), s(w);
        }, d.prototype.values = function() {
          var w = [];
          return this.forEach(function(S) {
            w.push(S);
          }), s(w);
        }, d.prototype.entries = function() {
          var w = [];
          return this.forEach(function(S, O) {
            w.push([O, S]);
          }), s(w);
        }, a.iterable && (d.prototype[Symbol.iterator] = d.prototype.entries);
        function l(w) {
          if (!w._noBody) {
            if (w.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            w.bodyUsed = !0;
          }
        }
        function f(w) {
          return new Promise(function(S, O) {
            w.onload = function() {
              S(w.result);
            }, w.onerror = function() {
              O(w.error);
            };
          });
        }
        function h(w) {
          var S = new FileReader(), O = f(S);
          return S.readAsArrayBuffer(w), O;
        }
        function p(w) {
          var S = new FileReader(), O = f(S), x = /charset=([A-Za-z0-9_-]+)/.exec(w.type), F = x ? x[1] : "utf-8";
          return S.readAsText(w, F), O;
        }
        function b(w) {
          for (var S = new Uint8Array(w), O = new Array(S.length), x = 0; x < S.length; x++)
            O[x] = String.fromCharCode(S[x]);
          return O.join("");
        }
        function _(w) {
          if (w.slice)
            return w.slice(0);
          var S = new Uint8Array(w.byteLength);
          return S.set(new Uint8Array(w)), S.buffer;
        }
        function y() {
          return this.bodyUsed = !1, this._initBody = function(w) {
            this.bodyUsed = this.bodyUsed, this._bodyInit = w, w ? typeof w == "string" ? this._bodyText = w : a.blob && Blob.prototype.isPrototypeOf(w) ? this._bodyBlob = w : a.formData && FormData.prototype.isPrototypeOf(w) ? this._bodyFormData = w : a.searchParams && URLSearchParams.prototype.isPrototypeOf(w) ? this._bodyText = w.toString() : a.arrayBuffer && a.blob && t(w) ? (this._bodyArrayBuffer = _(w.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(w) || n(w)) ? this._bodyArrayBuffer = _(w) : this._bodyText = w = Object.prototype.toString.call(w) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof w == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(w) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, a.blob && (this.blob = function() {
            var w = l(this);
            if (w)
              return w;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }), this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var w = l(this);
              return w || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
                this._bodyArrayBuffer.buffer.slice(
                  this._bodyArrayBuffer.byteOffset,
                  this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                )
              ) : Promise.resolve(this._bodyArrayBuffer));
            } else {
              if (a.blob)
                return this.blob().then(h);
              throw new Error("could not read as ArrayBuffer");
            }
          }, this.text = function() {
            var w = l(this);
            if (w)
              return w;
            if (this._bodyBlob)
              return p(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(b(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, a.formData && (this.formData = function() {
            return this.text().then(v);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var m = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function g(w) {
          var S = w.toUpperCase();
          return m.indexOf(S) > -1 ? S : w;
        }
        function T(w, S) {
          if (!(this instanceof T))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          S = S || {};
          var O = S.body;
          if (w instanceof T) {
            if (w.bodyUsed)
              throw new TypeError("Already read");
            this.url = w.url, this.credentials = w.credentials, S.headers || (this.headers = new d(w.headers)), this.method = w.method, this.mode = w.mode, this.signal = w.signal, !O && w._bodyInit != null && (O = w._bodyInit, w.bodyUsed = !0);
          } else
            this.url = String(w);
          if (this.credentials = S.credentials || this.credentials || "same-origin", (S.headers || !this.headers) && (this.headers = new d(S.headers)), this.method = g(S.method || this.method || "GET"), this.mode = S.mode || this.mode || null, this.signal = S.signal || this.signal || function() {
            if ("AbortController" in o) {
              var j = new AbortController();
              return j.signal;
            }
          }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && O)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          if (this._initBody(O), (this.method === "GET" || this.method === "HEAD") && (S.cache === "no-store" || S.cache === "no-cache")) {
            var x = /([?&])_=[^&]*/;
            if (x.test(this.url))
              this.url = this.url.replace(x, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
            else {
              var F = /\?/;
              this.url += (F.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
            }
          }
        }
        T.prototype.clone = function() {
          return new T(this, { body: this._bodyInit });
        };
        function v(w) {
          var S = new FormData();
          return w.trim().split("&").forEach(function(O) {
            if (O) {
              var x = O.split("="), F = x.shift().replace(/\+/g, " "), j = x.join("=").replace(/\+/g, " ");
              S.append(decodeURIComponent(F), decodeURIComponent(j));
            }
          }), S;
        }
        function E(w) {
          var S = new d(), O = w.replace(/\r?\n[\t ]+/g, " ");
          return O.split("\r").map(function(x) {
            return x.indexOf(`
`) === 0 ? x.substr(1, x.length) : x;
          }).forEach(function(x) {
            var F = x.split(":"), j = F.shift().trim();
            if (j) {
              var q = F.join(":").trim();
              try {
                S.append(j, q);
              } catch (Q) {
                console.warn("Response " + Q.message);
              }
            }
          }), S;
        }
        y.call(T.prototype);
        function R(w, S) {
          if (!(this instanceof R))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          if (S || (S = {}), this.type = "default", this.status = S.status === void 0 ? 200 : S.status, this.status < 200 || this.status > 599)
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          this.ok = this.status >= 200 && this.status < 300, this.statusText = S.statusText === void 0 ? "" : "" + S.statusText, this.headers = new d(S.headers), this.url = S.url || "", this._initBody(w);
        }
        y.call(R.prototype), R.prototype.clone = function() {
          return new R(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new d(this.headers),
            url: this.url
          });
        }, R.error = function() {
          var w = new R(null, { status: 200, statusText: "" });
          return w.ok = !1, w.status = 0, w.type = "error", w;
        };
        var L = [301, 302, 303, 307, 308];
        R.redirect = function(w, S) {
          if (L.indexOf(S) === -1)
            throw new RangeError("Invalid status code");
          return new R(null, { status: S, headers: { location: w } });
        }, r.DOMException = o.DOMException;
        try {
          new r.DOMException();
        } catch {
          r.DOMException = function(S, O) {
            this.message = S, this.name = O;
            var x = Error(S);
            this.stack = x.stack;
          }, r.DOMException.prototype = Object.create(Error.prototype), r.DOMException.prototype.constructor = r.DOMException;
        }
        function A(w, S) {
          return new Promise(function(O, x) {
            var F = new T(w, S);
            if (F.signal && F.signal.aborted)
              return x(new r.DOMException("Aborted", "AbortError"));
            var j = new XMLHttpRequest();
            function q() {
              j.abort();
            }
            j.onload = function() {
              var K = {
                statusText: j.statusText,
                headers: E(j.getAllResponseHeaders() || "")
              };
              F.url.indexOf("file://") === 0 && (j.status < 200 || j.status > 599) ? K.status = 200 : K.status = j.status, K.url = "responseURL" in j ? j.responseURL : K.headers.get("X-Request-URL");
              var U = "response" in j ? j.response : j.responseText;
              setTimeout(function() {
                O(new R(U, K));
              }, 0);
            }, j.onerror = function() {
              setTimeout(function() {
                x(new TypeError("Network request failed"));
              }, 0);
            }, j.ontimeout = function() {
              setTimeout(function() {
                x(new TypeError("Network request timed out"));
              }, 0);
            }, j.onabort = function() {
              setTimeout(function() {
                x(new r.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function Q(K) {
              try {
                return K === "" && o.location.href ? o.location.href : K;
              } catch {
                return K;
              }
            }
            if (j.open(F.method, Q(F.url), !0), F.credentials === "include" ? j.withCredentials = !0 : F.credentials === "omit" && (j.withCredentials = !1), "responseType" in j && (a.blob ? j.responseType = "blob" : a.arrayBuffer && (j.responseType = "arraybuffer")), S && typeof S.headers == "object" && !(S.headers instanceof d || o.Headers && S.headers instanceof o.Headers)) {
              var G = [];
              Object.getOwnPropertyNames(S.headers).forEach(function(K) {
                G.push(i(K)), j.setRequestHeader(K, c(S.headers[K]));
              }), F.headers.forEach(function(K, U) {
                G.indexOf(U) === -1 && j.setRequestHeader(U, K);
              });
            } else
              F.headers.forEach(function(K, U) {
                j.setRequestHeader(U, K);
              });
            F.signal && (F.signal.addEventListener("abort", q), j.onreadystatechange = function() {
              j.readyState === 4 && F.signal.removeEventListener("abort", q);
            }), j.send(typeof F._bodyInit > "u" ? null : F._bodyInit);
          });
        }
        return A.polyfill = !0, o.fetch || (o.fetch = A, o.Headers = d, o.Request = T, o.Response = R), r.Headers = d, r.Request = T, r.Response = R, r.fetch = A, Object.defineProperty(r, "__esModule", { value: !0 }), r;
      })({});
    })(typeof self < "u" ? self : bO);
  }()), bO;
}
var yO = {}, EQ;
function l4() {
  return EQ || (EQ = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.ERROR_CODES = u.ErrorCoded = void 0;
    class r extends Error {
      /* istanbul ignore next */
      constructor(a, t) {
        super(a), this.code = t;
      }
    }
    u.ErrorCoded = r, function(o) {
      o.COLLIDING_KEYWORDS = "colliding keywords", o.CONFLICTING_INDEXES = "conflicting indexes", o.CYCLIC_IRI_MAPPING = "cyclic IRI mapping", o.INVALID_ID_VALUE = "invalid @id value", o.INVALID_INDEX_VALUE = "invalid @index value", o.INVALID_NEST_VALUE = "invalid @nest value", o.INVALID_PREFIX_VALUE = "invalid @prefix value", o.INVALID_PROPAGATE_VALUE = "invalid @propagate value", o.INVALID_REVERSE_VALUE = "invalid @reverse value", o.INVALID_IMPORT_VALUE = "invalid @import value", o.INVALID_VERSION_VALUE = "invalid @version value", o.INVALID_BASE_IRI = "invalid base IRI", o.INVALID_CONTAINER_MAPPING = "invalid container mapping", o.INVALID_CONTEXT_ENTRY = "invalid context entry", o.INVALID_CONTEXT_NULLIFICATION = "invalid context nullification", o.INVALID_DEFAULT_LANGUAGE = "invalid default language", o.INVALID_INCLUDED_VALUE = "invalid @included value", o.INVALID_IRI_MAPPING = "invalid IRI mapping", o.INVALID_JSON_LITERAL = "invalid JSON literal", o.INVALID_KEYWORD_ALIAS = "invalid keyword alias", o.INVALID_LANGUAGE_MAP_VALUE = "invalid language map value", o.INVALID_LANGUAGE_MAPPING = "invalid language mapping", o.INVALID_LANGUAGE_TAGGED_STRING = "invalid language-tagged string", o.INVALID_LANGUAGE_TAGGED_VALUE = "invalid language-tagged value", o.INVALID_LOCAL_CONTEXT = "invalid local context", o.INVALID_REMOTE_CONTEXT = "invalid remote context", o.INVALID_REVERSE_PROPERTY = "invalid reverse property", o.INVALID_REVERSE_PROPERTY_MAP = "invalid reverse property map", o.INVALID_REVERSE_PROPERTY_VALUE = "invalid reverse property value", o.INVALID_SCOPED_CONTEXT = "invalid scoped context", o.INVALID_SCRIPT_ELEMENT = "invalid script element", o.INVALID_SET_OR_LIST_OBJECT = "invalid set or list object", o.INVALID_TERM_DEFINITION = "invalid term definition", o.INVALID_TYPE_MAPPING = "invalid type mapping", o.INVALID_TYPE_VALUE = "invalid type value", o.INVALID_TYPED_VALUE = "invalid typed value", o.INVALID_VALUE_OBJECT = "invalid value object", o.INVALID_VALUE_OBJECT_VALUE = "invalid value object value", o.INVALID_VOCAB_MAPPING = "invalid vocab mapping", o.IRI_CONFUSED_WITH_PREFIX = "IRI confused with prefix", o.KEYWORD_REDEFINITION = "keyword redefinition", o.LOADING_DOCUMENT_FAILED = "loading document failed", o.LOADING_REMOTE_CONTEXT_FAILED = "loading remote context failed", o.MULTIPLE_CONTEXT_LINK_HEADERS = "multiple context link headers", o.PROCESSING_MODE_CONFLICT = "processing mode conflict", o.PROTECTED_TERM_REDEFINITION = "protected term redefinition", o.CONTEXT_OVERFLOW = "context overflow", o.INVALID_BASE_DIRECTION = "invalid base direction", o.RECURSIVE_CONTEXT_INCLUSION = "recursive context inclusion", o.INVALID_STREAMING_KEY_ORDER = "invalid streaming key order", o.INVALID_EMBEDDED_NODE = "invalid embedded node", o.INVALID_ANNOTATION = "invalid annotation";
    }(u.ERROR_CODES || (u.ERROR_CODES = {}));
  }(yO)), yO;
}
var I2 = {}, OQ;
function uZ() {
  if (OQ) return I2;
  OQ = 1, Object.defineProperty(I2, "__esModule", { value: !0 }), I2.FetchDocumentLoader = void 0, aZ();
  const u = /* @__PURE__ */ l4(), r = Aw(), o = Tr();
  let a = class {
    constructor(e) {
      this.fetcher = e;
    }
    async load(e) {
      const n = await (this.fetcher || fetch)(e, { headers: new Headers({ accept: "application/ld+json" }) });
      if (n.ok && n.headers) {
        let i = n.headers.get("Content-Type");
        if (i) {
          const c = i.indexOf(";");
          c > 0 && (i = i.substr(0, c));
        }
        if (i === "application/ld+json")
          return await n.json();
        if (n.headers.has("Link")) {
          let c;
          if (n.headers.forEach((s, d) => {
            if (d === "link") {
              const l = (0, r.parse)(s);
              for (const f of l.get("type", "application/ld+json"))
                if (f.rel === "alternate") {
                  if (c)
                    throw new Error("Multiple JSON-LD alternate links were found on " + e);
                  c = (0, o.resolve)(f.uri, e);
                }
            }
          }), c)
            return this.load(c);
        }
        throw new u.ErrorCoded(`Unsupported JSON-LD media type ${i}`, u.ERROR_CODES.LOADING_DOCUMENT_FAILED);
      } else
        throw new Error(n.statusText || `Status code: ${n.status}`);
    }
  };
  return I2.FetchDocumentLoader = a, I2;
}
var _O = {}, R2 = {}, xQ;
function z8() {
  if (xQ) return R2;
  xQ = 1, Object.defineProperty(R2, "__esModule", { value: !0 }), R2.Util = void 0;
  let u = class ua {
    /**
     * Check if the given term is a valid compact IRI.
     * Otherwise, it may be an IRI.
     * @param {string} term A term.
     * @return {boolean} If it is a compact IRI.
     */
    static isCompactIri(o) {
      return o.indexOf(":") > 0 && !(o && o[0] === "#");
    }
    /**
     * Get the prefix from the given term.
     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {string} The prefix or null.
     */
    static getPrefix(o, a) {
      if (o && o[0] === "#")
        return null;
      const t = o.indexOf(":");
      if (t >= 0) {
        if (o.length > t + 1 && o.charAt(t + 1) === "/" && o.charAt(t + 2) === "/")
          return null;
        const e = o.substr(0, t);
        if (e === "_")
          return null;
        if (a[e])
          return e;
      }
      return null;
    }
    /**
     * From a given context entry value, get the string value, or the @id field.
     * @param contextValue A value for a term in a context.
     * @return {string} The id value, or null.
     */
    static getContextValueId(o) {
      if (o === null || typeof o == "string")
        return o;
      const a = o["@id"];
      return a || null;
    }
    /**
     * Check if the given simple term definition (string-based value of a context term)
     * should be considered a prefix.
     * @param value A simple term definition value.
     * @param options Options that define the way how expansion must be done.
     */
    static isSimpleTermDefinitionPrefix(o, a) {
      return !ua.isPotentialKeyword(o) && (a.allowPrefixNonGenDelims || typeof o == "string" && (o[0] === "_" || ua.isPrefixIriEndingWithGenDelim(o)));
    }
    /**
     * Check if the given keyword is of the keyword format "@"1*ALPHA.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is of the keyword format.
     */
    static isPotentialKeyword(o) {
      return typeof o == "string" && ua.KEYWORD_REGEX.test(o);
    }
    /**
     * Check if the given prefix ends with a gen-delim character.
     * @param {string} prefixIri A prefix IRI.
     * @return {boolean} If the given prefix IRI is valid.
     */
    static isPrefixIriEndingWithGenDelim(o) {
      return ua.ENDS_WITH_GEN_DELIM.test(o);
    }
    /**
     * Check if the given context value can be a prefix value.
     * @param value A context value.
     * @return {boolean} If it can be a prefix value.
     */
    static isPrefixValue(o) {
      return o && (typeof o == "string" || o && typeof o == "object");
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(o) {
      return !!(o && ua.IRI_REGEX.test(o));
    }
    /**
     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIriWeak(o) {
      return !!o && o[0] !== ":" && ua.IRI_REGEX_WEAK.test(o);
    }
    /**
     * Check if the given keyword is a defined according to the JSON-LD specification.
     * @param {string} keyword A potential keyword.
     * @return {boolean} If the given keyword is valid.
     */
    static isValidKeyword(o) {
      return ua.VALID_KEYWORDS[o];
    }
    /**
     * Check if the given term is protected in the context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {string} key A context term.
     * @return {boolean} If the given term has an @protected flag.
     */
    static isTermProtected(o, a) {
      const t = o[a];
      return typeof t != "string" && t && t["@protected"];
    }
    /**
     * Check if the given context has at least one protected term.
     * @param context A context.
     * @return If the context has a protected term.
     */
    static hasProtectedTerms(o) {
      for (const a of Object.keys(o))
        if (ua.isTermProtected(o, a))
          return !0;
      return !1;
    }
    /**
     * Check if the given key is an internal reserved keyword.
     * @param key A context key.
     */
    static isReservedInternalKeyword(o) {
      return o.startsWith("@__");
    }
    /**
     * Check if two objects are deepEqual to on another.
     * @param object1 The first object to test.
     * @param object2 The second object to test.
     */
    static deepEqual(o, a) {
      const t = Object.keys(o), e = Object.keys(a);
      return t.length !== e.length ? !1 : t.every((n) => {
        const i = o[n], c = a[n];
        return i === c || i !== null && c !== null && typeof i == "object" && typeof c == "object" && this.deepEqual(i, c);
      });
    }
  };
  return u.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/, u.IRI_REGEX_WEAK = /(?::[^:])|\//, u.KEYWORD_REGEX = /^@[a-z]+$/i, u.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/, u.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/, u.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/, u.VALID_KEYWORDS = {
    "@annotation": !0,
    "@base": !0,
    "@container": !0,
    "@context": !0,
    "@direction": !0,
    "@graph": !0,
    "@id": !0,
    "@import": !0,
    "@included": !0,
    "@index": !0,
    "@json": !0,
    "@language": !0,
    "@list": !0,
    "@nest": !0,
    "@none": !0,
    "@prefix": !0,
    "@propagate": !0,
    "@protected": !0,
    "@reverse": !0,
    "@set": !0,
    "@type": !0,
    "@value": !0,
    "@version": !0,
    "@vocab": !0
  }, u.EXPAND_KEYS_BLACKLIST = [
    "@base",
    "@vocab",
    "@language",
    "@version",
    "@direction"
  ], u.ALIAS_DOMAIN_BLACKLIST = [
    "@container",
    "@graph",
    "@id",
    "@index",
    "@list",
    "@nest",
    "@none",
    "@prefix",
    "@reverse",
    "@set",
    "@type",
    "@value",
    "@version"
  ], u.ALIAS_RANGE_BLACKLIST = [
    "@context",
    "@preserve"
  ], u.CONTAINERS = [
    "@list",
    "@set",
    "@index",
    "@language",
    "@graph",
    "@id",
    "@type"
  ], u.CONTAINERS_1_0 = [
    "@list",
    "@set",
    "@index"
  ], R2.Util = u, R2;
}
var IQ;
function oZ() {
  return IQ || (IQ = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.defaultExpandOptions = u.JsonLdContextNormalized = void 0;
    const r = Tr(), o = /* @__PURE__ */ l4(), a = /* @__PURE__ */ z8();
    class t {
      constructor(n) {
        this.contextRaw = n;
      }
      /**
       * @return The raw inner context.
       */
      getContextRaw() {
        return this.contextRaw;
      }
      /**
       * Expand the term or prefix of the given term if it has one,
       * otherwise return the term as-is.
       *
       * This will try to expand the IRI as much as possible.
       *
       * Iff in vocab-mode, then other references to other terms in the context can be used,
       * such as to `myTerm`:
       * ```
       * {
       *   "myTerm": "http://example.org/myLongTerm"
       * }
       * ```
       *
       * @param {string} term A term that is an URL or a prefixed URL.
       * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,
       *                              otherwise it is considered a regular term that is expanded based on @base.
       * @param {IExpandOptions} options Options that define the way how expansion must be done.
       * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
       * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).
       */
      expandTerm(n, i, c = u.defaultExpandOptions) {
        const s = this.contextRaw[n];
        if (s === null || s && s["@id"] === null)
          return null;
        let d = !0;
        if (s && i) {
          const _ = a.Util.getContextValueId(s);
          if (_ && _ !== n)
            if (typeof _ != "string" || !a.Util.isValidIri(_) && !a.Util.isValidKeyword(_))
              a.Util.isPotentialKeyword(_) || (d = !1);
            else
              return _;
        }
        const l = a.Util.getPrefix(n, this.contextRaw), f = this.contextRaw["@vocab"], h = (!!f || f === "") && f.indexOf(":") < 0, p = this.contextRaw["@base"], b = a.Util.isPotentialKeyword(n);
        if (l) {
          const _ = this.contextRaw[l], y = a.Util.getContextValueId(_);
          if (y) {
            if (typeof _ == "string" || !c.allowPrefixForcing) {
              if (!a.Util.isSimpleTermDefinitionPrefix(y, c))
                return n;
            } else if (y[0] !== "_" && !b && !_["@prefix"] && !(n in this.contextRaw))
              return n;
            return y + n.substr(l.length + 1);
          }
        } else if (i && (f || f === "" || c.allowVocabRelativeToBase && p && h) && !b && !a.Util.isCompactIri(n))
          if (h) {
            if (c.allowVocabRelativeToBase)
              return (f || p ? (0, r.resolve)(f, p) : "") + n;
            throw new o.ErrorCoded(`Relative vocab expansion for term '${n}' with vocab '${f}' is not allowed.`, o.ERROR_CODES.INVALID_VOCAB_MAPPING);
          } else
            return f + n;
        else if (!i && p && !b && !a.Util.isCompactIri(n))
          return (0, r.resolve)(n, p);
        if (d)
          return n;
        throw new o.ErrorCoded(`Invalid IRI mapping found for context entry '${n}': '${JSON.stringify(s)}'`, o.ERROR_CODES.INVALID_IRI_MAPPING);
      }
      /**
       * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
       *
       * This will try to compact the IRI as much as possible.
       *
       * @param {string} iri An IRI to compact.
       * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
       *                        otherwise it is considered a regular term that is compacted based on @base.
       * @return {string} The compacted term or the IRI as-is.
       */
      compactIri(n, i) {
        if (i && this.contextRaw["@vocab"] && n.startsWith(this.contextRaw["@vocab"]))
          return n.substr(this.contextRaw["@vocab"].length);
        if (!i && this.contextRaw["@base"] && n.startsWith(this.contextRaw["@base"]))
          return n.substr(this.contextRaw["@base"].length);
        const c = { prefix: "", suffix: n };
        for (const s in this.contextRaw) {
          const d = this.contextRaw[s];
          if (d && !a.Util.isPotentialKeyword(s)) {
            const l = a.Util.getContextValueId(d);
            if (n.startsWith(l)) {
              const f = n.substr(l.length);
              if (f)
                f.length < c.suffix.length && (c.prefix = s, c.suffix = f);
              else if (i)
                return s;
            }
          }
        }
        return c.prefix ? c.prefix + ":" + c.suffix : n;
      }
    }
    u.JsonLdContextNormalized = t, u.defaultExpandOptions = {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    };
  }(_O)), _O;
}
var RQ;
function U1e() {
  if (RQ) return x2;
  RQ = 1, Object.defineProperty(x2, "__esModule", { value: !0 }), x2.ContextParser = void 0, aZ();
  const u = Tr(), r = /* @__PURE__ */ l4(), o = /* @__PURE__ */ uZ(), a = /* @__PURE__ */ oZ(), t = /* @__PURE__ */ z8();
  let e = class Bf {
    constructor(i) {
      i = i || {}, this.documentLoader = i.documentLoader || new o.FetchDocumentLoader(), this.documentCache = {}, this.validateContext = !i.skipValidation, this.expandContentTypeToBase = !!i.expandContentTypeToBase, this.remoteContextsDepthLimit = i.remoteContextsDepthLimit || 32, this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in i ? !!i.redirectSchemaOrgHttps : !0;
    }
    /**
     * Validate the given @language value.
     * An error will be thrown if it is invalid.
     * @param value An @language value.
     * @param {boolean} strictRange If the string value should be strictly checked against a regex.
     * @param {string} errorCode The error code to emit on errors.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateLanguage(i, c, s) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(i)}'`, s);
      if (!t.Util.REGEX_LANGUAGE_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(i)}'`, s);
        return !1;
      }
      return !0;
    }
    /**
     * Validate the given @direction value.
     * An error will be thrown if it is invalid.
     * @param value An @direction value.
     * @param {boolean} strictValues If the string value should be strictly checked against a regex.
     * @return {boolean} If validation passed.
     *                   Can only be false if strictRange is false and the string value did not pass the regex.
     */
    static validateDirection(i, c) {
      if (typeof i != "string")
        throw new r.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
      if (!t.Util.REGEX_DIRECTION_TAG.test(i)) {
        if (c)
          throw new r.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(i)}'`, r.ERROR_CODES.INVALID_BASE_DIRECTION);
        return !1;
      }
      return !0;
    }
    /**
     * Add an @id term for all @reverse terms.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     */
    idifyReverseTerms(i) {
      for (const c of Object.keys(i)) {
        let s = i[c];
        if (s && typeof s == "object" && s["@reverse"] && !s["@id"]) {
          if (typeof s["@reverse"] != "string" || t.Util.isValidKeyword(s["@reverse"]))
            throw new r.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${s["@reverse"]}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
          s = i[c] = Object.assign(Object.assign({}, s), { "@id": s["@reverse"] }), s["@id"] = s["@reverse"], t.Util.isPotentialKeyword(s["@reverse"]) ? delete s["@reverse"] : s["@reverse"] = !0;
        }
      }
      return i;
    }
    /**
     * Expand all prefixed terms in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
     *                                          via @base if @vocab is set to null.
     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all
     * keys in the context will be expanded.
     */
    expandPrefixedTerms(i, c, s) {
      const d = i.getContextRaw();
      for (const l of s || Object.keys(d))
        if (t.Util.EXPAND_KEYS_BLACKLIST.indexOf(l) < 0 && !t.Util.isReservedInternalKeyword(l)) {
          const f = d[l];
          if (t.Util.isPotentialKeyword(l) && t.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(l) >= 0 && (l !== "@type" || typeof d[l] == "object" && !(d[l]["@protected"] || d[l]["@container"] === "@set")))
            throw new r.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          if (t.Util.ALIAS_RANGE_BLACKLIST.indexOf(t.Util.getContextValueId(f)) >= 0)
            throw new r.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${l} to ${JSON.stringify(f)}`, r.ERROR_CODES.INVALID_KEYWORD_ALIAS);
          if (f && t.Util.isPotentialKeyword(t.Util.getContextValueId(f)) && f["@prefix"] === !0)
            throw new r.ErrorCoded(`Tried to use keyword aliases as prefix: '${l}': '${JSON.stringify(f)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          for (; t.Util.isPrefixValue(d[l]); ) {
            const h = d[l];
            let p = !1;
            if (typeof h == "string")
              d[l] = i.expandTerm(h, !0), p = p || h !== d[l];
            else {
              const b = h["@id"], _ = h["@type"], y = !("@prefix" in h) || t.Util.isValidIri(l);
              if ("@id" in h)
                b != null && typeof b == "string" && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": i.expandTerm(b, !0) }), p = p || b !== d[l]["@id"]);
              else if (!t.Util.isPotentialKeyword(l) && y) {
                const m = i.expandTerm(l, !0);
                m !== l && (d[l] = Object.assign(Object.assign({}, d[l]), { "@id": m }), p = !0);
              }
              if (_ && typeof _ == "string" && _ !== "@vocab" && (!h["@container"] || !h["@container"]["@type"]) && y) {
                let m = i.expandTerm(_, !0);
                c && _ === m && (m = i.expandTerm(_, !1)), m !== _ && (p = !0, d[l] = Object.assign(Object.assign({}, d[l]), { "@type": m }));
              }
            }
            if (!p)
              break;
          }
        }
    }
    /**
     * Normalize the @language entries in the given context to lowercase.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} parseOptions The parsing options.
     */
    normalize(i, { processingMode: c, normalizeLanguageTags: s }) {
      if (s || c === 1)
        for (const d of Object.keys(i))
          if (d === "@language" && typeof i[d] == "string")
            i[d] = i[d].toLowerCase();
          else {
            const l = i[d];
            if (l && typeof l == "object" && typeof l["@language"] == "string") {
              const f = l["@language"].toLowerCase();
              f !== l["@language"] && (i[d] = Object.assign(Object.assign({}, l), { "@language": f }));
            }
          }
    }
    /**
     * Convert all @container strings and array values to hash-based values.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     */
    containersToHash(i) {
      for (const c of Object.keys(i)) {
        const s = i[c];
        if (s && typeof s == "object") {
          if (typeof s["@container"] == "string")
            i[c] = Object.assign(Object.assign({}, s), { "@container": { [s["@container"]]: !0 } });
          else if (Array.isArray(s["@container"])) {
            const d = {};
            for (const l of s["@container"])
              d[l] = !0;
            i[c] = Object.assign(Object.assign({}, s), { "@container": d });
          }
        }
      }
    }
    /**
     * Normalize and apply context-level @protected terms onto each term separately.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {number} processingMode The processing mode.
     */
    applyScopedProtected(i, { processingMode: c }, s) {
      if (c && c >= 1.1 && i["@protected"]) {
        for (const d of Object.keys(i))
          if (!t.Util.isReservedInternalKeyword(d) && !t.Util.isPotentialKeyword(d) && !t.Util.isTermProtected(i, d)) {
            const l = i[d];
            l && typeof l == "object" ? "@protected" in i[d] || (i[d] = Object.assign(Object.assign({}, i[d]), { "@protected": !0 })) : (i[d] = {
              "@id": l,
              "@protected": !0
            }, t.Util.isSimpleTermDefinitionPrefix(l, s) && (i[d] = Object.assign(Object.assign({}, i[d]), { "@prefix": !0 })));
          }
        delete i["@protected"];
      }
    }
    /**
     * Check if the given context inheritance does not contain any overrides of protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.
     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.
     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.
     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all
     * keys defined in contextAfter will be checked.
     */
    validateKeywordRedefinitions(i, c, s, d) {
      for (const l of d ?? Object.keys(c))
        if (t.Util.isTermProtected(i, l) && (typeof c[l] == "string" ? c[l] = { "@id": c[l], "@protected": !0 } : c[l] = Object.assign(Object.assign({}, c[l]), { "@protected": !0 }), !t.Util.deepEqual(i[l], c[l])))
          throw new r.ErrorCoded(`Attempted to override the protected keyword ${l} from ${JSON.stringify(t.Util.getContextValueId(i[l]))} to ${JSON.stringify(t.Util.getContextValueId(c[l]))}`, r.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
    }
    /**
     * Validate the entries of the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options The parse options.
     */
    validate(i, { processingMode: c }) {
      for (const s of Object.keys(i)) {
        if (t.Util.isReservedInternalKeyword(s))
          continue;
        if (s === "")
          throw new r.ErrorCoded(`The empty term is not allowed, got: '${s}': '${JSON.stringify(i[s])}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
        const d = i[s], l = typeof d;
        if (t.Util.isPotentialKeyword(s)) {
          switch (s.substr(1)) {
            case "vocab":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @vocab IRI: ${d}`, r.ERROR_CODES.INVALID_VOCAB_MAPPING);
              break;
            case "base":
              if (d !== null && l !== "string")
                throw new r.ErrorCoded(`Found an invalid @base IRI: ${i[s]}`, r.ERROR_CODES.INVALID_BASE_IRI);
              break;
            case "language":
              d !== null && Bf.validateLanguage(d, !0, r.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
              break;
            case "version":
              if (d !== null && l !== "number")
                throw new r.ErrorCoded(`Found an invalid @version number: ${d}`, r.ERROR_CODES.INVALID_VERSION_VALUE);
              break;
            case "direction":
              d !== null && Bf.validateDirection(d, !0);
              break;
            case "propagate":
              if (c === 1)
                throw new r.ErrorCoded(`Found an illegal @propagate keyword: ${d}`, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              if (d !== null && l !== "boolean")
                throw new r.ErrorCoded(`Found an invalid @propagate value: ${d}`, r.ERROR_CODES.INVALID_PROPAGATE_VALUE);
              break;
          }
          if (t.Util.isValidKeyword(s) && t.Util.isValidKeyword(t.Util.getContextValueId(d)))
            throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${t.Util.getContextValueId(d)}'`, r.ERROR_CODES.KEYWORD_REDEFINITION);
          continue;
        }
        if (d !== null)
          switch (l) {
            case "string":
              if (t.Util.getPrefix(d, i) === s)
                throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
              if (t.Util.isValidIriWeak(s)) {
                if (d === "@type")
                  throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                if (t.Util.isValidIri(d) && d !== new a.JsonLdContextNormalized(i).expandTerm(s))
                  throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${d}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              }
              break;
            case "object":
              if (!t.Util.isCompactIri(s) && !("@id" in d) && (d["@type"] === "@id" ? !i["@base"] : !i["@vocab"]))
                throw new r.ErrorCoded(`Missing @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
              for (const f of Object.keys(d)) {
                const h = d[f];
                if (h)
                  switch (f) {
                    case "@id":
                      if (t.Util.isValidKeyword(h) && h !== "@type" && h !== "@id" && h !== "@graph" && h !== "@nest")
                        throw new r.ErrorCoded(`Illegal keyword alias in term value, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.isValidIriWeak(s)) {
                        if (h === "@type")
                          throw new r.ErrorCoded(`IRIs can not be mapped to @type, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                        if (t.Util.isValidIri(h) && h !== new a.JsonLdContextNormalized(i).expandTerm(s))
                          throw new r.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      }
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`Detected non-string @id in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_IRI_MAPPING);
                      if (t.Util.getPrefix(h, i) === s)
                        throw new r.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.CYCLIC_IRI_MAPPING);
                      break;
                    case "@type":
                      if (d["@container"] === "@type" && h !== "@id" && h !== "@vocab")
                        throw new r.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (typeof h != "string")
                        throw new r.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(l)}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      if (h !== "@id" && h !== "@vocab" && (c === 1 || h !== "@json") && (c === 1 || h !== "@none") && (h[0] === "_" || !t.Util.isValidIri(h)))
                        throw new r.ErrorCoded(`A context @type must be an absolute IRI, found: '${s}': '${h}'`, r.ERROR_CODES.INVALID_TYPE_MAPPING);
                      break;
                    case "@reverse":
                      if (typeof h == "string" && d["@id"] && d["@id"] !== h)
                        throw new r.ErrorCoded(`Found non-matching @id and @reverse term values in '${s}':'${h}' and '${d["@id"]}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      if ("@nest" in d)
                        throw new r.ErrorCoded(`@nest is not allowed in the reverse property '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                      break;
                    case "@container":
                      if (c === 1 && (Object.keys(h).length > 1 || t.Util.CONTAINERS_1_0.indexOf(Object.keys(h)[0]) < 0))
                        throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${Object.keys(h)}') in 1.0, must be only one of ${t.Util.CONTAINERS_1_0.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      for (const p of Object.keys(h)) {
                        if (p === "@list" && d["@reverse"])
                          throw new r.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${s}'`, r.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        if (t.Util.CONTAINERS.indexOf(p) < 0)
                          throw new r.ErrorCoded(`Invalid term @container for '${s}' ('${p}'), must be one of ${t.Util.CONTAINERS.join(", ")}`, r.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                      }
                      break;
                    case "@language":
                      Bf.validateLanguage(h, !0, r.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                      break;
                    case "@direction":
                      Bf.validateDirection(h, !0);
                      break;
                    case "@prefix":
                      if (h !== null && typeof h != "boolean")
                        throw new r.ErrorCoded(`Found an invalid term @prefix boolean in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_PREFIX_VALUE);
                      if (!("@id" in d) && !t.Util.isValidIri(s))
                        throw new r.ErrorCoded(`Invalid @prefix definition for '${s}' ('${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@index":
                      if (c === 1 || !d["@container"] || !d["@container"]["@index"])
                        throw new r.ErrorCoded(`Attempt to add illegal key to value object: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
                      break;
                    case "@nest":
                      if (t.Util.isPotentialKeyword(h) && h !== "@nest")
                        throw new r.ErrorCoded(`Found an invalid term @nest value in: '${s}': '${JSON.stringify(d)}'`, r.ERROR_CODES.INVALID_NEST_VALUE);
                  }
              }
              break;
            default:
              throw new r.ErrorCoded(`Found an invalid term value: '${s}': '${d}'`, r.ERROR_CODES.INVALID_TERM_DEFINITION);
          }
      }
    }
    /**
     * Apply the @base context entry to the given context under certain circumstances.
     * @param context A context.
     * @param options Parsing options.
     * @param inheritFromParent If the @base value from the parent context can be inherited.
     * @return The given context.
     */
    applyBaseEntry(i, c, s) {
      return typeof i == "string" || (s && !("@base" in i) && c.parentContext && typeof c.parentContext == "object" && "@base" in c.parentContext && (i["@base"] = c.parentContext["@base"], c.parentContext["@__baseDocument"] && (i["@__baseDocument"] = !0)), c.baseIRI && !c.external && ("@base" in i ? i["@base"] !== null && typeof i["@base"] == "string" && !t.Util.isValidIri(i["@base"]) && (i["@base"] = (0, u.resolve)(i["@base"], c.parentContext && c.parentContext["@base"] || c.baseIRI)) : (i["@base"] = c.baseIRI, i["@__baseDocument"] = !0))), i;
    }
    /**
     * Resolve relative context IRIs, or return full IRIs as-is.
     * @param {string} contextIri A context IRI.
     * @param {string} baseIRI A base IRI.
     * @return {string} The normalized context IRI.
     */
    normalizeContextIri(i, c) {
      if (!t.Util.isValidIri(i))
        try {
          i = (0, u.resolve)(i, c);
        } catch {
          throw new Error(`Invalid context IRI: ${i}`);
        }
      return this.redirectSchemaOrgHttps && i.startsWith("http://schema.org") && (i = "https://schema.org/"), i;
    }
    /**
     * Parse scoped contexts in the given context.
     * @param {IJsonLdContextNormalizedRaw} context A context.
     * @param {IParseOptions} options Parsing options.
     * @return {IJsonLdContextNormalizedRaw} The mutated input context.
     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all
     * keys in the context will be iterated over.
     */
    async parseInnerContexts(i, c, s) {
      for (const d of s ?? Object.keys(i)) {
        const l = i[d];
        if (l && typeof l == "object" && "@context" in l && l["@context"] !== null && !c.ignoreScopedContexts) {
          if (this.validateContext)
            try {
              const f = Object.assign(Object.assign({}, i), { [d]: Object.assign({}, i[d]) });
              delete f[d]["@context"], await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, parentContext: f, ignoreProtection: !0, ignoreRemoteScopedContexts: !0, ignoreScopedContexts: !0 }));
            } catch (f) {
              throw new r.ErrorCoded(f.message, r.ERROR_CODES.INVALID_SCOPED_CONTEXT);
            }
          i[d] = Object.assign(Object.assign({}, l), { "@context": (await this.parse(l["@context"], Object.assign(Object.assign({}, c), { external: !1, minimalProcessing: !0, ignoreRemoteScopedContexts: !0, parentContext: i }))).getContextRaw() });
        }
      }
      return i;
    }
    async parse(i, c = {}, s = {}) {
      const { baseIRI: d, parentContext: l, external: f, processingMode: h = Bf.DEFAULT_PROCESSING_MODE, normalizeLanguageTags: p, ignoreProtection: b, minimalProcessing: _ } = c, y = c.remoteContexts || {};
      if (Object.keys(y).length >= this.remoteContextsDepthLimit)
        throw new r.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(y), r.ERROR_CODES.CONTEXT_OVERFLOW);
      if (i == null) {
        if (!b && l && t.Util.hasProtectedTerms(l))
          throw new r.ErrorCoded("Illegal context nullification when terms are protected", r.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
        return new a.JsonLdContextNormalized(this.applyBaseEntry({}, c, !1));
      } else if (typeof i == "string") {
        const m = this.normalizeContextIri(i, d), g = this.getOverriddenLoad(m, c);
        if (g)
          return new a.JsonLdContextNormalized(g);
        const T = await this.parse(await this.load(m), Object.assign(Object.assign({}, c), { baseIRI: m, external: !0, remoteContexts: Object.assign(Object.assign({}, y), { [m]: !0 }) }));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (Array.isArray(i)) {
        const m = [], g = await Promise.all(i.map((v, E) => {
          if (typeof v == "string") {
            const R = this.normalizeContextIri(v, d);
            m[E] = R;
            const L = this.getOverriddenLoad(R, c);
            return L || this.load(R);
          } else
            return v;
        }));
        if (_)
          return new a.JsonLdContextNormalized(g);
        const T = await g.reduce((v, E, R) => v.then((L) => this.parse(
          E,
          Object.assign(Object.assign({}, c), { baseIRI: m[R] || c.baseIRI, external: !!m[R] || c.external, parentContext: L.getContextRaw(), remoteContexts: m[R] ? Object.assign(Object.assign({}, y), { [m[R]]: !0 }) : y }),
          // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers
          {
            skipValidation: R < g.length - 1
          }
        )), Promise.resolve(new a.JsonLdContextNormalized(l || {})));
        return this.applyBaseEntry(T.getContextRaw(), c, !0), T;
      } else if (typeof i == "object") {
        if ("@context" in i)
          return await this.parse(i["@context"], c);
        if (i = Object.assign({}, i), f && delete i["@base"], this.applyBaseEntry(i, c, !0), this.containersToHash(i), _)
          return new a.JsonLdContextNormalized(i);
        let m = {};
        if ("@import" in i)
          if (h >= 1.1) {
            if (typeof i["@import"] != "string")
              throw new r.ErrorCoded("An @import value must be a string, but got " + typeof i["@import"], r.ERROR_CODES.INVALID_IMPORT_VALUE);
            m = await this.loadImportContext(this.normalizeContextIri(i["@import"], d)), delete i["@import"];
          } else
            throw new r.ErrorCoded("Context importing is not supported in JSON-LD 1.0", r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        this.applyScopedProtected(m, { processingMode: h }, a.defaultExpandOptions);
        const g = Object.assign(m, i);
        this.idifyReverseTerms(g), this.normalize(g, { processingMode: h, normalizeLanguageTags: p }), this.applyScopedProtected(g, { processingMode: h }, a.defaultExpandOptions);
        const T = Object.keys(g), v = [];
        if (typeof l == "object")
          for (const R in l)
            R in g ? v.push(R) : g[R] = l[R];
        await this.parseInnerContexts(g, c, T);
        const E = new a.JsonLdContextNormalized(g);
        return (g && g["@version"] || Bf.DEFAULT_PROCESSING_MODE) >= 1.1 && (i["@vocab"] && typeof i["@vocab"] == "string" || i["@vocab"] === "") && (l && "@vocab" in l && i["@vocab"].indexOf(":") < 0 ? g["@vocab"] = l["@vocab"] + i["@vocab"] : (t.Util.isCompactIri(i["@vocab"]) || i["@vocab"] in g) && (g["@vocab"] = E.expandTerm(i["@vocab"], !0))), this.expandPrefixedTerms(E, this.expandContentTypeToBase, T), !b && l && h >= 1.1 && this.validateKeywordRedefinitions(l, g, a.defaultExpandOptions, v), this.validateContext && !s.skipValidation && this.validate(g, { processingMode: h }), E;
      } else
        throw new r.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${i}`, r.ERROR_CODES.INVALID_LOCAL_CONTEXT);
    }
    /**
     * Fetch the given URL as a raw JSON-LD context.
     * @param url An URL.
     * @return A promise resolving to a raw JSON-LD context.
     */
    async load(i) {
      const c = this.documentCache[i];
      if (c)
        return c;
      let s;
      try {
        s = await this.documentLoader.load(i);
      } catch (d) {
        throw new r.ErrorCoded(`Failed to load remote context ${i}: ${d.message}`, r.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
      }
      if (!("@context" in s))
        throw new r.ErrorCoded(`Missing @context in remote context at ${i}`, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      return this.documentCache[i] = s["@context"];
    }
    /**
     * Override the given context that may be loaded.
     *
     * This will check whether or not the url is recursively being loaded.
     * @param url An URL.
     * @param options Parsing options.
     * @return An overridden context, or null.
     *         Optionally an error can be thrown if a cyclic context is detected.
     */
    getOverriddenLoad(i, c) {
      if (i in (c.remoteContexts || {})) {
        if (c.ignoreRemoteScopedContexts)
          return i;
        throw new r.ErrorCoded("Detected a cyclic context inclusion of " + i, r.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
      }
      return null;
    }
    /**
     * Load an @import'ed context.
     * @param importContextIri The full URI of an @import value.
     */
    async loadImportContext(i) {
      let c = await this.load(i);
      if (typeof c != "object" || Array.isArray(c))
        throw new r.ErrorCoded("An imported context must be a single object: " + i, r.ERROR_CODES.INVALID_REMOTE_CONTEXT);
      if ("@import" in c)
        throw new r.ErrorCoded("An imported context can not import another context: " + i, r.ERROR_CODES.INVALID_CONTEXT_ENTRY);
      return c = Object.assign({}, c), this.containersToHash(c), c;
    }
  };
  return e.DEFAULT_PROCESSING_MODE = 1.1, x2.ContextParser = e, x2;
}
var gO = {}, FQ;
function V1e() {
  return FQ || (FQ = 1, Object.defineProperty(gO, "__esModule", { value: !0 })), gO;
}
var mO = {}, NQ;
function Q1e() {
  return NQ || (NQ = 1, Object.defineProperty(mO, "__esModule", { value: !0 })), mO;
}
var PQ;
function H1e() {
  return PQ || (PQ = 1, function(u) {
    var r = Xd && Xd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xd && Xd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ U1e(), u), o(/* @__PURE__ */ l4(), u), o(/* @__PURE__ */ uZ(), u), o(/* @__PURE__ */ V1e(), u), o(/* @__PURE__ */ Q1e(), u), o(/* @__PURE__ */ oZ(), u), o(/* @__PURE__ */ z8(), u);
  }(Xd)), Xd;
}
var DQ;
function cZ() {
  if (DQ) return O2;
  DQ = 1, Object.defineProperty(O2, "__esModule", { value: !0 }), O2.DocumentLoaderMediated = void 0;
  const u = /* @__PURE__ */ Aa(), r = gh(), o = /* @__PURE__ */ H1e();
  let a = class sZ extends o.FetchDocumentLoader {
    constructor(e, n) {
      super(sZ.createFetcher(e, n)), this.mediatorHttp = e, this.context = n;
    }
    static createFetcher(e, n) {
      return async (i, c) => {
        const s = await e.mediate({ input: i, init: c, context: n });
        return s.json = async () => JSON.parse(await (0, r.stringify)(u.ActorHttp.toNodeReadable(s.body))), s;
      };
    }
  };
  return O2.DocumentLoaderMediated = a, O2;
}
var LQ;
function G1e() {
  if (LQ) return e2;
  LQ = 1, Object.defineProperty(e2, "__esModule", { value: !0 }), e2.ActorRdfParseJsonLd = void 0;
  const u = /* @__PURE__ */ yh(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ $1e(), t = /* @__PURE__ */ cZ();
  let e = class extends u.ActorRdfParseFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/ld+json": 1.0,
     *       "application/json": 0.15
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD",
     *       "application/json": "http://www.w3.org/ns/formats/JSON-LD"
     *     }} mediaTypeFormats
     */
    constructor(i) {
      super(i);
    }
    async testHandle(i, c, s) {
      return s.has(r.KeysRdfParseHtmlScript.processingHtmlScript) && c !== "application/ld+json" ? (0, o.failTest)("JSON-LD in script tags can only have media type 'application/ld+json'") : !c || !(c in this.mediaTypePriorities || c.endsWith("+json")) ? (0, o.failTest)(`Unrecognized media type: ${c}`) : await this.testHandleChecked(i);
    }
    async runHandle(i, c, s) {
      var h;
      const d = i.context.getSafe(r.KeysInitQuery.dataFactory);
      return { data: a.JsonLdParser.fromHttpResponse(((h = i.metadata) == null ? void 0 : h.baseIRI) ?? "", c, i.headers, {
        dataFactory: d,
        documentLoader: s.get(r.KeysRdfParseJsonLd.documentLoader) ?? new t.DocumentLoaderMediated(this.mediatorHttp, s),
        strictValues: s.get(r.KeysRdfParseJsonLd.strictValues),
        ...s.get(r.KeysRdfParseJsonLd.parserOptions)
      }).import(i.data) };
    }
  };
  return e2.ActorRdfParseJsonLd = e, e2;
}
var jQ;
function z1e() {
  return jQ || (jQ = 1, function(u) {
    var r = Gd && Gd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Gd && Gd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ G1e(), u), o(/* @__PURE__ */ cZ(), u);
  }(Gd)), Gd;
}
var Jd = {}, F2 = {}, Kd = {}, N2 = {}, MQ;
function k1e() {
  if (MQ) return N2;
  MQ = 1, Object.defineProperty(N2, "__esModule", { value: !0 }), N2.ActorRdfUpdateHypermedia = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {RDF hypermedia updating failed: none of the configured actors were able to handle an update for ${action.url}} busFailMessage
     * @param destinationType - The destination type.
     */
    /* eslint-enable max-len */
    constructor(a, t) {
      super(a), this.destinationType = t;
    }
    async test(a) {
      return a.forceDestinationType && this.destinationType !== a.forceDestinationType ? (0, u.failTest)(`Actor ${this.name} is not able to handle destination type ${a.forceDestinationType}.`) : this.testMetadata(a);
    }
  };
  return N2.ActorRdfUpdateHypermedia = r, N2;
}
var CQ;
function k8() {
  return CQ || (CQ = 1, function(u) {
    var r = Kd && Kd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Kd && Kd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ k1e(), u);
  }(Kd)), Kd;
}
var P2 = {}, qQ;
function dZ() {
  if (qQ) return P2;
  qQ = 1, Object.defineProperty(P2, "__esModule", { value: !0 }), P2.QuadDestinationPatchSparqlUpdate = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ yt(), o = Ow(), a = Bt();
  let t = class {
    constructor(n, i, c) {
      this.url = n, this.context = i, this.mediatorHttp = c;
    }
    async update(n) {
      const i = this.createCombinedQuadsQuery(n.insert, n.delete);
      await this.wrapSparqlUpdateRequest(i);
    }
    createCombinedQuadsQuery(n, i) {
      return new r.ArrayIterator([], { autoStart: !1 }).append(this.createQuadsQuery("DELETE", i)).append(i && n ? [` ;
`] : []).append(this.createQuadsQuery("INSERT", n));
    }
    createQuadsQuery(n, i) {
      return i ? i.map((c) => {
        let s = `${(0, o.termToString)(c.subject)} ${(0, o.termToString)(c.predicate)} ${(0, o.termToString)(c.object)} .`;
        return c.graph.termType === "DefaultGraph" ? s = `  ${s}
` : s = `  GRAPH ${(0, o.termToString)(c.graph)} { ${s} }
`, s;
      }).prepend([`${n} DATA {
`]).append(["}"]) : new r.ArrayIterator([], { autoStart: !1 });
    }
    async wrapSparqlUpdateRequest(n) {
      const i = new a.Readable();
      i.wrap(n);
      const c = new Headers({ "content-type": "application/sparql-update" }), s = await this.mediatorHttp.mediate({
        context: this.context,
        init: {
          headers: c,
          method: "PATCH",
          body: u.ActorHttp.toWebReadableStream(i)
        },
        input: this.url
      });
      await (0, u.validateAndCloseHttpResponse)(this.url, s);
    }
    async deleteGraphs(n, i, c) {
      throw new Error("Patch-based SPARQL Update destinations don't support named graphs");
    }
    async createGraphs(n, i) {
      throw new Error("Patch-based SPARQL Update destinations don't support named graphs");
    }
  };
  return P2.QuadDestinationPatchSparqlUpdate = t, P2;
}
var BQ;
function X1e() {
  if (BQ) return F2;
  BQ = 1, Object.defineProperty(F2, "__esModule", { value: !0 }), F2.ActorRdfUpdateHypermediaPatchSparqlUpdate = void 0;
  const u = /* @__PURE__ */ k8(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ dZ();
  let a = class extends u.ActorRdfUpdateHypermedia {
    constructor(e) {
      super(e, "patchSparqlUpdate");
    }
    async testMetadata(e) {
      return !e.forceDestinationType && !e.metadata.patchSparqlUpdate ? (0, r.failTest)(`Actor ${this.name} could not detect a destination with 'application/sparql-update' as 'Accept-Patch' header.`) : !e.forceDestinationType && !e.exists ? (0, r.failTest)(`Actor ${this.name} can only patch a destination that already exists.`) : (0, r.passTestVoid)();
    }
    async run(e) {
      return this.logInfo(e.context, `Identified as patchSparqlUpdate destination: ${e.url}`), {
        destination: new o.QuadDestinationPatchSparqlUpdate(e.url, e.context, this.mediatorHttp)
      };
    }
  };
  return F2.ActorRdfUpdateHypermediaPatchSparqlUpdate = a, F2;
}
var $Q;
function J1e() {
  return $Q || ($Q = 1, function(u) {
    var r = Jd && Jd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Jd && Jd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ X1e(), u), o(/* @__PURE__ */ dZ(), u);
  }(Jd)), Jd;
}
var Wd = {}, D2 = {}, L2 = {}, UQ;
function lZ() {
  if (UQ) return L2;
  UQ = 1, Object.defineProperty(L2, "__esModule", { value: !0 }), L2.QuadDestinationPutLdp = void 0;
  const u = /* @__PURE__ */ Aa();
  let r = class {
    constructor(a, t, e, n, i, c) {
      this.url = a, this.context = t, this.mediaTypes = e, this.mediatorHttp = n, this.mediatorRdfSerializeMediatypes = i, this.mediatorRdfSerialize = c;
    }
    async update(a) {
      if (a.delete)
        throw new Error("Put-based LDP destinations don't support deletions");
      a.insert && await this.wrapRdfUpdateRequest("INSERT", a.insert);
    }
    async wrapRdfUpdateRequest(a, t) {
      const { mediaTypes: e } = await this.mediatorRdfSerializeMediatypes.mediate({ context: this.context, mediaTypes: !0 }), n = this.mediaTypes.filter((l) => l in e), i = n.length > 0 ? n[0] : Object.keys(e).sort((l, f) => e[f] - e[l])[0], { handle: { data: c } } = await this.mediatorRdfSerialize.mediate({
        context: this.context,
        handle: { quadStream: t, context: this.context },
        handleMediaType: i
      }), s = new Headers({ "content-type": i }), d = await this.mediatorHttp.mediate({
        context: this.context,
        init: {
          headers: s,
          method: "PUT",
          body: u.ActorHttp.toWebReadableStream(c)
        },
        input: this.url
      });
      await (0, u.validateAndCloseHttpResponse)(this.url, d);
    }
    async deleteGraphs(a, t, e) {
      throw new Error("Put-based LDP destinations don't support named graphs");
    }
    async createGraphs(a, t) {
      throw new Error("Put-based LDP destinations don't support named graphs");
    }
  };
  return L2.QuadDestinationPutLdp = r, L2;
}
var VQ;
function K1e() {
  if (VQ) return D2;
  VQ = 1, Object.defineProperty(D2, "__esModule", { value: !0 }), D2.ActorRdfUpdateHypermediaPutLdp = void 0;
  const u = /* @__PURE__ */ k8(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ lZ();
  let a = class extends u.ActorRdfUpdateHypermedia {
    constructor(e) {
      super(e, "putLdp");
    }
    async testMetadata(e) {
      if (!e.forceDestinationType) {
        if (!e.metadata.allowHttpMethods || !e.metadata.allowHttpMethods.includes("PUT"))
          return (0, r.failTest)(`Actor ${this.name} could not detect a destination with 'Allow: PUT' header.`);
        if (e.exists)
          return (0, r.failTest)(`Actor ${this.name} can only put on a destination that does not already exists.`);
      }
      return (0, r.passTestVoid)();
    }
    async run(e) {
      return this.logInfo(e.context, `Identified as putLdp destination: ${e.url}`), {
        destination: new o.QuadDestinationPutLdp(e.url, e.context, e.metadata.putAccepted || [], this.mediatorHttp, this.mediatorRdfSerializeMediatypes, this.mediatorRdfSerialize)
      };
    }
  };
  return D2.ActorRdfUpdateHypermediaPutLdp = a, D2;
}
var QQ;
function W1e() {
  return QQ || (QQ = 1, function(u) {
    var r = Wd && Wd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Wd && Wd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ K1e(), u), o(/* @__PURE__ */ lZ(), u);
  }(Wd)), Wd;
}
var Yd = {}, j2 = {}, M2 = {}, Zd = {}, el = {}, tl = {}, C2 = {}, HQ;
function Y1e() {
  if (HQ) return C2;
  HQ = 1, Object.defineProperty(C2, "__esModule", { value: !0 }), C2.SparqlXmlParser = void 0;
  const u = Or(), r = aY(), o = Bt();
  let a = class {
    constructor(e) {
      e = e || {}, this.dataFactory = e.dataFactory || new u.DataFactory(), this.prefixVariableQuestionMark = !!e.prefixVariableQuestionMark;
    }
    /**
     * Convert a SPARQL XML bindings response stream to a stream of bindings objects.
     *
     * The bindings stream will emit a 'variables' event that will contain
     * the array of variables (as RDF.Variable[]), as defined in the response head.
     *
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.
     * @return {NodeJS.ReadableStream} A stream of bindings.
     */
    parseXmlResultsStream(e) {
      const n = (g) => m.emit("error", g);
      e.on("error", n);
      const i = new r.SaxesParser(), c = [];
      let s = !1, d = !1;
      const l = [];
      let f = {}, h = "", p = "", b, _ = "", y = [];
      i.on("error", n), i.on("opentag", (g) => {
        g.name === "variable" && this.stackEquals(c, ["sparql", "head"]) ? l.push(this.dataFactory.variable(g.attributes.name)) : g.name === "results" && this.stackEquals(c, ["sparql"]) ? d = !0 : g.name === "result" && this.stackEquals(c, ["sparql", "results"]) ? f = {} : g.name === "binding" && this.stackEquals(c, ["sparql", "results", "result"]) ? (h = g.attributes.name || "", p = "", b = "", _ = "", y = []) : g.name === "triple" && this.stackBeginsWith(c, ["sparql", "results", "result"]) ? y.push({ components: {} }) : c[c.length - 1] === "triple" && this.stackBeginsWith(c, ["sparql", "results", "result", "binding"]) ? (p = "", b = "", _ = "", ["subject", "predicate", "object"].includes(g.name) ? y[y.length - 1].currentComponent = g.name : n(new Error(`Illegal quoted triple component '${g.name}' found on line ${i.line + 1}`))) : this.stackBeginsWith(c, ["sparql", "results", "result", "binding"]) && (p = g.name, "xml:lang" in g.attributes ? b = g.attributes["xml:lang"] : "datatype" in g.attributes ? b = this.dataFactory.namedNode(g.attributes.datatype) : b = void 0), c.push(g.name);
      }), i.on("closetag", (g) => {
        if (this.stackEquals(c, ["sparql", "head"]) && (m.emit("variables", l), s = !0), this.stackEquals(c, ["sparql", "results", "result"]) && m.push(f), this.stackBeginsWith(c, ["sparql", "results", "result", "binding"])) {
          let T;
          if (!h && p)
            n(new Error(`Terms should have a name on line ${i.line + 1}`));
          else if (p === "uri")
            T = this.dataFactory.namedNode(_);
          else if (p === "bnode")
            T = this.dataFactory.blankNode(_);
          else if (p === "literal")
            T = this.dataFactory.literal(_, b);
          else if (c[c.length - 1] === "triple") {
            const v = y.pop();
            v && v.components.subject && v.components.predicate && v.components.object ? T = this.dataFactory.quad(v.components.subject, v.components.predicate, v.components.object) : n(new Error(`Incomplete quoted triple on line ${i.line + 1}`));
          } else p && n(new Error(`Invalid term type '${p}' on line ${i.line + 1}`));
          if (T)
            if (y.length > 0) {
              const v = y[y.length - 1];
              v.components[v.currentComponent] && n(new Error(`The ${v.currentComponent} in a quoted triple on line ${i.line + 1} was already defined before`)), v.components[v.currentComponent] = T;
            } else {
              const v = this.prefixVariableQuestionMark ? "?" + h : h;
              f[v] = T;
            }
          p = void 0;
        }
        c.pop();
      }), i.on("text", (g) => {
        this.stackBeginsWith(c, ["sparql", "results", "result", "binding"]) && c[c.length - 1] === p && (_ = g);
      });
      const m = e.on("end", (g) => {
        d ? s || m.emit("variables", []) : m.emit("error", new Error("No valid SPARQL query results were found."));
      }).pipe(new o.Transform({
        objectMode: !0,
        transform(g, T, v) {
          i.write(g), v();
        }
      }));
      return m;
    }
    /**
     * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.
     * This will reject if the given response was not a valid boolean response.
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.
     * @return {Promise<boolean>} The response boolean.
     */
    parseXmlBooleanStream(e) {
      return new Promise((n, i) => {
        const c = new r.SaxesParser(), s = [];
        c.on("error", i), c.on("opentag", (d) => {
          s.push(d.name);
        }), c.on("closetag", (d) => {
          s.pop();
        }), c.on("text", (d) => {
          this.stackEquals(s, ["sparql", "boolean"]) && n(d === "true");
        }), e.on("error", i).on("data", (d) => c.write(d)).on("end", () => i(new Error("No valid ASK response was found.")));
      });
    }
    stackEquals(e, n) {
      return e.length === n.length && e.every((i, c) => n[c] === i);
    }
    stackBeginsWith(e, n) {
      return e.length >= n.length && n.every((i, c) => e[c] === i);
    }
  };
  return C2.SparqlXmlParser = a, C2;
}
var GQ;
function Z1e() {
  return GQ || (GQ = 1, function(u) {
    var r = tl && tl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = tl && tl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Y1e(), u);
  }(tl)), tl;
}
var vO = { exports: {} }, zQ;
function ebe() {
  return zQ || (zQ = 1, function(u) {
    (function() {
      var r;
      typeof window == "object" && window ? r = window : r = zf, u.exports ? u.exports = r.Promise ? r.Promise : e : r.Promise || (r.Promise = e);
      var o = r.setImmediate || function(f) {
        setTimeout(f, 1);
      };
      function a(f, h) {
        return function() {
          f.apply(h, arguments);
        };
      }
      var t = Array.isArray || function(f) {
        return Object.prototype.toString.call(f) === "[object Array]";
      };
      function e(f) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        if (typeof f != "function") throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], l(f, a(i, this), a(c, this));
      }
      function n(f) {
        var h = this;
        if (this._state === null) {
          this._deferreds.push(f);
          return;
        }
        o(function() {
          var p = h._state ? f.onFulfilled : f.onRejected;
          if (p === null) {
            (h._state ? f.resolve : f.reject)(h._value);
            return;
          }
          var b;
          try {
            b = p(h._value);
          } catch (_) {
            f.reject(_);
            return;
          }
          f.resolve(b);
        });
      }
      function i(f) {
        try {
          if (f === this) throw new TypeError("A promise cannot be resolved with itself.");
          if (f && (typeof f == "object" || typeof f == "function")) {
            var h = f.then;
            if (typeof h == "function") {
              l(a(h, f), a(i, this), a(c, this));
              return;
            }
          }
          this._state = !0, this._value = f, s.call(this);
        } catch (p) {
          c.call(this, p);
        }
      }
      function c(f) {
        this._state = !1, this._value = f, s.call(this);
      }
      function s() {
        for (var f = 0, h = this._deferreds.length; f < h; f++)
          n.call(this, this._deferreds[f]);
        this._deferreds = null;
      }
      function d(f, h, p, b) {
        this.onFulfilled = typeof f == "function" ? f : null, this.onRejected = typeof h == "function" ? h : null, this.resolve = p, this.reject = b;
      }
      function l(f, h, p) {
        var b = !1;
        try {
          f(function(_) {
            b || (b = !0, h(_));
          }, function(_) {
            b || (b = !0, p(_));
          });
        } catch (_) {
          if (b) return;
          b = !0, p(_);
        }
      }
      e.prototype.catch = function(f) {
        return this.then(null, f);
      }, e.prototype.then = function(f, h) {
        var p = this;
        return new e(function(b, _) {
          n.call(p, new d(f, h, b, _));
        });
      }, e.all = function() {
        var f = Array.prototype.slice.call(arguments.length === 1 && t(arguments[0]) ? arguments[0] : arguments);
        return new e(function(h, p) {
          if (f.length === 0) return h([]);
          var b = f.length;
          function _(m, g) {
            try {
              if (g && (typeof g == "object" || typeof g == "function")) {
                var T = g.then;
                if (typeof T == "function") {
                  T.call(g, function(v) {
                    _(m, v);
                  }, p);
                  return;
                }
              }
              f[m] = g, --b === 0 && h(f);
            } catch (v) {
              p(v);
            }
          }
          for (var y = 0; y < f.length; y++)
            _(y, f[y]);
        });
      }, e.resolve = function(f) {
        return f && typeof f == "object" && f.constructor === e ? f : new e(function(h) {
          h(f);
        });
      }, e.reject = function(f) {
        return new e(function(h, p) {
          p(f);
        });
      }, e.race = function(f) {
        return new e(function(h, p) {
          for (var b = 0, _ = f.length; b < _; b++)
            f[b].then(h, p);
        });
      };
    })();
  }(vO)), vO.exports;
}
var TO, kQ;
function tbe() {
  if (kQ) return TO;
  kQ = 1;
  var u = ebe();
  return TO = function(r, o, a) {
    typeof o == "function" && (a = o, o = null);
    var t = "", e = new u(function(n, i) {
      r.on("data", function(c) {
        t += typeof o == "string" ? c.toString(o) : c.toString();
      }), r.on("end", function() {
        n(t);
      }), r.on("error", i);
    });
    return a && e.then(function(n) {
      a(null, n);
    }, a), e;
  }, TO;
}
var XQ;
function rbe() {
  if (XQ) return el;
  XQ = 1;
  var u = el && el.__awaiter || function(s, d, l, f) {
    function h(p) {
      return p instanceof l ? p : new l(function(b) {
        b(p);
      });
    }
    return new (l || (l = Promise))(function(p, b) {
      function _(g) {
        try {
          m(f.next(g));
        } catch (T) {
          b(T);
        }
      }
      function y(g) {
        try {
          m(f.throw(g));
        } catch (T) {
          b(T);
        }
      }
      function m(g) {
        g.done ? p(g.value) : h(g.value).then(_, y);
      }
      m((f = f.apply(s, d || [])).next());
    });
  };
  Object.defineProperty(el, "__esModule", { value: !0 }), el.SparqlEndpointFetcher = void 0;
  const r = CY(), o = iu, a = MY(), t = _w(), e = /* @__PURE__ */ qW(), n = /* @__PURE__ */ Z1e(), i = tbe();
  let c = class D0 {
    constructor(d) {
      var l, f, h;
      this.method = (l = d == null ? void 0 : d.method) !== null && l !== void 0 ? l : "POST", this.timeout = d == null ? void 0 : d.timeout, this.additionalUrlParams = (f = d == null ? void 0 : d.additionalUrlParams) !== null && f !== void 0 ? f : new URLSearchParams(), this.defaultHeaders = (h = d == null ? void 0 : d.defaultHeaders) !== null && h !== void 0 ? h : new Headers(), this.fetchCb = d == null ? void 0 : d.fetch, this.sparqlJsonParser = new e.SparqlJsonParser(d), this.sparqlXmlParser = new n.SparqlXmlParser(d), this.sparqlParsers = {
        [D0.CONTENTTYPE_SPARQL_JSON]: {
          parseBooleanStream: (p) => this.sparqlJsonParser.parseJsonBooleanStream(p),
          parseResultsStream: (p) => this.sparqlJsonParser.parseJsonResultsStream(p)
        },
        [D0.CONTENTTYPE_SPARQL_XML]: {
          parseBooleanStream: (p) => this.sparqlXmlParser.parseXmlBooleanStream(p),
          parseResultsStream: (p) => this.sparqlXmlParser.parseXmlResultsStream(p)
        }
      };
    }
    /**
     * Get the query type of the given query.
     *
     * This will parse the query and thrown an exception on syntax errors.
     *
     * @param {string} query A query.
     * @return {'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN'} The query type.
     */
    getQueryType(d) {
      const l = new t.Parser({ sparqlStar: !0 }).parse(d);
      return l.type === "query" ? l.queryType === "DESCRIBE" ? "CONSTRUCT" : l.queryType : "UNKNOWN";
    }
    /**
     * Get the query type of the given update query.
     *
     * This will parse the update query and thrown an exception on syntax errors.
     *
     * @param {string} query An update query.
     * @return {'UNKNOWN' | UpdateTypes} The included update operations.
     */
    getUpdateTypes(d) {
      const l = new t.Parser({ sparqlStar: !0 }).parse(d);
      if (l.type === "update") {
        const f = {};
        for (const h of l.updates)
          "type" in h ? f[h.type] = !0 : f[h.updateType] = !0;
        return f;
      }
      return "UNKNOWN";
    }
    /**
     * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.
     * @see IBindings
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.
     */
    fetchBindings(d, l) {
      return u(this, void 0, void 0, function* () {
        const [f, h] = yield this.fetchRawStream(d, l, D0.CONTENTTYPE_SPARQL), p = this.sparqlParsers[f];
        if (!p)
          throw new Error(`Unknown SPARQL results content type: ${f}`);
        return p.parseResultsStream(h);
      });
    }
    /**
     * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<boolean>} A boolean resolving to the answer.
     */
    fetchAsk(d, l) {
      return u(this, void 0, void 0, function* () {
        const [f, h] = yield this.fetchRawStream(d, l, D0.CONTENTTYPE_SPARQL), p = this.sparqlParsers[f];
        if (!p)
          throw new Error(`Unknown SPARQL results content type: ${f}`);
        return p.parseBooleanStream(h);
      });
    }
    /**
     * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<Stream>} A stream of triples.
     */
    fetchTriples(d, l) {
      return u(this, void 0, void 0, function* () {
        const [f, h] = yield this.fetchRawStream(d, l, D0.CONTENTTYPE_TURTLE);
        return h.pipe(new o.StreamParser({ format: f }));
      });
    }
    /**
     * Send an update query to the given endpoint URL using POST.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     */
    fetchUpdate(d, l) {
      return u(this, void 0, void 0, function* () {
        const f = new AbortController(), h = {};
        this.defaultHeaders.forEach((b, _) => {
          h[_] = b;
        });
        const p = {
          method: "POST",
          headers: Object.assign(Object.assign({}, h), { "content-type": "application/sparql-update" }),
          body: l,
          signal: f.signal
        };
        yield this.handleFetchCall(d, p, { ignoreBody: !0 }), f.abort();
      });
    }
    /**
     * Send a query to the given endpoint URL and return the resulting stream.
     *
     * This will only accept responses with the application/sparql-results+json content type.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     * @param {string} acceptHeader The HTTP accept to use.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.
     */
    fetchRawStream(d, l, f) {
      return u(this, void 0, void 0, function* () {
        let h = this.method === "POST" ? d : `${d}?query=${encodeURIComponent(l)}`, p;
        const b = new Headers(this.defaultHeaders);
        if (b.append("Accept", f), this.method === "POST") {
          b.append("Content-Type", "application/x-www-form-urlencoded"), p = new URLSearchParams(), p.set("query", l);
          for (const [_, y] of this.additionalUrlParams.entries())
            p.set(_, y);
          b.append("Content-Length", p.toString().length.toString());
        } else this.additionalUrlParams.toString().length > 0 && (h += `&${this.additionalUrlParams.toString()}`);
        return this.handleFetchCall(h, { headers: b, method: this.method, body: p });
      });
    }
    /**
     * Helper function to generalize internal fetch calls.
     *
     * @param {string}      url     The URL to call.
     * @param {RequestInit} init    Options to pass along to the fetch call.
     * @param {any}         options Other specific fetch options.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.
     */
    handleFetchCall(d, l, f) {
      return u(this, void 0, void 0, function* () {
        var h, p, b;
        let _, y;
        if (this.timeout) {
          const T = new AbortController();
          l.signal = T.signal, _ = setTimeout(() => T.abort(), this.timeout);
        }
        const m = yield ((h = this.fetchCb) !== null && h !== void 0 ? h : fetch)(d, l);
        if (clearTimeout(_), !(f != null && f.ignoreBody) && m.body && (y = r(m.body) ? m.body : (0, a.readableFromWeb)(m.body)), !m.ok || !y && !(f != null && f.ignoreBody)) {
          const T = d.split("?").at(0), v = y ? yield i(y) : "empty response";
          throw new Error(`Invalid SPARQL endpoint response from ${T} (HTTP status ${m.status}):
${v}`);
        }
        return [(b = (p = m.headers.get("Content-Type")) === null || p === void 0 ? void 0 : p.split(";").at(0)) !== null && b !== void 0 ? b : "", y];
      });
    }
  };
  return el.SparqlEndpointFetcher = c, c.CONTENTTYPE_SPARQL_JSON = "application/sparql-results+json", c.CONTENTTYPE_SPARQL_XML = "application/sparql-results+xml", c.CONTENTTYPE_TURTLE = "text/turtle", c.CONTENTTYPE_SPARQL = `${c.CONTENTTYPE_SPARQL_JSON};q=1.0,${c.CONTENTTYPE_SPARQL_XML};q=0.7`, el;
}
var JQ;
function fZ() {
  return JQ || (JQ = 1, function(u) {
    var r = Zd && Zd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zd && Zd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rbe(), u);
  }(Zd)), Zd;
}
var KQ;
function hZ() {
  if (KQ) return M2;
  KQ = 1, Object.defineProperty(M2, "__esModule", { value: !0 }), M2.QuadDestinationSparql = void 0;
  const u = gh(), r = /* @__PURE__ */ yt(), o = /* @__PURE__ */ fZ(), a = Ow();
  let t = class {
    constructor(n, i, c, s) {
      this.url = n, this.context = i, this.mediatorHttp = c, this.endpointFetcher = new o.SparqlEndpointFetcher({
        fetch: (d, l) => this.mediatorHttp.mediate({ input: d, init: l, context: this.context }),
        prefixVariableQuestionMark: !0,
        dataFactory: s
      });
    }
    async update(n) {
      const i = this.createCombinedQuadsQuery(n.insert, n.delete);
      await this.wrapSparqlUpdateRequest(i);
    }
    createCombinedQuadsQuery(n, i) {
      return new r.ArrayIterator([], { autoStart: !1 }).append(this.createQuadsQuery("DELETE", i)).append(i && n ? [` ;
`] : []).append(this.createQuadsQuery("INSERT", n));
    }
    createQuadsQuery(n, i) {
      return i ? i.map((c) => {
        let s = `${(0, a.termToString)(c.subject)} ${(0, a.termToString)(c.predicate)} ${(0, a.termToString)(c.object)} .`;
        return c.graph.termType === "DefaultGraph" ? s = `  ${s}
` : s = `  GRAPH ${(0, a.termToString)(c.graph)} { ${s} }
`, s;
      }).prepend([`${n} DATA {
`]).append(["}"]) : new r.ArrayIterator([], { autoStart: !1 });
    }
    async wrapSparqlUpdateRequest(n) {
      const i = await (0, u.stringify)(n);
      await this.endpointFetcher.fetchUpdate(this.url, i);
    }
    async deleteGraphs(n, i, c) {
      const s = Array.isArray(n) ? n : [n], d = [];
      for (const l of s) {
        let f;
        typeof l == "string" ? f = l : l.termType === "DefaultGraph" ? f = "DEFAULT" : f = `GRAPH <${l.value}>`, d.push(`${c ? "DROP" : "CLEAR"} ${i ? "" : "SILENT "}${f}`);
      }
      await this.endpointFetcher.fetchUpdate(this.url, d.join("; "));
    }
    async createGraphs(n, i) {
      const c = [];
      for (const s of n)
        c.push(`CREATE${i ? "" : " SILENT"} GRAPH <${s.value}>`);
      await this.endpointFetcher.fetchUpdate(this.url, c.join("; "));
    }
  };
  return M2.QuadDestinationSparql = t, M2;
}
var WQ;
function nbe() {
  if (WQ) return j2;
  WQ = 1, Object.defineProperty(j2, "__esModule", { value: !0 }), j2.ActorRdfUpdateHypermediaSparql = void 0;
  const u = /* @__PURE__ */ k8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ hZ();
  let t = class extends u.ActorRdfUpdateHypermedia {
    constructor(n) {
      super(n, "sparql");
    }
    async testMetadata(n) {
      return !n.forceDestinationType && !n.metadata.sparqlService && !(this.checkUrlSuffixSparql && (n.url.endsWith("/sparql") || n.url.endsWith("/sparql/"))) && !(this.checkUrlSuffixUpdate && (n.url.endsWith("/update") || n.url.endsWith("/update/"))) ? (0, o.failTest)(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql or /update.`) : (0, o.passTestVoid)();
    }
    async run(n) {
      this.logInfo(n.context, `Identified as sparql destination: ${n.url}`);
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory);
      return {
        destination: new a.QuadDestinationSparql(n.metadata.sparqlService || n.url, n.context, this.mediatorHttp, i)
      };
    }
  };
  return j2.ActorRdfUpdateHypermediaSparql = t, j2;
}
var YQ;
function ibe() {
  return YQ || (YQ = 1, function(u) {
    var r = Yd && Yd.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Yd && Yd.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ nbe(), u), o(/* @__PURE__ */ hZ(), u);
  }(Yd)), Yd;
}
var rl = {}, q2 = {}, ZQ;
function abe() {
  if (ZQ) return q2;
  ZQ = 1, Object.defineProperty(q2, "__esModule", { value: !0 }), q2.ActorQueryOperationAsk = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ vt();
  let a = class extends u.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "ask");
    }
    async testOperation(e, n) {
      return (0, r.passTestVoid)();
    }
    async runOperation(e, n) {
      const i = await this.mediatorQueryOperation.mediate({ operation: e.input, context: n }), { bindingsStream: c } = (0, o.getSafeBindings)(i);
      return { type: "boolean", execute: async () => (await c.take(1).toArray()).length === 1 };
    }
  };
  return q2.ActorQueryOperationAsk = a, q2;
}
var eH;
function ube() {
  return eH || (eH = 1, function(u) {
    var r = rl && rl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = rl && rl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ abe(), u);
  }(rl)), rl;
}
var nl = {}, B2 = {}, tH;
function obe() {
  if (tH) return B2;
  tH = 1, Object.defineProperty(B2, "__esModule", { value: !0 }), B2.ActorQueryOperationBgpJoin = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorQueryOperationTypedMediated {
    constructor(n) {
      super(n, "bgp");
    }
    async testOperation(n, i) {
      return (0, o.passTestVoid)();
    }
    async runOperation(n, i) {
      const c = i.getSafe(r.KeysInitQuery.dataFactory), s = new a.Factory(c);
      return this.mediatorQueryOperation.mediate({
        operation: s.createJoin(n.patterns),
        context: i
      });
    }
  };
  return B2.ActorQueryOperationBgpJoin = t, B2;
}
var rH;
function sbe() {
  return rH || (rH = 1, function(u) {
    var r = nl && nl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = nl && nl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ obe(), u);
  }(nl)), nl;
}
var il = {}, $2 = {}, U2 = {}, nH;
function pZ() {
  if (nH) return U2;
  nH = 1, Object.defineProperty(U2, "__esModule", { value: !0 }), U2.BindingsToQuadsIterator = void 0;
  const u = /* @__PURE__ */ yt(), r = zn();
  let o = class ST extends u.MultiTransformIterator {
    constructor(t, e, n) {
      super(n, { autoStart: !1 }), this.dataFactory = t, this.template = e, this.blankNodeCounter = 0;
    }
    /**
     * Bind the given term.
     * If the term is a variable and the variable is bound in the bindings object,
     * return the bindings value.
     * If the term is a variable and the variable is not bound in the bindings object,
     * a falsy value is returned..
     * Otherwise, the term itself is returned.
     * @param {Bindings}  bindings A bindings object.
     * @param {RDF.Term}  term     An RDF term.
     * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.
     *                             If the given term is a variable, then the bound term is returned,
     *                             or a falsy value if it did not exist in the bindings.
     */
    static bindTerm(t, e) {
      return e.termType === "Variable" ? t.get(e) : e;
    }
    /**
     * Bind the given quad pattern.
     * If one of the terms was a variable AND is not bound in the bindings,
     * a falsy value will be returned.
     * @param {Bindings} bindings A bindings object.
     * @param {RDF.Quad} pattern  An RDF quad.
     * @return {RDF.Quad}         A bound RDF quad or undefined.
     */
    static bindQuad(t, e) {
      try {
        return (0, r.mapTermsNested)(e, (n) => {
          const i = ST.bindTerm(t, n);
          if (!i)
            throw new Error("Unbound term");
          return i;
        });
      } catch {
      }
    }
    /**
     * Convert a blank node to a unique blank node in the given context.
     * If the given term is not a blank node, the term itself will be returned.
     * @param dataFactory The data factory.
     * @param             blankNodeCounter A counter value for the blank node.
     * @param {RDF.Term}  term             The term that should be localized.
     * @return {RDF.Term}                  A term.
     */
    static localizeBlankNode(t, e, n) {
      return n.termType === "BlankNode" ? t.blankNode(`${n.value}${e}`) : n;
    }
    /**
     * Convert the given quad to a quad that only contains unique blank nodes.
     * @param dataFactory The data factory.
     * @param            blankNodeCounter A counter value for the blank node.
     * @param {RDF.BaseQuad} pattern          The pattern that should be localized.
     * @return {RDF.BaseQuad}                 A quad.
     */
    static localizeQuad(t, e, n) {
      return (0, r.mapTermsNested)(n, (i) => ST.localizeBlankNode(t, e, i));
    }
    /**
     * Convert the given template to a list of quads based on the given bindings.
     * @param {Bindings}    bindings           A bindings object.
     * @param {RDF.Quad[]}  template           A list of quad patterns.
     * @param               blankNodeCounter   A counter value for the blank node.
     * @return {RDF.Quad[]}                    A list of quads.
     */
    bindTemplate(t, e, n) {
      return e.map(ST.localizeQuad.bind(null, this.dataFactory, n)).map((c) => ST.bindQuad.bind(null, t)(c)).filter(Boolean);
    }
    _createTransformer(t) {
      return new u.ArrayIterator(this.bindTemplate(t, this.template, this.blankNodeCounter++), { autoStart: !1 });
    }
  };
  return U2.BindingsToQuadsIterator = o, U2;
}
var iH;
function cbe() {
  if (iH) return $2;
  iH = 1, Object.defineProperty($2, "__esModule", { value: !0 }), $2.ActorQueryOperationConstruct = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = zn(), e = ft(), n = /* @__PURE__ */ pZ();
  let i = class bZ extends u.ActorQueryOperationTypedMediated {
    constructor(s) {
      super(s, "construct");
    }
    /**
     * Find all variables in a list of triple patterns.
     * @param {Algebra.Pattern[]} patterns An array of triple patterns.
     * @return {RDF.Variable[]} The variables in the triple patterns.
     */
    static getVariables(s) {
      return (0, t.uniqTerms)([].concat.apply([], s.map((d) => (0, t.getVariables)((0, t.getTermsNested)(d)))));
    }
    async testOperation(s, d) {
      return (0, o.passTestVoid)();
    }
    async runOperation(s, d) {
      const l = d.getSafe(r.KeysInitQuery.dataFactory), f = bZ.getVariables(s.template), h = { type: e.Algebra.types.PROJECT, input: s.input, variables: f }, p = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: h, context: d })), b = new n.BindingsToQuadsIterator(l, s.template, p.bindingsStream);
      return {
        metadata: () => p.metadata().then((y) => ({
          ...y,
          order: void 0,
          cardinality: {
            type: y.cardinality.type,
            value: y.cardinality.value * s.template.length
          },
          availableOrders: void 0
        })),
        quadStream: b,
        type: "quads"
      };
    }
  };
  return $2.ActorQueryOperationConstruct = i, $2;
}
var aH;
function yZ() {
  return aH || (aH = 1, function(u) {
    var r = il && il.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = il && il.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ cbe(), u), o(/* @__PURE__ */ pZ(), u);
  }(il)), il;
}
var al = {}, V2 = {}, wO = {}, di = {}, ul = {}, Q2 = {}, uH;
function _Z() {
  if (uH) return Q2;
  uH = 1, Object.defineProperty(Q2, "__esModule", { value: !0 }), Q2.BlankNode = void 0;
  class u {
    constructor(o) {
      this.termType = "BlankNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  }
  return Q2.BlankNode = u, Q2;
}
var H2 = {}, G2 = {}, oH;
function gZ() {
  if (oH) return G2;
  oH = 1, Object.defineProperty(G2, "__esModule", { value: !0 }), G2.DefaultGraph = void 0;
  class u {
    constructor() {
      this.termType = "DefaultGraph", this.value = "";
    }
    equals(o) {
      return !!o && o.termType === "DefaultGraph";
    }
  }
  return G2.DefaultGraph = u, u.INSTANCE = new u(), G2;
}
var z2 = {}, k2 = {}, sH;
function X8() {
  if (sH) return k2;
  sH = 1, Object.defineProperty(k2, "__esModule", { value: !0 }), k2.NamedNode = void 0;
  class u {
    constructor(o) {
      this.termType = "NamedNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "NamedNode" && o.value === this.value;
    }
  }
  return k2.NamedNode = u, k2;
}
var cH;
function mZ() {
  if (cH) return z2;
  cH = 1, Object.defineProperty(z2, "__esModule", { value: !0 }), z2.Literal = void 0;
  const u = X8();
  class r {
    constructor(a, t) {
      this.termType = "Literal", this.value = a, typeof t == "string" ? (this.language = t, this.datatype = r.RDF_LANGUAGE_STRING, this.direction = "") : t ? "termType" in t ? (this.language = "", this.datatype = t, this.direction = "") : (this.language = t.language, this.datatype = t.direction ? r.RDF_DIRECTIONAL_LANGUAGE_STRING : r.RDF_LANGUAGE_STRING, this.direction = t.direction || "") : (this.language = "", this.datatype = r.XSD_STRING, this.direction = "");
    }
    equals(a) {
      return !!a && a.termType === "Literal" && a.value === this.value && a.language === this.language && (a.direction === this.direction || !a.direction && this.direction === "") && this.datatype.equals(a.datatype);
    }
  }
  return z2.Literal = r, r.RDF_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), r.RDF_DIRECTIONAL_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString"), r.XSD_STRING = new u.NamedNode("http://www.w3.org/2001/XMLSchema#string"), z2;
}
var X2 = {}, dH;
function vZ() {
  if (dH) return X2;
  dH = 1, Object.defineProperty(X2, "__esModule", { value: !0 }), X2.Quad = void 0;
  class u {
    constructor(o, a, t, e) {
      this.termType = "Quad", this.value = "", this.subject = o, this.predicate = a, this.object = t, this.graph = e;
    }
    equals(o) {
      return !!o && (o.termType === "Quad" || !o.termType) && this.subject.equals(o.subject) && this.predicate.equals(o.predicate) && this.object.equals(o.object) && this.graph.equals(o.graph);
    }
  }
  return X2.Quad = u, X2;
}
var J2 = {}, lH;
function TZ() {
  if (lH) return J2;
  lH = 1, Object.defineProperty(J2, "__esModule", { value: !0 }), J2.Variable = void 0;
  class u {
    constructor(o) {
      this.termType = "Variable", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "Variable" && o.value === this.value;
    }
  }
  return J2.Variable = u, J2;
}
var fH;
function dbe() {
  if (fH) return H2;
  fH = 1, Object.defineProperty(H2, "__esModule", { value: !0 }), H2.DataFactory = void 0;
  const u = _Z(), r = gZ(), o = mZ(), a = X8(), t = vZ(), e = TZ();
  let n = 0;
  class i {
    constructor(s) {
      this.blankNodeCounter = 0, s = s || {}, this.blankNodePrefix = s.blankNodePrefix || `df_${n++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(s) {
      return new a.NamedNode(s);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(s) {
      return new u.BlankNode(s || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language, datatype, or directional language.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           If `languageOrDatatype` is a NamedNode, it is used for the value
     *                           of `NamedNode.language`.
     *                           Otherwise, it is used as a directional language,
     *                           from which the language is set to `languageOrDatatype.language`
     *                           and the direction to `languageOrDatatype.direction`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(s, d) {
      return new o.Literal(s, d);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(s) {
      return new e.Variable(s);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
      return r.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(s, d, l, f) {
      return new t.Quad(s, d, l, f || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(s) {
      switch (s.termType) {
        case "NamedNode":
          return this.namedNode(s.value);
        case "BlankNode":
          return this.blankNode(s.value);
        case "Literal":
          return s.language ? this.literal(s.value, s.language) : s.datatype.equals(o.Literal.XSD_STRING) ? this.literal(s.value) : this.literal(s.value, this.fromTerm(s.datatype));
        case "Variable":
          return this.variable(s.value);
        case "DefaultGraph":
          return this.defaultGraph();
        case "Quad":
          return this.quad(this.fromTerm(s.subject), this.fromTerm(s.predicate), this.fromTerm(s.object), this.fromTerm(s.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(s) {
      return this.fromTerm(s);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  }
  return H2.DataFactory = i, H2;
}
var hH;
function lbe() {
  return hH || (hH = 1, function(u) {
    var r = ul && ul.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ul && ul.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(_Z(), u), o(dbe(), u), o(gZ(), u), o(mZ(), u), o(X8(), u), o(vZ(), u), o(TZ(), u);
  }(ul)), ul;
}
var pH;
function fbe() {
  if (pH) return di;
  pH = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.termToString = o, di.getLiteralValue = a, di.getLiteralType = t, di.getLiteralLanguage = e, di.getLiteralDirection = n, di.stringToTerm = i, di.quadToStringQuad = c, di.stringQuadToQuad = s;
  const u = lbe(), r = new u.DataFactory();
  function o(d) {
    if (d)
      switch (d.termType) {
        case "NamedNode":
          return d.value;
        case "BlankNode":
          return "_:" + d.value;
        case "Literal":
          const l = d;
          return '"' + l.value + '"' + (l.datatype && l.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString" ? "^^" + l.datatype.value : "") + (l.language ? "@" + l.language : "") + (l.direction ? "--" + l.direction : "");
        case "Quad":
          return `<<${o(d.subject)} ${o(d.predicate)} ${o(d.object)}${d.graph.termType === "DefaultGraph" ? "" : " " + o(d.graph)}>>`;
        case "Variable":
          return "?" + d.value;
        case "DefaultGraph":
          return d.value;
      }
  }
  function a(d) {
    const l = /^"([^]*)"/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1];
  }
  function t(d) {
    const l = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1] || (l[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string");
  }
  function e(d) {
    const l = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    if (l[1]) {
      let f = l[1].toLowerCase();
      const h = f.indexOf("--");
      return h >= 0 && (f = f.slice(0, h)), f;
    }
    return "";
  }
  function n(d) {
    const l = d.indexOf("--", d.lastIndexOf('"'));
    if (l >= 0) {
      const f = d.slice(l + 2, d.length);
      if (f === "ltr" || f === "rtl")
        return f;
      throw new Error(d + " is not a literal with a valid direction");
    }
    return "";
  }
  function i(d, l) {
    if (l = l || r, !d || !d.length)
      return l.defaultGraph();
    switch (d[0]) {
      case "_":
        return l.blankNode(d.substr(2));
      case "?":
        if (!l.variable)
          throw new Error("Missing 'variable()' method on the given DataFactory");
        return l.variable(d.substr(1));
      case '"':
        const f = e(d), h = n(d), p = l.namedNode(t(d));
        return l.literal(a(d), f ? { language: f, direction: h } : p);
      case "<":
      default:
        if (d[0] === "<" && d.length > 4 && d[1] === "<" && d[d.length - 1] === ">" && d[d.length - 2] === ">") {
          const b = d.slice(2, -2).trim();
          let _ = [], y = 0, m = 0, g = !1;
          for (let T = 0; T < b.length; T++) {
            const v = b[T];
            if (v === "<" && y++, v === ">") {
              if (y === 0)
                throw new Error("Found closing tag without opening tag in " + d);
              y--;
            }
            if (v === '"') {
              let E = !1, R = T;
              for (; R-- > 0 && b[R] === "\\"; )
                E = !E;
              E || (g = !g);
            }
            if (v === " " && !g && y === 0) {
              for (_.push(b.slice(m, T)); b[T + 1] === " "; )
                T += 1;
              m = T + 1;
            }
          }
          if (y !== 0)
            throw new Error("Found opening tag without closing tag in " + d);
          if (_.push(b.slice(m, b.length)), _.length !== 3 && _.length !== 4)
            throw new Error("Nested quad syntax error " + d);
          return _ = _.map((T) => T.startsWith("<") && !T.includes(" ") ? T.slice(1, -1) : T), l.quad(i(_[0]), i(_[1]), i(_[2]), _[3] ? i(_[3]) : void 0);
        }
        return l.namedNode(d);
    }
  }
  function c(d) {
    return {
      subject: o(d.subject),
      predicate: o(d.predicate),
      object: o(d.object),
      graph: o(d.graph)
    };
  }
  function s(d, l) {
    return l = l || r, l.quad(i(d.subject, l), i(d.predicate, l), i(d.object, l), i(d.graph, l));
  }
  return di;
}
var bH;
function hbe() {
  return bH || (bH = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.termToString = u.stringToTerm = u.stringQuadToQuad = u.quadToStringQuad = u.getLiteralValue = u.getLiteralType = u.getLiteralDirection = u.getLiteralLanguage = void 0;
    const r = fbe();
    Object.defineProperty(u, "getLiteralLanguage", { enumerable: !0, get: function() {
      return r.getLiteralLanguage;
    } }), Object.defineProperty(u, "getLiteralDirection", { enumerable: !0, get: function() {
      return r.getLiteralDirection;
    } }), Object.defineProperty(u, "getLiteralType", { enumerable: !0, get: function() {
      return r.getLiteralType;
    } }), Object.defineProperty(u, "getLiteralValue", { enumerable: !0, get: function() {
      return r.getLiteralValue;
    } }), Object.defineProperty(u, "quadToStringQuad", { enumerable: !0, get: function() {
      return r.quadToStringQuad;
    } }), Object.defineProperty(u, "stringQuadToQuad", { enumerable: !0, get: function() {
      return r.stringQuadToQuad;
    } }), Object.defineProperty(u, "stringToTerm", { enumerable: !0, get: function() {
      return r.stringToTerm;
    } }), Object.defineProperty(u, "termToString", { enumerable: !0, get: function() {
      return r.termToString;
    } });
  }(wO)), wO;
}
var yH;
function pbe() {
  if (yH) return V2;
  yH = 1, Object.defineProperty(V2, "__esModule", { value: !0 }), V2.ActorQueryOperationDistinctIdentity = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ vt(), a = hbe();
  let t = class extends u.ActorQueryOperationTypedMediated {
    constructor(n) {
      super(n, "distinct");
    }
    async testOperation(n, i) {
      return (0, r.passTestVoid)();
    }
    async runOperation(n, i) {
      const c = await this.mediatorQueryOperation.mediate({ operation: n.input, context: i });
      if (c.type === "quads") {
        const f = (0, o.getSafeQuads)(c);
        return {
          type: "quads",
          quadStream: f.quadStream.filter(await this.newIdentityFilterQuads()),
          metadata: f.metadata
        };
      }
      const s = (0, o.getSafeBindings)(c), d = (await s.metadata()).variables.map((f) => f.variable);
      return {
        type: "bindings",
        bindingsStream: s.bindingsStream.filter(await this.newIdentityFilter(d)),
        metadata: s.metadata
      };
    }
    /**
     * Create a new distinct filter function.
     * This will maintain an internal Identity datastructure so that every bindings object only returns true once.
     * @param variables The variables to take into account while hashing.
     * @return {(bindings: Bindings) => boolean} A distinct filter for bindings.
     */
    async newIdentityFilter(n) {
      const i = {};
      return (c) => {
        const s = n.map((d) => a.termToString(c.get(d))).join("-");
        return !(s in i) && (i[s] = !0);
      };
    }
    /**
     * Create a new distinct filter function to Identity quads.
     * This will maintain an internal Identity datastructure so that every quad object only returns true once.
     * @return {(quad: RDF.Quad) => boolean} A distinct filter for quads.
     */
    async newIdentityFilterQuads() {
      const n = {};
      return (i) => {
        const c = Object.values(a.quadToStringQuad(i)).join(" ");
        return !(c in n) && (n[c] = !0);
      };
    }
  };
  return V2.ActorQueryOperationDistinctIdentity = t, V2;
}
var _H;
function bbe() {
  return _H || (_H = 1, function(u) {
    var r = al && al.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = al && al.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ pbe(), u);
  }(al)), al;
}
var ol = {}, K2 = {}, gH;
function ybe() {
  if (gH) return K2;
  gH = 1, Object.defineProperty(K2, "__esModule", { value: !0 }), K2.ActorQueryOperationExtend = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ ve(), t = /* @__PURE__ */ vt();
  let e = class extends u.ActorQueryOperationTypedMediated {
    constructor(i) {
      super(i, "extend"), this.mediatorExpressionEvaluatorFactory = i.mediatorExpressionEvaluatorFactory;
    }
    async testOperation() {
      return (0, r.passTestVoid)();
    }
    async runOperation(i, c) {
      const { expression: s, input: d, variable: l } = i, f = (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: d, context: c }));
      if ((await f.metadata()).variables.some((_) => _.variable.equals(l)))
        throw new Error(`Illegal binding to variable '${l.value}' that has already been bound`);
      const h = await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: s, context: c }), p = async (_, y, m) => {
        try {
          const g = await h.evaluate(_), T = _.set(l, g);
          m(T);
        } catch (g) {
          (0, a.isExpressionError)(g) ? (m(_), this.logWarn(c, `Expression error for extend operation (${g.message})with bindings '${(0, o.bindingsToString)(_)}'`)) : b.emit("error", g);
        }
        y();
      }, b = f.bindingsStream.transform({ autoStart: !1, transform: p });
      return {
        type: "bindings",
        bindingsStream: b,
        async metadata() {
          const _ = await f.metadata();
          return { ..._, variables: [..._.variables, { variable: l, canBeUndef: !1 }] };
        }
      };
    }
  };
  return K2.ActorQueryOperationExtend = e, K2;
}
var mH;
function _be() {
  return mH || (mH = 1, function(u) {
    var r = ol && ol.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ol && ol.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ybe(), u);
  }(ol)), ol;
}
var sl = {}, W2 = {}, vH;
function gbe() {
  if (vH) return W2;
  vH = 1, Object.defineProperty(W2, "__esModule", { value: !0 }), W2.ActorQueryOperationFilter = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ ve(), t = /* @__PURE__ */ vt();
  let e = class extends u.ActorQueryOperationTypedMediated {
    constructor(i) {
      super(i, "filter"), this.mediatorExpressionEvaluatorFactory = i.mediatorExpressionEvaluatorFactory;
    }
    async testOperation() {
      return (0, r.passTestVoid)();
    }
    async runOperation(i, c) {
      const s = await this.mediatorQueryOperation.mediate({ operation: i.input, context: c }), d = (0, t.getSafeBindings)(s);
      (0, t.validateQueryOutput)(d, "bindings");
      const l = await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: i.expression, context: c }), f = async (p, b, _) => {
        try {
          await l.evaluateAsEBV(p) && _(p);
        } catch (y) {
          (0, a.isExpressionError)(y) ? this.logWarn(c, "Error occurred while filtering.", () => ({ error: y, bindings: (0, o.bindingsToString)(p) })) : h.emit("error", y);
        }
        b();
      }, h = d.bindingsStream.transform({ transform: f, autoStart: !1 });
      return { type: "bindings", bindingsStream: h, metadata: d.metadata };
    }
  };
  return W2.ActorQueryOperationFilter = e, W2;
}
var TH;
function mbe() {
  return TH || (TH = 1, function(u) {
    var r = sl && sl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = sl && sl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ gbe(), u);
  }(sl)), sl;
}
var cl = {}, Y2 = {}, wH;
function vbe() {
  if (wH) return Y2;
  wH = 1, Object.defineProperty(Y2, "__esModule", { value: !0 }), Y2.ActorQueryOperationFromQuad = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class Pn extends u.ActorQueryOperationTypedMediated {
    constructor(n) {
      super(n, "from");
    }
    /**
     * Create a deep copy of the given operation.
     * @param {Operation} operation An operation.
     * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.
     * @return {Operation} The copied operation.
     */
    static copyOperation(n, i) {
      const c = {};
      for (const s of Object.keys(n))
        Array.isArray(n[s]) && s !== "template" ? s === "variables" ? c[s] = n[s] : c[s] = n[s].map(i) : Pn.ALGEBRA_TYPES.includes(n[s].type) ? c[s] = i(n[s]) : c[s] = n[s];
      return c;
    }
    /**
     * Recursively transform the given operation to use the given graphs as default graph
     * This will (possibly) create a new operation and not modify the given operation.
     * @package
     * @param algebraFactory The algebra factory.
     * @param {Operation} operation An operation.
     * @param {RDF.Term[]} defaultGraphs Graph terms.
     * @return {Operation} A new operation.
     */
    static applyOperationDefaultGraph(n, i, c) {
      if (i.type === "bgp" && i.patterns.length > 0 || i.type === "path" || i.type === "pattern") {
        if (i.type === "bgp")
          return Pn.joinOperations(n, i.patterns.map((d) => {
            if (d.graph.termType !== "DefaultGraph")
              return n.createBgp([d]);
            const l = c.map((f) => n.createBgp([Object.assign(n.createPattern(d.subject, d.predicate, d.object, f), { metadata: d.metadata })]));
            return Pn.unionOperations(n, l);
          }));
        if (i.graph.termType !== "DefaultGraph")
          return i;
        const s = c.map((d) => i.type === "path" ? n.createPath(i.subject, i.predicate, i.object, d) : Object.assign(n.createPattern(i.subject, i.predicate, i.object, d), { metadata: i.metadata }));
        return Pn.unionOperations(n, s);
      }
      return Pn.copyOperation(i, (s) => this.applyOperationDefaultGraph(n, s, c));
    }
    /**
     * Recursively transform the given operation to use the given graphs as named graph
     * This will (possibly) create a new operation and not modify the given operation.
     * @package
     * @param algebraFactory The algebra factory.
     * @param {Operation} operation An operation.
     * @param {RDF.Term[]} namedGraphs Graph terms.
     * @param {RDF.Term[]} defaultGraphs Default graph terms.
     * @return {Operation} A new operation.
     */
    static applyOperationNamedGraph(n, i, c, s) {
      if (i.type === "bgp" && i.patterns.length > 0 || i.type === "path" || i.type === "pattern") {
        const d = i.type === "bgp" ? i.patterns[0].graph : i.graph;
        if (d.termType === "DefaultGraph")
          return { type: a.Algebra.types.BGP, patterns: [] };
        if (d.termType === "Variable") {
          if (c.length === 1) {
            const f = c[0], h = {};
            h[`?${d.value}`] = f;
            const p = n.createValues([d], [h]);
            let b;
            return i.type === "bgp" ? b = n.createBgp(i.patterns.map((_) => n.createPattern(_.subject, _.predicate, _.object, f))) : i.type === "path" ? b = n.createPath(i.subject, i.predicate, i.object, f) : b = n.createPattern(i.subject, i.predicate, i.object, f), n.createJoin([p, b]);
          }
          return Pn.unionOperations(n, c.map((f) => Pn.applyOperationNamedGraph(n, i, [f], s)));
        }
        return [...c, ...s].some((f) => f.equals(d)) ? i : { type: a.Algebra.types.BGP, patterns: [] };
      }
      return Pn.copyOperation(i, (d) => this.applyOperationNamedGraph(n, d, c, s));
    }
    /**
     * Transform the given array of operations into a join operation.
     * @package
     * @param algebraFactory The algebra factory.
     * @param {Operation[]} operations An array of operations, must contain at least one operation.
     * @return {Join} A join operation.
     */
    static joinOperations(n, i) {
      if (i.length === 1)
        return i[0];
      if (i.length > 1)
        return n.createJoin(i);
      throw new Error("A join can only be applied on at least one operation");
    }
    /**
     * Transform the given array of operations into a union operation.
     * @package
     * @param algebraFactory The algebra factory.
     * @param {Operation[]} operations An array of operations, must contain at least one operation.
     * @return {Union} A union operation.
     */
    static unionOperations(n, i) {
      if (i.length === 1)
        return i[0];
      if (i.length > 1)
        return n.createUnion(i);
      throw new Error("A union can only be applied on at least one operation");
    }
    /**
     * Transform an operation based on the default and named graphs in the pattern.
     *
     * FROM sets the default graph.
     * If multiple are available, take the union of the operation for all of them at quad-pattern level.
     *
     * FROM NAMED indicates which named graphs are available.
     * This will rewrite the query so that only triples from the given named graphs can be selected.
     *
     * @package
     * @param algebraFactory The algebra factory.
     * @param {From} pattern A from operation.
     * @return {Operation} The transformed operation.
     */
    static createOperation(n, i) {
      let c = i.input;
      return i.default.length > 0 && (c = Pn.applyOperationDefaultGraph(n, c, i.default)), (i.named.length > 0 || i.default.length > 0) && (c = Pn.applyOperationNamedGraph(n, c, i.named, i.default)), c;
    }
    async testOperation(n, i) {
      return (0, o.passTestVoid)();
    }
    async runOperation(n, i) {
      const c = i.getSafe(r.KeysInitQuery.dataFactory), s = new a.Factory(c), d = Pn.createOperation(s, n);
      return this.mediatorQueryOperation.mediate({ operation: d, context: i });
    }
  };
  return Y2.ActorQueryOperationFromQuad = t, t.ALGEBRA_TYPES = Object.keys(a.Algebra.types).map((e) => a.Algebra.types[e]), Y2;
}
var SH;
function Tbe() {
  return SH || (SH = 1, function(u) {
    var r = cl && cl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = cl && cl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ vbe(), u);
  }(cl)), cl;
}
var dl = {}, Z2 = {}, AH;
function wbe() {
  if (AH) return Z2;
  AH = 1, Object.defineProperty(Z2, "__esModule", { value: !0 }), Z2.ActorQueryOperationProject = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ g8(), t = /* @__PURE__ */ vt();
  let e = class extends u.ActorQueryOperationTypedMediated {
    constructor(i) {
      super(i, "project");
    }
    async testOperation(i, c) {
      return (0, o.passTestVoid)();
    }
    async runOperation(i, c) {
      const s = c.getSafe(r.KeysInitQuery.dataFactory), d = (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: i.input, context: c })), l = await d.metadata(), f = Object.fromEntries(l.variables.map((g) => [g.variable.value, g])), h = i.variables.map((g) => ({ variable: g, canBeUndef: !1 })), p = Object.fromEntries(h.map((g) => [g.variable.value, g])), b = l.variables.filter((g) => !(g.variable.value in p)), _ = h.map((g) => ({
        variable: g.variable,
        canBeUndef: !(g.variable.value in f) || f[g.variable.value].canBeUndef
      }));
      let y = b.length === 0 ? d.bindingsStream : d.bindingsStream.map((g) => {
        for (const T of b)
          g = g.delete(T.variable);
        return g;
      }), m = 0;
      return y = y.map((g) => {
        m++;
        const T = /* @__PURE__ */ new Map();
        return g.map((v) => {
          if (v instanceof a.BlankNodeBindingsScoped) {
            let E = T.get(v.value);
            return E || (E = s.blankNode(`${v.value}${m}`), T.set(v.value, E)), E;
          }
          return v;
        });
      }), {
        type: "bindings",
        bindingsStream: y,
        metadata: async () => ({ ...l, variables: _ })
      };
    }
  };
  return Z2.ActorQueryOperationProject = e, Z2;
}
var EH;
function Sbe() {
  return EH || (EH = 1, function(u) {
    var r = dl && dl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = dl && dl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ wbe(), u);
  }(dl)), dl;
}
var ll = {}, ev = {}, OH;
function Abe() {
  if (OH) return ev;
  OH = 1, Object.defineProperty(ev, "__esModule", { value: !0 }), ev.ActorQueryOperationReducedHash = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ vt(), a = /* @__PURE__ */ fh();
  let t = class extends u.ActorQueryOperationTypedMediated {
    constructor(n) {
      super(n, "reduced");
    }
    async testOperation(n, i) {
      return (0, r.passTestVoid)();
    }
    async runOperation(n, i) {
      const c = (0, o.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: n.input, context: i })), s = (await c.metadata()).variables.map((l) => l.variable);
      return {
        type: "bindings",
        bindingsStream: c.bindingsStream.filter(await this.newHashFilter(i, s)),
        metadata: c.metadata
      };
    }
    /**
     * Create a new distinct filter function.
     * This will maintain an internal hash datastructure so that every bindings object only returns true once.
     * @param context The action context.
     * @param variables The variables to take into account while hashing.
     * @return {(bindings: Bindings) => boolean} A distinct filter for bindings.
     */
    async newHashFilter(n, i) {
      const { hashFunction: c } = await this.mediatorHashBindings.mediate({ context: n }), s = new a.LRUCache({ max: this.cacheSize });
      return (d) => {
        const l = c(d, i);
        return s.has(l) ? !1 : (s.set(l, !0), !0);
      };
    }
  };
  return ev.ActorQueryOperationReducedHash = t, ev;
}
var xH;
function Ebe() {
  return xH || (xH = 1, function(u) {
    var r = ll && ll.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ll && ll.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Abe(), u);
  }(ll)), ll;
}
var fl = {}, tv = {}, IH;
function Obe() {
  if (IH) return tv;
  IH = 1, Object.defineProperty(tv, "__esModule", { value: !0 }), tv.ActorQueryOperationSlice = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class extends u.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "slice");
    }
    async testOperation(e, n) {
      return (0, o.passTestVoid)();
    }
    async runOperation(e, n) {
      e.length && (n = n.set(r.KeysQueryOperation.limitIndicator, e.length));
      const i = await this.mediatorQueryOperation.mediate({ operation: e.input, context: n });
      return i.type === "bindings" ? {
        type: "bindings",
        bindingsStream: this.sliceStream(i.bindingsStream, e),
        metadata: this.sliceMetadata(i, e)
      } : i.type === "quads" ? {
        type: "quads",
        quadStream: this.sliceStream(i.quadStream, e),
        metadata: this.sliceMetadata(i, e)
      } : i;
    }
    // Slice the stream based on the pattern values
    sliceStream(e, n) {
      const i = !!n.length || n.length === 0, { start: c } = n, s = i ? n.start + n.length - 1 : Number.POSITIVE_INFINITY;
      return e.transform({ offset: c, limit: Math.max(s - c + 1, 0), autoStart: !1 });
    }
    // If we find metadata, apply slicing on the total number of items
    sliceMetadata(e, n) {
      const i = !!n.length || n.length === 0;
      return () => e.metadata().then((c) => {
        const s = { ...c.cardinality };
        return Number.isFinite(s.value) && (s.value = Math.max(0, s.value - n.start), i && (s.value = Math.min(s.value, n.length))), { ...c, cardinality: s };
      });
    }
  };
  return tv.ActorQueryOperationSlice = a, tv;
}
var RH;
function xbe() {
  return RH || (RH = 1, function(u) {
    var r = fl && fl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = fl && fl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Obe(), u);
  }(fl)), fl;
}
var hl = {}, rv = {}, FH;
function Ibe() {
  if (FH) return rv;
  FH = 1, Object.defineProperty(rv, "__esModule", { value: !0 }), rv.ActorQueryOperationUnion = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Rr(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt();
  let e = class dS extends u.ActorQueryOperationTypedMediated {
    constructor(i) {
      super(i, "union");
    }
    /**
     * Takes the union of the given double array variables.
     * Uniqueness is guaranteed.
     * @param {string[][]} variables Double array of variables to take the union of.
     * @return {string[]} The union of the given variables.
     */
    static unionVariables(i) {
      const c = {};
      for (const s of i)
        for (const d of s) {
          c[d.variable.value] || (c[d.variable.value] = {
            variable: d.variable,
            canBeUndef: d.canBeUndef,
            occurrences: 0
          });
          const l = c[d.variable.value];
          l.canBeUndef = l.canBeUndef || d.canBeUndef, l.occurrences++;
        }
      return Object.values(c).map((s) => s.occurrences === i.length ? { variable: s.variable, canBeUndef: s.canBeUndef } : { variable: s.variable, canBeUndef: !0 });
    }
    /**
     * Takes the union of the given metadata array.
     * It will ensure that the cardinality metadata value is properly calculated.
     * @param {{[p: string]: any}[]} metadatas Array of metadata.
     * @param bindings If the union of the variables field should also be taken.
     * @param context The action context
     * @param mediatorRdfMetadataAccumulate Mediator for metadata accumulation
     * @return {{[p: string]: any}} Union of the metadata.
     */
    static async unionMetadata(i, c, s, d) {
      let l = (await d.mediate({ mode: "initialize", context: s })).metadata;
      for (const h of i)
        l = {
          ...h,
          ...(await d.mediate({
            mode: "append",
            accumulatedMetadata: l,
            appendingMetadata: h,
            context: s
          })).metadata
        };
      l.state = new o.MetadataValidationState();
      const f = () => l.state.invalidate();
      for (const h of i)
        h.state.addInvalidateListener(f);
      if (c) {
        const h = i.map((p) => p.variables);
        l.variables = dS.unionVariables(h);
      }
      return l;
    }
    async testOperation(i, c) {
      return (0, r.passTestVoid)();
    }
    async runOperation(i, c) {
      const s = await Promise.all(i.input.map((l) => this.mediatorQueryOperation.mediate({ operation: l, context: c })));
      let d;
      for (const l of s)
        if (d === void 0)
          d = l.type;
        else if (d !== l.type)
          throw new Error(`Unable to union ${d} and ${l.type}`);
      if (d === "bindings" || i.input.length === 0) {
        const l = s.map(a.getSafeBindings);
        return { type: "bindings", bindingsStream: new t.UnionIterator(l.map((p) => p.bindingsStream), { autoStart: !1 }), metadata: () => Promise.all(l.map((p) => p.metadata())).then((p) => dS.unionMetadata(p, !0, c, this.mediatorRdfMetadataAccumulate)) };
      }
      if (d === "quads") {
        const l = s.map(a.getSafeQuads);
        return { type: "quads", quadStream: new t.UnionIterator(l.map((p) => p.quadStream), { autoStart: !1 }), metadata: () => Promise.all(l.map((p) => p.metadata())).then((p) => dS.unionMetadata(p, !1, c, this.mediatorRdfMetadataAccumulate)) };
      }
      throw new Error(`Unable to union ${d}`);
    }
  };
  return rv.ActorQueryOperationUnion = e, rv;
}
var NH;
function wZ() {
  return NH || (NH = 1, function(u) {
    var r = hl && hl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = hl && hl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ibe(), u);
  }(hl)), hl;
}
var pl = {}, nv = {}, bl = {}, iv = {}, av = {}, PH;
function SZ() {
  if (PH) return av;
  PH = 1, Object.defineProperty(av, "__esModule", { value: !0 }), av.PathVariableObjectIterator = void 0;
  const u = /* @__PURE__ */ vt(), r = /* @__PURE__ */ yt(), o = lr();
  let a = class extends r.BufferedIterator {
    constructor(e, n, i, c, s, d, l, f = 16) {
      super({ autoStart: !1 }), this.algebraFactory = e, this.subject = n, this.predicate = i, this.graph = c, this.context = s, this.mediatorQueryOperation = d, this.maxRunningOperations = f, this.termHashes = /* @__PURE__ */ new Map(), this.runningOperations = [], this.pendingOperations = [], this.started = !1, this._push(this.subject, l);
    }
    getProperty(e, n) {
      return !this.started && e === "metadata" && this.startNextOperation(!1).catch((i) => this.emit("error", i)), super.getProperty(e, n);
    }
    _end(e) {
      for (const n of this.runningOperations)
        n.destroy();
      super._end(e);
    }
    _push(e, n = !0) {
      let i;
      if (n && (i = (0, o.termToString)(e), this.termHashes.has(i)))
        return !1;
      const c = this.algebraFactory.dataFactory.variable("b");
      return this.pendingOperations.push({
        variable: c,
        operation: this.algebraFactory.createPath(e, this.predicate, c, this.graph)
      }), i && (this.termHashes.set(i, e), super._push(e)), !0;
    }
    async startNextOperation(e) {
      this.started = !0;
      const n = this.pendingOperations.pop(), i = (0, u.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: n.operation, context: this.context })), c = i.bindingsStream.map((s) => s.get(n.variable));
      c.done || (this.runningOperations.push(c), c.on("error", (s) => this.destroy(s)), c.on("readable", () => {
        e && this._fillBufferAsync(), this.readable = !0;
      }), c.on("end", () => {
        this.runningOperations.splice(this.runningOperations.indexOf(c), 1), e && this._fillBufferAsync(), this.readable = !0;
      })), this.getProperty("metadata") || this.setProperty("metadata", i.metadata);
    }
    _read(e, n) {
      const i = this;
      (async function() {
        for (; i.runningOperations.length < i.maxRunningOperations && i.pendingOperations.length !== 0; )
          await i.startNextOperation(!0);
        let c = 0, s, d = !0;
        for (; !d || c !== (c = e); ) {
          d = !0;
          for (let l = 0; l < i.runningOperations.length && e > 0; l++)
            (s = i.runningOperations[l].read()) !== null && (i._push(s) ? e-- : d = !1);
        }
        i.closeIfNeeded();
      })().then(() => {
        n();
      }, (c) => this.destroy(c));
    }
    closeIfNeeded() {
      this.runningOperations.length === 0 && this.pendingOperations.length === 0 && this.close();
    }
  };
  return av.PathVariableObjectIterator = a, av;
}
var DH;
function Rbe() {
  if (DH) return iv;
  DH = 1, Object.defineProperty(iv, "__esModule", { value: !0 }), iv.ActorAbstractPath = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt(), e = lr(), n = ft(), i = /* @__PURE__ */ SZ();
  let c = class extends u.ActorQueryOperationTypedMediated {
    constructor(d, l) {
      super(d, "path"), this.predicateType = l;
    }
    async testOperation(d, l) {
      return d.predicate.type !== this.predicateType ? (0, o.failTest)(`This Actor only supports ${this.predicateType} Path operations.`) : (0, o.passTestVoid)();
    }
    // Generates a variable that does not yet occur in the path
    generateVariable(d, l, f) {
      return f ? l && (l.subject.value === f || l.object.value === f) ? this.generateVariable(d, l, `${f}b`) : d.variable(f) : this.generateVariable(d, l, "b");
    }
    // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number
    // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.
    // https://www.w3.org/TR/sparql11-query/#propertypaths
    async isPathArbitraryLengthDistinct(d, l, f) {
      return l.get(r.KeysQueryOperation.isPathArbitraryLengthDistinctKey) ? (l = l.set(r.KeysQueryOperation.isPathArbitraryLengthDistinctKey, !1), { context: l, operation: void 0 }) : (l = l.set(r.KeysQueryOperation.isPathArbitraryLengthDistinctKey, !0), { context: l, operation: (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({
        operation: d.createDistinct(f),
        context: l
      })) });
    }
    async predicateStarGraphVariable(d, l, f, h, p, b, _) {
      const y = this.getPathSources(f), m = this.generateVariable(b.dataFactory, b.createPath(d, f, l, h)), g = b.createUnion([
        this.assignPatternSources(b, b.createPattern(d, m, l, h), y),
        this.assignPatternSources(b, b.createPattern(l, m, d, h), y)
      ]), T = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ context: p, operation: g })), v = /* @__PURE__ */ new Set();
      return {
        bindingsStream: new t.MultiTransformIterator(T.bindingsStream, {
          multiTransform: (R) => {
            const L = R.get(h);
            return v.has(L.value) ? new t.EmptyIterator() : (v.add(L.value), new t.TransformIterator(async () => {
              const A = new t.BufferedIterator();
              return await this.getObjectsPredicateStar(b, d, f, L, p, {}, A, { count: 0 }), A.map((w) => _.bindings([
                [l, w],
                [h, L]
              ]));
            }, { maxBufferSize: 128 }));
          },
          autoStart: !1
        }),
        metadata: T.metadata
      };
    }
    /**
     * Returns an iterator with Bindings of the query subject predicate* ?o or subject predicate+ ?o
     * If graph is a variable, it will also be in those bindings
     * @param {Term} subject Term of where we start the predicate* search.
     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
     * @param {Variable} object Variable of the zeroOrMore-query.
     * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)
     * @param {ActionContext} context The context to pass to sub-opertations
     * @param emitFirstSubject If the path operation is predicate*, otherwise it is predicate+.
     * @param algebraFactory The algebra factory.
     * @param bindingsFactory The data factory.
     * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.
     */
    async getObjectsPredicateStarEval(d, l, f, h, p, b, _, y) {
      if (h.termType === "Variable")
        return this.predicateStarGraphVariable(d, f, l, h, p, _, y);
      const m = new i.PathVariableObjectIterator(_, d, l, h, p, this.mediatorQueryOperation, b);
      return {
        bindingsStream: m.map((T) => y.bindings([[f, T]])),
        async metadata() {
          const T = await new Promise((v) => {
            m.getProperty("metadata", (E) => v(E()));
          });
          return T.cardinality.value++, T;
        }
      };
    }
    /**
     * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.
     * @param algebraFactory The algebra factory.
     * @param {Term} object Term of where we start the predicate* search.
     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
     * @param {Term} graph The graph in which we search for the pattern.
     * @param {ActionContext} context
     * @param {Record<string, Term>} termHashes Remembers the objects we've already searched for.
     * @param {BufferedIterator<Term>} it Iterator to push terms to.
     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).
     * @return {Promise<IPathResultStream['metadata']>} The results metadata.
     */
    async getObjectsPredicateStar(d, l, f, h, p, b, _, y) {
      const m = (0, e.termToString)(l);
      if (b[m])
        return;
      _._push(l), b[m] = l, y.count++;
      const g = this.generateVariable(d.dataFactory), T = d.createPath(l, f, g, h), v = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: T, context: p }));
      return v.bindingsStream.on("data", async (E) => {
        const R = E.get(g);
        await this.getObjectsPredicateStar(d, R, f, h, p, b, _, y);
      }), v.bindingsStream.on("end", () => {
        --y.count === 0 && _.close();
      }), v.metadata;
    }
    /**
     * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.
     * @param {string} subjectVar String representation of subjectVariable
     * @param {string} objectVar String representation of objectVariable
     * @param {Term} subjectVal Term of where we start the predicate* search.
     * @param {Term} objectVal Found solution for an object, start for the new step.
     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
     * @param {Term} graph The graph in which we search for the pattern.
     * @param {ActionContext} context
     * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal
     * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs
     * @param {{[id: string]: Term}} termHashesCurrentSubject
     * Remembers the pairs we've already searched for, can stop searching if so.
     * @param {BufferedIterator<Bindings>} it Iterator to push terms to.
     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).
     * @param algebraFactory The algebra factory.
     * @param bindingsFactory The bindings factory.
     * @return {Promise<void>} All solutions of query should have been pushed to it by then.
     */
    // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal
    // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal
    async getSubjectAndObjectBindingsPredicateStar(d, l, f, h, p, b, _, y, m, g, T, v, E) {
      const R = (0, e.termToString)(h) + (0, e.termToString)(b);
      if (m[R])
        return;
      if (T.count++, m[R] = !0, g._push(E.bindings([
        [d, f],
        [l, h]
      ])), R in y) {
        const A = await y[R];
        for (const w of A)
          await this.getSubjectAndObjectBindingsPredicateStar(d, l, f, w, p, b, _, y, m, g, T, v, E);
        --T.count === 0 && g.close();
        return;
      }
      const L = new Promise(async (A, w) => {
        const S = [], O = this.generateVariable(v.dataFactory), x = v.createPath(h, p, O, b), F = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: x, context: _ }));
        F.bindingsStream.on("data", async (j) => {
          const q = j.get(O);
          S.push(q), await this.getSubjectAndObjectBindingsPredicateStar(d, l, f, q, p, b, _, y, m, g, T, v, E);
        }), F.bindingsStream.on("error", w), F.bindingsStream.on("end", () => {
          --T.count === 0 && g.close(), A(S);
        });
      });
      y[R] = L;
    }
    /**
     * Find all sources recursively contained in the given path operation.
     * @param operation
     */
    getPathSources(d) {
      switch (d.type) {
        case n.Algebra.types.ALT:
        case n.Algebra.types.SEQ:
          return d.input.flatMap((l) => this.getPathSources(l));
        case n.Algebra.types.INV:
        case n.Algebra.types.ONE_OR_MORE_PATH:
        case n.Algebra.types.ZERO_OR_MORE_PATH:
        case n.Algebra.types.ZERO_OR_ONE_PATH:
          return this.getPathSources(d.path);
        case n.Algebra.types.LINK:
        case n.Algebra.types.NPS: {
          const l = (0, a.getOperationSource)(d);
          if (!l)
            throw new Error("Could not find a required source on a link path operation");
          return [l];
        }
      }
    }
    assignPatternSources(d, l, f) {
      if (f.length === 0)
        throw new Error("Attempted to assign zero sources to a pattern during property path handling");
      return f.length === 1 ? (0, a.assignOperationSource)(l, f[0]) : d.createUnion(f.map((h) => (0, a.assignOperationSource)(l, h)), !0);
    }
  };
  return iv.ActorAbstractPath = c, iv;
}
var LH;
function su() {
  return LH || (LH = 1, function(u) {
    var r = bl && bl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bl && bl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rbe(), u), o(/* @__PURE__ */ SZ(), u);
  }(bl)), bl;
}
var jH;
function Fbe() {
  if (jH) return nv;
  jH = 1, Object.defineProperty(nv, "__esModule", { value: !0 }), nv.ActorQueryOperationPathAlt = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ wZ(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt(), e = ft();
  let n = class extends u.ActorAbstractPath {
    constructor(c) {
      super(c, e.Algebra.types.ALT);
    }
    async runOperation(c, s) {
      const d = s.getSafe(o.KeysInitQuery.dataFactory), l = new e.Factory(d), f = c.predicate, h = (await Promise.all(f.input.map((_) => this.mediatorQueryOperation.mediate({
        context: s,
        operation: l.createPath(c.subject, _, c.object, c.graph)
      })))).map(a.getSafeBindings);
      return {
        type: "bindings",
        bindingsStream: new t.UnionIterator(h.map((_) => _.bindingsStream), { autoStart: !1 }),
        metadata: () => Promise.all(h.map((_) => _.metadata())).then((_) => r.ActorQueryOperationUnion.unionMetadata(_, !0, s, this.mediatorRdfMetadataAccumulate))
      };
    }
  };
  return nv.ActorQueryOperationPathAlt = n, nv;
}
var MH;
function Nbe() {
  return MH || (MH = 1, function(u) {
    var r = pl && pl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = pl && pl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Fbe(), u);
  }(pl)), pl;
}
var yl = {}, uv = {}, CH;
function Pbe() {
  if (CH) return uv;
  CH = 1, Object.defineProperty(uv, "__esModule", { value: !0 }), uv.ActorQueryOperationPathInv = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = ft();
  let a = class extends u.ActorAbstractPath {
    constructor(e) {
      super(e, o.Algebra.types.INV);
    }
    async runOperation(e, n) {
      const i = n.getSafe(r.KeysInitQuery.dataFactory), c = new o.Factory(i), s = e.predicate, d = c.createPath(e.object, s.path, e.subject, e.graph);
      return this.mediatorQueryOperation.mediate({ operation: d, context: n });
    }
  };
  return uv.ActorQueryOperationPathInv = a, uv;
}
var qH;
function Dbe() {
  return qH || (qH = 1, function(u) {
    var r = yl && yl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = yl && yl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Pbe(), u);
  }(yl)), yl;
}
var _l = {}, ov = {}, BH;
function Lbe() {
  if (BH) return ov;
  BH = 1, Object.defineProperty(ov, "__esModule", { value: !0 }), ov.ActorQueryOperationPathLink = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = ft();
  let a = class extends u.ActorAbstractPath {
    constructor(e) {
      super(e, o.Algebra.types.LINK);
    }
    async runOperation(e, n) {
      const i = n.getSafe(r.KeysInitQuery.dataFactory), c = new o.Factory(i), s = e.predicate, d = Object.assign(c.createPattern(e.subject, s.iri, e.object, e.graph), { metadata: s.metadata });
      return this.mediatorQueryOperation.mediate({ operation: d, context: n });
    }
  };
  return ov.ActorQueryOperationPathLink = a, ov;
}
var $H;
function jbe() {
  return $H || ($H = 1, function(u) {
    var r = _l && _l.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _l && _l.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Lbe(), u);
  }(_l)), _l;
}
var gl = {}, sv = {}, UH;
function Mbe() {
  if (UH) return sv;
  UH = 1, Object.defineProperty(sv, "__esModule", { value: !0 }), sv.ActorQueryOperationPathNps = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ vt(), a = ft();
  let t = class extends u.ActorAbstractPath {
    constructor(n) {
      super(n, a.Algebra.types.NPS);
    }
    async runOperation(n, i) {
      const c = i.getSafe(r.KeysInitQuery.dataFactory), s = new a.Factory(c), d = n.predicate, l = this.generateVariable(c, n), f = Object.assign(s.createPattern(n.subject, l, n.object, n.graph), { metadata: d.metadata }), h = (0, o.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: f, context: i }));
      return {
        type: "bindings",
        bindingsStream: h.bindingsStream.map((b) => d.iris.some((_) => _.equals(b.get(l))) ? null : b.delete(l)),
        metadata: h.metadata
      };
    }
  };
  return sv.ActorQueryOperationPathNps = t, sv;
}
var VH;
function Cbe() {
  return VH || (VH = 1, function(u) {
    var r = gl && gl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = gl && gl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Mbe(), u);
  }(gl)), gl;
}
var ml = {}, cv = {}, QH;
function qbe() {
  if (QH) return cv;
  QH = 1, Object.defineProperty(cv, "__esModule", { value: !0 }), cv.ActorQueryOperationClear = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ vt();
  let a = class extends u.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "clear");
    }
    async testOperation(e, n) {
      return (0, o.testReadOnly)(n);
    }
    async runOperation(e, n) {
      const i = n.getSafe(r.KeysInitQuery.dataFactory);
      let c;
      e.source === "DEFAULT" ? c = i.defaultGraph() : typeof e.source == "string" ? c = e.source : c = [e.source];
      const { execute: s } = await this.mediatorUpdateQuads.mediate({
        deleteGraphs: {
          graphs: c,
          requireExistence: !e.silent,
          dropGraphs: !1
        },
        context: n
      });
      return {
        type: "void",
        execute: s
      };
    }
  };
  return cv.ActorQueryOperationClear = a, cv;
}
var HH;
function Bbe() {
  return HH || (HH = 1, function(u) {
    var r = ml && ml.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ml && ml.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ qbe(), u);
  }(ml)), ml;
}
var vl = {}, dv = {}, GH;
function $be() {
  if (GH) return dv;
  GH = 1, Object.defineProperty(dv, "__esModule", { value: !0 }), dv.ActorQueryOperationUpdateCompositeUpdate = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ vt();
  let o = class extends u.ActorQueryOperationTypedMediated {
    constructor(t) {
      super(t, "compositeupdate");
    }
    async testOperation(t, e) {
      return (0, r.testReadOnly)(e);
    }
    async runOperation(t, e) {
      return {
        type: "void",
        execute: () => (async () => {
          for (const i of t.updates)
            await (0, r.getSafeVoid)(await this.mediatorQueryOperation.mediate({ operation: i, context: e })).execute();
        })()
      };
    }
  };
  return dv.ActorQueryOperationUpdateCompositeUpdate = o, dv;
}
var zH;
function Ube() {
  return zH || (zH = 1, function(u) {
    var r = vl && vl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vl && vl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ $be(), u);
  }(vl)), vl;
}
var Tl = {}, lv = {}, kH;
function Vbe() {
  if (kH) return lv;
  kH = 1, Object.defineProperty(lv, "__esModule", { value: !0 }), lv.ActorQueryOperationCreate = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ vt();
  let o = class extends u.ActorQueryOperationTypedMediated {
    constructor(t) {
      super(t, "create");
    }
    async testOperation(t, e) {
      return (0, r.testReadOnly)(e);
    }
    async runOperation(t, e) {
      const { execute: n } = await this.mediatorUpdateQuads.mediate({
        createGraphs: {
          graphs: [t.source],
          requireNonExistence: !t.silent
        },
        context: e
      });
      return {
        type: "void",
        execute: n
      };
    }
  };
  return lv.ActorQueryOperationCreate = o, lv;
}
var XH;
function Qbe() {
  return XH || (XH = 1, function(u) {
    var r = Tl && Tl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Tl && Tl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Vbe(), u);
  }(Tl)), Tl;
}
var wl = {}, fv = {}, JH;
function Hbe() {
  if (JH) return fv;
  JH = 1, Object.defineProperty(fv, "__esModule", { value: !0 }), fv.ActorQueryOperationDrop = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ vt();
  let a = class extends u.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "drop");
    }
    async testOperation(e, n) {
      return (0, o.testReadOnly)(n);
    }
    async runOperation(e, n) {
      const i = n.getSafe(r.KeysInitQuery.dataFactory);
      let c;
      e.source === "DEFAULT" ? c = i.defaultGraph() : typeof e.source == "string" ? c = e.source : c = [e.source];
      const { execute: s } = await this.mediatorUpdateQuads.mediate({
        deleteGraphs: {
          graphs: c,
          requireExistence: !e.silent,
          dropGraphs: !0
        },
        context: n
      });
      return {
        type: "void",
        execute: s
      };
    }
  };
  return fv.ActorQueryOperationDrop = a, fv;
}
var KH;
function Gbe() {
  return KH || (KH = 1, function(u) {
    var r = wl && wl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = wl && wl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Hbe(), u);
  }(wl)), wl;
}
var Sl = {}, hv = {}, WH;
function zbe() {
  if (WH) return hv;
  WH = 1, Object.defineProperty(hv, "__esModule", { value: !0 }), hv.ActorQueryOperationLoad = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ vt(), a = ft();
  let t = class extends u.ActorQueryOperationTypedMediated {
    constructor(n) {
      super(n, "load");
    }
    async testOperation(n, i) {
      return (0, o.testReadOnly)(i);
    }
    async runOperation(n, i) {
      const c = i.getSafe(r.KeysInitQuery.dataFactory), s = new a.Factory(c);
      let d = i;
      n.silent && (d = d.set(r.KeysInitQuery.lenient, !0));
      const { querySource: l } = await this.mediatorQuerySourceIdentify.mediate({
        querySourceUnidentified: { value: n.source.value },
        context: d
      });
      let h = (0, o.getSafeQuads)(await this.mediatorQueryOperation.mediate({
        operation: s.createConstruct((0, o.assignOperationSource)(s.createPattern(c.variable("s"), c.variable("p"), c.variable("o")), l), [s.createPattern(c.variable("s"), c.variable("p"), c.variable("o"))]),
        context: d
      })).quadStream;
      n.destination && (h = h.map((b) => c.quad(b.subject, b.predicate, b.object, n.destination)));
      const { execute: p } = await this.mediatorUpdateQuads.mediate({
        quadStreamInsert: h,
        context: i
      });
      return {
        type: "void",
        execute: p
      };
    }
  };
  return hv.ActorQueryOperationLoad = t, hv;
}
var YH;
function kbe() {
  return YH || (YH = 1, function(u) {
    var r = Sl && Sl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Sl && Sl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ zbe(), u);
  }(Sl)), Sl;
}
var Al = {}, pv = {}, ZH;
function Xbe() {
  if (ZH) return pv;
  ZH = 1, Object.defineProperty(pv, "__esModule", { value: !0 }), pv.ActorQueryOperationJoin = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ cn(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Rr(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt(), n = Or();
  let i = class extends u.ActorQueryOperationTypedMediated {
    constructor(s) {
      super(s, "join");
    }
    async testOperation(s, d) {
      return (0, o.passTestVoid)();
    }
    async runOperation(s, d) {
      const l = (await Promise.all(s.input.map(async (f) => ({
        output: await this.mediatorQueryOperation.mediate({ operation: f, context: d }),
        operation: f
      })))).map(({ output: f, operation: h }) => ({
        output: (0, t.getSafeBindings)(f),
        operation: h
      }));
      if ((await Promise.all(l.map((f) => f.output.metadata()))).some((f) => f.cardinality.value === 0 && f.cardinality.type === "exact")) {
        for (const f of l)
          f.output.bindingsStream.close();
        return {
          bindingsStream: new e.ArrayIterator([], { autoStart: !1 }),
          metadata: async () => ({
            state: new a.MetadataValidationState(),
            cardinality: { type: "exact", value: 0 },
            variables: r.ActorRdfJoin.joinVariables(new n.DataFactory(), await r.ActorRdfJoin.getMetadatas(l))
          }),
          type: "bindings"
        };
      }
      return this.mediatorJoin.mediate({ type: "inner", entries: l, context: d });
    }
  };
  return pv.ActorQueryOperationJoin = i, pv;
}
var eG;
function Jbe() {
  return eG || (eG = 1, function(u) {
    var r = Al && Al.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Al && Al.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Xbe(), u);
  }(Al)), Al;
}
var El = {}, bv = {}, tG;
function Kbe() {
  if (tG) return bv;
  tG = 1, Object.defineProperty(bv, "__esModule", { value: !0 }), bv.ActorQueryOperationLeftJoin = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ ve(), t = /* @__PURE__ */ vt();
  let e = class extends u.ActorQueryOperationTypedMediated {
    constructor(i) {
      super(i, "leftjoin"), this.mediatorExpressionEvaluatorFactory = i.mediatorExpressionEvaluatorFactory;
    }
    async testOperation(i, c) {
      return (0, r.passTestVoid)();
    }
    async runOperation(i, c) {
      const s = (await Promise.all(i.input.map(async (l) => ({
        output: await this.mediatorQueryOperation.mediate({ operation: l, context: c }),
        operation: l
      })))).map(({ output: l, operation: f }) => ({
        output: (0, t.getSafeBindings)(l),
        operation: f
      })), d = await this.mediatorJoin.mediate({ type: "optional", entries: s, context: c });
      if (i.expression) {
        const f = (await s[1].output.metadata()).variables, h = await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: i.expression, context: c }), p = d.bindingsStream.transform({
          autoStart: !1,
          // eslint-disable-next-line ts/no-misused-promises
          transform: async (b, _, y) => {
            if (!f.every((m) => b.has(m.variable.value)))
              return y(b), _();
            try {
              await h.evaluateAsEBV(b) && y(b);
            } catch (m) {
              (0, a.isExpressionError)(m) ? this.logWarn(c, "Error occurred while filtering.", () => ({ error: m, bindings: (0, o.bindingsToString)(b) })) : p.emit("error", m);
            }
            _();
          }
        });
        d.bindingsStream = p;
      }
      return d;
    }
  };
  return bv.ActorQueryOperationLeftJoin = e, bv;
}
var rG;
function Wbe() {
  return rG || (rG = 1, function(u) {
    var r = El && El.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = El && El.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Kbe(), u);
  }(El)), El;
}
var Ol = {}, yv = {}, nG;
function Ybe() {
  if (nG) return yv;
  nG = 1, Object.defineProperty(yv, "__esModule", { value: !0 }), yv.ActorQueryOperationMinus = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ vt();
  let a = class extends u.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "minus");
    }
    async testOperation(e, n) {
      return (0, r.passTestVoid)();
    }
    async runOperation(e, n) {
      const i = (await Promise.all(e.input.map(async (c) => ({
        output: await this.mediatorQueryOperation.mediate({ operation: c, context: n }),
        operation: c
      })))).map(({ output: c, operation: s }) => ({
        output: (0, o.getSafeBindings)(c),
        operation: s
      }));
      return this.mediatorJoin.mediate({ type: "minus", entries: i, context: n });
    }
  };
  return yv.ActorQueryOperationMinus = a, yv;
}
var iG;
function Zbe() {
  return iG || (iG = 1, function(u) {
    var r = Ol && Ol.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ol && Ol.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Ybe(), u);
  }(Ol)), Ol;
}
var xl = {}, _v = {}, aG;
function eye() {
  if (aG) return _v;
  aG = 1, Object.defineProperty(_v, "__esModule", { value: !0 }), _v.ActorQueryOperationPathSeq = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ vt(), a = ft();
  let t = class extends u.ActorAbstractPath {
    constructor(n) {
      super(n, a.Algebra.types.SEQ);
    }
    async runOperation(n, i) {
      const c = i.getSafe(r.KeysInitQuery.dataFactory), s = new a.Factory(c), d = n.predicate;
      let l = n.subject;
      const f = [], h = await Promise.all(d.input.map((_, y) => {
        const m = y === d.input.length - 1 ? n.object : this.generateVariable(c, n, `b${y}`), g = s.createPath(l, _, m, n.graph), T = this.mediatorQueryOperation.mediate({
          context: i,
          operation: g
        });
        return l = m, y < d.input.length - 1 && f.push(m), { output: T, operation: g };
      }).map(async ({ output: _, operation: y }) => ({
        output: (0, o.getSafeBindings)(await _),
        operation: y
      }))), p = (0, o.getSafeBindings)(await this.mediatorJoin.mediate({ type: "inner", entries: h, context: i }));
      return {
        type: "bindings",
        bindingsStream: p.bindingsStream.transform({
          transform(_, y, m) {
            for (const g of f)
              _ = _.delete(g);
            m(_), y();
          }
        }),
        async metadata() {
          const _ = await p.metadata(), y = _.variables.filter((m) => !f.some((g) => g.value === m.variable.value));
          return { ..._, variables: y };
        }
      };
    }
  };
  return _v.ActorQueryOperationPathSeq = t, _v;
}
var uG;
function tye() {
  return uG || (uG = 1, function(u) {
    var r = xl && xl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xl && xl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ eye(), u);
  }(xl)), xl;
}
var Il = {}, gv = {}, oG;
function rye() {
  if (oG) return gv;
  oG = 1, Object.defineProperty(gv, "__esModule", { value: !0 }), gv.ActorRdfJoinMultiSmallest = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = ft();
  let e = class extends u.ActorRdfJoin {
    constructor(i) {
      super(i, {
        logicalType: "inner",
        physicalName: "multi-smallest",
        limitEntries: 3,
        limitEntriesMin: !0,
        canHandleUndefs: !0,
        isLeaf: !1
      });
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    async sortJoinEntries(i, c) {
      return (await this.mediatorJoinEntriesSort.mediate({ entries: i, context: c })).entries;
    }
    async getOutput(i, c) {
      const s = i.context.getSafe(r.KeysInitQuery.dataFactory), d = new t.Factory(s), l = c.sortedEntries, f = l[0], h = l[1];
      l.splice(0, 2);
      const p = {
        output: (0, a.getSafeBindings)(await this.mediatorJoin.mediate({ type: i.type, entries: [f, h], context: i.context })),
        operation: d.createJoin([f.operation, h.operation], !1)
      };
      return l.push(p), {
        result: await this.mediatorJoin.mediate({
          type: i.type,
          entries: l,
          context: i.context
        })
      };
    }
    async getJoinCoefficients(i, c) {
      let { metadatas: s } = c;
      s = [...s];
      const d = await this.sortJoinEntries(i.entries.map((h, p) => ({ ...h, metadata: s[p] })), i.context);
      s = d.map((h) => h.metadata);
      const l = u.ActorRdfJoin.getRequestInitialTimes(s), f = u.ActorRdfJoin.getRequestItemTimes(s);
      return (0, o.passTestWithSideData)({
        iterations: s[0].cardinality.value * s[1].cardinality.value * s.slice(2).reduce((h, p) => h * p.cardinality.value, 1),
        persistedItems: 0,
        blockingItems: 0,
        requestTime: l[0] + s[0].cardinality.value * f[0] + l[1] + s[1].cardinality.value * f[1] + s.slice(2).reduce((h, p, b) => h + l.slice(2)[b] + p.cardinality.value * f.slice(2)[b], 0)
      }, { ...c, sortedEntries: d });
    }
  };
  return gv.ActorRdfJoinMultiSmallest = e, gv;
}
var sG;
function nye() {
  return sG || (sG = 1, function(u) {
    var r = Il && Il.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Il && Il.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rye(), u);
  }(Il)), Il;
}
var Rl = {}, mv = {}, vv = {}, cG;
function AZ() {
  if (cG) return vv;
  cG = 1, Object.defineProperty(vv, "__esModule", { value: !0 }), vv.MaxAggregator = void 0;
  const u = /* @__PURE__ */ Wr();
  let r = class extends u.AggregateEvaluator {
    constructor(a, t, e, n) {
      super(a, t, n), this.orderByEvaluator = e, this.state = void 0;
    }
    putTerm(a) {
      if (a.termType !== "Literal")
        throw new Error(`Term with value ${a.value} has type ${a.termType} and is not a literal`);
      this.state === void 0 ? this.state = a : this.orderByEvaluator.orderTypes(this.state, a) === -1 && (this.state = a);
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : this.state;
    }
  };
  return vv.MaxAggregator = r, vv;
}
var dG;
function iye() {
  if (dG) return mv;
  dG = 1, Object.defineProperty(mv, "__esModule", { value: !0 }), mv.ActorBindingsAggregatorFactoryMax = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ AZ();
  let a = class extends u.ActorBindingsAggregatorFactory {
    constructor(e) {
      super(e), this.mediatorTermComparatorFactory = e.mediatorTermComparatorFactory;
    }
    async test(e) {
      return e.expr.aggregator !== "max" ? (0, r.failTest)("This actor only supports the 'max' aggregator.") : (0, r.passTestVoid)();
    }
    async run({ expr: e, context: n }) {
      return new o.MaxAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: e.expression, context: n }), e.distinct, await this.mediatorTermComparatorFactory.mediate({ context: n }));
    }
  };
  return mv.ActorBindingsAggregatorFactoryMax = a, mv;
}
var lG;
function aye() {
  return lG || (lG = 1, function(u) {
    var r = Rl && Rl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Rl && Rl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ iye(), u), o(/* @__PURE__ */ AZ(), u);
  }(Rl)), Rl;
}
var Fl = {}, Tv = {}, wv = {}, fG;
function EZ() {
  if (fG) return wv;
  fG = 1, Object.defineProperty(wv, "__esModule", { value: !0 }), wv.MinAggregator = void 0;
  const u = /* @__PURE__ */ Wr();
  let r = class extends u.AggregateEvaluator {
    constructor(a, t, e, n) {
      super(a, t, n), this.orderByEvaluator = e, this.state = void 0;
    }
    putTerm(a) {
      if (a.termType !== "Literal")
        throw new Error(`Term with value ${a.value} has type ${a.termType} and is not a literal`);
      this.state === void 0 ? this.state = a : this.orderByEvaluator.orderTypes(this.state, a) === 1 && (this.state = a);
    }
    termResult() {
      return this.state === void 0 ? this.emptyValue() : this.state;
    }
  };
  return wv.MinAggregator = r, wv;
}
var hG;
function uye() {
  if (hG) return Tv;
  hG = 1, Object.defineProperty(Tv, "__esModule", { value: !0 }), Tv.ActorBindingsAggregatorFactoryMin = void 0;
  const u = /* @__PURE__ */ Wr(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ EZ();
  let a = class extends u.ActorBindingsAggregatorFactory {
    constructor(e) {
      super(e), this.mediatorTermComparatorFactory = e.mediatorTermComparatorFactory;
    }
    async test(e) {
      return e.expr.aggregator !== "min" ? (0, r.failTest)("This actor only supports the 'min' aggregator.") : (0, r.passTestVoid)();
    }
    async run({ context: e, expr: n }) {
      return new o.MinAggregator(await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: n.expression, context: e }), n.distinct, await this.mediatorTermComparatorFactory.mediate({ context: e }));
    }
  };
  return Tv.ActorBindingsAggregatorFactoryMin = a, Tv;
}
var pG;
function oye() {
  return pG || (pG = 1, function(u) {
    var r = Fl && Fl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Fl && Fl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ uye(), u), o(/* @__PURE__ */ EZ(), u);
  }(Fl)), Fl;
}
var Nl = {}, Sv = {}, Av = {}, bG;
function sye() {
  if (bG) return Av;
  bG = 1, Object.defineProperty(Av, "__esModule", { value: !0 }), Av.SortIterator = void 0;
  const u = /* @__PURE__ */ yt();
  let r = class extends u.TransformIterator {
    constructor(a, t, e) {
      super(a, e);
      const n = e && e.window;
      this.windowLength = Number.isFinite(n) && n > 0 ? n : Number.POSITIVE_INFINITY, this.sort = t, this.sorted = [];
    }
    // Reads the smallest item in the current sorting window
    _read(a, t) {
      let e, { length: n } = this.sorted;
      for (; n !== this.windowLength && (e = this.source.read(), e !== null); ) {
        let i = 0, c = n - 1, s, d;
        for (; i <= c; )
          s = Math.trunc((i + c) / 2), d = this.sort(e, this.sorted[s]), d < 0 ? i = s + 1 : d > 0 ? c = s - 1 : (i = s, c = -1);
        this.sorted.splice(i, 0, e), n++;
      }
      n === this.windowLength && this._push(this.sorted.pop()), t();
    }
    // Flushes remaining data after the source has ended
    _flush(a) {
      let { length: t } = this.sorted;
      for (; t--; )
        this._push(this.sorted.pop());
      a();
    }
  };
  return Av.SortIterator = r, Av;
}
var yG;
function cye() {
  if (yG) return Sv;
  yG = 1, Object.defineProperty(Sv, "__esModule", { value: !0 }), Sv.ActorQueryOperationOrderBy = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ ve(), a = /* @__PURE__ */ vt(), t = ft(), e = /* @__PURE__ */ sye();
  let n = class extends u.ActorQueryOperationTypedMediated {
    constructor(c) {
      super(c, "orderby"), this.window = c.window ?? Number.POSITIVE_INFINITY, this.mediatorExpressionEvaluatorFactory = c.mediatorExpressionEvaluatorFactory, this.mediatorTermComparatorFactory = c.mediatorTermComparatorFactory;
    }
    async testOperation() {
      return (0, r.passTestVoid)();
    }
    async runOperation(c, s) {
      const d = await this.mediatorQueryOperation.mediate({ operation: c.input, context: s }), l = (0, a.getSafeBindings)(d), f = { window: this.window };
      let { bindingsStream: h } = l;
      const p = await this.mediatorTermComparatorFactory.mediate({ context: s });
      for (let b = c.expressions.length - 1; b >= 0; b--) {
        let _ = c.expressions[b];
        const y = this.isAscending(_);
        _ = this.extractSortExpression(_);
        const m = await this.mediatorExpressionEvaluatorFactory.mediate({ algExpr: _, context: s }), g = async (E, R, L) => {
          try {
            const A = await m.evaluate(E);
            L({ bindings: E, result: A });
          } catch (A) {
            (0, o.isExpressionError)(A) || h.emit("error", A), L({ bindings: E, result: void 0 });
          }
          R();
        }, T = h.transform({ transform: g });
        h = new e.SortIterator(T, (E, R) => {
          let L = p.orderTypes(E.result, R.result);
          return y || (L *= -1), L;
        }, f).map(({ bindings: E }) => E);
      }
      return {
        type: "bindings",
        bindingsStream: h,
        metadata: l.metadata
      };
    }
    // Remove descending operator if necessary
    extractSortExpression(c) {
      const { expressionType: s, operator: d } = c;
      return s !== t.Algebra.expressionTypes.OPERATOR ? c : d === "desc" ? c.args[0] : c;
    }
    isAscending(c) {
      const { expressionType: s, operator: d } = c;
      return s !== t.Algebra.expressionTypes.OPERATOR ? !0 : d !== "desc";
    }
  };
  return Sv.ActorQueryOperationOrderBy = n, Sv;
}
var _G;
function dye() {
  return _G || (_G = 1, function(u) {
    var r = Nl && Nl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Nl && Nl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ cye(), u);
  }(Nl)), Nl;
}
var Pl = {}, Ev = {}, gG;
function lye() {
  if (gG) return Ev;
  gG = 1, Object.defineProperty(Ev, "__esModule", { value: !0 }), Ev.ActorOptimizeQueryOperationFilterPushdown = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = zn(), e = ft();
  let n = class extends u.ActorOptimizeQueryOperation {
    constructor(c) {
      super(c);
    }
    async test(c) {
      return (0, o.passTestVoid)();
    }
    async run(c) {
      const s = c.context.getSafe(r.KeysInitQuery.dataFactory), d = new e.Factory(s);
      let l = c.operation;
      const f = this;
      this.splitConjunctive && (l = e.Util.mapOperation(l, {
        filter(y, m) {
          return y.expression.expressionType === e.Algebra.expressionTypes.OPERATOR && y.expression.operator === "&&" ? (f.logDebug(c.context, `Split conjunctive filter into ${y.expression.args.length} nested filters`), {
            recurse: !0,
            result: y.expression.args.reduce((g, T) => m.createFilter(g, T), y.input)
          }) : {
            recurse: !0,
            result: y
          };
        }
      }, d));
      const h = this.getSources(l), p = new Map(await Promise.all(h.map(async (y) => [y, await y.source.getSelectorShape(c.context)])));
      let b = !0, _ = 0;
      for (; b && _ < this.maxIterations; )
        b = !1, l = e.Util.mapOperation(l, {
          filter(y, m) {
            if (!f.shouldAttemptPushDown(y, h, p))
              return {
                recurse: !0,
                result: y
              };
            const g = f.getExpressionVariables(y.expression), [T, v] = f.filterPushdown(y.expression, g, y.input, m, c.context);
            return T && (b = !0), {
              recurse: !0,
              result: v
            };
          }
        }), _++;
      return _ > 1 && f.logDebug(c.context, `Pushed down filters in ${_} iterations`), this.mergeConjunctive && (l = e.Util.mapOperation(l, {
        filter(y, m) {
          if (y.input.type === e.Algebra.types.FILTER) {
            const { nestedExpressions: g, input: T } = f.getNestedFilterExpressions(y);
            return f.logDebug(c.context, `Merge ${g.length} nested filters into conjunctive filter`), {
              recurse: !0,
              result: m.createFilter(T, g.slice(1).reduce((v, E) => m.createOperatorExpression("&&", [v, E]), g[0]))
            };
          }
          return {
            recurse: !0,
            result: y
          };
        }
      })), { operation: l, context: c.context };
    }
    /**
     * Check if the given filter operation must be attempted to push down, based on the following criteria:
     * - Always push down if aggressive mode is enabled
     * - Push down if the filter is extremely selective
     * - Push down if federated and at least one accepts the filter
     * @param operation The filter operation
     * @param sources The query sources in the operation
     * @param sourceShapes A mapping of sources to selector shapes.
     */
    shouldAttemptPushDown(c, s, d) {
      if (this.aggressivePushdown)
        return !0;
      const l = c.expression;
      return !!(l.expressionType === e.Algebra.expressionTypes.OPERATOR && l.operator === "=" && (l.args[0].expressionType === "term" && l.args[0].term.termType !== "Variable" && l.args[1].expressionType === "term" && l.args[1].term.termType === "Variable" || l.args[0].expressionType === "term" && l.args[0].term.termType === "Variable" && l.args[1].expressionType === "term" && l.args[1].term.termType !== "Variable") || s.some((f) => (0, a.doesShapeAcceptOperation)(d.get(f), c)));
    }
    /**
     * Collected all sources that are defined within the given operation of children recursively.
     * @param operation An operation.
     */
    getSources(c) {
      const s = /* @__PURE__ */ new Set(), d = (l) => {
        const f = (0, a.getOperationSource)(l);
        return f && s.add(f), !1;
      };
      return e.Util.recurseOperation(c, {
        [e.Algebra.types.PATTERN]: d,
        [e.Algebra.types.LINK]: d,
        [e.Algebra.types.NPS]: d,
        [e.Algebra.types.SERVICE]: d
      }), [...s];
    }
    /**
     * Get all variables inside the given expression.
     * @param expression An expression.
     * @return An array of variables, or undefined if the expression is unsupported for pushdown.
     */
    getExpressionVariables(c) {
      switch (c.expressionType) {
        case e.Algebra.expressionTypes.AGGREGATE:
        case e.Algebra.expressionTypes.WILDCARD:
          throw new Error(`Getting expression variables is not supported for ${c.expressionType}`);
        case e.Algebra.expressionTypes.EXISTENCE:
          return e.Util.inScopeVariables(c.input);
        case e.Algebra.expressionTypes.NAMED:
          return [];
        case e.Algebra.expressionTypes.OPERATOR:
          return (0, t.uniqTerms)(c.args.flatMap((s) => this.getExpressionVariables(s)));
        case e.Algebra.expressionTypes.TERM:
          return c.term.termType === "Variable" ? [c.term] : [];
      }
    }
    getOverlappingOperations(c, s) {
      const d = [], l = [], f = [];
      for (const h of c.input) {
        const p = e.Util.inScopeVariables(h);
        this.variablesSubSetOf(s, p) ? d.push(h) : this.variablesIntersect(s, p) ? l.push(h) : f.push(h);
      }
      return {
        fullyOverlapping: d,
        partiallyOverlapping: l,
        notOverlapping: f
      };
    }
    /**
     * Recursively push down the given expression into the given operation if possible.
     * Different operators have different semantics for choosing whether or not to push down,
     * and how this pushdown is done.
     * For every passed operator, it is checked whether or not the filter will have any effect on the operation.
     * If not, the filter is voided.
     * @param expression An expression to push down.
     * @param expressionVariables The variables inside the given expression.
     * @param operation The operation to push down into.
     * @param factory An algebra factory.
     * @param context The action context.
     * @return A tuple indicating if the operation was modified and the modified operation.
     */
    filterPushdown(c, s, d, l, f) {
      if (this.isExpressionFalse(c))
        return [!0, l.createUnion([])];
      if (c.type === e.Algebra.types.EXPRESSION && c.expressionType === e.Algebra.expressionTypes.EXISTENCE)
        return [!1, l.createFilter(d, c)];
      switch (d.type) {
        case e.Algebra.types.EXTEND:
          return this.variablesIntersect([d.variable], s) ? [!1, l.createFilter(d, c)] : [!0, l.createExtend(this.filterPushdown(c, s, d.input, l, f)[1], d.variable, d.expression)];
        case e.Algebra.types.FILTER: {
          const [h, p] = this.filterPushdown(c, s, d.input, l, f);
          return [h, l.createFilter(p, d.expression)];
        }
        case e.Algebra.types.JOIN: {
          if (d.input.length === 0)
            return [!1, l.createFilter(d, c)];
          const { fullyOverlapping: h, partiallyOverlapping: p, notOverlapping: b } = this.getOverlappingOperations(d, s), _ = [];
          let y = !1;
          return h.length > 0 && (y = !0, _.push(l.createJoin(h.map((m) => this.filterPushdown(c, s, m, l, f)[1])))), p.length > 0 && _.push(l.createFilter(l.createJoin(p, !1), c)), b.length > 0 && _.push(...b), _.length > 1 && (y = !0), y && this.logDebug(f, `Push down filter across join entries with ${h.length} fully overlapping, ${p.length} partially overlapping, and ${b.length} not overlapping`), [y, _.length === 1 ? _[0] : l.createJoin(_)];
        }
        case e.Algebra.types.NOP:
          return [!0, d];
        case e.Algebra.types.PROJECT:
          return this.variablesIntersect(d.variables, s) ? [!0, l.createProject(this.filterPushdown(c, s, d.input, l, f)[1], d.variables)] : [!0, d];
        case e.Algebra.types.UNION: {
          const { fullyOverlapping: h, partiallyOverlapping: p, notOverlapping: b } = this.getOverlappingOperations(d, s), _ = [];
          let y = !1;
          return h.length > 0 && (y = !0, _.push(l.createUnion(h.map((m) => this.filterPushdown(c, s, m, l, f)[1])))), p.length > 0 && _.push(l.createFilter(l.createUnion(p, !1), c)), b.length > 0 && _.push(...b), _.length > 1 && (y = !0), y && this.logDebug(f, `Push down filter across union entries with ${h.length} fully overlapping, ${p.length} partially overlapping, and ${b.length} not overlapping`), [y, _.length === 1 ? _[0] : l.createUnion(_)];
        }
        case e.Algebra.types.VALUES:
          return this.variablesIntersect(d.variables, s) ? [!1, l.createFilter(d, c)] : [!0, d];
        case e.Algebra.types.LEFT_JOIN: {
          if (this.pushIntoLeftJoins) {
            const h = e.Util.inScopeVariables(d.input[1]);
            if (!this.variablesIntersect(s, h))
              return this.logDebug(f, "Push down filter into left join"), [!0, l.createLeftJoin(this.filterPushdown(c, s, d.input[0], l, f)[1], d.input[1], d.expression)];
          }
          return [!1, l.createFilter(d, c)];
        }
        case e.Algebra.types.PATTERN: {
          if (this.pushEqualityIntoPatterns) {
            const h = this.getEqualityExpressionPushableIntoPattern(c);
            if (h) {
              let p = !1;
              const b = d.metadata;
              if (d = (0, t.mapTermsNested)(d, (_) => _.equals(h.variable) ? (p = !0, h.term) : _), d.type = e.Algebra.types.PATTERN, d.metadata = b, p)
                return this.logDebug(f, `Push down filter into pattern for ?${h.variable.value}`), [!0, l.createJoin([
                  d,
                  l.createValues([h.variable], [{ [`?${h.variable.value}`]: h.term }])
                ])];
            }
          }
          return [!1, l.createFilter(d, c)];
        }
        case e.Algebra.types.PATH: {
          if (this.pushEqualityIntoPatterns) {
            const h = this.getEqualityExpressionPushableIntoPattern(c);
            if (h && (d.subject.equals(h.variable) || d.object.equals(h.variable))) {
              this.logDebug(f, `Push down filter into path for ?${h.variable.value}`);
              const p = d.metadata;
              return d = l.createPath(d.subject.equals(h.variable) ? h.term : d.subject, d.predicate, d.object.equals(h.variable) ? h.term : d.object), d.metadata = p, [!0, l.createJoin([
                d,
                l.createValues([h.variable], [{ [`?${h.variable.value}`]: h.term }])
              ])];
            }
          }
          return [!1, l.createFilter(d, c)];
        }
        case e.Algebra.types.MINUS:
        case e.Algebra.types.ALT:
        case e.Algebra.types.ASK:
        case e.Algebra.types.BGP:
        case e.Algebra.types.CONSTRUCT:
        case e.Algebra.types.DESCRIBE:
        case e.Algebra.types.DISTINCT:
        case e.Algebra.types.EXPRESSION:
        case e.Algebra.types.FROM:
        case e.Algebra.types.GRAPH:
        case e.Algebra.types.GROUP:
        case e.Algebra.types.INV:
        case e.Algebra.types.LINK:
        case e.Algebra.types.NPS:
        case e.Algebra.types.ONE_OR_MORE_PATH:
        case e.Algebra.types.ORDER_BY:
        case e.Algebra.types.REDUCED:
        case e.Algebra.types.SEQ:
        case e.Algebra.types.SERVICE:
        case e.Algebra.types.SLICE:
        case e.Algebra.types.ZERO_OR_MORE_PATH:
        case e.Algebra.types.ZERO_OR_ONE_PATH:
        case e.Algebra.types.COMPOSITE_UPDATE:
        case e.Algebra.types.DELETE_INSERT:
        case e.Algebra.types.LOAD:
        case e.Algebra.types.CLEAR:
        case e.Algebra.types.CREATE:
        case e.Algebra.types.DROP:
        case e.Algebra.types.ADD:
        case e.Algebra.types.MOVE:
        case e.Algebra.types.COPY:
          return [!1, l.createFilter(d, c)];
      }
    }
    /**
     * Check if the given expression is a simple equals operation with one variable and one non-literal
     * (or literal with canonical lexical form) term that can be pushed into a pattern.
     * @param expression The current expression.
     * @return The variable and term to fill into the pattern, or undefined.
     */
    getEqualityExpressionPushableIntoPattern(c) {
      if (c.expressionType === e.Algebra.expressionTypes.OPERATOR && c.operator === "=") {
        if (c.args[0].expressionType === "term" && c.args[0].term.termType !== "Variable" && (c.args[0].term.termType !== "Literal" || this.isLiteralWithCanonicalLexicalForm(c.args[0].term)) && c.args[1].expressionType === "term" && c.args[1].term.termType === "Variable")
          return {
            variable: c.args[1].term,
            term: c.args[0].term
          };
        if (c.args[0].expressionType === "term" && c.args[0].term.termType === "Variable" && c.args[1].expressionType === "term" && c.args[1].term.termType !== "Variable" && (c.args[1].term.termType !== "Literal" || this.isLiteralWithCanonicalLexicalForm(c.args[1].term)))
          return {
            variable: c.args[0].term,
            term: c.args[1].term
          };
      }
    }
    /**
     * Check if the given term is a literal with datatype that where all values
     * can only have one possible lexical representation.
     * In other words, no variants of values exist that should be considered equal.
     * For example: "01"^xsd:number and "1"^xsd:number will return false.
     * @param term An RDF term.
     * @protected
     */
    isLiteralWithCanonicalLexicalForm(c) {
      if (c.termType === "Literal")
        switch (c.datatype.value) {
          case "http://www.w3.org/2001/XMLSchema#string":
          case "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString":
          case "http://www.w3.org/2001/XMLSchema#normalizedString":
          case "http://www.w3.org/2001/XMLSchema#anyURI":
          case "http://www.w3.org/2001/XMLSchema#base64Binary":
          case "http://www.w3.org/2001/XMLSchema#language":
          case "http://www.w3.org/2001/XMLSchema#Name":
          case "http://www.w3.org/2001/XMLSchema#NCName":
          case "http://www.w3.org/2001/XMLSchema#NMTOKEN":
          case "http://www.w3.org/2001/XMLSchema#token":
          case "http://www.w3.org/2001/XMLSchema#hexBinary":
            return !0;
        }
      return !1;
    }
    /**
     * Check if there is an overlap between the two given lists of variables.
     * @param varsA A list of variables.
     * @param varsB A list of variables.
     */
    variablesIntersect(c, s) {
      return c.some((d) => s.some((l) => d.equals(l)));
    }
    /**
     * Check if all variables from the first list are included in the second list.
     * The second list may contain other variables as well.
     * @param varsNeedles A list of variables to search for.
     * @param varsHaystack A list of variables to search in.
     */
    variablesSubSetOf(c, s) {
      return c.length <= s.length && c.every((d) => s.some((l) => d.equals(l)));
    }
    /**
     * Check if an expression is simply 'false'.
     * @param expression An expression.
     */
    isExpressionFalse(c) {
      return c.term && c.term.termType === "Literal" && c.term.value === "false";
    }
    /**
     * Get all directly nested filter expressions.
     * As soon as a non-filter is found, it is returned as the input field.
     * @param op A filter expression.
     */
    getNestedFilterExpressions(c) {
      if (c.input.type === e.Algebra.types.FILTER) {
        const s = this.getNestedFilterExpressions(c.input);
        return { nestedExpressions: [c.expression, ...s.nestedExpressions], input: s.input };
      }
      return { nestedExpressions: [c.expression], input: c.input };
    }
  };
  return Ev.ActorOptimizeQueryOperationFilterPushdown = n, Ev;
}
var mG;
function fye() {
  return mG || (mG = 1, function(u) {
    var r = Pl && Pl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Pl && Pl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ lye(), u);
  }(Pl)), Pl;
}
var Dl = {}, Ov = {}, Ll = {}, vG;
function OZ() {
  if (vG) return Ll;
  vG = 1, Object.defineProperty(Ll, "__esModule", { value: !0 }), Ll.ActorDereferenceHttpBase = Ll.mediaTypesToAcceptString = void 0;
  const u = /* @__PURE__ */ F8(), r = /* @__PURE__ */ Aa(), o = /* @__PURE__ */ _e(), a = gh(), t = Tr(), e = /^[^ ;]*/u;
  function n(c, s) {
    const d = "*/*;q=0.1", l = [], f = Object.entries(c).map(([p, b]) => ({ mediaType: p, priority: b })).sort((p, b) => b.priority === p.priority ? p.mediaType.localeCompare(b.mediaType) : b.priority - p.priority);
    let h = f.length - 1;
    for (const { mediaType: p, priority: b } of f) {
      const _ = p + (b === 1 ? "" : `;q=${b.toFixed(3).replace(/0*$/u, "")}`);
      if (h + _.length > s) {
        for (; h + d.length > s; ) {
          const y = l.pop() ?? "";
          h -= y.length + 1;
        }
        l.push(d);
        break;
      }
      l.push(_), h += _.length;
    }
    return l.length === 0 ? "*/*" : l.join(",");
  }
  Ll.mediaTypesToAcceptString = n;
  let i = class extends u.ActorDereference {
    constructor(s) {
      super(s);
    }
    async test({ url: s }) {
      return /^https?:/u.test(s) ? (0, o.passTestVoid)() : (0, o.failTest)(`Cannot retrieve ${s} because it is not an HTTP(S) URL.`);
    }
    async run(s) {
      var y, m;
      let d = !0;
      const l = new Headers(s.headers);
      l.append("Accept", n(await ((y = s.mediaTypes) == null ? void 0 : y.call(s)) ?? {}, this.getMaxAcceptHeaderLength()));
      let f;
      const h = Date.now();
      try {
        f = await this.mediatorHttp.mediate({
          context: s.context,
          init: { headers: l, method: s.method },
          input: s.url
        });
      } catch (g) {
        return this.handleDereferenceErrors(s, g);
      }
      const p = (0, t.resolve)(f.url, s.url), b = Date.now() - h;
      if (f.status !== 200) {
        d = !1;
        const g = f.body ? await (0, a.stringify)(r.ActorHttp.toNodeReadable(f.body)) : "empty response";
        if (!s.acceptErrors) {
          const T = new Error(`Could not retrieve ${s.url} (HTTP status ${f.status}):
${g}`);
          return this.handleDereferenceErrors(s, T, f.headers, b);
        }
      }
      const _ = (m = e.exec(f.headers.get("content-type") ?? "")) == null ? void 0 : m[0];
      return {
        url: p,
        data: d ? r.ActorHttp.toNodeReadable(f.body) : (0, u.emptyReadable)(),
        exists: d,
        requestTime: b,
        headers: f.headers,
        mediaType: _ === "text/plain" ? void 0 : _
      };
    }
  };
  return Ll.ActorDereferenceHttpBase = i, Ll;
}
var TG;
function hye() {
  if (TG) return Ov;
  TG = 1, Object.defineProperty(Ov, "__esModule", { value: !0 }), Ov.ActorDereferenceHttp = void 0;
  const u = /* @__PURE__ */ OZ();
  class r extends u.ActorDereferenceHttpBase {
    getMaxAcceptHeaderLength() {
      return this.maxAcceptHeaderLengthBrowser;
    }
  }
  return Ov.ActorDereferenceHttp = r, Ov;
}
var wG;
function pye() {
  return wG || (wG = 1, function(u) {
    var r = Dl && Dl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Dl && Dl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ hye(), u), o(/* @__PURE__ */ OZ(), u);
  }(Dl)), Dl;
}
var jl = {}, xv = {}, SG;
function bye() {
  if (SG) return xv;
  SG = 1, Object.defineProperty(xv, "__esModule", { value: !0 }), xv.ActorHttpProxy = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class extends u.ActorHttp {
    constructor(e) {
      super(e);
    }
    async test(e) {
      const n = e.context.get(r.KeysHttpProxy.httpProxyHandler);
      return n ? await n.getProxy(e) ? (0, o.passTest)({ time: Number.POSITIVE_INFINITY }) : (0, o.failTest)(`Actor ${this.name} could not determine a proxy for the given request.`) : (0, o.failTest)(`Actor ${this.name} could not find a proxy handler in the context.`);
    }
    async run(e) {
      const n = typeof e.input == "string" ? e.input : e.input.url, i = e.context.get(r.KeysHttpProxy.httpProxyHandler), c = await this.mediatorHttp.mediate({
        ...await i.getProxy(e),
        context: e.context.delete(r.KeysHttpProxy.httpProxyHandler)
      });
      return Object.defineProperty(c, "url", {
        configurable: !0,
        enumerable: !0,
        get: () => c.headers.get("x-final-url") ?? n
      }), c;
    }
  };
  return xv.ActorHttpProxy = a, xv;
}
var Iv = {}, AG;
function yye() {
  if (AG) return Iv;
  AG = 1, Object.defineProperty(Iv, "__esModule", { value: !0 }), Iv.ProxyHandlerStatic = void 0;
  let u = class {
    constructor(o) {
      this.prefixUrl = o;
    }
    async getProxy(o) {
      return {
        init: o.init,
        input: this.modifyInput(o.input)
      };
    }
    modifyInput(o) {
      return typeof o == "string" ? this.prefixUrl + o : new Request(this.prefixUrl + o.url, o);
    }
  };
  return Iv.ProxyHandlerStatic = u, Iv;
}
var EG;
function _ye() {
  return EG || (EG = 1, function(u) {
    var r = jl && jl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = jl && jl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ bye(), u), o(/* @__PURE__ */ yye(), u);
  }(jl)), jl;
}
var Ml = {}, Rv = {}, OG;
function gye() {
  if (OG) return Rv;
  OG = 1, Object.defineProperty(Rv, "__esModule", { value: !0 }), Rv.ActorContextPreprocessQuerySourceIdentify = void 0;
  const u = /* @__PURE__ */ Tw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ fh();
  let t = class extends u.ActorContextPreprocess {
    constructor(n) {
      super(n), this.cache = this.cacheSize ? new a.LRUCache({ max: this.cacheSize }) : void 0;
      const i = this.cache;
      i && this.httpInvalidator.addInvalidateListener(({ url: c }) => c ? i.delete(c) : i.clear());
    }
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      let i = n.context;
      if (i.has(r.KeysInitQuery.querySourcesUnidentified)) {
        const c = n.context.get(r.KeysInitQuery.querySourcesUnidentified), s = await Promise.all(c.map((f) => this.expandSource(f))), d = await Promise.all(s.map(async (f) => this.identifySource(f, n.context))), l = n.context.get(r.KeysStatistics.dereferencedLinks);
        if (l)
          for (const f of d)
            l.updateStatistic({
              url: f.source.referenceValue,
              metadata: {
                seed: !0
              }
            }, f.source);
        i = n.context.delete(r.KeysInitQuery.querySourcesUnidentified).set(r.KeysQueryOperation.querySources, d);
      }
      return { context: i };
    }
    async expandSource(n) {
      return typeof n == "string" || "match" in n ? { value: n } : {
        ...n,
        context: (await this.mediatorContextPreprocess.mediate({
          context: o.ActionContext.ensureActionContext(n.context ?? {})
        })).context
      };
    }
    identifySource(n, i) {
      let c;
      return typeof n.value == "string" && this.cache && (c = this.cache.get(n.value)), c || (c = this.mediatorQuerySourceIdentify.mediate({ querySourceUnidentified: n, context: i }).then(({ querySource: s }) => s), typeof n.value == "string" && this.cache && this.cache.set(n.value, c)), c;
    }
  };
  return Rv.ActorContextPreprocessQuerySourceIdentify = t, Rv;
}
var xG;
function mye() {
  return xG || (xG = 1, function(u) {
    var r = Ml && Ml.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ml && Ml.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ gye(), u);
  }(Ml)), Ml;
}
var Cl = {}, Fv = {}, IG;
function vye() {
  if (IG) return Fv;
  IG = 1, Object.defineProperty(Fv, "__esModule", { value: !0 }), Fv.ActorRdfUpdateQuadsHypermedia = void 0;
  const u = /* @__PURE__ */ V8(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ fh();
  let a = class extends u.ActorRdfUpdateQuadsDestination {
    constructor(e) {
      super(e), this.cache = this.cacheSize ? new o.LRUCache({ max: this.cacheSize }) : void 0;
      const n = this.cache;
      n && this.httpInvalidator.addInvalidateListener(({ url: i }) => i ? n.delete(i) : n.clear());
    }
    async test(e) {
      return (0, u.getContextDestinationUrl)((0, u.getContextDestination)(e.context)) ? (0, r.passTestVoid)() : (0, r.failTest)(`Actor ${this.name} can only update quads against a single destination URL.`);
    }
    getDestination(e) {
      const n = (0, u.getContextDestination)(e);
      let i = (0, u.getContextDestinationUrl)(n);
      if (this.cache && this.cache.has(i))
        return this.cache.get(i);
      const c = (async () => {
        var f;
        let s, d;
        try {
          const h = await this.mediatorDereferenceRdf.mediate({ context: e, url: i, acceptErrors: !0 });
          d = h.exists, i = h.url;
          const p = await this.mediatorMetadata.mediate({ context: e, url: i, quads: h.data, triples: (f = h.metadata) == null ? void 0 : f.triples });
          s = (await this.mediatorMetadataExtract.mediate({
            context: e,
            url: i,
            metadata: p.metadata,
            headers: h.headers,
            requestTime: h.requestTime
          })).metadata;
        } catch {
          s = {}, d = !1;
        }
        const { destination: l } = await this.mediatorRdfUpdateHypermedia.mediate({
          context: e,
          url: i,
          metadata: s,
          exists: d,
          forceDestinationType: (0, u.getDataDestinationType)(n)
        });
        return l;
      })();
      return this.cache && this.cache.set(i, c), c;
    }
  };
  return Fv.ActorRdfUpdateQuadsHypermedia = a, Fv;
}
var RG;
function Tye() {
  return RG || (RG = 1, function(u) {
    var r = Cl && Cl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Cl && Cl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ vye(), u);
  }(Cl)), Cl;
}
var ql = {}, Nv = {}, FG;
function wye() {
  if (FG) return Nv;
  FG = 1, Object.defineProperty(Nv, "__esModule", { value: !0 }), Nv.ActionObserverHttp = void 0;
  const u = /* @__PURE__ */ _e();
  class r extends u.ActionObserver {
    /* eslint-disable max-len */
    /**
     * @param args - @defaultNested {<npmd:@comunica/bus-http/^4.0.0/components/ActorHttp.jsonld#ActorHttp_default_bus>} bus
     */
    constructor(a) {
      super(a), this.requests = 0, this.bus.subscribeObserver(this), this.httpInvalidator.addInvalidateListener(() => {
        this.requests = 0;
      });
    }
    /* eslint-enable max-len */
    onRun(a, t, e) {
      this.observedActors.includes(a.name) && this.requests++;
    }
  }
  return Nv.ActionObserverHttp = r, Nv;
}
var Pv = {}, NG;
function Sye() {
  if (NG) return Pv;
  NG = 1, Object.defineProperty(Pv, "__esModule", { value: !0 }), Pv.ActorQueryResultSerializeSparqlJson = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ yt(), a = Bt();
  let t = class AT extends u.ActorQueryResultSerializeFixedMediaTypes {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/sparql-results+json": 0.8
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/sparql-results+json": "http://www.w3.org/ns/formats/SPARQL_Results_JSON"
     *     }} mediaTypeFormats
     *   \ @defaultNested {true} emitMetadata
     *   \ @defaultNested {<default_observer> a <caqrssj:components/ActionObserverHttp.jsonld#ActionObserverHttp>} httpObserver
     */
    constructor(n) {
      super(n);
    }
    /* eslint-enable max-len */
    /**
     * Converts an RDF term to its JSON representation.
     * @param {RDF.Term} value An RDF term.
     * @return {any} A JSON object.
     */
    static bindingToJsonBindings(n) {
      if (n.termType === "Literal") {
        const i = n, c = { value: i.value, type: "literal" }, { language: s, datatype: d } = i;
        return s ? c["xml:lang"] = s : d && d.value !== "http://www.w3.org/2001/XMLSchema#string" && (c.datatype = d.value), c;
      }
      return n.termType === "BlankNode" ? { value: n.value, type: "bnode" } : n.termType === "Quad" ? {
        value: {
          subject: AT.bindingToJsonBindings(n.subject),
          predicate: AT.bindingToJsonBindings(n.predicate),
          object: AT.bindingToJsonBindings(n.object)
        },
        type: "triple"
      } : { value: n.value, type: "uri" };
    }
    async testHandleChecked(n, i) {
      return ["bindings", "boolean"].includes(n.type) ? (0, r.passTestVoid)() : (0, r.failTest)("This actor can only handle bindings streams or booleans.");
    }
    async runHandle(n, i, c) {
      const s = new a.Readable(), d = {};
      if (n.type === "bindings") {
        const l = await n.metadata();
        l.variables.length > 0 && (d.vars = l.variables.map((f) => f.variable.value));
      }
      if (s.push(`{"head": ${JSON.stringify(d)},
`), n.type === "bindings") {
        const l = n.bindingsStream;
        s.push(`"results": { "bindings": [
`);
        let f = !0;
        function* h(p) {
          yield p();
        }
        s.wrap(
          // JSON SPARQL results spec does not allow unbound variables and blank node bindings
          (0, o.wrap)(l).map((p) => {
            const b = `${f ? "" : `,
`}${JSON.stringify(Object.fromEntries([...p].map(([_, y]) => [_.value, AT.bindingToJsonBindings(y)])))}`;
            return f = !1, b;
          }).append((0, o.wrap)(h(() => `
]}${this.emitMetadata ? `,
"metadata": { "httpRequests": ${this.httpObserver.requests} }` : ""}}
`)))
        );
      } else
        s.wrap((0, o.wrap)(n.execute().then((l) => [`"boolean":${l}
}
`])));
      return { data: s };
    }
  };
  return Pv.ActorQueryResultSerializeSparqlJson = t, Pv;
}
var PG;
function DG() {
  return PG || (PG = 1, function(u) {
    var r = ql && ql.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ql && ql.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ wye(), u), o(/* @__PURE__ */ Sye(), u);
  }(ql)), ql;
}
var Bl = {}, Dv = {}, LG;
function Aye() {
  if (LG) return Dv;
  LG = 1, Object.defineProperty(Dv, "__esModule", { value: !0 }), Dv.ActionObserverHttp = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.ActionObserver {
    /* eslint-disable max-len */
    /**
     * @param args - @defaultNested {<npmd:@comunica/bus-http/^4.0.0/components/ActorHttp.jsonld#ActorHttp_default_bus>} bus
     */
    constructor(a) {
      super(a), this.requests = 0, this.bus.subscribeObserver(this), this.httpInvalidator.addInvalidateListener(() => {
        this.requests = 0;
      });
    }
    /* eslint-enable max-len */
    onRun(a, t, e) {
      this.observedActors.includes(a.name) && this.requests++;
    }
  };
  return Dv.ActionObserverHttp = r, Dv;
}
var Lv = {}, jG;
function Eye() {
  if (jG) return Lv;
  jG = 1, Object.defineProperty(Lv, "__esModule", { value: !0 }), Lv.ActorQueryResultSerializeStats = void 0;
  const u = /* @__PURE__ */ Ci(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ yt(), t = Bt();
  let e = class extends u.ActorQueryResultSerializeFixedMediaTypes {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {{ "stats": 0.5 }} mediaTypePriorities
     *   \ @defaultNested {{ "stats": "https://comunica.linkeddatafragments.org/#results_stats" }} mediaTypeFormats
     *   \ @defaultNested {<default_observer> a <caqrsst:components/ActionObserverHttp.jsonld#ActionObserverHttp>} httpObserver
     */
    constructor(i) {
      super(i);
    }
    /* eslint-enable max-len */
    async testHandleChecked(i, c) {
      return ["bindings", "quads"].includes(i.type) ? (0, o.passTestVoid)() : (0, o.failTest)("This actor can only handle bindings streams or quad streams.");
    }
    pushHeader(i) {
      const c = [
        "Result",
        "Delay (ms)",
        "HTTP requests"
      ].join(",");
      i.push(`${c}
`);
    }
    createStat(i, c) {
      return `${[
        c,
        this.delay(i),
        this.httpObserver.requests
      ].join(",")}
`;
    }
    createSpecialLine(i, c) {
      return `${[
        i,
        this.delay(c),
        this.httpObserver.requests
      ].join(",")}
`;
    }
    async runHandle(i, c, s) {
      const d = new t.Readable(), l = i.type === "bindings" ? i.bindingsStream : i.quadStream, f = i.context.getSafe(r.KeysInitQuery.queryTimestampHighResolution);
      let h = 1;
      function* p(_) {
        yield _();
      }
      const b = (0, a.wrap)(l).map(() => this.createStat(f, h++)).prepend([this.createSpecialLine("PLANNING", f)]).append((0, a.wrap)(p(() => this.createSpecialLine("TOTAL", f))));
      return this.pushHeader(d), d.wrap(b), { data: d };
    }
    now() {
      return performance.now();
    }
    delay(i) {
      return this.now() - i;
    }
  };
  return Lv.ActorQueryResultSerializeStats = e, Lv;
}
var MG;
function CG() {
  return MG || (MG = 1, function(u) {
    var r = Bl && Bl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Bl && Bl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Aye(), u), o(/* @__PURE__ */ Eye(), u);
  }(Bl)), Bl;
}
var $l = {}, jv = {}, Ul = {}, Mv = {}, qG;
function Oye() {
  if (qG) return Mv;
  qG = 1, Object.defineProperty(Mv, "__esModule", { value: !0 }), Mv.ActorQuerySourceIdentifyHypermedia = void 0;
  const u = /* @__PURE__ */ _e();
  class r extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query source hypermedia identification failed: none of the configured actors were able to identify ${action.url}} busFailMessage
     * @param sourceType The source type.
     */
    /* eslint-enable max-len */
    constructor(a, t) {
      super(a), this.sourceType = t;
    }
    async test(a) {
      return a.forceSourceType && this.sourceType !== a.forceSourceType ? (0, u.failTest)(`Actor ${this.name} is not able to handle source type ${a.forceSourceType}.`) : this.testMetadata(a);
    }
  }
  return Mv.ActorQuerySourceIdentifyHypermedia = r, Mv;
}
var BG;
function J8() {
  return BG || (BG = 1, function(u) {
    var r = Ul && Ul.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ul && Ul.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Oye(), u);
  }(Ul)), Ul;
}
var Cv = {}, Vl = {}, qv = {}, $G;
function xye() {
  if ($G) return qv;
  $G = 1, Object.defineProperty(qv, "__esModule", { value: !0 }), qv.ActorQuerySourceIdentify = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query source identification failed: none of the configured actors were able to identify ${action.querySourceUnidentified.value}} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return qv.ActorQuerySourceIdentify = r, qv;
}
var Sr = {}, UG;
function Iye() {
  if (UG) return Sr;
  UG = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.filterMatchingQuotedQuads = Sr.quadsOrderToBindingsOrder = Sr.quadsMetadataToBindingsMetadata = Sr.setMetadata = Sr.getDuplicateElementLinks = Sr.getVariables = Sr.isTermVariable = Sr.quadsToBindings = void 0;
  const u = /* @__PURE__ */ uu(), r = /* @__PURE__ */ Rr(), o = lr(), a = zn(), t = VK();
  function e(h, p, b, _, y) {
    const m = i(p), g = p.graph.termType === "Variable" && !y, T = c(p), v = (0, a.reduceTermsNested)(p, (L, A, w) => (A.termType === "Variable" && (L[w.join("_")] = A.value), L), {});
    let E = h;
    g && (E = E.filter((L) => L.graph.termType !== "DefaultGraph")), T && (E = E.filter((L) => {
      for (const A in T) {
        const w = A.split("_"), S = (0, a.getValueNestedPath)(L, w);
        for (const O of T[A])
          if (!S.equals((0, a.getValueNestedPath)(L, O)))
            return !1;
      }
      return !0;
    }));
    const R = new u.ClosableIterator(E.map((L) => _.bindings(Object.keys(v).map((A) => {
      const w = A.split("_"), S = v[A], O = (0, a.getValueNestedPath)(L, w);
      return [b.variable(S), O];
    }))), {
      onClose: () => h.destroy()
    });
    return s(b, R, h, v, m, g || !!T), R;
  }
  Sr.quadsToBindings = e;
  function n(h) {
    return h.termType === "Variable";
  }
  Sr.isTermVariable = n;
  function i(h) {
    return (0, a.uniqTerms)((0, a.getTermsNested)(h).filter(n));
  }
  Sr.getVariables = i;
  function c(h) {
    const p = {};
    let b = !1;
    if ((0, a.forEachTermsNested)(h, (y, m) => {
      if (y.termType === "Variable") {
        const g = (0, o.termToString)(y), T = (p[g] || (p[g] = [])).push(m);
        b = b || T > 1;
      }
    }), !b)
      return;
    const _ = {};
    for (const y in p) {
      const m = p[y], g = m.slice(1);
      g.length > 0 && (_[m[0].join("_")] = g);
    }
    return _;
  }
  Sr.getDuplicateElementLinks = c;
  function s(h, p, b, _, y, m) {
    const g = (v) => {
      m && (v.cardinality.type = "estimate"), p.setProperty("metadata", d(h, (0, r.validateMetadataQuads)(v), _, y)), v.state && v.state.addInvalidateListener(() => {
        s(h, p, b, _, y, m);
      });
    }, T = b.getProperty("metadata");
    T ? g(T) : b.getProperty("metadata", g);
  }
  Sr.setMetadata = s;
  function d(h, p, b, _) {
    return {
      ...p,
      order: p.order ? l(h, p.order, b) : void 0,
      availableOrders: p.availableOrders ? p.availableOrders.map((y) => ({
        cost: y.cost,
        terms: l(h, y.terms, b)
      })) : void 0,
      variables: _.map((y) => ({ variable: y, canBeUndef: !1 }))
    };
  }
  Sr.quadsMetadataToBindingsMetadata = d;
  function l(h, p, b) {
    const _ = {};
    return p.map((y) => {
      const m = b[y.term];
      if (m && !_[m])
        return _[m] = !0, {
          term: h.variable(m),
          direction: y.direction
        };
    }).filter(Boolean);
  }
  Sr.quadsOrderToBindingsOrder = l;
  function f(h, p) {
    return (0, a.someTerms)(h, (b) => b.termType === "Quad") && (p = p.filter((b) => (0, t.matchPatternMappings)(b, h))), p;
  }
  return Sr.filterMatchingQuotedQuads = f, Sr;
}
var VG;
function Fw() {
  return VG || (VG = 1, function(u) {
    var r = Vl && Vl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Vl && Vl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ xye(), u), o(/* @__PURE__ */ Iye(), u);
  }(Vl)), Vl;
}
var QG;
function xZ() {
  if (QG) return Cv;
  QG = 1, Object.defineProperty(Cv, "__esModule", { value: !0 }), Cv.QuerySourceQpf = void 0;
  const u = /* @__PURE__ */ Fw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ Rr(), a = /* @__PURE__ */ yt(), t = lr(), e = Ow(), n = zn();
  let i = class {
    constructor(d, l, f, h, p, b, _, y, m, g, T, v, E, R) {
      if (this.referenceValue = T, this.mediatorMetadata = d, this.mediatorMetadataExtract = l, this.mediatorDereferenceRdf = f, this.dataFactory = h, this.algebraFactory = p, this.bindingsFactory = b, this.subjectUri = _, this.predicateUri = y, this.objectUri = m, this.graphUri = g, this.url = T, this.bindingsRestricted = E, this.cachedQuads = {}, this.searchForm = this.getSearchForm(v), this.defaultGraph = v.defaultGraph ? this.dataFactory.namedNode(v.defaultGraph) : void 0, R) {
        let L = (0, a.wrap)(R);
        this.defaultGraph && (L = this.reverseMapQuadsToDefaultGraph(L)), v = { ...v, state: new o.MetadataValidationState() }, L.setProperty("metadata", v), this.cacheQuads(L, this.dataFactory.variable(""), this.dataFactory.variable(""), this.dataFactory.variable(""), this.dataFactory.variable(""));
      }
      this.selectorShape = this.bindingsRestricted ? {
        type: "operation",
        operation: {
          operationType: "pattern",
          pattern: this.algebraFactory.createPattern(this.dataFactory.variable("s"), this.dataFactory.variable("p"), this.dataFactory.variable("o"), this.dataFactory.variable("g"))
        },
        variablesOptional: [
          this.dataFactory.variable("s"),
          this.dataFactory.variable("p"),
          this.dataFactory.variable("o"),
          this.dataFactory.variable("g")
        ],
        filterBindings: !0
      } : {
        type: "operation",
        operation: {
          operationType: "pattern",
          pattern: this.algebraFactory.createPattern(this.dataFactory.variable("s"), this.dataFactory.variable("p"), this.dataFactory.variable("o"), this.dataFactory.variable("g"))
        },
        variablesOptional: [
          this.dataFactory.variable("s"),
          this.dataFactory.variable("p"),
          this.dataFactory.variable("o"),
          this.dataFactory.variable("g")
        ]
      };
    }
    async getSelectorShape() {
      return this.selectorShape;
    }
    queryBindings(d, l, f) {
      if (d.type !== "pattern")
        throw new Error(`Attempted to pass non-pattern operation '${d.type}' to QuerySourceQpf`);
      const h = !!l.get(r.KeysQueryOperation.unionDefaultGraph);
      let p = this.match(d.subject, d.predicate, d.object, d.graph, h, l, f);
      return p = (0, u.filterMatchingQuotedQuads)(d, p), (0, u.quadsToBindings)(p, d, this.dataFactory, this.bindingsFactory, h);
    }
    /**
     * Get a first QPF search form.
     * @param {{[p: string]: any}} metadata A metadata object.
     * @return {ISearchForm} A search form, or null if none could be found.
     */
    getSearchForm(d) {
      if (!d.searchForms || !d.searchForms.values)
        return;
      const { searchForms: l } = d;
      for (const f of l.values)
        if (this.graphUri && this.subjectUri in f.mappings && this.predicateUri in f.mappings && this.objectUri in f.mappings && this.graphUri in f.mappings && Object.keys(f.mappings).length === 4 || this.subjectUri in f.mappings && this.predicateUri in f.mappings && this.objectUri in f.mappings && Object.keys(f.mappings).length === 3)
          return f;
    }
    /**
     * Create a QPF fragment IRI for the given quad pattern.
     * @param {ISearchForm} searchForm A search form.
     * @param {Term} subject A term.
     * @param {Term} predicate A term.
     * @param {Term} object A term.
     * @param {Term} graph A term.
     * @return {string} A URI.
     */
    createFragmentUri(d, l, f, h, p) {
      const b = {}, _ = [
        { uri: this.subjectUri, term: l },
        { uri: this.predicateUri, term: f },
        { uri: this.objectUri, term: h },
        { uri: this.graphUri, term: p }
      ];
      for (const y of _)
        y.uri && (this.bindingsRestricted || y.term.termType !== "Variable" && (y.term.termType !== "Quad" || (0, n.everyTermsNested)(y.term, (m) => m.termType !== "Variable"))) && (b[y.uri] = (0, t.termToString)(y.term));
      return d.getUri(b);
    }
    match(d, l, f, h, p, b, _) {
      let y = !1;
      if (h.termType === "DefaultGraph")
        if (this.defaultGraph)
          y = !0, h = this.defaultGraph;
        else if (Object.keys(this.searchForm.mappings).length === 4 && !this.defaultGraph)
          if (p)
            h = this.dataFactory.variable("g");
          else {
            const v = new a.ArrayIterator([], { autoStart: !1 });
            return v.setProperty("metadata", {
              state: new o.MetadataValidationState(),
              requestTime: 0,
              cardinality: { type: "exact", value: 0 },
              first: null,
              next: null,
              last: null
            }), v;
          }
        else Object.keys(this.searchForm.mappings).length === 3 && (h = this.dataFactory.variable("g"));
      if (!(_ != null && _.filterBindings)) {
        const v = this.getCachedQuads(d, l, f, h);
        if (v)
          return v;
      }
      const m = this;
      let g;
      const T = async function() {
        var A;
        let v = m.createFragmentUri(m.searchForm, d, l, f, h);
        _ != null && _.filterBindings && (v = await m.getBindingsRestrictedLink(d, l, f, h, v, _.filterBindings));
        const E = await m.mediatorDereferenceRdf.mediate({ context: b, url: v });
        v = E.url;
        const R = await m.mediatorMetadata.mediate({ context: b, url: v, quads: E.data, triples: (A = E.metadata) == null ? void 0 : A.triples }), { metadata: L } = await m.mediatorMetadataExtract.mediate({
          context: b,
          url: v,
          metadata: R.metadata,
          requestTime: E.requestTime
        });
        return g.setProperty("metadata", { ...L, state: new o.MetadataValidationState(), subsetOf: m.url }), R.data;
      }();
      return g = new a.TransformIterator(async () => {
        const v = await T, E = this.dataFactory.defaultGraph();
        let R = (0, a.wrap)(v).transform({
          filter(L) {
            return (0, n.matchPattern)(L, d, l, f, h) ? !0 : y && (0, n.matchPattern)(L, d, l, f, E);
          }
        });
        return (y || h.termType === "Variable") && (R = this.reverseMapQuadsToDefaultGraph(R)), R;
      }, { autoStart: !1 }), _ != null && _.filterBindings ? g : (this.cacheQuads(g, d, l, f, h), this.getCachedQuads(d, l, f, h));
    }
    /**
     * If we add bindings for brTPF, append it to the URL.
     * We have to hardcode this because brTPF doesn't expose a URL template for passing bindings.
     * @param subject The subject.
     * @param predicate The predicate.
     * @param object The object.
     * @param graph The graph.
     * @param url The original QPF URL.
     * @param filterBindings The bindings to restrict with.
     * @param filterBindings.bindings The bindings stream.
     * @param filterBindings.metadata The bindings metadata.
     * @protected
     */
    async getBindingsRestrictedLink(d, l, f, h, p, b) {
      const _ = [];
      for (const m of await b.bindings.toArray()) {
        const g = ["("];
        for (const T of b.metadata.variables) {
          const v = m.get(T.variable);
          g.push(v ? (0, e.termToString)(v) : "UNDEF"), g.push(" ");
        }
        g.push(")"), _.push(g.join(""));
      }
      _.length === 0 && _.push("(<ex:comunica:unknown>)");
      const y = encodeURIComponent(`(${b.metadata.variables.map((m) => `?${m.variable.value}`).join(" ")}) { ${_.join(" ")} }`);
      return `${p}&values=${y}`;
    }
    reverseMapQuadsToDefaultGraph(d) {
      const l = this.dataFactory.defaultGraph();
      return d.map((f) => (0, n.mapTerms)(f, (h, p) => p === "graph" && h.equals(this.defaultGraph) ? l : h));
    }
    getPatternId(d, l, f, h) {
      return JSON.stringify({
        s: d.termType === "Variable" ? "" : c(d),
        p: l.termType === "Variable" ? "" : c(l),
        o: f.termType === "Variable" ? "" : c(f),
        g: h.termType === "Variable" ? "" : c(h)
      });
    }
    cacheQuads(d, l, f, h, p) {
      const b = this.getPatternId(l, f, h, p);
      this.cachedQuads[b] = d.clone();
    }
    getCachedQuads(d, l, f, h) {
      const p = this.getPatternId(d, l, f, h), b = this.cachedQuads[p];
      if (b)
        return b.clone();
    }
    queryQuads(d, l) {
      throw new Error("queryQuads is not implemented in QuerySourceQpf");
    }
    queryBoolean(d, l) {
      throw new Error("queryBoolean is not implemented in QuerySourceQpf");
    }
    queryVoid(d, l) {
      throw new Error("queryVoid is not implemented in QuerySourceQpf");
    }
  };
  Cv.QuerySourceQpf = i;
  function c(s) {
    return s.termType === "DefaultGraph" ? (
      // Any character that cannot be present in a URL will do
      "|"
    ) : (0, t.termToString)(s);
  }
  return Cv;
}
var HG;
function Rye() {
  if (HG) return jv;
  HG = 1, Object.defineProperty(jv, "__esModule", { value: !0 }), jv.ActorQuerySourceIdentifyHypermediaQpf = void 0;
  const u = /* @__PURE__ */ J8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = ft(), e = /* @__PURE__ */ xZ();
  let n = class extends u.ActorQuerySourceIdentifyHypermedia {
    constructor(c) {
      super(c, "qpf");
    }
    async test(c) {
      return c.forceSourceType && c.forceSourceType !== "qpf" && c.forceSourceType !== "brtpf" ? (0, o.failTest)(`Actor ${this.name} is not able to handle source type ${c.forceSourceType}.`) : this.testMetadata(c);
    }
    async testMetadata(c) {
      const { searchForm: s } = await this.createSource(c.url, c.metadata, c.context, c.forceSourceType === "brtpf");
      return s ? c.handledDatasets && c.handledDatasets[s.dataset] ? (0, o.failTest)(`Actor ${this.name} can only be applied for the first page of a QPF dataset.`) : (0, o.passTest)({ filterFactor: 1 }) : (0, o.failTest)("Illegal state: found no TPF/QPF search form anymore in metadata.");
    }
    /**
     * Look for the search form
     * @param {IActionRdfResolveHypermedia} action the metadata to look for the form.
     * @return {Promise<IActorRdfResolveHypermediaOutput>} A promise resolving to a hypermedia form.
     */
    async run(c) {
      this.logInfo(c.context, `Identified as qpf source: ${c.url}`);
      const s = await this.createSource(c.url, c.metadata, c.context, c.forceSourceType === "brtpf", c.quads);
      return { source: s, dataset: s.searchForm.dataset };
    }
    async createSource(c, s, d, l, f) {
      const h = d.getSafe(r.KeysInitQuery.dataFactory), p = new t.Factory(h);
      return new e.QuerySourceQpf(this.mediatorMetadata, this.mediatorMetadataExtract, this.mediatorDereferenceRdf, h, p, await a.BindingsFactory.create(this.mediatorMergeBindingsContext, d, h), this.subjectUri, this.predicateUri, this.objectUri, this.graphUri, c, s, l, f);
    }
  };
  return jv.ActorQuerySourceIdentifyHypermediaQpf = n, jv;
}
var GG;
function Fye() {
  return GG || (GG = 1, function(u) {
    var r = $l && $l.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = $l && $l.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Rye(), u), o(/* @__PURE__ */ xZ(), u);
  }($l)), $l;
}
var Ql = {}, Bv = {}, $v = {}, zG;
function IZ() {
  if (zG) return $v;
  zG = 1, Object.defineProperty($v, "__esModule", { value: !0 }), $v.QuerySourceSparql = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ _e(), o = /* @__PURE__ */ Rr(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt(), e = /* @__PURE__ */ fZ(), n = /* @__PURE__ */ fh(), i = zn(), c = ft();
  let s = class Dn {
    constructor(l, f, h, p, b, _, y, m, g, T, v, E, R, L, A) {
      this.referenceValue = l, this.url = l, this.context = f, this.mediatorHttp = h, this.bindMethod = p, this.dataFactory = b, this.algebraFactory = _, this.bindingsFactory = y, this.endpointFetcher = new e.SparqlEndpointFetcher({
        method: m ? "GET" : "POST",
        fetch: (w, S) => this.mediatorHttp.mediate({ input: w, init: S, context: this.lastSourceContext }),
        prefixVariableQuestionMark: !0,
        dataFactory: b
      }), this.cache = g > 0 ? new n.LRUCache({ max: g }) : void 0, this.countTimeout = T, this.cardinalityCountQueries = v, this.cardinalityEstimateConstruction = E, this.defaultGraph = R, this.unionDefaultGraph = L ?? !1, this.datasets = A;
    }
    async getSelectorShape() {
      return Dn.SELECTOR_SHAPE;
    }
    queryBindings(l, f, h) {
      let p;
      h != null && h.joinBindings ? p = Dn.addBindingsToOperation(this.algebraFactory, this.bindMethod, l, h.joinBindings) : p = Promise.resolve(l);
      const b = new t.TransformIterator(async () => {
        const _ = await p, y = c.Util.inScopeVariables(_), m = f.get(u.KeysInitQuery.queryString), g = f.getSafe(u.KeysInitQuery.queryFormat), T = !(h != null && h.joinBindings) && m && g.language === "sparql" ? m : Dn.operationToSelectQuery(this.algebraFactory, _, y), v = Dn.getOperationUndefs(_);
        return this.queryBindingsRemote(this.url, T, y, f, v);
      }, { autoStart: !1 });
      return this.attachMetadata(b, f, p), b;
    }
    queryQuads(l, f) {
      this.lastSourceContext = this.context.merge(f);
      const h = this.endpointFetcher.fetchTriples(this.url, f.get(u.KeysInitQuery.queryString) ?? Dn.operationToQuery(l));
      this.lastSourceContext = void 0;
      const p = (0, t.wrap)(h, { autoStart: !1, maxBufferSize: Number.POSITIVE_INFINITY });
      return this.attachMetadata(p, f, Promise.resolve(l.input)), p;
    }
    queryBoolean(l, f) {
      this.lastSourceContext = this.context.merge(f);
      const h = this.endpointFetcher.fetchAsk(this.url, f.get(u.KeysInitQuery.queryString) ?? Dn.operationToQuery(l));
      return this.lastSourceContext = void 0, h;
    }
    queryVoid(l, f) {
      this.lastSourceContext = this.context.merge(f);
      const h = this.endpointFetcher.fetchUpdate(this.url, f.get(u.KeysInitQuery.queryString) ?? Dn.operationToQuery(l));
      return this.lastSourceContext = void 0, h;
    }
    attachMetadata(l, f, h) {
      let p = [];
      new Promise(async (b, _) => {
        var y, m;
        try {
          const g = await h, T = c.Util.inScopeVariables(g), v = this.operationToNormalizedCountQuery(g), E = Dn.getOperationUndefs(g);
          p = T.map((S) => ({
            variable: S,
            canBeUndef: E.some((O) => O.equals(S))
          }));
          const R = (y = this.cache) == null ? void 0 : y.get(v);
          if (R)
            return b(R);
          if (this.cardinalityEstimateConstruction) {
            const S = await this.estimateOperationCardinality(g);
            if (Number.isFinite(S.value))
              return (m = this.cache) == null || m.set(v, S), b(S);
          }
          if (!this.cardinalityCountQueries)
            return b({ type: "estimate", value: Number.POSITIVE_INFINITY, dataset: this.url });
          const L = setTimeout(() => b({
            type: "estimate",
            value: Number.POSITIVE_INFINITY,
            dataset: this.url
          }), this.countTimeout), A = this.dataFactory.variable("count"), w = await this.queryBindingsRemote(this.url, v, [A], f, []);
          w.on("data", (S) => {
            var F;
            clearTimeout(L);
            const O = S.get(A), x = {
              type: "estimate",
              value: Number.POSITIVE_INFINITY,
              dataset: this.url
            };
            if (O) {
              const j = Number.parseInt(O.value, 10);
              Number.isNaN(j) || (x.type = "exact", x.value = j, (F = this.cache) == null || F.set(v, x));
            }
            return b(x);
          }), w.on("error", () => {
            clearTimeout(L), b({ type: "estimate", value: Number.POSITIVE_INFINITY, dataset: this.url });
          }), w.on("end", () => {
            clearTimeout(L), b({ type: "estimate", value: Number.POSITIVE_INFINITY, dataset: this.url });
          });
        } catch (g) {
          return _(g);
        }
      }).then((b) => {
        l.setProperty("metadata", {
          state: new o.MetadataValidationState(),
          cardinality: b,
          variables: p
        });
      }).catch(() => l.setProperty("metadata", {
        state: new o.MetadataValidationState(),
        cardinality: { type: "estimate", value: Number.POSITIVE_INFINITY, dataset: this.url },
        variables: p
      }));
    }
    /**
     * Convert an algebra operation into a query string, and if the operation is a simple triple pattern,
     * then also replace any variables with s, p, and o to increase the chance of cache hits.
     * @param {Algebra.Operation} operation The operation to convert into a query string.
     * @returns {string} Query string for a COUNT query over the operation.
     */
    operationToNormalizedCountQuery(l) {
      const f = l.type === c.Algebra.types.PATTERN ? this.algebraFactory.createPattern(l.subject.termType === "Variable" ? this.dataFactory.variable("s") : l.subject, l.predicate.termType === "Variable" ? this.dataFactory.variable("p") : l.predicate, l.object.termType === "Variable" ? this.dataFactory.variable("o") : l.object) : l;
      return Dn.operationToCountQuery(this.dataFactory, this.algebraFactory, f);
    }
    /**
     * Performs local cardinality estimation for the specified SPARQL algebra operation, which should
     * result in better estimation performance at the expense of accuracy.
     * @param {Algebra.Operation} operation A query operation.
     */
    async estimateOperationCardinality(l) {
      const f = {
        getCardinality: (h) => {
          var _;
          const p = this.operationToNormalizedCountQuery(h), b = (_ = this.cache) == null ? void 0 : _.get(p);
          if (b)
            return b;
          if (this.datasets) {
            const y = this.datasets.filter((g) => this.unionDefaultGraph || this.defaultGraph && g.uri.endsWith(this.defaultGraph)).map((g) => (0, a.estimateCardinality)(h, g));
            return {
              type: y.some((g) => g.type === "estimate") ? "estimate" : "exact",
              value: y.length > 0 ? y.reduce((g, T) => g + T.value, 0) : 0,
              dataset: this.url
            };
          }
        },
        source: this.url,
        uri: this.url
      };
      return (0, a.estimateCardinality)(l, f);
    }
    /**
     * Create an operation that includes the bindings from the given bindings stream.
     * @param algebraFactory The algebra factory.
     * @param bindMethod A method for adding bindings to an operation.
     * @param operation The operation to bind to.
     * @param addBindings The bindings to add.
     * @param addBindings.bindings The bindings stream.
     * @param addBindings.metadata The bindings metadata.
     */
    static async addBindingsToOperation(l, f, h, p) {
      const b = await p.bindings.toArray();
      switch (f) {
        case "values":
          return l.createJoin([
            l.createValues(p.metadata.variables.map((_) => _.variable), b.map((_) => Object.fromEntries([..._].map(([y, m]) => [`?${y.value}`, m])))),
            h
          ], !1);
        case "union":
          throw new Error('Not implemented yet: "union" case');
        case "filter":
          throw new Error('Not implemented yet: "filter" case');
      }
    }
    /**
     * Convert an operation to a select query for this pattern.
     * @param algebraFactory The algebra factory.
     * @param {Algebra.Operation} operation A query operation.
     * @param {RDF.Variable[]} variables The variables in scope for the operation.
     * @return {string} A select query string.
     */
    static operationToSelectQuery(l, f, h) {
      return Dn.operationToQuery(l.createProject(f, h));
    }
    /**
     * Convert an operation to a count query for the number of matching triples for this pattern.
     * @param dataFactory The data factory.
     * @param algebraFactory The algebra factory.
     * @param {Algebra.Operation} operation A query operation.
     * @return {string} A count query string.
     */
    static operationToCountQuery(l, f, h) {
      return Dn.operationToQuery(f.createProject(f.createExtend(f.createGroup(h, [], [f.createBoundAggregate(l.variable("var0"), "count", f.createWildcardExpression(), !1)]), l.variable("count"), f.createTermExpression(l.variable("var0"))), [l.variable("count")]));
    }
    /**
     * Convert an operation to a query for this pattern.
     * @param {Algebra.Operation} operation A query operation.
     * @return {string} A query string.
     */
    static operationToQuery(l) {
      return (0, c.toSparql)(l, { sparqlStar: !0 });
    }
    /**
     * Check if the given operation may produce undefined values.
     * @param operation
     */
    static getOperationUndefs(l) {
      const f = [];
      return c.Util.recurseOperation(l, {
        leftjoin(h) {
          const p = c.Util.inScopeVariables(h.input[0]), b = c.Util.inScopeVariables(h.input[1]);
          for (const _ of b)
            p.some((y) => y.equals(_)) || f.push(_);
          return !1;
        },
        values(h) {
          for (const p of h.variables)
            h.bindings.some((b) => !(`?${p.value}` in b)) && f.push(p);
          return !1;
        },
        union(h) {
          const p = h.input.map(c.Util.inScopeVariables);
          for (const b of (0, i.uniqTerms)(p.flat()))
            p.every((_) => _.some((y) => y.equals(b))) || f.push(b);
          return !0;
        }
      }), (0, i.uniqTerms)(f);
    }
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @param {RDF.Variable[]} variables The expected variables.
     * @param {IActionContext} context The source context.
     * @param undefVariables Variables that may have undefs.
     * @return {BindingsStream} A stream of bindings.
     */
    async queryBindingsRemote(l, f, h, p, b) {
      const _ = /* @__PURE__ */ new Set();
      for (const m of b)
        _.add(m.value);
      this.lastSourceContext = this.context.merge(p);
      const y = await this.endpointFetcher.fetchBindings(l, f);
      return this.lastSourceContext = void 0, (0, t.wrap)(y, { autoStart: !1, maxBufferSize: Number.POSITIVE_INFINITY }).map((m) => this.bindingsFactory.bindings(h.map((g) => {
        var v;
        const T = m[`?${g.value}`];
        return !_.has(g.value) && !T && ((v = r.Actor.getContextLogger(this.context)) == null || v.warn(`The endpoint ${l} failed to provide a binding for ${g.value}.`)), [g, T];
      }).filter(([g, T]) => !!T)));
    }
    toString() {
      return `QuerySourceSparql(${this.url})`;
    }
  };
  return $v.QuerySourceSparql = s, s.SELECTOR_SHAPE = {
    type: "disjunction",
    children: [
      {
        type: "operation",
        operation: { operationType: "wildcard" },
        joinBindings: !0
      }
    ]
  }, $v;
}
var kG;
function Nye() {
  if (kG) return Bv;
  kG = 1, Object.defineProperty(Bv, "__esModule", { value: !0 }), Bv.ActorQuerySourceIdentifyHypermediaSparql = void 0;
  const u = /* @__PURE__ */ J8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = ft(), e = /* @__PURE__ */ IZ();
  let n = class extends u.ActorQuerySourceIdentifyHypermedia {
    constructor(c) {
      super(c, "sparql");
    }
    async testMetadata(c) {
      return !c.forceSourceType && !this.forceSourceType && !c.metadata.sparqlService && !(this.checkUrlSuffix && (c.url.endsWith("/sparql") || c.url.endsWith("/sparql/"))) ? (0, o.failTest)(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql.`) : (0, o.passTest)({ filterFactor: 1 });
    }
    async run(c) {
      var h;
      this.logInfo(c.context, `Identified ${c.url} as sparql source with service URL: ${c.metadata.sparqlService || c.url}`);
      const s = c.context.getSafe(r.KeysInitQuery.dataFactory), d = new t.Factory(s), l = ((h = c.context.get(r.KeysQueryOperation.querySources)) == null ? void 0 : h.length) === 1;
      return { source: new e.QuerySourceSparql(
        c.forceSourceType ?? this.forceSourceType ? c.url : c.metadata.sparqlService || c.url,
        c.context,
        this.mediatorHttp,
        this.bindMethod,
        s,
        d,
        await a.BindingsFactory.create(this.mediatorMergeBindingsContext, c.context, s),
        this.forceHttpGet,
        this.cacheSize,
        this.countTimeout,
        // Cardinalities can be infinity when we're querying just a single source.
        this.cardinalityCountQueries && !l,
        this.cardinalityEstimateConstruction,
        c.metadata.defaultGraph,
        c.metadata.unionDefaultGraph,
        c.metadata.datasets
      ) };
    }
  };
  return Bv.ActorQuerySourceIdentifyHypermediaSparql = n, Bv;
}
var XG;
function Pye() {
  return XG || (XG = 1, function(u) {
    var r = Ql && Ql.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ql && Ql.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Nye(), u), o(/* @__PURE__ */ IZ(), u);
  }(Ql)), Ql;
}
var Hl = {}, Uv = {}, Gl = {}, Vv = {}, Qv = {}, JG;
function RZ() {
  if (JG) return Qv;
  JG = 1, Object.defineProperty(Qv, "__esModule", { value: !0 }), Qv.QuerySourceRdfJs = void 0;
  const u = /* @__PURE__ */ Fw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ Rr(), a = /* @__PURE__ */ yt(), t = zn(), e = ft();
  let n = class hn {
    constructor(c, s, d) {
      this.source = c, this.referenceValue = c, this.dataFactory = s, this.bindingsFactory = d;
      const l = new e.Factory(this.dataFactory);
      this.selectorShape = {
        type: "operation",
        operation: {
          operationType: "pattern",
          pattern: l.createPattern(this.dataFactory.variable("s"), this.dataFactory.variable("p"), this.dataFactory.variable("o"))
        },
        variablesOptional: [
          this.dataFactory.variable("s"),
          this.dataFactory.variable("p"),
          this.dataFactory.variable("o")
        ]
      }, this.dummyDefaultGraph = this.dataFactory.variable("__comunica:defaultGraph");
    }
    static nullifyVariables(c, s) {
      return !c || c.termType === "Variable" || !s && c.termType === "Quad" && (0, t.someTermsNested)(c, (d) => d.termType === "Variable") ? void 0 : c;
    }
    static hasDuplicateVariables(c) {
      const s = (0, t.filterTermsNested)(c, (d) => d.termType === "Variable");
      return s.length > 1 && (0, t.uniqTerms)(s).length < s.length;
    }
    async getSelectorShape() {
      return this.selectorShape;
    }
    queryBindings(c, s) {
      var p;
      if (c.type !== "pattern")
        throw new Error(`Attempted to pass non-pattern operation '${c.type}' to QuerySourceRdfJs`);
      const d = !!s.get(r.KeysQueryOperation.unionDefaultGraph);
      if (c.graph.termType === "DefaultGraph" && d && (c.graph = this.dummyDefaultGraph), this.source.matchBindings) {
        const b = this.source.matchBindings(this.bindingsFactory, c.subject, c.predicate, c.object, c.graph);
        let _ = b instanceof a.AsyncIterator ? b : (0, a.wrap)(b, { autoStart: !1 }), y = !1;
        if (c.graph.termType === "Variable" && !d) {
          y = !0;
          const m = c.graph;
          _ = _.filter((g) => g.get(m).termType !== "DefaultGraph");
        }
        if (c.graph.equals(this.dummyDefaultGraph) && (_ = _.map((m) => m.delete(this.dummyDefaultGraph)), c.graph = this.dataFactory.defaultGraph()), !_.getProperty("metadata")) {
          const m = (0, u.getVariables)(c).map((g) => ({ variable: g, canBeUndef: !1 }));
          this.setMetadata(_, c, s, y, { variables: m }).catch((g) => _.destroy(g));
        }
        return _;
      }
      const l = !!((p = this.source.features) != null && p.quotedTripleFiltering), f = this.source.match(hn.nullifyVariables(c.subject, l), hn.nullifyVariables(c.predicate, l), hn.nullifyVariables(c.object, l), hn.nullifyVariables(c.graph, l));
      let h = f instanceof a.AsyncIterator ? f : (0, a.wrap)(f, { autoStart: !1 });
      return l || (h = (0, u.filterMatchingQuotedQuads)(c, h)), h.getProperty("metadata") || this.setMetadata(h, c, s).catch((b) => h.destroy(b)), c.graph.equals(this.dummyDefaultGraph) && (c.graph = this.dataFactory.defaultGraph()), (0, u.quadsToBindings)(h, c, this.dataFactory, this.bindingsFactory, !!s.get(r.KeysQueryOperation.unionDefaultGraph));
    }
    async setMetadata(c, s, d, l = !1, f = {}) {
      var y;
      const h = !!((y = this.source.features) != null && y.quotedTripleFiltering), p = !!d.get(r.KeysQueryOperation.unionDefaultGraph);
      s.graph.termType === "DefaultGraph" && p && (s.graph = this.dummyDefaultGraph);
      let b;
      if (this.source.countQuads)
        b = await this.source.countQuads(hn.nullifyVariables(s.subject, h), hn.nullifyVariables(s.predicate, h), hn.nullifyVariables(s.object, h), hn.nullifyVariables(s.graph, h));
      else {
        let m = 0;
        b = await new Promise((g, T) => {
          const v = this.source.match(hn.nullifyVariables(s.subject, h), hn.nullifyVariables(s.predicate, h), hn.nullifyVariables(s.object, h), hn.nullifyVariables(s.graph, h));
          v.on("error", T), v.on("end", () => g(m)), v.on("data", () => m++);
        });
      }
      const _ = !h && (0, t.someTerms)(s, (m) => m.termType === "Quad") || hn.hasDuplicateVariables(s);
      c.setProperty("metadata", {
        state: new o.MetadataValidationState(),
        cardinality: {
          type: _ || l ? "estimate" : "exact",
          value: b
        },
        // Force requestTime to zero, since this will be free for future calls, as we're fully indexed at this stage.
        requestTime: 0,
        ...f
      });
    }
    queryQuads(c, s) {
      throw new Error("queryQuads is not implemented in QuerySourceRdfJs");
    }
    queryBoolean(c, s) {
      throw new Error("queryBoolean is not implemented in QuerySourceRdfJs");
    }
    queryVoid(c, s) {
      throw new Error("queryVoid is not implemented in QuerySourceRdfJs");
    }
    toString() {
      return `QuerySourceRdfJs(${this.source.constructor.name})`;
    }
  };
  return Qv.QuerySourceRdfJs = n, Qv;
}
var KG;
function Dye() {
  if (KG) return Vv;
  KG = 1, Object.defineProperty(Vv, "__esModule", { value: !0 }), Vv.ActorQuerySourceIdentifyRdfJs = void 0;
  const u = /* @__PURE__ */ Fw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ RZ();
  let e = class extends u.ActorQuerySourceIdentify {
    constructor(i) {
      super(i);
    }
    async test(i) {
      const c = i.querySourceUnidentified;
      return c.type !== void 0 && c.type !== "rdfjs" ? (0, o.failTest)(`${this.name} requires a single query source with rdfjs type to be present in the context.`) : typeof c.value == "string" || !("match" in c.value) ? (0, o.failTest)(`${this.name} received an invalid rdfjs query source.`) : (0, o.passTestVoid)();
    }
    async run(i) {
      const c = i.context.getSafe(r.KeysInitQuery.dataFactory);
      return {
        querySource: {
          source: new t.QuerySourceRdfJs(i.querySourceUnidentified.value, c, await a.BindingsFactory.create(this.mediatorMergeBindingsContext, i.context, c)),
          context: i.querySourceUnidentified.context ?? new o.ActionContext()
        }
      };
    }
  };
  return Vv.ActorQuerySourceIdentifyRdfJs = e, Vv;
}
var SO = {}, WG;
function Lye() {
  return WG || (WG = 1, Object.defineProperty(SO, "__esModule", { value: !0 })), SO;
}
var YG;
function K8() {
  return YG || (YG = 1, function(u) {
    var r = Gl && Gl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Gl && Gl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Dye(), u), o(/* @__PURE__ */ Lye(), u), o(/* @__PURE__ */ RZ(), u);
  }(Gl)), Gl;
}
var z6 = {}, zl = {}, Hv = {}, Gv = {}, kl = {}, zv = {}, ZG;
function FZ() {
  if (ZG) return zv;
  ZG = 1, Object.defineProperty(zv, "__esModule", { value: !0 }), zv.BlankNode = void 0;
  class u {
    constructor(o) {
      this.termType = "BlankNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  }
  return zv.BlankNode = u, zv;
}
var kv = {}, Xv = {}, ez;
function NZ() {
  if (ez) return Xv;
  ez = 1, Object.defineProperty(Xv, "__esModule", { value: !0 }), Xv.DefaultGraph = void 0;
  class u {
    constructor() {
      this.termType = "DefaultGraph", this.value = "";
    }
    equals(o) {
      return !!o && o.termType === "DefaultGraph";
    }
  }
  return Xv.DefaultGraph = u, u.INSTANCE = new u(), Xv;
}
var Jv = {}, Kv = {}, tz;
function W8() {
  if (tz) return Kv;
  tz = 1, Object.defineProperty(Kv, "__esModule", { value: !0 }), Kv.NamedNode = void 0;
  class u {
    constructor(o) {
      this.termType = "NamedNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "NamedNode" && o.value === this.value;
    }
  }
  return Kv.NamedNode = u, Kv;
}
var rz;
function PZ() {
  if (rz) return Jv;
  rz = 1, Object.defineProperty(Jv, "__esModule", { value: !0 }), Jv.Literal = void 0;
  const u = W8();
  class r {
    constructor(a, t) {
      this.termType = "Literal", this.value = a, typeof t == "string" ? (this.language = t, this.datatype = r.RDF_LANGUAGE_STRING, this.direction = "") : t ? "termType" in t ? (this.language = "", this.datatype = t, this.direction = "") : (this.language = t.language, this.datatype = t.direction ? r.RDF_DIRECTIONAL_LANGUAGE_STRING : r.RDF_LANGUAGE_STRING, this.direction = t.direction || "") : (this.language = "", this.datatype = r.XSD_STRING, this.direction = "");
    }
    equals(a) {
      return !!a && a.termType === "Literal" && a.value === this.value && a.language === this.language && (a.direction === this.direction || !a.direction && this.direction === "") && this.datatype.equals(a.datatype);
    }
  }
  return Jv.Literal = r, r.RDF_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), r.RDF_DIRECTIONAL_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString"), r.XSD_STRING = new u.NamedNode("http://www.w3.org/2001/XMLSchema#string"), Jv;
}
var Wv = {}, nz;
function DZ() {
  if (nz) return Wv;
  nz = 1, Object.defineProperty(Wv, "__esModule", { value: !0 }), Wv.Quad = void 0;
  class u {
    constructor(o, a, t, e) {
      this.termType = "Quad", this.value = "", this.subject = o, this.predicate = a, this.object = t, this.graph = e;
    }
    equals(o) {
      return !!o && (o.termType === "Quad" || !o.termType) && this.subject.equals(o.subject) && this.predicate.equals(o.predicate) && this.object.equals(o.object) && this.graph.equals(o.graph);
    }
  }
  return Wv.Quad = u, Wv;
}
var Yv = {}, iz;
function LZ() {
  if (iz) return Yv;
  iz = 1, Object.defineProperty(Yv, "__esModule", { value: !0 }), Yv.Variable = void 0;
  class u {
    constructor(o) {
      this.termType = "Variable", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "Variable" && o.value === this.value;
    }
  }
  return Yv.Variable = u, Yv;
}
var az;
function jye() {
  if (az) return kv;
  az = 1, Object.defineProperty(kv, "__esModule", { value: !0 }), kv.DataFactory = void 0;
  const u = FZ(), r = NZ(), o = PZ(), a = W8(), t = DZ(), e = LZ();
  let n = 0;
  class i {
    constructor(s) {
      this.blankNodeCounter = 0, s = s || {}, this.blankNodePrefix = s.blankNodePrefix || `df_${n++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(s) {
      return new a.NamedNode(s);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(s) {
      return new u.BlankNode(s || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language, datatype, or directional language.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           If `languageOrDatatype` is a NamedNode, it is used for the value
     *                           of `NamedNode.language`.
     *                           Otherwise, it is used as a directional language,
     *                           from which the language is set to `languageOrDatatype.language`
     *                           and the direction to `languageOrDatatype.direction`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(s, d) {
      return new o.Literal(s, d);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(s) {
      return new e.Variable(s);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
      return r.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(s, d, l, f) {
      return new t.Quad(s, d, l, f || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(s) {
      switch (s.termType) {
        case "NamedNode":
          return this.namedNode(s.value);
        case "BlankNode":
          return this.blankNode(s.value);
        case "Literal":
          return s.language ? this.literal(s.value, s.language) : s.datatype.equals(o.Literal.XSD_STRING) ? this.literal(s.value) : this.literal(s.value, this.fromTerm(s.datatype));
        case "Variable":
          return this.variable(s.value);
        case "DefaultGraph":
          return this.defaultGraph();
        case "Quad":
          return this.quad(this.fromTerm(s.subject), this.fromTerm(s.predicate), this.fromTerm(s.object), this.fromTerm(s.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(s) {
      return this.fromTerm(s);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  }
  return kv.DataFactory = i, kv;
}
var uz;
function Bi() {
  return uz || (uz = 1, function(u) {
    var r = kl && kl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = kl && kl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(FZ(), u), o(jye(), u), o(NZ(), u), o(PZ(), u), o(W8(), u), o(DZ(), u), o(LZ(), u);
  }(kl)), kl;
}
var Xl = {}, Mt = {}, oz;
function Mye() {
  if (oz) return Mt;
  oz = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.TRIPLE_TERM_NAMES = Mt.QUAD_TERM_NAMES = void 0, Mt.getTerms = o, Mt.getTermsNested = a, Mt.getNamedTerms = t, Mt.collectNamedTerms = e, Mt.forEachTerms = n, Mt.forEachTermsNested = i, Mt.filterTerms = c, Mt.filterTermsNested = s, Mt.filterQuadTermNames = d, Mt.filterQuadTermNamesNested = l, Mt.mapTerms = f, Mt.mapTermsNested = h, Mt.reduceTerms = p, Mt.reduceTermsNested = b, Mt.everyTerms = _, Mt.everyTermsNested = y, Mt.someTerms = m, Mt.someTermsNested = g, Mt.getValueNestedPath = T, Mt.matchTerm = v, Mt.matchPattern = E, Mt.matchPatternComplete = R, Mt.matchPatternMappings = L;
  const u = Bi(), r = new u.DataFactory();
  Mt.QUAD_TERM_NAMES = ["subject", "predicate", "object", "graph"], Mt.TRIPLE_TERM_NAMES = ["subject", "predicate", "object"];
  function o(A, w) {
    return w && A.graph.termType === "DefaultGraph" ? [A.subject, A.predicate, A.object] : [A.subject, A.predicate, A.object, A.graph];
  }
  function a(A, w) {
    const S = [];
    for (const O of o(A, w))
      O.termType === "Quad" ? a(O, w).forEach((x) => S.push(x)) : S.push(O);
    return S;
  }
  function t(A) {
    return [
      { key: "subject", value: A.subject },
      { key: "predicate", value: A.predicate },
      { key: "object", value: A.object },
      { key: "graph", value: A.graph }
    ];
  }
  function e(A, w, S) {
    const O = {};
    return A.forEach((x) => O[x.key] = x.value), w && (O.subject = O.subject || w("subject"), O.predicate = O.predicate || w("predicate"), O.object = O.object || w("object"), O.graph = O.graph || w("graph")), (S || r).quad(O.subject, O.predicate, O.object, O.graph);
  }
  function n(A, w) {
    w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph");
  }
  function i(A, w, S = []) {
    A.subject.termType === "Quad" ? i(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"]), A.predicate.termType === "Quad" ? i(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"]), A.object.termType === "Quad" ? i(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"]), A.graph.termType === "Quad" ? i(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]);
  }
  function c(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push(A.subject), w(A.predicate, "predicate") && S.push(A.predicate), w(A.object, "object") && S.push(A.object), w(A.graph, "graph") && S.push(A.graph), S;
  }
  function s(A, w, S = []) {
    let O = [];
    return A.subject.termType === "Quad" ? O = [...O, ...s(A.subject, w, [...S, "subject"])] : w(A.subject, [...S, "subject"]) && O.push(A.subject), A.predicate.termType === "Quad" ? O = [...O, ...s(A.predicate, w, [...S, "predicate"])] : w(A.predicate, [...S, "predicate"]) && O.push(A.predicate), A.object.termType === "Quad" ? O = [...O, ...s(A.object, w, [...S, "object"])] : w(A.object, [...S, "object"]) && O.push(A.object), A.graph.termType === "Quad" ? O = [...O, ...s(A.graph, w, [...S, "graph"])] : w(A.graph, [...S, "graph"]) && O.push(A.graph), O;
  }
  function d(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push("subject"), w(A.predicate, "predicate") && S.push("predicate"), w(A.object, "object") && S.push("object"), w(A.graph, "graph") && S.push("graph"), S;
  }
  function l(A, w, S = []) {
    let O = [];
    const x = [...S, "subject"];
    A.subject.termType === "Quad" ? O = [...O, ...l(A.subject, w, x)] : w(A.subject, x) && O.push(x);
    const F = [...S, "predicate"];
    A.predicate.termType === "Quad" ? O = [...O, ...l(A.predicate, w, F)] : w(A.predicate, F) && O.push(F);
    const j = [...S, "object"];
    A.object.termType === "Quad" ? O = [...O, ...l(A.object, w, j)] : w(A.object, j) && O.push(j);
    const q = [...S, "graph"];
    return A.graph.termType === "Quad" ? O = [...O, ...l(A.graph, w, q)] : w(A.graph, q) && O.push(q), O;
  }
  function f(A, w, S) {
    return (S || r).quad(w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph"));
  }
  function h(A, w, S, O = []) {
    return (S || r).quad(A.subject.termType === "Quad" ? h(A.subject, w, S, [...O, "subject"]) : w(A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? h(A.predicate, w, S, [...O, "predicate"]) : w(A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? h(A.object, w, S, [...O, "object"]) : w(A.object, [...O, "object"]), A.graph.termType === "Quad" ? h(A.graph, w, S, [...O, "graph"]) : w(A.graph, [...O, "graph"]));
  }
  function p(A, w, S) {
    let O = S;
    return O = w(O, A.subject, "subject"), O = w(O, A.predicate, "predicate"), O = w(O, A.object, "object"), w(O, A.graph, "graph");
  }
  function b(A, w, S, O = []) {
    let x = S;
    return A.subject.termType === "Quad" ? x = b(A.subject, w, x, [...O, "subject"]) : x = w(x, A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? x = b(A.predicate, w, x, [...O, "predicate"]) : x = w(x, A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? x = b(A.object, w, x, [...O, "object"]) : x = w(x, A.object, [...O, "object"]), A.graph.termType === "Quad" ? x = b(A.graph, w, x, [...O, "graph"]) : x = w(x, A.graph, [...O, "graph"]), x;
  }
  function _(A, w) {
    return w(A.subject, "subject") && w(A.predicate, "predicate") && w(A.object, "object") && w(A.graph, "graph");
  }
  function y(A, w, S = []) {
    return (A.subject.termType === "Quad" ? y(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) && (A.predicate.termType === "Quad" ? y(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) && (A.object.termType === "Quad" ? y(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) && (A.graph.termType === "Quad" ? y(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  function m(A, w) {
    return w(A.subject, "subject") || w(A.predicate, "predicate") || w(A.object, "object") || w(A.graph, "graph");
  }
  function g(A, w, S = []) {
    return (A.subject.termType === "Quad" ? g(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) || (A.predicate.termType === "Quad" ? g(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) || (A.object.termType === "Quad" ? g(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) || (A.graph.termType === "Quad" ? g(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  function T(A, w) {
    if (w.length === 0)
      return A;
    if (A.termType === "Quad")
      return T(A[w[0]], w.slice(1));
    throw new Error(`Tried to get ${w[0]} from term of type ${A.termType}`);
  }
  function v(A, w) {
    return !w || w.termType === "Variable" || w.termType === "Quad" && A.termType === "Quad" && R(A, w) || w.equals(A);
  }
  function E(A, w, S, O, x) {
    return v(A.subject, w) && v(A.predicate, S) && v(A.object, O) && v(A.graph, x);
  }
  function R(A, w) {
    return E(A, w.subject, w.predicate, w.object, w.graph);
  }
  function L(A, w, S = {}) {
    const O = {};
    function x(F, j) {
      return _(F, (q, Q) => {
        var G, K;
        const U = j[Q];
        switch (q.termType) {
          case "Variable":
            return S.skipVarMapping && U.termType === "Variable" || ((K = (G = O[q.value]) === null || G === void 0 ? void 0 : G.equals(U)) !== null && K !== void 0 ? K : (O[q.value] = U, !0));
          case "Quad":
            return U.termType === "Quad" && x(q, U);
          default:
            return q.equals(U);
        }
      });
    }
    return x(w, A) && (S.returnMappings ? O : !0);
  }
  return Mt;
}
var vn = {}, AO = {}, li = {}, sz;
function Cye() {
  if (sz) return li;
  sz = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.termToString = o, li.getLiteralValue = a, li.getLiteralType = t, li.getLiteralLanguage = e, li.getLiteralDirection = n, li.stringToTerm = i, li.quadToStringQuad = c, li.stringQuadToQuad = s;
  const u = Bi(), r = new u.DataFactory();
  function o(d) {
    if (d)
      switch (d.termType) {
        case "NamedNode":
          return d.value;
        case "BlankNode":
          return "_:" + d.value;
        case "Literal":
          const l = d;
          return '"' + l.value + '"' + (l.datatype && l.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString" ? "^^" + l.datatype.value : "") + (l.language ? "@" + l.language : "") + (l.direction ? "--" + l.direction : "");
        case "Quad":
          return `<<${o(d.subject)} ${o(d.predicate)} ${o(d.object)}${d.graph.termType === "DefaultGraph" ? "" : " " + o(d.graph)}>>`;
        case "Variable":
          return "?" + d.value;
        case "DefaultGraph":
          return d.value;
      }
  }
  function a(d) {
    const l = /^"([^]*)"/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1];
  }
  function t(d) {
    const l = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1] || (l[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string");
  }
  function e(d) {
    const l = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    if (l[1]) {
      let f = l[1].toLowerCase();
      const h = f.indexOf("--");
      return h >= 0 && (f = f.slice(0, h)), f;
    }
    return "";
  }
  function n(d) {
    const l = d.indexOf("--", d.lastIndexOf('"'));
    if (l >= 0) {
      const f = d.slice(l + 2, d.length);
      if (f === "ltr" || f === "rtl")
        return f;
      throw new Error(d + " is not a literal with a valid direction");
    }
    return "";
  }
  function i(d, l) {
    if (l = l || r, !d || !d.length)
      return l.defaultGraph();
    switch (d[0]) {
      case "_":
        return l.blankNode(d.substr(2));
      case "?":
        if (!l.variable)
          throw new Error("Missing 'variable()' method on the given DataFactory");
        return l.variable(d.substr(1));
      case '"':
        const f = e(d), h = n(d), p = l.namedNode(t(d));
        return l.literal(a(d), f ? { language: f, direction: h } : p);
      case "<":
      default:
        if (d[0] === "<" && d.length > 4 && d[1] === "<" && d[d.length - 1] === ">" && d[d.length - 2] === ">") {
          const b = d.slice(2, -2).trim();
          let _ = [], y = 0, m = 0, g = !1;
          for (let T = 0; T < b.length; T++) {
            const v = b[T];
            if (v === "<" && y++, v === ">") {
              if (y === 0)
                throw new Error("Found closing tag without opening tag in " + d);
              y--;
            }
            if (v === '"') {
              let E = !1, R = T;
              for (; R-- > 0 && b[R] === "\\"; )
                E = !E;
              E || (g = !g);
            }
            if (v === " " && !g && y === 0) {
              for (_.push(b.slice(m, T)); b[T + 1] === " "; )
                T += 1;
              m = T + 1;
            }
          }
          if (y !== 0)
            throw new Error("Found opening tag without closing tag in " + d);
          if (_.push(b.slice(m, b.length)), _.length !== 3 && _.length !== 4)
            throw new Error("Nested quad syntax error " + d);
          return _ = _.map((T) => T.startsWith("<") && !T.includes(" ") ? T.slice(1, -1) : T), l.quad(i(_[0]), i(_[1]), i(_[2]), _[3] ? i(_[3]) : void 0);
        }
        return l.namedNode(d);
    }
  }
  function c(d) {
    return {
      subject: o(d.subject),
      predicate: o(d.predicate),
      object: o(d.object),
      graph: o(d.graph)
    };
  }
  function s(d, l) {
    return l = l || r, l.quad(i(d.subject, l), i(d.predicate, l), i(d.object, l), i(d.graph, l));
  }
  return li;
}
var cz;
function Nw() {
  return cz || (cz = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.termToString = u.stringToTerm = u.stringQuadToQuad = u.quadToStringQuad = u.getLiteralValue = u.getLiteralType = u.getLiteralDirection = u.getLiteralLanguage = void 0;
    const r = Cye();
    Object.defineProperty(u, "getLiteralLanguage", { enumerable: !0, get: function() {
      return r.getLiteralLanguage;
    } }), Object.defineProperty(u, "getLiteralDirection", { enumerable: !0, get: function() {
      return r.getLiteralDirection;
    } }), Object.defineProperty(u, "getLiteralType", { enumerable: !0, get: function() {
      return r.getLiteralType;
    } }), Object.defineProperty(u, "getLiteralValue", { enumerable: !0, get: function() {
      return r.getLiteralValue;
    } }), Object.defineProperty(u, "quadToStringQuad", { enumerable: !0, get: function() {
      return r.quadToStringQuad;
    } }), Object.defineProperty(u, "stringQuadToQuad", { enumerable: !0, get: function() {
      return r.stringQuadToQuad;
    } }), Object.defineProperty(u, "stringToTerm", { enumerable: !0, get: function() {
      return r.stringToTerm;
    } }), Object.defineProperty(u, "termToString", { enumerable: !0, get: function() {
      return r.termToString;
    } });
  }(AO)), AO;
}
var dz;
function qye() {
  if (dz) return vn;
  dz = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.TERM_TYPES = void 0, vn.uniqTerms = r, vn.getTermsOfType = o, vn.getNamedNodes = a, vn.getBlankNodes = t, vn.getLiterals = e, vn.getVariables = n, vn.getDefaultGraphs = i, vn.getQuads = c;
  const u = Nw();
  vn.TERM_TYPES = ["NamedNode", "BlankNode", "Literal", "Variable", "DefaultGraph", "Quad"];
  function r(s) {
    const d = {};
    return s.filter((l) => {
      const f = (0, u.termToString)(l);
      return !(f in d) && (d[f] = !0);
    });
  }
  function o(s, d) {
    return s.filter((l) => l.termType === d);
  }
  function a(s) {
    return o(s, "NamedNode");
  }
  function t(s) {
    return o(s, "BlankNode");
  }
  function e(s) {
    return o(s, "Literal");
  }
  function n(s) {
    return o(s, "Variable");
  }
  function i(s) {
    return o(s, "DefaultGraph");
  }
  function c(s) {
    return o(s, "Quad");
  }
  return vn;
}
var lz;
function f4() {
  return lz || (lz = 1, function(u) {
    var r = Xl && Xl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Xl && Xl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(Mye(), u), o(qye(), u);
  }(Xl)), Xl;
}
var Zv = {}, fz;
function jZ() {
  if (fz) return Zv;
  fz = 1, Object.defineProperty(Zv, "__esModule", { value: !0 }), Zv.TermDictionaryNumberRecordFullTerms = void 0;
  const u = Bi(), r = Nw();
  let o = class {
    constructor(t = new u.DataFactory()) {
      this.lastId = 0, this.dictionary = {}, this.reverseDictionary = {}, this.features = { quotedTriples: !1 }, this.dataFactory = t;
    }
    encode(t) {
      const e = (0, r.termToString)(t);
      let n = this.dictionary[e];
      return n === void 0 && (n = this.lastId++, this.dictionary[e] = n, this.reverseDictionary[n] = t), n;
    }
    encodeOptional(t) {
      const e = (0, r.termToString)(t);
      return this.dictionary[e];
    }
    decode(t) {
      const e = this.reverseDictionary[t];
      if (e === void 0)
        throw new Error(`The value ${t} is not present in this dictionary`);
      return e;
    }
    *encodings() {
      for (const t of Object.keys(this.reverseDictionary))
        yield Number.parseInt(t, 10);
    }
    findQuotedTriples(t) {
      throw new Error("findQuotedTriples is not supported");
    }
    findQuotedTriplesEncoded(t) {
      throw new Error("findQuotedTriplesEncoded is not supported");
    }
  };
  return Zv.TermDictionaryNumberRecordFullTerms = o, Zv;
}
var e3 = {}, t3 = {}, EO = {}, hz;
function $i() {
  return hz || (hz = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.QUAD_TERM_NAMES_INVERSE = void 0, u.getBestIndex = o, u.getComponentOrderScore = a, u.orderQuadComponents = t, u.encodeOptionalTerms = e, u.quadToPattern = n, u.quadHasVariables = i, u.arePatternsQuoted = c;
    const r = f4();
    u.QUAD_TERM_NAMES_INVERSE = Object.fromEntries(r.QUAD_TERM_NAMES.map((s, d) => [s, d]));
    function o(s, d) {
      if (s.length === 1 || d.every((h) => h !== void 0))
        return 0;
      const l = [];
      for (let h = 0; h < r.QUAD_TERM_NAMES.length; h++)
        d[h] && l.push(r.QUAD_TERM_NAMES[h]);
      return s.map((h, p) => ({ score: a(h, l), index: p })).sort((h, p) => p.score - h.score)[0].index;
    }
    function a(s, d) {
      return s.map((l, f) => d.includes(l) ? s.length - f : 0).reduce((l, f) => l + f, 0);
    }
    function t(s, d) {
      return s.map((l) => {
        const f = u.QUAD_TERM_NAMES_INVERSE[l];
        return d[f];
      });
    }
    function e(s, d) {
      const l = s.map((f) => {
        if (f) {
          if (f.termType === "Quad" && i(f))
            return;
          const h = d.encodeOptional(f);
          return h === void 0 ? "none" : h;
        }
        return f;
      });
      if (!l.includes("none"))
        return l;
    }
    function n(s, d, l, f, h) {
      let p = !1;
      return [[s || void 0, d || void 0, l || void 0, f || void 0].map((_) => {
        if (_) {
          if (_.termType === "Variable")
            return;
          if (_.termType === "Quad") {
            if (h)
              return _;
            p = !0;
            return;
          }
        }
        return _;
      }), p];
    }
    function i(s) {
      for (const d of r.QUAD_TERM_NAMES) {
        const l = s[d];
        if (l.termType === "Variable" || l.termType === "Quad" && i(l))
          return !0;
      }
      return !1;
    }
    function c(s) {
      return s.map((d) => (d == null ? void 0 : d.termType) === "Quad" && i(d));
    }
  }(EO)), EO;
}
var pz;
function Y8() {
  if (pz) return t3;
  pz = 1, Object.defineProperty(t3, "__esModule", { value: !0 }), t3.RdfStoreIndexNestedMap = void 0;
  const u = $i();
  let r = class {
    constructor(a) {
      this.features = {
        quotedTripleFiltering: !1
      }, this.dictionary = a.dictionary, this.nestedMap = /* @__PURE__ */ new Map();
    }
    set(a, t) {
      const e = this.nestedMap;
      let n = e.get(a[0]);
      n || (n = /* @__PURE__ */ new Map(), e.set(a[0], n));
      let i = n.get(a[1]);
      i || (i = /* @__PURE__ */ new Map(), n.set(a[1], i));
      let c = i.get(a[2]);
      c || (c = /* @__PURE__ */ new Map(), i.set(a[2], c));
      const s = c.has(a[3]);
      return s || c.set(a[3], t), !s;
    }
    remove(a) {
      const t = this.nestedMap, e = t.get(a[0]);
      if (!e)
        return !1;
      const n = e.get(a[1]);
      if (!n)
        return !1;
      const i = n.get(a[2]);
      if (!i)
        return !1;
      const c = i.delete(a[3]);
      return c && i.size === 0 && (n.delete(a[2]), n.size === 0 && (e.delete(a[1]), e.size === 0 && t.delete(a[0]))), c;
    }
    get(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!(!t || t.includes(void 0)))
        return this.getEncoded(t);
    }
    getEncoded(a) {
      const t = this.nestedMap.get(a[0]);
      if (!t)
        return;
      const e = t.get(a[1]);
      if (!e)
        return;
      const n = e.get(a[2]);
      if (n)
        return n.get(a[3]);
    }
    *find(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!t)
        return;
      const [e, n, i, c] = t, [s, d, l, f] = a;
      let h, p, b, _, y, m, g;
      const T = this.nestedMap, v = e !== void 0 ? T.has(e) ? [e] : [] : T.keys();
      for (const E of v) {
        y = T.get(E), h = s || this.dictionary.decode(E);
        const R = n !== void 0 ? y.has(n) ? [n] : [] : y.keys();
        for (const L of R) {
          m = y.get(L), p = d || this.dictionary.decode(L);
          const A = i !== void 0 ? m.has(i) ? [i] : [] : m.keys();
          for (const w of A) {
            g = m.get(w), b = l || this.dictionary.decode(w);
            const S = c !== void 0 ? g.has(c) ? [c] : [] : g.keys();
            for (const O of S)
              _ = f || this.dictionary.decode(O), yield [h, p, b, _];
          }
        }
      }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(a, t) {
      const [e, n, i, c] = a;
      let s, d, l;
      const f = this.nestedMap, h = e !== void 0 ? f.has(e) ? [e] : [] : f.keys();
      for (const p of h) {
        s = f.get(p);
        const b = n !== void 0 ? s.has(n) ? [n] : [] : s.keys();
        for (const _ of b) {
          d = s.get(_);
          const y = i !== void 0 ? d.has(i) ? [i] : [] : d.keys();
          for (const m of y) {
            l = d.get(m);
            const g = c !== void 0 ? l.has(c) ? [c] : [] : l.keys();
            for (const T of g)
              yield [p, _, m, T];
          }
        }
      }
    }
    count(a) {
      let t = 0;
      const e = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!e)
        return 0;
      const n = e[0], i = e[1], c = e[2], s = e[3];
      let d, l, f;
      const h = this.nestedMap, p = n !== void 0 ? h.has(n) ? [n] : [] : h.keys();
      for (const b of p) {
        d = h.get(b);
        const _ = i !== void 0 ? d.has(i) ? [i] : [] : d.keys();
        for (const y of _) {
          l = d.get(y);
          const m = c !== void 0 ? l.has(c) ? [c] : [] : l.keys();
          for (const g of m)
            f = l.get(g), s !== void 0 ? f.has(s) && t++ : t += f.size;
        }
      }
      return t;
    }
  };
  return t3.RdfStoreIndexNestedMap = r, t3;
}
var bz;
function MZ() {
  if (bz) return e3;
  bz = 1, Object.defineProperty(e3, "__esModule", { value: !0 }), e3.TermDictionaryQuotedIndexed = void 0;
  const u = Bi(), r = Y8(), o = $i();
  let a = class oa {
    constructor(e, n = new u.DataFactory()) {
      this.quotedTriplesDictionary = [], this.features = { quotedTriples: !0 }, this.plainTermDictionary = e;
      const i = {
        // Not required
        indexCombinations: [],
        // Not required
        indexConstructor: void 0,
        dictionary: this,
        dataFactory: n
      };
      this.quotedTriplesReverseDictionaries = [
        new r.RdfStoreIndexNestedMap(i),
        new r.RdfStoreIndexNestedMap(i),
        new r.RdfStoreIndexNestedMap(i)
      ], this.dataFactory = n;
    }
    encode(e) {
      return e.termType === "Quad" ? this.encodeQuotedTriple(e, !1) : this.plainTermDictionary.encode(e);
    }
    encodeQuotedTriple(e, n) {
      if (e.graph.termType !== "DefaultGraph")
        throw new Error("Encoding of quoted quads outside of the default graph is not allowed");
      const i = (0, o.encodeOptionalTerms)([e.subject, e.predicate, e.object, e.graph], this), c = i && i.every((f) => f !== void 0) ? this.quotedTriplesReverseDictionaries[0].getEncoded(i) : void 0;
      if (c !== void 0 || n)
        return c === void 0 ? void 0 : oa.BITMASK | c;
      const s = [
        this.encode(e.subject),
        this.encode(e.predicate),
        this.encode(e.object)
      ], d = this.quotedTriplesDictionary.length + 1;
      this.quotedTriplesDictionary.push(s);
      const l = this.encode(this.dataFactory.defaultGraph());
      return this.quotedTriplesReverseDictionaries[0].set([
        s[0],
        s[1],
        s[2],
        l
      ], d), this.quotedTriplesReverseDictionaries[1].set([
        s[1],
        s[2],
        s[0],
        l
      ], d), this.quotedTriplesReverseDictionaries[2].set([
        s[2],
        s[0],
        s[1],
        l
      ], d), oa.BITMASK | d;
    }
    encodeOptional(e) {
      return e.termType === "Quad" ? this.encodeQuotedTriple(e, !0) : this.plainTermDictionary.encodeOptional(e);
    }
    decode(e) {
      if (oa.BITMASK & e) {
        const n = (~oa.BITMASK & e) - 1;
        if (n >= this.quotedTriplesDictionary.length)
          throw new Error(`The value ${e} is not present in the quoted triples range of the dictionary`);
        const i = this.quotedTriplesDictionary[n];
        return this.dataFactory.quad(this.decode(i[0]), this.decode(i[1]), this.decode(i[2]));
      }
      return this.plainTermDictionary.decode(e);
    }
    *encodings() {
      for (const e of this.plainTermDictionary.encodings())
        yield e;
      for (const e of this.quotedTriplesDictionary.keys())
        yield oa.BITMASK | 1 + e;
    }
    *findQuotedTriples(e) {
      for (const n of this.findQuotedTriplesEncoded(e))
        yield this.decode(n);
    }
    *findQuotedTriplesEncoded(e) {
      const [n, i] = (0, o.quadToPattern)(e.subject, e.predicate, e.object, e.graph, !0);
      for (const c of this.patternToIterable(n[0]))
        for (const s of this.patternToIterable(n[1]))
          for (const d of this.patternToIterable(n[2]))
            for (const l of this.patternToIterable(n[3]))
              if (c && s || !s && !d) {
                const f = [c, s, d, l];
                for (const h of this.quotedTriplesReverseDictionaries[0].findEncoded(f, n))
                  yield oa.BITMASK | this.quotedTriplesReverseDictionaries[0].getEncoded(h);
              } else if (!c && s) {
                const f = [s, d, c, l];
                for (const h of this.quotedTriplesReverseDictionaries[1].findEncoded(f, n))
                  yield oa.BITMASK | this.quotedTriplesReverseDictionaries[1].getEncoded(h);
              } else {
                const f = [d, c, s, l];
                for (const h of this.quotedTriplesReverseDictionaries[2].findEncoded(f, n))
                  yield oa.BITMASK | this.quotedTriplesReverseDictionaries[2].getEncoded(h);
              }
    }
    /**
     * Helper function to convert a term to an iterator over encoded terms.
     * @param patternTerm A term.
     * @protected
     */
    *patternToIterable(e) {
      if ((e == null ? void 0 : e.termType) === "Quad") {
        yield* this.findQuotedTriplesEncoded(e);
        return;
      }
      if (e === void 0) {
        yield void 0;
        return;
      }
      const n = this.encodeOptional(e);
      n !== void 0 && (yield n);
    }
  };
  return e3.TermDictionaryQuotedIndexed = a, a.BITMASK = 1 << 31, e3;
}
var r3 = {}, yz;
function CZ() {
  if (yz) return r3;
  yz = 1, Object.defineProperty(r3, "__esModule", { value: !0 }), r3.RdfStoreIndexNestedMapQuoted = void 0;
  const u = $i(), r = Y8();
  let o = class extends r.RdfStoreIndexNestedMap {
    constructor(t) {
      super(t), this.features = {
        quotedTripleFiltering: !0
      };
    }
    *getQuotedPatternKeys(t, e) {
      for (const n of this.dictionary.findQuotedTriplesEncoded(e))
        t.has(n) && (yield n);
    }
    *find(t) {
      const e = (0, u.encodeOptionalTerms)(t, this.dictionary);
      if (!e)
        return;
      const [n, i, c, s] = e, [d, l, f, h] = t, [p, b, _, y] = (0, u.arePatternsQuoted)(t);
      let m, g, T, v, E, R, L;
      const A = this.nestedMap, w = d !== void 0 ? p ? this.getQuotedPatternKeys(A, d) : A.has(n) ? [n] : [] : A.keys();
      for (const S of w) {
        E = A.get(S), m = !p && d ? d : this.dictionary.decode(S);
        const O = l !== void 0 ? b ? this.getQuotedPatternKeys(E, l) : E.has(i) ? [i] : [] : E.keys();
        for (const x of O) {
          R = E.get(x), g = !b && l ? l : this.dictionary.decode(x);
          const F = f !== void 0 ? _ ? this.getQuotedPatternKeys(R, f) : R.has(c) ? [c] : [] : R.keys();
          for (const j of F) {
            L = R.get(j), T = !_ && f ? f : this.dictionary.decode(j);
            const q = h !== void 0 ? y ? this.getQuotedPatternKeys(L, h) : L.has(s) ? [s] : [] : L.keys();
            for (const Q of q)
              v = !y && h ? h : this.dictionary.decode(Q), yield [m, g, T, v];
          }
        }
      }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(t, e) {
      const [n, i, c, s] = t, [d, l, f, h] = e, [p, b, _, y] = (0, u.arePatternsQuoted)(e);
      let m, g, T;
      const v = this.nestedMap, E = d !== void 0 ? p ? this.getQuotedPatternKeys(v, d) : v.has(n) ? [n] : [] : v.keys();
      for (const R of E) {
        m = v.get(R);
        const L = l !== void 0 ? b ? this.getQuotedPatternKeys(m, l) : m.has(i) ? [i] : [] : m.keys();
        for (const A of L) {
          g = m.get(A);
          const w = f !== void 0 ? _ ? this.getQuotedPatternKeys(g, f) : g.has(c) ? [c] : [] : g.keys();
          for (const S of w) {
            T = g.get(S);
            const O = h !== void 0 ? y ? this.getQuotedPatternKeys(T, h) : T.has(s) ? [s] : [] : T.keys();
            for (const x of O)
              yield [
                Number.parseInt(R, 10),
                Number.parseInt(A, 10),
                Number.parseInt(S, 10),
                Number.parseInt(x, 10)
              ];
          }
        }
      }
    }
    count(t) {
      let e = 0;
      const n = (0, u.encodeOptionalTerms)(t, this.dictionary);
      if (!n)
        return 0;
      const [i, c, s, d] = n, [l, f, h, p] = t, [b, _, y, m] = (0, u.arePatternsQuoted)(t);
      let g, T, v;
      const E = this.nestedMap, R = l !== void 0 ? b ? this.getQuotedPatternKeys(E, l) : E.has(i) ? [i] : [] : E.keys();
      for (const L of R) {
        g = E.get(L);
        const A = f !== void 0 ? _ ? this.getQuotedPatternKeys(g, f) : g.has(c) ? [c] : [] : g.keys();
        for (const w of A) {
          T = g.get(w);
          const S = h !== void 0 ? y ? this.getQuotedPatternKeys(T, h) : T.has(s) ? [s] : [] : T.keys();
          for (const O of S)
            v = T.get(O), p !== void 0 ? m ? e += [...this.getQuotedPatternKeys(v, p)].length : v.has(d) && e++ : e += v.size;
        }
      }
      return e;
    }
  };
  return r3.RdfStoreIndexNestedMapQuoted = o, r3;
}
var _z;
function qZ() {
  if (_z) return Gv;
  _z = 1, Object.defineProperty(Gv, "__esModule", { value: !0 }), Gv.RdfStore = void 0;
  const u = /* @__PURE__ */ yt(), r = Bi(), o = f4(), a = $Z(), t = jZ(), e = MZ(), n = CZ(), i = $i();
  let c = class ET {
    constructor(d) {
      this.features = { quotedTripleFiltering: !0 }, this._size = 0, this.options = d, this.dataFactory = d.dataFactory, this.dictionary = d.dictionary, this.indexesWrapped = ET.constructIndexesWrapped(d), this.indexesWrappedComponentOrders = this.indexesWrapped.map((l) => l.componentOrder);
    }
    /**
     * Create an RDF store with default settings.
     * Concretely, this store stores triples in GSPO, GPOS, and GOSP order,
     * and makes use of in-memory number dictionary encoding.
     */
    static createDefault() {
      return new ET({
        indexCombinations: ET.DEFAULT_INDEX_COMBINATIONS,
        indexConstructor: (d) => new n.RdfStoreIndexNestedMapQuoted(d),
        dictionary: new e.TermDictionaryQuotedIndexed(new t.TermDictionaryNumberRecordFullTerms()),
        dataFactory: new r.DataFactory()
      });
    }
    /**
     * Internal helper to create index objects.
     * @param options The RDF store options object.
     */
    static constructIndexesWrapped(d) {
      const l = [];
      if (d.indexCombinations.length === 0)
        throw new Error("At least one index combination is required");
      for (const f of d.indexCombinations) {
        if (!ET.isCombinationValid(f))
          throw new Error(`Invalid index combination: ${f}`);
        l.push({
          index: d.indexConstructor(d),
          componentOrder: f,
          componentOrderInverse: Object.fromEntries(f.map((h, p) => [h, p]))
        });
      }
      return l;
    }
    /**
     * Check if a given quad term order is valid.
     * @param combination A quad term order.
     */
    static isCombinationValid(d) {
      for (const l of o.QUAD_TERM_NAMES)
        if (!d.includes(l))
          return !1;
      return d.length === 4;
    }
    /**
     * The number of quads in this store.
     */
    get size() {
      return this._size;
    }
    /**
     * Add a quad to the store.
     * @param quad An RDF quad.
     * @return boolean If the quad was not yet present in the index.
     */
    addQuad(d) {
      const l = [
        this.dictionary.encode(d.subject),
        this.dictionary.encode(d.predicate),
        this.dictionary.encode(d.object),
        this.dictionary.encode(d.graph)
      ];
      let f = !1;
      for (const h of this.indexesWrapped)
        f = h.index.set((0, i.orderQuadComponents)(h.componentOrder, l), !0);
      return f ? (this._size++, !0) : !1;
    }
    /**
     * Remove a quad from the store.
     * @param quad An RDF quad.
     * @return boolean If the quad was present in the index.
     */
    removeQuad(d) {
      const l = [
        this.dictionary.encodeOptional(d.subject),
        this.dictionary.encodeOptional(d.predicate),
        this.dictionary.encodeOptional(d.object),
        this.dictionary.encodeOptional(d.graph)
      ];
      if (l.includes(void 0))
        return !1;
      let f = !1;
      for (const h of this.indexesWrapped)
        if (f = h.index.remove((0, i.orderQuadComponents)(h.componentOrder, l)), !f)
          break;
      return f ? (this._size--, !0) : !1;
    }
    /**
     * Removes all streamed quads.
     * @param stream A stream of quads
     */
    remove(d) {
      return d.on("data", (l) => this.removeQuad(l)), d;
    }
    /**
     * All quads matching the pattern will be removed.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    removeMatches(d, l, f, h) {
      return this.remove(this.match(d, l, f, h));
    }
    /**
     * Deletes the given named graph.
     * @param graph The graph term or string to match.
     */
    deleteGraph(d) {
      return typeof d == "string" && (d = this.dataFactory.namedNode(d)), this.removeMatches(void 0, void 0, void 0, d);
    }
    /**
     * Import the given stream of quads into the store.
     * @param stream A stream of RDF quads.
     */
    import(d) {
      return d.on("data", (l) => this.addQuad(l)), d;
    }
    /**
     * Returns a generator producing all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    *readQuads(d, l, f, h) {
      const p = !!this.dictionary.features.quotedTriples && Object.values(this.indexesWrapped).every((g) => g.index.features.quotedTripleFiltering), [b, _] = (0, i.quadToPattern)(d, l, f, h, p), y = this.indexesWrapped[(0, i.getBestIndex)(this.indexesWrappedComponentOrders, b)], m = (0, i.orderQuadComponents)(y.componentOrder, b);
      for (const g of y.index.find(m)) {
        const T = this.dataFactory.quad(g[y.componentOrderInverse.subject], g[y.componentOrderInverse.predicate], g[y.componentOrderInverse.object], g[y.componentOrderInverse.graph]);
        _ ? (0, o.matchPattern)(T, d, l, f, h) && (yield T) : yield T;
      }
    }
    /**
     * Returns an array containing all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    getQuads(d, l, f, h) {
      return [...this.readQuads(d, l, f, h)];
    }
    /**
     * Returns a stream that produces all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    match(d, l, f, h) {
      return (0, u.wrap)(this.readQuads(d, l, f, h));
    }
    /**
     * Returns a generator producing all quads matching the pattern.
     * @param subject The subject, which can be a variable.
     * @param predicate The predicate, which can be a variable.
     * @param object The object, which can be a variable.
     * @param graph The graph, which can be a variable.
     */
    *readBindings(d, l, f, h, p) {
      const b = !!this.dictionary.features.quotedTriples && Object.values(this.indexesWrapped).every((A) => A.index.features.quotedTripleFiltering), [_, y] = (0, i.quadToPattern)(l, f, h, p, b), m = this.indexesWrapped[(0, i.getBestIndex)(this.indexesWrappedComponentOrders, _)], g = (0, i.orderQuadComponents)(m.componentOrder, _), T = (0, i.encodeOptionalTerms)(g, this.dictionary);
      if (!T)
        return;
      const v = (0, i.orderQuadComponents)(m.componentOrder, [l, f, h, p]), E = [];
      for (let A = 0; A < v.length; A++)
        (v[A].termType === "Variable" || v[A].termType === "Quad") && E.push(A);
      let R = !1;
      const L = v.map((A, w) => {
        const S = [];
        for (let O = w + 1; O < v.length; O++)
          A.equals(v[O]) && (S.push(O), R = !0);
        return S;
      });
      for (const A of m.index.findEncoded(T, g)) {
        let w = !1, S = !1;
        const O = [];
        for (const x of E) {
          if (R) {
            const j = L[x];
            if (j) {
              for (const q of j)
                if (A[x] !== A[q]) {
                  w = !0;
                  break;
                }
            }
            if (w)
              break;
          }
          const F = this.dictionary.decode(A[x]);
          if (v[x].termType === "Quad") {
            if (F.termType === "Quad") {
              const j = (0, o.matchPatternMappings)(F, v[x], { returnMappings: !0 });
              if (j) {
                S = !0;
                for (const [q, Q] of Object.entries(j)) {
                  const G = this.dataFactory.variable(q);
                  if (O.some((K) => K[0].equals(G) && !K[1].equals(Q))) {
                    w = !0;
                    break;
                  }
                  O.push([G, Q]);
                }
                continue;
              }
            }
            w = !0;
            break;
          }
          if (S && O.some((j) => j[0].equals(v[x]) && !j[1].equals(F))) {
            w = !0;
            break;
          }
          O.push([v[x], F]);
        }
        w || (yield d.bindings(O));
      }
    }
    /**
     * Returns an array containing all bindings matching the pattern.
     * @param bindingsFactory The factory that will be used to create bindings.
     * @param subject The subject, which can be a variable.
     * @param predicate The predicate, which can be a variable.
     * @param object The object, which can be a variable.
     * @param graph The graph, which can be a variable.
     */
    getBindings(d, l, f, h, p) {
      return [...this.readBindings(d, l, f, h, p)];
    }
    /**
     * Returns a stream that produces all quads matching the pattern.
     * @param bindingsFactory The factory that will be used to create bindings.
     * @param subject The subject, which can be a variable.
     * @param predicate The predicate, which can be a variable.
     * @param object The object, which can be a variable.
     * @param graph The graph, which can be a variable.
     */
    matchBindings(d, l, f, h, p) {
      return (0, u.wrap)(this.readBindings(d, l, f, h, p));
    }
    /**
     * Returns the exact cardinality of the quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    countQuads(d, l, f, h) {
      const p = !!this.dictionary.features.quotedTriples && Object.values(this.indexesWrapped).every((m) => m.index.features.quotedTripleFiltering), [b] = (0, i.quadToPattern)(d, l, f, h, p);
      if (b.every((m) => m === void 0))
        return this.size;
      const _ = this.indexesWrapped[(0, i.getBestIndex)(this.indexesWrappedComponentOrders, b)], y = (0, i.orderQuadComponents)(_.componentOrder, b);
      return _.index.count(y);
    }
    /**
     * Wrap this store inside a DatasetCore interface.
     * Any mutations in either this store or the wrapper will propagate to each other.
     */
    asDataset() {
      return new a.DatasetCoreWrapper(this);
    }
  };
  return Gv.RdfStore = c, c.DEFAULT_INDEX_COMBINATIONS = [
    ["graph", "subject", "predicate", "object"],
    ["graph", "predicate", "object", "subject"],
    ["graph", "object", "subject", "predicate"]
  ], Gv;
}
var gz;
function $Z() {
  if (gz) return Hv;
  gz = 1, Object.defineProperty(Hv, "__esModule", { value: !0 }), Hv.DatasetCoreWrapper = void 0;
  const u = qZ();
  let r = class BZ {
    constructor(a) {
      this.store = a;
    }
    get size() {
      return this.store.size;
    }
    add(a) {
      return this.store.addQuad(a), this;
    }
    delete(a) {
      return this.store.removeQuad(a), this;
    }
    has(a) {
      for (const t of this.store.readQuads(a.subject, a.predicate, a.object, a.graph))
        return !0;
      return !1;
    }
    match(a, t, e, n) {
      const i = new u.RdfStore(this.store.options);
      for (const c of this.store.readQuads(a, t, e, n))
        i.addQuad(c);
      return new BZ(i);
    }
    [Symbol.iterator]() {
      return this.store.readQuads();
    }
  };
  return Hv.DatasetCoreWrapper = r, Hv;
}
var OO = {}, mz;
function Bye() {
  return mz || (mz = 1, Object.defineProperty(OO, "__esModule", { value: !0 })), OO;
}
var n3 = {}, vz;
function $ye() {
  if (vz) return n3;
  vz = 1, Object.defineProperty(n3, "__esModule", { value: !0 }), n3.TermDictionaryNumberMap = void 0;
  const u = Bi(), r = Nw();
  let o = class {
    constructor(t = new u.DataFactory()) {
      this.lastId = 0, this.dictionary = /* @__PURE__ */ new Map(), this.reverseDictionary = /* @__PURE__ */ new Map(), this.features = { quotedTriples: !1 }, this.dataFactory = t;
    }
    encode(t) {
      const e = (0, r.termToString)(t);
      let n = this.dictionary.get(e);
      return n === void 0 && (n = this.lastId++, this.dictionary.set(e, n), this.reverseDictionary.set(n, e)), n;
    }
    encodeOptional(t) {
      const e = (0, r.termToString)(t);
      return this.dictionary.get(e);
    }
    decode(t) {
      const e = this.reverseDictionary.get(t);
      if (e === void 0)
        throw new Error(`The value ${t} is not present in this dictionary`);
      return (0, r.stringToTerm)(e, this.dataFactory);
    }
    encodings() {
      return this.reverseDictionary.keys();
    }
    findQuotedTriples(t) {
      throw new Error("findQuotedTriples is not supported");
    }
    findQuotedTriplesEncoded(t) {
      throw new Error("findQuotedTriplesEncoded is not supported");
    }
  };
  return n3.TermDictionaryNumberMap = o, n3;
}
var i3 = {}, Tz;
function Uye() {
  if (Tz) return i3;
  Tz = 1, Object.defineProperty(i3, "__esModule", { value: !0 }), i3.TermDictionaryNumberRecord = void 0;
  const u = Bi(), r = Nw();
  let o = class {
    constructor(t = new u.DataFactory()) {
      this.lastId = 0, this.dictionary = {}, this.reverseDictionary = {}, this.features = { quotedTriples: !1 }, this.dataFactory = t;
    }
    encode(t) {
      const e = (0, r.termToString)(t);
      let n = this.dictionary[e];
      return n === void 0 && (n = this.lastId++, this.dictionary[e] = n, this.reverseDictionary[n] = e), n;
    }
    encodeOptional(t) {
      const e = (0, r.termToString)(t);
      return this.dictionary[e];
    }
    decode(t) {
      const e = this.reverseDictionary[t];
      if (e === void 0)
        throw new Error(`The value ${t} is not present in this dictionary`);
      return (0, r.stringToTerm)(e, this.dataFactory);
    }
    *encodings() {
      for (const t of Object.keys(this.reverseDictionary))
        yield Number.parseInt(t, 10);
    }
    findQuotedTriples(t) {
      throw new Error("findQuotedTriples is not supported");
    }
    findQuotedTriplesEncoded(t) {
      throw new Error("findQuotedTriplesEncoded is not supported");
    }
  };
  return i3.TermDictionaryNumberRecord = o, i3;
}
var a3 = {}, wz;
function Vye() {
  if (wz) return a3;
  wz = 1, Object.defineProperty(a3, "__esModule", { value: !0 }), a3.TermDictionaryQuoted = void 0;
  const u = Bi(), r = f4();
  let o = class $f {
    constructor(t, e, n = new u.DataFactory()) {
      this.features = { quotedTriples: !0 }, this.plainTermDictionary = t, this.quotedTriplesDictionary = e, this.dataFactory = n;
    }
    encode(t) {
      return t.termType === "Quad" ? $f.BITMASK | 1 + this.quotedTriplesDictionary.encode(t) : this.plainTermDictionary.encode(t);
    }
    encodeOptional(t) {
      if (t.termType === "Quad") {
        const e = this.quotedTriplesDictionary.encodeOptional(t);
        return e === void 0 ? e : $f.BITMASK | 1 + e;
      }
      return this.plainTermDictionary.encodeOptional(t);
    }
    decode(t) {
      if ($f.BITMASK & t) {
        const e = (~$f.BITMASK & t) - 1;
        return this.quotedTriplesDictionary.decode(e);
      }
      return this.plainTermDictionary.decode(t);
    }
    *encodings() {
      for (const t of this.plainTermDictionary.encodings())
        yield t;
      for (const t of this.quotedTriplesDictionary.encodings())
        yield $f.BITMASK | 1 + t;
    }
    *findQuotedTriples(t) {
      for (const e of this.findQuotedTriplesEncoded(t))
        yield this.decode(e);
    }
    *findQuotedTriplesEncoded(t) {
      for (let e of this.quotedTriplesDictionary.encodings()) {
        e = $f.BITMASK | 1 + e;
        const n = this.decode(e);
        (0, r.matchPattern)(n, t.subject, t.predicate, t.object, t.graph) && (yield e);
      }
    }
  };
  return a3.TermDictionaryQuoted = o, o.BITMASK = 1 << 31, a3;
}
var u3 = {}, Sz;
function Qye() {
  if (Sz) return u3;
  Sz = 1, Object.defineProperty(u3, "__esModule", { value: !0 }), u3.TermDictionaryQuotedReferential = void 0;
  const u = Bi(), r = f4(), o = $i();
  let a = class sa {
    constructor(e, n = new u.DataFactory()) {
      this.quotedTriplesDictionary = [], this.quotedTriplesReverseDictionary = {}, this.features = { quotedTriples: !0 }, this.plainTermDictionary = e, this.dataFactory = n;
    }
    encode(e) {
      return e.termType === "Quad" ? this.encodeQuotedTriple(e, !1) : this.plainTermDictionary.encode(e);
    }
    encodeQuotedTriple(e, n) {
      var l;
      if (e.graph.termType !== "DefaultGraph")
        throw new Error("Encoding of quoted quads outside of the default graph is not allowed");
      const i = (l = (0, o.encodeOptionalTerms)([e.subject, e.predicate, e.object, void 0], this)) == null ? void 0 : l.slice(0, 3), c = i && i.every((f) => f !== void 0) ? this.quotedTriplesReverseDictionary[i.join(sa.SEPARATOR)] : void 0;
      if (c !== void 0 || n)
        return c === void 0 ? void 0 : sa.BITMASK | c;
      const s = [
        this.encode(e.subject),
        this.encode(e.predicate),
        this.encode(e.object)
      ], d = this.quotedTriplesDictionary.length + 1;
      return this.quotedTriplesDictionary.push(s), this.quotedTriplesReverseDictionary[s.join(sa.SEPARATOR)] = d, sa.BITMASK | d;
    }
    encodeOptional(e) {
      return e.termType === "Quad" ? this.encodeQuotedTriple(e, !0) : this.plainTermDictionary.encodeOptional(e);
    }
    decode(e) {
      if (sa.BITMASK & e) {
        const n = (~sa.BITMASK & e) - 1;
        if (n >= this.quotedTriplesDictionary.length)
          throw new Error(`The value ${e} is not present in the quoted triples range of the dictionary`);
        const i = this.quotedTriplesDictionary[n];
        return this.dataFactory.quad(this.decode(i[0]), this.decode(i[1]), this.decode(i[2]));
      }
      return this.plainTermDictionary.decode(e);
    }
    *encodings() {
      for (const e of this.plainTermDictionary.encodings())
        yield e;
      for (const e of this.quotedTriplesDictionary.keys())
        yield sa.BITMASK | 1 + e;
    }
    *findQuotedTriples(e) {
      for (const n of this.findQuotedTriplesEncoded(e))
        yield this.decode(n);
    }
    *findQuotedTriplesEncoded(e) {
      for (let n of this.quotedTriplesDictionary.keys()) {
        n = sa.BITMASK | 1 + n;
        const i = this.decode(n);
        (0, r.matchPattern)(i, e.subject, e.predicate, e.object, e.graph) && (yield n);
      }
    }
  };
  return u3.TermDictionaryQuotedReferential = a, a.BITMASK = 1 << 31, a.SEPARATOR = "_", u3;
}
var o3 = {}, Az;
function Hye() {
  if (Az) return o3;
  Az = 1, Object.defineProperty(o3, "__esModule", { value: !0 }), o3.TermDictionarySymbol = void 0;
  const u = Bi(), r = Nw();
  let o = class {
    constructor(t = new u.DataFactory()) {
      this.features = { quotedTriples: !1 }, this.dataFactory = t;
    }
    encode(t) {
      return Symbol.for(`rdf::${(0, r.termToString)(t)}`);
    }
    encodeOptional(t) {
      return this.encode(t);
    }
    decode(t) {
      const e = Symbol.keyFor(t);
      if (e === void 0)
        throw new Error(`The value ${String(t)} is not present in this dictionary`);
      return (0, r.stringToTerm)(e.slice(5), this.dataFactory);
    }
    encodings() {
      throw new Error("encodings is not supported");
    }
    findQuotedTriples(t) {
      throw new Error("findQuotedTriples is not supported");
    }
    findQuotedTriplesEncoded(t) {
      throw new Error("findQuotedTriplesEncoded is not supported");
    }
  };
  return o3.TermDictionarySymbol = o, o3;
}
var xO = {}, Ez;
function Gye() {
  return Ez || (Ez = 1, Object.defineProperty(xO, "__esModule", { value: !0 })), xO;
}
var s3 = {}, Oz;
function UZ() {
  if (Oz) return s3;
  Oz = 1, Object.defineProperty(s3, "__esModule", { value: !0 }), s3.RdfStoreIndexNestedMapRecursive = void 0;
  const u = $i();
  let r = class {
    constructor(a) {
      this.features = {
        quotedTripleFiltering: !1
      }, this.dictionary = a.dictionary, this.nestedMap = /* @__PURE__ */ new Map();
    }
    set(a, t) {
      let e = this.nestedMap, n = !1;
      for (const [i, c] of a.entries()) {
        const s = e;
        let d = s.get(c);
        d ? i === a.length - 1 && (n = !0) : (d = i === a.length - 1 ? t : /* @__PURE__ */ new Map(), s.set(c, d)), e = d;
      }
      return !n;
    }
    remove(a) {
      const t = this.nestedMap, e = t.get(a[0]);
      if (!e)
        return !1;
      const n = e.get(a[1]);
      if (!n)
        return !1;
      const i = n.get(a[2]);
      if (!i)
        return !1;
      const c = i.delete(a[3]);
      return c && i.size === 0 && (n.delete(a[2]), n.size === 0 && (e.delete(a[1]), e.size === 0 && t.delete(a[0]))), c;
    }
    get(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!(!t || t.includes(void 0)))
        return this.getEncoded(t);
    }
    getEncoded(a) {
      const t = this.nestedMap.get(a[0]);
      if (!t)
        return;
      const e = t.get(a[1]);
      if (!e)
        return;
      const n = e.get(a[2]);
      if (n)
        return n.get(a[3]);
    }
    *find(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (t)
        for (const e of this.findEncoded(t, a))
          yield [
            t[0] !== void 0 ? a[0] : this.dictionary.decode(e[0]),
            t[1] !== void 0 ? a[1] : this.dictionary.decode(e[1]),
            t[2] !== void 0 ? a[2] : this.dictionary.decode(e[2]),
            t[3] !== void 0 ? a[3] : this.dictionary.decode(e[3])
          ];
    }
    *findEncoded(a, t) {
      return yield* this.findEncodedInner(0, a, t, this.nestedMap, []);
    }
    *findEncodedInner(a, t, e, n, i) {
      if (a === t.length)
        yield [...i];
      else {
        const c = t[a];
        if (e[a]) {
          const d = c;
          if (d !== void 0) {
            const l = n.get(d);
            l && (i[a] = c, yield* this.findEncodedInner(a + 1, t, e, l, i));
          }
        } else
          for (const [d, l] of n.entries())
            i[a] = d, yield* this.findEncodedInner(a + 1, t, e, l, i);
      }
    }
    count(a) {
      return this.countInner(0, a, this.nestedMap);
    }
    countInner(a, t, e) {
      const n = t[a];
      let i = 0;
      if (n) {
        const c = this.dictionary.encodeOptional(n);
        if (c !== void 0) {
          if (a === t.length - 1)
            return e.has(c) ? 1 : 0;
          const s = e.get(c);
          s && (i += this.countInner(a + 1, t, s));
        }
      } else {
        if (a === t.length - 1)
          return e.size;
        for (const c of e.values())
          i += this.countInner(a + 1, t, c);
      }
      return i;
    }
  };
  return s3.RdfStoreIndexNestedMapRecursive = r, s3;
}
var c3 = {}, xz;
function zye() {
  if (xz) return c3;
  xz = 1, Object.defineProperty(c3, "__esModule", { value: !0 }), c3.RdfStoreIndexNestedMapRecursiveQuoted = void 0;
  const u = $i(), r = UZ();
  let o = class extends r.RdfStoreIndexNestedMapRecursive {
    constructor(t) {
      super(t), this.features = {
        quotedTripleFiltering: !0
      };
    }
    *findEncoded(t, e) {
      return yield* this.findEncodedInnerQuoted(0, t, e, (0, u.arePatternsQuoted)(e), this.nestedMap, []);
    }
    *findEncodedInnerQuoted(t, e, n, i, c, s) {
      if (t === e.length)
        yield [...s];
      else {
        const d = e[t], l = n[t];
        if (l)
          if (i[t]) {
            const f = this.dictionary.findQuotedTriplesEncoded(l);
            for (const h of f) {
              const p = c.get(h);
              p && (s[t] = h, yield* this.findEncodedInnerQuoted(t + 1, e, n, i, p, s));
            }
          } else {
            const f = d;
            if (f !== void 0) {
              const h = c.get(f);
              h && (s[t] = d, yield* this.findEncodedInnerQuoted(t + 1, e, n, i, h, s));
            }
          }
        else for (const [f, h] of c.entries())
          s[t] = f, yield* this.findEncodedInnerQuoted(t + 1, e, n, i, h, s);
      }
    }
    countInner(t, e, n) {
      const i = e[t];
      let c = 0;
      if (i)
        if (i.termType === "Quad" && (0, u.quadHasVariables)(i)) {
          const s = this.dictionary.findQuotedTriplesEncoded(i);
          for (const d of s)
            if (t === e.length - 1)
              n.has(d) && c++;
            else {
              const l = n.get(d);
              l && (c += this.countInner(t + 1, e, l));
            }
        } else {
          const s = this.dictionary.encodeOptional(i);
          if (s !== void 0) {
            if (t === e.length - 1)
              return n.has(s) ? 1 : 0;
            const d = n.get(s);
            d && (c += this.countInner(t + 1, e, d));
          }
        }
      else {
        if (t === e.length - 1)
          return n.size;
        for (const s of n.values())
          c += this.countInner(t + 1, e, s);
      }
      return c;
    }
  };
  return c3.RdfStoreIndexNestedMapRecursiveQuoted = o, c3;
}
var l3 = {}, Iz;
function VZ() {
  if (Iz) return l3;
  Iz = 1, Object.defineProperty(l3, "__esModule", { value: !0 }), l3.RdfStoreIndexNestedRecord = void 0;
  const u = $i();
  let r = class {
    constructor(a) {
      this.features = {
        quotedTripleFiltering: !1
      }, this.dictionary = a.dictionary, this.nestedRecords = {};
    }
    set(a, t) {
      const e = this.nestedRecords, n = e[a[0]] || (e[a[0]] = {}), i = n[a[1]] || (n[a[1]] = {}), c = i[a[2]] || (i[a[2]] = {});
      return c[a[3]] ? !1 : (c[a[3]] = t, !0);
    }
    remove(a) {
      const t = this.nestedRecords, e = t[a[0]];
      if (!e)
        return !1;
      const n = e[a[1]];
      if (!n)
        return !1;
      const i = n[a[2]];
      return !i || !i[a[3]] ? !1 : (delete i[a[3]], Object.keys(i).length === 0 && (delete n[a[2]], Object.keys(n).length === 0 && (delete e[a[1]], Object.keys(e).length === 0 && delete t[a[0]])), !0);
    }
    get(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!(!t || t.includes(void 0)))
        return this.getEncoded(t);
    }
    getEncoded(a) {
      var t, e, n;
      return (n = (e = (t = this.nestedRecords[a[0]]) == null ? void 0 : t[a[1]]) == null ? void 0 : e[a[2]]) == null ? void 0 : n[a[3]];
    }
    *find(a) {
      const t = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!t)
        return;
      const [e, n, i, c] = t, [s, d, l, f] = a;
      let h, p, b, _, y, m, g;
      const T = this.nestedRecords, v = e !== void 0 ? e in T ? [e] : [] : Object.keys(T);
      for (const E of v) {
        y = T[E], h = s || this.dictionary.decode(Number.parseInt(E, 10));
        const R = n !== void 0 ? n in y ? [n] : [] : Object.keys(y);
        for (const L of R) {
          m = y[L], p = d || this.dictionary.decode(Number.parseInt(L, 10));
          const A = i !== void 0 ? i in m ? [i] : [] : Object.keys(m);
          for (const w of A) {
            g = m[w], b = l || this.dictionary.decode(Number.parseInt(w, 10));
            const S = c !== void 0 ? c in g ? [c] : [] : Object.keys(g);
            for (const O of S)
              _ = f || this.dictionary.decode(Number.parseInt(O, 10)), yield [h, p, b, _];
          }
        }
      }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(a, t) {
      const [e, n, i, c] = a;
      let s, d, l;
      const f = this.nestedRecords, h = e !== void 0 ? e in f ? [e] : [] : Object.keys(f);
      for (const p of h) {
        s = f[p];
        const b = n !== void 0 ? n in s ? [n] : [] : Object.keys(s);
        for (const _ of b) {
          d = s[_];
          const y = i !== void 0 ? i in d ? [i] : [] : Object.keys(d);
          for (const m of y) {
            l = d[m];
            const g = c !== void 0 ? c in l ? [c] : [] : Object.keys(l);
            for (const T of g)
              yield [
                Number.parseInt(p, 10),
                Number.parseInt(_, 10),
                Number.parseInt(m, 10),
                Number.parseInt(T, 10)
              ];
          }
        }
      }
    }
    count(a) {
      let t = 0;
      const e = (0, u.encodeOptionalTerms)(a, this.dictionary);
      if (!e)
        return 0;
      const n = e[0], i = e[1], c = e[2], s = e[3];
      let d, l, f;
      const h = this.nestedRecords, p = n !== void 0 ? n in h ? [n] : [] : Object.keys(h);
      for (const b of p) {
        d = h[b];
        const _ = i !== void 0 ? i in d ? [i] : [] : Object.keys(d);
        for (const y of _) {
          l = d[y];
          const m = c !== void 0 ? c in l ? [c] : [] : Object.keys(l);
          for (const g of m)
            f = l[g], s !== void 0 ? s in f && t++ : t += Object.keys(f).length;
        }
      }
      return t;
    }
  };
  return l3.RdfStoreIndexNestedRecord = r, l3;
}
var f3 = {}, Rz;
function kye() {
  if (Rz) return f3;
  Rz = 1, Object.defineProperty(f3, "__esModule", { value: !0 }), f3.RdfStoreIndexNestedRecordQuoted = void 0;
  const u = $i(), r = VZ();
  let o = class extends r.RdfStoreIndexNestedRecord {
    constructor(t) {
      super(t), this.features = {
        quotedTripleFiltering: !0
      };
    }
    *getQuotedPatternKeys(t, e) {
      for (const n of this.dictionary.findQuotedTriplesEncoded(e))
        n in t && (yield n);
    }
    *find(t) {
      const e = (0, u.encodeOptionalTerms)(t, this.dictionary);
      if (!e)
        return;
      const [n, i, c, s] = e, [d, l, f, h] = t, [p, b, _, y] = (0, u.arePatternsQuoted)(t);
      let m, g, T, v, E, R, L;
      const A = this.nestedRecords, w = d !== void 0 ? p ? this.getQuotedPatternKeys(A, d) : n in A ? [n] : [] : Object.keys(A);
      for (const S of w) {
        E = A[S], m = !p && d ? d : this.dictionary.decode(Number.parseInt(S, 10));
        const O = l !== void 0 ? b ? this.getQuotedPatternKeys(E, l) : i in E ? [i] : [] : Object.keys(E);
        for (const x of O) {
          R = E[x], g = !b && l ? l : this.dictionary.decode(Number.parseInt(x, 10));
          const F = f !== void 0 ? _ ? this.getQuotedPatternKeys(R, f) : c in R ? [c] : [] : Object.keys(R);
          for (const j of F) {
            L = R[j], T = !_ && f ? f : this.dictionary.decode(Number.parseInt(j, 10));
            const q = h !== void 0 ? y ? this.getQuotedPatternKeys(L, h) : s in L ? [s] : [] : Object.keys(L);
            for (const Q of q)
              v = !y && h ? h : this.dictionary.decode(Number.parseInt(Q, 10)), yield [m, g, T, v];
          }
        }
      }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(t, e) {
      const [n, i, c, s] = t, [d, l, f, h] = e, [p, b, _, y] = (0, u.arePatternsQuoted)(e);
      let m, g, T;
      const v = this.nestedRecords, E = d !== void 0 ? p ? this.getQuotedPatternKeys(v, d) : n in v ? [n] : [] : Object.keys(v);
      for (const R of E) {
        m = v[R];
        const L = l !== void 0 ? b ? this.getQuotedPatternKeys(m, l) : i in m ? [i] : [] : Object.keys(m);
        for (const A of L) {
          g = m[A];
          const w = f !== void 0 ? _ ? this.getQuotedPatternKeys(g, f) : c in g ? [c] : [] : Object.keys(g);
          for (const S of w) {
            T = g[S];
            const O = h !== void 0 ? y ? this.getQuotedPatternKeys(T, h) : s in T ? [s] : [] : Object.keys(T);
            for (const x of O)
              yield [
                Number.parseInt(R, 10),
                Number.parseInt(A, 10),
                Number.parseInt(S, 10),
                Number.parseInt(x, 10)
              ];
          }
        }
      }
    }
    count(t) {
      let e = 0;
      const n = (0, u.encodeOptionalTerms)(t, this.dictionary);
      if (!n)
        return 0;
      const [i, c, s, d] = n, [l, f, h, p] = t, [b, _, y, m] = (0, u.arePatternsQuoted)(t);
      let g, T, v;
      const E = this.nestedRecords, R = l !== void 0 ? b ? this.getQuotedPatternKeys(E, l) : i in E ? [i] : [] : Object.keys(E);
      for (const L of R) {
        g = E[L];
        const A = f !== void 0 ? _ ? this.getQuotedPatternKeys(g, f) : c in g ? [c] : [] : Object.keys(g);
        for (const w of A) {
          T = g[w];
          const S = h !== void 0 ? y ? this.getQuotedPatternKeys(T, h) : s in T ? [s] : [] : Object.keys(T);
          for (const O of S)
            v = T[O], p !== void 0 ? m ? e += [...this.getQuotedPatternKeys(v, p)].length : d in v && e++ : e += Object.keys(v).length;
        }
      }
      return e;
    }
  };
  return f3.RdfStoreIndexNestedRecordQuoted = o, f3;
}
var IO = {}, Fz;
function Xye() {
  return Fz || (Fz = 1, Object.defineProperty(IO, "__esModule", { value: !0 })), IO;
}
var RO = {}, Nz;
function Jye() {
  return Nz || (Nz = 1, Object.defineProperty(RO, "__esModule", { value: !0 })), RO;
}
var Pz;
function Kye() {
  return Pz || (Pz = 1, function(u) {
    var r = zl && zl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = zl && zl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o($Z(), u), o(Bye(), u), o($ye(), u), o(Uye(), u), o(jZ(), u), o(Vye(), u), o(MZ(), u), o(Qye(), u), o(Hye(), u), o(Gye(), u), o(Y8(), u), o(CZ(), u), o(UZ(), u), o(zye(), u), o(VZ(), u), o(kye(), u), o(Xye(), u), o($i(), u), o(Jye(), u), o(qZ(), u);
  }(zl)), zl;
}
var Dz;
function QZ() {
  if (Dz) return z6;
  Dz = 1, Object.defineProperty(z6, "__esModule", { value: !0 }), z6.storeStream = r;
  const u = Kye();
  function r(o) {
    const a = u.RdfStore.createDefault();
    return new Promise((t, e) => a.import(o).on("error", e).once("end", () => t(a)));
  }
  return z6;
}
var Lz;
function Wye() {
  if (Lz) return Uv;
  Lz = 1, Object.defineProperty(Uv, "__esModule", { value: !0 }), Uv.ActorQuerySourceIdentifyHypermediaNone = void 0;
  const u = /* @__PURE__ */ K8(), r = /* @__PURE__ */ J8(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ _e(), t = /* @__PURE__ */ Jt(), e = QZ();
  let n = class extends r.ActorQuerySourceIdentifyHypermedia {
    constructor(c) {
      super(c, "file");
    }
    async testMetadata(c) {
      return (0, a.passTest)({ filterFactor: 0 });
    }
    async run(c) {
      this.logInfo(c.context, `Identified as file source: ${c.url}`);
      const s = c.context.getSafe(o.KeysInitQuery.dataFactory), d = new u.QuerySourceRdfJs(await (0, e.storeStream)(c.quads), s, await t.BindingsFactory.create(this.mediatorMergeBindingsContext, c.context, s));
      return d.toString = () => `QuerySourceRdfJs(${c.url})`, d.referenceValue = c.url, { source: d };
    }
  };
  return Uv.ActorQuerySourceIdentifyHypermediaNone = n, Uv;
}
var jz;
function Yye() {
  return jz || (jz = 1, function(u) {
    var r = Hl && Hl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Hl && Hl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Wye(), u);
  }(Hl)), Hl;
}
var Jl = {}, h3 = {}, Kl = {}, p3 = {}, Mz;
function Zye() {
  if (Mz) return p3;
  Mz = 1, Object.defineProperty(p3, "__esModule", { value: !0 }), p3.ActorExpressionEvaluatorFactory = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     * \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     * \ @defaultNested {Creation of Expression Evaluator failed} busFailMessage
     */
    constructor(a) {
      super(a), this.mediatorQueryOperation = a.mediatorQueryOperation, this.mediatorFunctionFactory = a.mediatorFunctionFactory, this.mediatorMergeBindingsContext = a.mediatorMergeBindingsContext;
    }
  };
  return p3.ActorExpressionEvaluatorFactory = r, p3;
}
var Cz;
function e_e() {
  return Cz || (Cz = 1, function(u) {
    var r = Kl && Kl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Kl && Kl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Zye(), u);
  }(Kl)), Kl;
}
var b3 = {}, qz;
function HZ() {
  if (qz) return b3;
  qz = 1, Object.defineProperty(b3, "__esModule", { value: !0 }), b3.AlgebraTransformer = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ ve(), o = ft();
  let a = class lS extends r.TermTransformer {
    constructor(e, n) {
      super(e.getSafe(u.KeysExpressionEvaluator.superTypeProvider)), this.context = e, this.mediatorFunctionFactory = n;
    }
    async transformAlgebra(e) {
      const n = o.Algebra.expressionTypes;
      switch (e.expressionType) {
        case n.TERM:
          return this.transformTerm(e);
        case n.OPERATOR:
          return await this.transformOperator(e);
        case n.NAMED:
          return await this.transformNamed(e);
        case n.EXISTENCE:
          return lS.transformExistence(e);
        case n.AGGREGATE:
          return lS.transformAggregate(e);
        case n.WILDCARD:
          return lS.transformWildcard(e);
      }
    }
    static transformWildcard(e) {
      return new r.NamedNode(e.wildcard.value);
    }
    async getOperator(e, n) {
      const i = await this.mediatorFunctionFactory.mediate({
        functionName: e,
        arguments: n.args,
        context: this.context
      }), c = await Promise.all(n.args.map((s) => this.transformAlgebra(s)));
      if (!i.checkArity(c))
        throw new r.InvalidArity(c, e);
      return new r.Operator(e, c, i.apply);
    }
    async transformOperator(e) {
      return this.getOperator(e.operator.toLowerCase(), e);
    }
    async transformNamed(e) {
      return this.getOperator(e.name.value, e);
    }
    static transformAggregate(e) {
      const n = e.aggregator;
      return new r.Aggregate(n, e);
    }
    static transformExistence(e) {
      return new r.Existence(e);
    }
  };
  return b3.AlgebraTransformer = a, b3;
}
var y3 = {}, _3 = {}, Bz;
function GZ() {
  if (Bz) return _3;
  Bz = 1, Object.defineProperty(_3, "__esModule", { value: !0 }), _3.InternalEvaluator = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ ru(), o = /* @__PURE__ */ ve(), a = /* @__PURE__ */ vt(), t = ft(), e = /* @__PURE__ */ HZ();
  let n = class {
    constructor(c, s, d, l) {
      this.context = c, this.mediatorQueryOperation = d, this.bindingsFactory = l, this.subEvaluators = {
        [r.ExpressionType.Term]: (f, h) => this.term(f),
        [r.ExpressionType.Variable]: (f, h) => this.variable(f, h),
        [r.ExpressionType.Operator]: (f, h) => this.evalFunction(f, h),
        [r.ExpressionType.Existence]: (f, h) => this.evalExistence(f, h),
        [r.ExpressionType.Aggregate]: (f, h) => this.evalAggregate()
      }, this.transformer = new e.AlgebraTransformer(c, s);
    }
    async evaluatorExpressionEvaluation(c, s) {
      return this.subEvaluators[c.expressionType].bind(this)(c, s);
    }
    term(c) {
      return c;
    }
    variable(c, s) {
      const d = s.get(o.expressionToVar(this.context.getSafe(u.KeysInitQuery.dataFactory), c));
      if (!d)
        throw new o.UnboundVariableError(c.name, s);
      return this.transformer.transformRDFTermUnsafe(d);
    }
    async evalFunction(c, s) {
      return c.apply({
        args: c.args,
        mapping: s,
        exprEval: this
      });
    }
    async evalExistence(c, s) {
      const d = this.context.getSafe(u.KeysInitQuery.dataFactory), l = new t.Factory(d), f = (0, a.materializeOperation)(c.expression.input, s, l, this.bindingsFactory), h = await this.mediatorQueryOperation.mediate({ operation: f, context: this.context }), p = (0, a.getSafeBindings)(h);
      return await new Promise((b, _) => {
        p.bindingsStream.on("end", () => {
          b(!1);
        }), p.bindingsStream.on("error", _), p.bindingsStream.on("data", () => {
          p.bindingsStream.close(), b(!0);
        });
      }).then((b) => c.expression.not ? !b : b).then((b) => new o.BooleanLiteral(b));
    }
    evalAggregate() {
      throw new o.NoAggregator();
    }
  };
  return _3.InternalEvaluator = n, _3;
}
var $z;
function t_e() {
  if ($z) return y3;
  $z = 1, Object.defineProperty(y3, "__esModule", { value: !0 }), y3.ExpressionEvaluator = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ GZ();
  let o = class {
    constructor(t, e, n, i, c) {
      this.context = t, this.expr = e, this.mediatorFunctionFactory = n, this.mediatorQueryOperation = i, this.bindingsFactory = c, this.internalEvaluator = new r.InternalEvaluator(t, n, i, c);
    }
    async evaluate(t) {
      return (await this.internalEvaluator.evaluatorExpressionEvaluation(this.expr, t)).toRDF(this.context.getSafe(u.KeysInitQuery.dataFactory));
    }
    async evaluateAsEBV(t) {
      return (await this.internalEvaluator.evaluatorExpressionEvaluation(this.expr, t)).coerceEBV();
    }
    evaluateAsEvaluatorExpression(t) {
      return this.evaluatorExpressionEvaluation(this.expr, t);
    }
    evaluatorExpressionEvaluation(t, e) {
      return this.internalEvaluator.evaluatorExpressionEvaluation(t, e);
    }
  };
  return y3.ExpressionEvaluator = o, y3;
}
var Uz;
function r_e() {
  if (Uz) return h3;
  Uz = 1, Object.defineProperty(h3, "__esModule", { value: !0 }), h3.ActorExpressionEvaluatorFactoryDefault = void 0;
  const u = /* @__PURE__ */ e_e(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ ve(), e = /* @__PURE__ */ HZ(), n = /* @__PURE__ */ t_e();
  let i = class extends u.ActorExpressionEvaluatorFactory {
    constructor(s) {
      super(s);
    }
    async test(s) {
      return (0, o.passTestVoid)();
    }
    async run(s) {
      const d = (0, t.prepareEvaluatorActionContext)(s.context);
      return new n.ExpressionEvaluator(d, await new e.AlgebraTransformer(d, this.mediatorFunctionFactory).transformAlgebra(s.algExpr), this.mediatorFunctionFactory, this.mediatorQueryOperation, await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s.context, s.context.getSafe(r.KeysInitQuery.dataFactory)));
    }
  };
  return h3.ActorExpressionEvaluatorFactoryDefault = i, h3;
}
var Vz;
function n_e() {
  return Vz || (Vz = 1, function(u) {
    var r = Jl && Jl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Jl && Jl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ r_e(), u);
  }(Jl)), Jl;
}
var Wl = {}, g3 = {}, m3 = {}, Qz;
function i_e() {
  if (Qz) return m3;
  Qz = 1, Object.defineProperty(m3, "__esModule", { value: !0 }), m3.GroupsState = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ Jt();
  let o = class {
    constructor(t, e, n, i, c) {
      this.pattern = t, this.mediatorBindingsAggregatorFactory = e, this.context = n, this.bindingsFactory = i, this.variables = c, this.groups = /* @__PURE__ */ new Map(), this.groupsInitializer = /* @__PURE__ */ new Map(), this.groupVariables = new Set(this.pattern.variables.map((s) => s.value)), this.waitCounter = 1, this.resultHasBeenCalled = !1;
    }
    /**
     * - Consumes a stream binding
     * - Find the corresponding group and create one if need be
     * - Feeds the binding to the group's aggregators
     *
     * @param {Bindings} bindings - The Bindings to consume
     */
    consumeBindings(t) {
      const e = this.resultCheck();
      if (e)
        return e;
      this.waitCounter++;
      const n = t.filter((d, l) => this.groupVariables.has(l.value)), i = this.hashBindings(n);
      let c = this.groupsInitializer.get(i), s;
      if (c) {
        const d = c;
        s = (async () => {
          const l = await d;
          await Promise.all(this.pattern.aggregates.map(async (f) => {
            const h = f.variable.value;
            await l.aggregators[h].putBindings(t);
          }));
        })().then(async () => {
          await this.subtractWaitCounterAndCollect();
        });
      } else
        c = (async () => {
          const d = {};
          await Promise.all(this.pattern.aggregates.map(async (f) => {
            const h = f.variable.value;
            d[h] = await this.mediatorBindingsAggregatorFactory.mediate({ expr: f, context: this.context }), await d[h].putBindings(t);
          }));
          const l = { aggregators: d, bindings: n };
          return this.groups.set(i, l), await this.subtractWaitCounterAndCollect(), l;
        })(), this.groupsInitializer.set(i, c), s = c;
      return s;
    }
    async subtractWaitCounterAndCollect() {
      --this.waitCounter === 0 && await this.handleResultCollection();
    }
    async handleResultCollection() {
      const t = this.context.getSafe(u.KeysInitQuery.dataFactory);
      let e = await Promise.all([...this.groups].map(async ([n, i]) => {
        const { bindings: c, aggregators: s } = i;
        let d = c;
        for (const l in s) {
          const f = await s[l].result();
          f && (d = d.set(t.variable(l), f));
        }
        return d;
      }));
      if (e.length === 0 && this.groupVariables.size === 0) {
        const n = [];
        await Promise.all(this.pattern.aggregates.map(async (i) => {
          const c = i.variable, d = await (await this.mediatorBindingsAggregatorFactory.mediate({ expr: i, context: this.context })).result();
          d !== void 0 && n.push([c, d]);
        })), e = [this.bindingsFactory.bindings(n)];
      }
      this.waitResolver(e);
    }
    resultCheck() {
      if (this.resultHasBeenCalled)
        return Promise.reject(new Error("Calling any function after calling collectResult is invalid."));
    }
    /**
     * Collect the result of the final state. This returns a Bindings per group,
     * and a (possibly empty) Bindings in case no Bindings have been consumed yet.
     * You can only call this method once, after calling this method,
     * calling any function on this will result in an error being thrown.
     */
    async collectResults() {
      const t = this.resultCheck();
      if (t)
        return t;
      this.resultHasBeenCalled = !0;
      const e = new Promise((n) => {
        this.waitResolver = n;
      });
      return await this.subtractWaitCounterAndCollect(), e;
    }
    /**
     * @param {Bindings} bindings - Bindings to hash
     */
    hashBindings(t) {
      return (0, r.bindingsToCompactString)(t, this.variables);
    }
  };
  return m3.GroupsState = o, m3;
}
var Hz;
function a_e() {
  if (Hz) return g3;
  Hz = 1, Object.defineProperty(g3, "__esModule", { value: !0 }), g3.ActorQueryOperationGroup = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt(), n = /* @__PURE__ */ i_e();
  let i = class extends u.ActorQueryOperationTypedMediated {
    constructor(s) {
      super(s, "group"), this.mediatorBindingsAggregatorFactory = s.mediatorBindingsAggregatorFactory;
    }
    async testOperation() {
      return (0, o.passTestVoid)();
    }
    async runOperation(s, d) {
      const l = d.getSafe(r.KeysInitQuery.dataFactory), f = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, d, l), { input: h, aggregates: p } = s, b = await this.mediatorQueryOperation.mediate({ operation: h, context: d }), _ = (0, t.getSafeBindings)(b), y = [
        ...s.variables,
        ...p.map((T) => T.variable)
      ].map((T) => ({ variable: T, canBeUndef: !1 })), m = (await _.metadata()).variables.map((T) => T.variable);
      return {
        type: "bindings",
        bindingsStream: new e.TransformIterator(() => new Promise((T, v) => {
          const E = new n.GroupsState(s, this.mediatorBindingsAggregatorFactory, d, f, m);
          _.bindingsStream.on("end", async () => {
            try {
              const R = new e.ArrayIterator(await E.collectResults(), { autoStart: !1 });
              T(R);
            } catch (R) {
              v(R);
            }
          }), _.bindingsStream.on("error", v), _.bindingsStream.on("data", (R) => {
            E.consumeBindings(R).catch(v);
          });
        }), { autoStart: !1 }),
        metadata: async () => ({ ...await _.metadata(), variables: y })
      };
    }
  };
  return g3.ActorQueryOperationGroup = i, g3;
}
var Gz;
function u_e() {
  return Gz || (Gz = 1, function(u) {
    var r = Wl && Wl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Wl && Wl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ a_e(), u);
  }(Wl)), Wl;
}
var Yl = {}, v3 = {}, zz;
function o_e() {
  if (zz) return v3;
  zz = 1, Object.defineProperty(v3, "__esModule", { value: !0 }), v3.ActorQueryOperationNop = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ Rr(), e = /* @__PURE__ */ yt();
  let n = class extends u.ActorQueryOperationTypedMediated {
    constructor(c) {
      super(c, "nop");
    }
    async testOperation(c, s) {
      return (0, o.passTestVoid)();
    }
    async runOperation(c, s) {
      const d = s.getSafe(r.KeysInitQuery.dataFactory), l = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s, d);
      return {
        bindingsStream: new e.SingletonIterator(l.bindings()),
        metadata: () => Promise.resolve({
          state: new t.MetadataValidationState(),
          cardinality: { type: "exact", value: 1 },
          variables: []
        }),
        type: "bindings"
      };
    }
  };
  return v3.ActorQueryOperationNop = n, v3;
}
var kz;
function s_e() {
  return kz || (kz = 1, function(u) {
    var r = Yl && Yl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Yl && Yl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ o_e(), u);
  }(Yl)), Yl;
}
var Zl = {}, T3 = {}, Xz;
function c_e() {
  if (Xz) return T3;
  Xz = 1, Object.defineProperty(T3, "__esModule", { value: !0 }), T3.ActorQueryOperationService = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ Rr(), e = /* @__PURE__ */ vt(), n = /* @__PURE__ */ yt();
  let i = class extends u.ActorQueryOperationTypedMediated {
    constructor(s) {
      super(s, "service");
    }
    async testOperation(s, d) {
      return s.name.termType !== "NamedNode" ? (0, o.failTest)(`${this.name} can only query services by IRI, while a ${s.name.termType} was given.`) : (0, o.passTestVoid)();
    }
    async runOperation(s, d) {
      const { querySource: l } = await this.mediatorQuerySourceIdentify.mediate({
        querySourceUnidentified: {
          value: s.name.value,
          type: this.forceSparqlEndpoint ? "sparql" : void 0
        },
        context: d
      });
      let f;
      try {
        f = (0, e.getSafeBindings)(await this.mediatorQueryOperation.mediate({
          operation: (0, e.assignOperationSource)(s.input, l),
          context: d
        }));
      } catch (h) {
        if (s.silent) {
          const p = d.getSafe(r.KeysInitQuery.dataFactory), b = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, d, p);
          f = {
            bindingsStream: new n.SingletonIterator(b.bindings()),
            type: "bindings",
            metadata: async () => ({
              state: new t.MetadataValidationState(),
              cardinality: { type: "exact", value: 1 },
              variables: []
            })
          }, this.logWarn(d, `An error occurred when executing a SERVICE clause: ${h.message}`);
        } else
          throw h;
      }
      return f;
    }
  };
  return T3.ActorQueryOperationService = i, T3;
}
var Jz;
function d_e() {
  return Jz || (Jz = 1, function(u) {
    var r = Zl && Zl.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Zl && Zl.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ c_e(), u);
  }(Zl)), Zl;
}
var ef = {}, w3 = {}, Kz;
function l_e() {
  if (Kz) return w3;
  Kz = 1, Object.defineProperty(w3, "__esModule", { value: !0 }), w3.ActorQueryOperationValues = void 0;
  const u = /* @__PURE__ */ Ht(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ Rr(), e = /* @__PURE__ */ yt();
  let n = class extends u.ActorQueryOperationTyped {
    constructor(c) {
      super(c, "values");
    }
    async testOperation(c, s) {
      return (0, o.passTestVoid)();
    }
    async runOperation(c, s) {
      const d = s.getSafe(r.KeysInitQuery.dataFactory), l = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s, d);
      return { type: "bindings", bindingsStream: new e.ArrayIterator(c.bindings.map((p) => l.bindings(Object.entries(p).map(([b, _]) => [d.variable(b.slice(1)), _])))), metadata: () => Promise.resolve({
        state: new t.MetadataValidationState(),
        cardinality: { type: "exact", value: c.bindings.length },
        variables: c.variables.map((p) => ({
          variable: p,
          canBeUndef: c.bindings.some((b) => !(`?${p.value}` in b))
        }))
      }) };
    }
  };
  return w3.ActorQueryOperationValues = n, w3;
}
var Wz;
function f_e() {
  return Wz || (Wz = 1, function(u) {
    var r = ef && ef.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ef && ef.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ l_e(), u);
  }(ef)), ef;
}
var tf = {}, S3 = {}, Yz;
function h_e() {
  if (Yz) return S3;
  Yz = 1, Object.defineProperty(S3, "__esModule", { value: !0 }), S3.ActorQueryOperationPathOneOrMore = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt(), e = ft();
  let n = class extends u.ActorAbstractPath {
    constructor(c) {
      super(c, e.Algebra.types.ONE_OR_MORE_PATH);
    }
    async runOperation(c, s) {
      const d = s.getSafe(r.KeysInitQuery.dataFactory), l = new e.Factory(d), f = await o.BindingsFactory.create(this.mediatorMergeBindingsContext, s, d), h = await this.isPathArbitraryLengthDistinct(l, s, c);
      if (h.operation)
        return h.operation;
      s = h.context;
      const p = c.predicate;
      if (c.subject.termType !== "Variable" && c.object.termType === "Variable") {
        const m = c.object, g = await this.getObjectsPredicateStarEval(c.subject, p.path, m, c.graph, s, !1, l, f), T = (c.graph.termType === "Variable" ? [m, c.graph] : [m]).map((v) => ({ variable: v, canBeUndef: !1 }));
        return {
          type: "bindings",
          bindingsStream: g.bindingsStream,
          metadata: async () => ({ ...await g.metadata(), variables: T })
        };
      }
      if (c.subject.termType === "Variable" && c.object.termType === "Variable") {
        const m = l.createDistinct(l.createPath(c.subject, c.predicate.path, c.object, c.graph)), g = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ context: s, operation: m })), T = c.subject, v = c.object, E = {}, R = new t.MultiTransformIterator(g.bindingsStream, {
          multiTransform: (A) => {
            const w = A.get(T), S = A.get(v), O = c.graph.termType === "Variable" ? A.get(c.graph) : c.graph;
            return new t.TransformIterator(async () => {
              const x = new t.BufferedIterator();
              return await this.getSubjectAndObjectBindingsPredicateStar(T, v, w, S, p.path, O, s, E, {}, x, { count: 0 }, l, f), x.map((F) => (c.graph.termType === "Variable" && (F = F.set(c.graph, O)), F));
            }, { autoStart: !1, maxBufferSize: 128 });
          },
          autoStart: !1
        }), L = (c.graph.termType === "Variable" ? [T, v, c.graph] : [T, v]).map((A) => ({ variable: A, canBeUndef: !1 }));
        return {
          type: "bindings",
          bindingsStream: R,
          metadata: async () => ({ ...await g.metadata(), variables: L })
        };
      }
      if (c.subject.termType === "Variable" && c.object.termType !== "Variable")
        return this.mediatorQueryOperation.mediate({
          context: s,
          operation: l.createPath(c.object, l.createOneOrMorePath(l.createInv(p.path)), c.subject, c.graph)
        });
      const b = this.generateVariable(d), _ = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({
        context: s,
        operation: l.createPath(c.subject, p, b, c.graph)
      }));
      return {
        type: "bindings",
        bindingsStream: _.bindingsStream.map((m) => c.object.equals(m.get(b)) ? c.graph.termType === "Variable" ? f.bindings([[c.graph, m.get(c.graph)]]) : f.bindings() : null),
        metadata: async () => ({
          ...await _.metadata(),
          variables: (c.graph.termType === "Variable" ? [c.graph] : []).map((m) => ({ variable: m, canBeUndef: !1 }))
        })
      };
    }
  };
  return S3.ActorQueryOperationPathOneOrMore = n, S3;
}
var Zz;
function p_e() {
  return Zz || (Zz = 1, function(u) {
    var r = tf && tf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = tf && tf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ h_e(), u);
  }(tf)), tf;
}
var rf = {}, A3 = {}, ek;
function b_e() {
  if (ek) return A3;
  ek = 1, Object.defineProperty(A3, "__esModule", { value: !0 }), A3.ActorQueryOperationPathZeroOrMore = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ vt(), t = /* @__PURE__ */ yt(), e = lr(), n = ft();
  let i = class extends u.ActorAbstractPath {
    constructor(s) {
      super(s, n.Algebra.types.ZERO_OR_MORE_PATH);
    }
    async runOperation(s, d) {
      const l = d.getSafe(r.KeysInitQuery.dataFactory), f = new n.Factory(l), h = await o.BindingsFactory.create(this.mediatorMergeBindingsContext, d, l), p = await this.isPathArbitraryLengthDistinct(f, d, s);
      if (p.operation)
        return p.operation;
      d = p.context;
      const b = s.predicate, _ = this.getPathSources(b), y = s.subject.termType === "Variable", m = s.object.termType === "Variable";
      if (s.subject.termType === "Variable" && s.object.termType === "Variable") {
        const L = this.generateVariable(l, s), A = this.assignPatternSources(f, f.createPattern(s.subject, L, s.object, s.graph), _), w = (0, a.getSafeBindings)(await this.mediatorQueryOperation.mediate({ context: d, operation: A })), S = s.subject, O = s.object, x = /* @__PURE__ */ new Set(), F = {}, j = new t.MultiTransformIterator(w.bindingsStream, {
          multiTransform: (Q) => {
            const G = Q.get(S), K = Q.get(O), U = s.graph.termType === "Variable" ? Q.get(s.graph) : s.graph, ae = (0, e.termToString)(G) + (0, e.termToString)(U), ye = (0, e.termToString)(K) + (0, e.termToString)(U);
            return new t.TransformIterator(async () => {
              if (x.has(ae) && x.has(ye))
                return new t.EmptyIterator();
              const pe = new t.BufferedIterator(), ee = { count: 0 };
              return x.has(ae) || (x.add(ae), await this.getSubjectAndObjectBindingsPredicateStar(S, O, G, G, b.path, U, d, F, {}, pe, ee, f, h)), x.has(ye) || (x.add(ye), await this.getSubjectAndObjectBindingsPredicateStar(S, O, K, K, b.path, U, d, F, {}, pe, ee, f, h)), pe.map((Te) => (s.graph.termType === "Variable" && (Te = Te.set(s.graph, U)), Te));
            }, { autoStart: !1, maxBufferSize: 128 });
          },
          autoStart: !1
        }), q = (s.graph.termType === "Variable" ? [S, s.object, s.graph] : [S, s.object]).map((Q) => ({ variable: Q, canBeUndef: !1 }));
        return {
          type: "bindings",
          bindingsStream: j,
          metadata: async () => ({ ...await w.metadata(), variables: q })
        };
      }
      if (!y && !m) {
        const L = this.generateVariable(l), A = await this.getObjectsPredicateStarEval(s.subject, b.path, L, s.graph, d, !0, f, h);
        return {
          type: "bindings",
          bindingsStream: A.bindingsStream.map((S) => s.object.equals(S.get(L)) ? s.graph.termType === "Variable" ? h.bindings([[s.graph, S.get(s.graph)]]) : h.bindings() : null),
          metadata: async () => ({
            ...await A.metadata(),
            variables: (s.graph.termType === "Variable" ? [s.graph] : []).map((S) => ({ variable: S, canBeUndef: !1 }))
          })
        };
      }
      const g = y ? s.object : s.subject, T = y ? s.subject : s.object, v = y ? f.createInv(b.path) : b.path, E = await this.getObjectsPredicateStarEval(g, v, T, s.graph, d, !0, f, h), R = (s.graph.termType === "Variable" ? [T, s.graph] : [T]).map((L) => ({ variable: L, canBeUndef: !1 }));
      return {
        type: "bindings",
        bindingsStream: E.bindingsStream,
        metadata: async () => ({ ...await E.metadata(), variables: R })
      };
    }
  };
  return A3.ActorQueryOperationPathZeroOrMore = i, A3;
}
var tk;
function y_e() {
  return tk || (tk = 1, function(u) {
    var r = rf && rf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = rf && rf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ b_e(), u);
  }(rf)), rf;
}
var nf = {}, E3 = {}, rk;
function __e() {
  if (rk) return E3;
  rk = 1, Object.defineProperty(E3, "__esModule", { value: !0 }), E3.ActorQueryOperationPathZeroOrOne = void 0;
  const u = /* @__PURE__ */ su(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ Rr(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt(), n = ft();
  let i = class extends u.ActorAbstractPath {
    constructor(s) {
      super(s, n.Algebra.types.ZERO_OR_ONE_PATH);
    }
    async runOperation(s, d) {
      const l = d.getSafe(r.KeysInitQuery.dataFactory), f = new n.Factory(l), h = await o.BindingsFactory.create(this.mediatorMergeBindingsContext, d, l), p = s.predicate, b = this.getPathSources(p), _ = [];
      if (s.subject.termType !== "Variable" && s.object.termType !== "Variable" && s.subject.equals(s.object))
        return {
          type: "bindings",
          bindingsStream: new e.SingletonIterator(h.bindings()),
          metadata: () => Promise.resolve({
            state: new a.MetadataValidationState(),
            cardinality: { type: "exact", value: 1 },
            variables: []
          })
        };
      const y = await this.isPathArbitraryLengthDistinct(f, d, s);
      if (y.operation)
        return y.operation;
      d = y.context;
      const m = (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({
        context: d,
        operation: f.createPath(s.subject, p.path, s.object, s.graph)
      }));
      let g;
      if (s.subject.termType === "Variable" && s.object.termType === "Variable") {
        const v = this.generateVariable(l, s), E = (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({
          context: d,
          operation: f.createFilter(this.assignPatternSources(f, f.createPattern(s.subject, v, s.object, s.graph), b), f.createOperatorExpression("=", [
            f.createTermExpression(s.subject),
            f.createTermExpression(s.object)
          ]))
        })).bindingsStream.map((R) => R.delete(v));
        g = new e.UnionIterator([
          E,
          m.bindingsStream
        ], { autoStart: !1 });
      } else
        s.subject.termType === "Variable" && _.push(h.bindings([[s.subject, s.object]])), s.object.termType === "Variable" && _.push(h.bindings([[s.object, s.subject]])), g = m.bindingsStream.prepend(_);
      return {
        type: "bindings",
        bindingsStream: g,
        metadata: async () => {
          const v = await m.metadata();
          return {
            ...v,
            cardinality: {
              ...v.cardinality,
              // Add one to cardinality because we allow *ZERO* or more.
              value: v.cardinality.value + 1
            }
          };
        }
      };
    }
  };
  return E3.ActorQueryOperationPathZeroOrOne = i, E3;
}
var nk;
function g_e() {
  return nk || (nk = 1, function(u) {
    var r = nf && nf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = nf && nf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ __e(), u);
  }(nf)), nf;
}
var af = {}, O3 = {}, ik;
function m_e() {
  if (ik) return O3;
  ik = 1, Object.defineProperty(O3, "__esModule", { value: !0 }), O3.ActorQueryOperationUpdateDeleteInsert = void 0;
  const u = /* @__PURE__ */ yZ(), r = /* @__PURE__ */ Ht(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt();
  let n = class extends r.ActorQueryOperationTypedMediated {
    constructor(c) {
      super(c, "deleteinsert"), this.blankNodeCounter = 0;
    }
    async testOperation(c, s) {
      return (0, t.testReadOnly)(s);
    }
    async runOperation(c, s) {
      const d = s.getSafe(o.KeysInitQuery.dataFactory), l = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s, d), f = c.where ? (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: c.where, context: s })).bindingsStream : new e.ArrayIterator([l.bindings()], { autoStart: !1 });
      let h, p;
      c.insert && (h = new u.BindingsToQuadsIterator(d, c.insert.map(u.BindingsToQuadsIterator.localizeQuad.bind(null, d, this.blankNodeCounter)), f.clone()), this.blankNodeCounter++), c.delete && (p = new u.BindingsToQuadsIterator(d, c.delete.map(u.BindingsToQuadsIterator.localizeQuad.bind(null, d, this.blankNodeCounter)), f.clone()), this.blankNodeCounter++);
      const { execute: b } = await this.mediatorUpdateQuads.mediate({
        quadStreamInsert: h,
        quadStreamDelete: p,
        context: s
      });
      return {
        type: "void",
        execute: b
      };
    }
  };
  return O3.ActorQueryOperationUpdateDeleteInsert = n, O3;
}
var ak;
function v_e() {
  return ak || (ak = 1, function(u) {
    var r = af && af.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = af && af.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ m_e(), u);
  }(af)), af;
}
var uf = {}, x3 = {}, of = {}, I3 = {}, uk;
function T_e() {
  if (uk) return I3;
  uk = 1, Object.defineProperty(I3, "__esModule", { value: !0 }), I3.ActorQueryProcess = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /* eslint-disable max-len */
    /**
     * @param args -
     *   \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *   \ @defaultNested {Query processing failed: none of the configured actor were process to the query "${action.query}"} busFailMessage
     */
    /* eslint-enable max-len */
    constructor(a) {
      super(a);
    }
  };
  return I3.ActorQueryProcess = r, I3;
}
var ok;
function h4() {
  return ok || (ok = 1, function(u) {
    var r = of && of.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = of && of.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ T_e(), u);
  }(of)), of;
}
var sk;
function w_e() {
  if (sk) return x3;
  sk = 1, Object.defineProperty(x3, "__esModule", { value: !0 }), x3.ActorQueryProcessSequential = void 0;
  const u = /* @__PURE__ */ h4(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ vt(), e = ft();
  let n = class extends u.ActorQueryProcess {
    constructor(c) {
      super(c);
    }
    async test(c) {
      return c.context.get(r.KeysInitQuery.explain) ?? c.context.get(new o.ActionContextKey("explain")) ? (0, o.failTest)(`${this.name} is not able to explain queries.`) : (0, o.passTestVoid)();
    }
    async run(c) {
      let { operation: s, context: d } = await this.parse(c.query, c.context);
      return { operation: s, context: d } = await this.optimize(s, d), { result: await this.evaluate(s, d) };
    }
    async parse(c, s) {
      s = (await this.mediatorContextPreprocess.mediate({ context: s, initialize: !0 })).context;
      let d;
      if (typeof c == "string") {
        s = s.set(r.KeysInitQuery.queryString, c);
        const l = s.get(r.KeysInitQuery.baseIRI), f = s.get(r.KeysInitQuery.queryFormat), h = await this.mediatorQueryParse.mediate({ context: s, query: c, queryFormat: f, baseIRI: l });
        d = h.operation, h.baseIRI && (s = s.set(r.KeysInitQuery.baseIRI, h.baseIRI));
      } else
        d = c;
      if (s.has(r.KeysInitQuery.initialBindings)) {
        const l = s.getSafe(r.KeysInitQuery.dataFactory), f = new e.Factory(l), h = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s, l);
        d = (0, t.materializeOperation)(d, s.get(r.KeysInitQuery.initialBindings), f, h, { strictTargetVariables: !0 }), s = s.delete(r.KeysInitQuery.queryString);
      }
      return { operation: d, context: s };
    }
    async optimize(c, s) {
      return s = s.set(r.KeysInitQuery.query, c), { operation: c, context: s } = await this.mediatorOptimizeQueryOperation.mediate({ context: s, operation: c }), s = s.set(r.KeysInitQuery.query, c), { operation: c, context: s };
    }
    async evaluate(c, s) {
      const d = await this.mediatorQueryOperation.mediate({ context: s, operation: c });
      return d.context = s, d;
    }
  };
  return x3.ActorQueryProcessSequential = n, x3;
}
var ck;
function S_e() {
  return ck || (ck = 1, function(u) {
    var r = uf && uf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = uf && uf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ w_e(), u);
  }(uf)), uf;
}
var sf = {}, R3 = {}, F3 = {}, N3 = {}, P3 = {}, dk;
function A_e() {
  if (dk) return P3;
  dk = 1, Object.defineProperty(P3, "__esModule", { value: !0 }), P3.LinkedRdfSourcesAsyncRdfIterator = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ Rr(), o = /* @__PURE__ */ yt();
  let a = class extends o.BufferedIterator {
    constructor(e, n, i, c, s, d, l, f) {
      if (super({ autoStart: !1, ...f }), this.started = !1, this.currentIterators = [], this.iteratorsPendingCreation = 0, this.iteratorsPendingTermination = 0, this.accumulatedMetadata = Promise.resolve(void 0), this._reading = !1, this.cacheSize = e, this.operation = n, this.queryBindingsOptions = i, this.context = c, this.firstUrl = s, this.maxIterators = d, this.sourceStateGetter = l, this.maxIterators <= 0)
        throw new Error(`LinkedRdfSourcesAsyncRdfIterator.maxIterators must be larger than zero, but got ${this.maxIterators}`);
    }
    /**
     * Start filling the buffer of this iterator.
     */
    kickstart() {
      this.started || this._fillBufferAsync();
    }
    getProperty(e, n) {
      return e === "metadata" && !this.started && (this.preflightMetadata || (this.preflightMetadata = new Promise((i, c) => {
        this.sourceStateGetter({ url: this.firstUrl }, {}).then((s) => {
          const d = s.source.queryBindings(this.operation, this.context);
          d.getProperty("metadata", (l) => {
            l.state = new r.MetadataValidationState(), d.destroy(), this.accumulateMetadata(s.metadata, l).then((f) => {
              const h = { ...s.metadata, ...l, ...f };
              i(h);
            }).catch(() => {
              i({
                ...s.metadata,
                state: new r.MetadataValidationState()
              });
            });
          });
        }).catch(c);
      })), this.preflightMetadata.then((i) => this.setProperty("metadata", i)).catch((i) => this.emit("error", i))), super.getProperty(e, n);
    }
    _end(e) {
      for (const n of this.currentIterators)
        n.destroy();
      super._end(e);
    }
    _read(e, n) {
      if (this.started) {
        for (const i of this.currentIterators) {
          for (; e > 0; ) {
            const c = i.read();
            if (c === null)
              break;
            e--, this._push(c);
          }
          if (e <= 0)
            break;
        }
        e >= 0 && this.canStartNewIterator() ? this.sourceStateGetter({ url: this.firstUrl }, {}).then((i) => {
          this.startIteratorsForNextUrls(i.handledDatasets, !1), n();
        }) : n();
      } else
        this.started = !0, this.sourceStateGetter({ url: this.firstUrl }, {}).then((i) => {
          this.startIterator(i), n();
        }).catch((i) => setTimeout(() => this.destroy(i)));
    }
    canStartNewIterator() {
      return this.currentIterators.length + this.iteratorsPendingCreation + this.iteratorsPendingTermination < this.maxIterators && (!this.canStartNewIteratorConsiderReadable() || !this.readable);
    }
    canStartNewIteratorConsiderReadable() {
      return !0;
    }
    areIteratorsRunning() {
      return this.currentIterators.length + this.iteratorsPendingCreation + this.iteratorsPendingTermination > 0;
    }
    /**
     * Start a new iterator for the given source.
     * Once the iterator is done, it will either determine a new source, or it will close the linked iterator.
     * @param {ISourceState} startSource The start source state.
     */
    startIterator(e) {
      try {
        const n = e.source.queryBindings(this.operation, this.context, this.queryBindingsOptions);
        this.currentIterators.push(n);
        let i = !1, c = !1;
        n._destination = this, n.on("error", (s) => this.destroy(s)), n.on("readable", () => this._fillBuffer()), n.on("end", () => {
          this.currentIterators.splice(this.currentIterators.indexOf(n), 1), i = !0, c || this.iteratorsPendingTermination++, c && this.startIteratorsForNextUrls(e.handledDatasets, !0);
        }), n.getProperty("metadata", (s) => {
          this.accumulatedMetadata = this.accumulatedMetadata.then((d) => (async () => (d || (d = e.metadata), this.accumulateMetadata(d, s)))().then((l) => {
            const f = { ...e.metadata, ...s, ...l };
            return f.state = new r.MetadataValidationState(), this.updateMetadata(f), this.preflightMetadata && this.preflightMetadata.then((h) => h.state.invalidate()).catch(() => {
            }), this.getSourceLinks(f, e).then((h) => Promise.all(h)).then(async (h) => {
              const p = await this.getLinkQueue();
              for (const b of h)
                p.push(b, e.link);
              c = !0, i && this.iteratorsPendingTermination--, this.startIteratorsForNextUrls(e.handledDatasets, !0);
            }).catch((h) => this.destroy(h)), f;
          })).catch((d) => (this.destroy(d), {}));
        });
      } catch (n) {
        this.destroy(n);
      }
    }
    updateMetadata(e) {
      const n = this.getProperty("metadata");
      this.setProperty("metadata", e), n == null || n.state.invalidate();
    }
    isRunning() {
      return !this.done;
    }
    /**
     * Check if a next URL is in the queue.
     * If yes, start a new iterator.
     * If no, close this iterator.
     * @param handledDatasets
     * @param canClose
     */
    startIteratorsForNextUrls(e, n) {
      this.getLinkQueue().then((i) => {
        for (; this.canStartNewIterator() && this.isRunning(); ) {
          const c = i.pop();
          if (c)
            this.iteratorsPendingCreation++, this.sourceStateGetter(c, e).then((s) => {
              const d = this.context.get(u.KeysStatistics.dereferencedLinks);
              d && d.updateStatistic({
                url: s.link.url,
                metadata: { ...s.metadata, ...s.link.metadata }
              }, s.source), this.iteratorsPendingCreation--, this.startIterator(s);
            }).catch((s) => this.emit("error", s));
          else
            break;
        }
        n && this.isCloseable(i, !0) && this.close();
      }).catch((i) => this.destroy(i));
    }
    isCloseable(e, n) {
      return e.isEmpty() && !this.areIteratorsRunning();
    }
  };
  return P3.LinkedRdfSourcesAsyncRdfIterator = a, P3;
}
var lk;
function E_e() {
  if (lk) return N3;
  lk = 1, Object.defineProperty(N3, "__esModule", { value: !0 }), N3.MediatedLinkedRdfSourcesAsyncRdfIterator = void 0;
  const u = /* @__PURE__ */ Be(), r = /* @__PURE__ */ A_e();
  let o = class extends r.LinkedRdfSourcesAsyncRdfIterator {
    constructor(t, e, n, i, c, s, d, l, f, h, p, b, _, y) {
      super(
        t,
        e,
        n,
        i,
        s,
        d,
        l,
        // Buffersize must be infinite for an aggregated store because it must keep filling until there are no more
        // derived iterators in the aggregated store.
        f ? { maxBufferSize: Number.POSITIVE_INFINITY } : void 0
      ), this.wasForcefullyClosed = !1, this.forceSourceType = c, this.mediatorMetadataAccumulate = h, this.mediatorRdfResolveHypermediaLinks = p, this.mediatorRdfResolveHypermediaLinksQueue = b, this.handledUrls = { [s]: !0 }, this.aggregatedStore = f, this.dataFactory = _, this.algebraFactory = y;
    }
    // Mark the aggregated store as ended once we trigger the closing or destroying of this iterator.
    // We don't override _end, because that would mean that we have to wait
    // until the buffer of this iterator must be fully consumed, which will not always be the case.
    close() {
      if (!this.aggregatedStore) {
        super.close();
        return;
      }
      this.getLinkQueue().then((t) => {
        this.isCloseable(t, !1) ? (this.aggregatedStore && setTimeout(() => this.aggregatedStore.end()), super.close()) : this.wasForcefullyClosed = !0;
      }).catch((t) => super.destroy(t));
    }
    destroy(t) {
      if (!this.aggregatedStore) {
        super.destroy(t);
        return;
      }
      this.getLinkQueue().then((e) => {
        t ?? this.isCloseable(e, !1) ? (this.aggregatedStore && setTimeout(() => this.aggregatedStore.end()), super.destroy(t)) : this.wasForcefullyClosed = !0;
      }).catch((e) => super.destroy(e));
    }
    isCloseable(t, e) {
      return (e ? t.isEmpty() : this.wasForcefullyClosed || t.isEmpty()) && !this.areIteratorsRunning();
    }
    canStartNewIterator() {
      return !this.wasForcefullyClosed && // eslint-disable-next-line ts/prefer-nullish-coalescing
      this.aggregatedStore && this.aggregatedStore.hasRunningIterators() || super.canStartNewIterator();
    }
    canStartNewIteratorConsiderReadable() {
      return !this.aggregatedStore;
    }
    isRunning() {
      return this.aggregatedStore && this.aggregatedStore.hasRunningIterators() || !this.done;
    }
    getLinkQueue() {
      return this.linkQueue || (this.linkQueue = this.mediatorRdfResolveHypermediaLinksQueue.mediate({ firstUrl: this.firstUrl, context: this.context }).then((t) => t.linkQueue)), this.linkQueue;
    }
    async getSourceLinks(t, e) {
      try {
        const { links: n } = await this.mediatorRdfResolveHypermediaLinks.mediate({ context: this.context, metadata: t }), i = this.context.get(u.KeysStatistics.discoveredLinks);
        if (i)
          for (const c of n)
            i.updateStatistic({ url: c.url, metadata: { ...c.metadata } }, e.link);
        return n.filter((c) => this.handledUrls[c.url] ? !1 : (this.handledUrls[c.url] = !0, !0));
      } catch {
        return [];
      }
    }
    startIterator(t) {
      var e;
      if (this.aggregatedStore && !this.aggregatedStore.containedSources.has(t.link.url)) {
        (e = this.aggregatedStore) == null || e.containedSources.add(t.link.url);
        const n = t.source.queryBindings(this.algebraFactory.createPattern(this.dataFactory.variable("s"), this.dataFactory.variable("p"), this.dataFactory.variable("o"), this.dataFactory.variable("g")), this.context.set(u.KeysQueryOperation.unionDefaultGraph, !0)).map((i) => this.dataFactory.quad(i.get("s"), i.get("p"), i.get("o"), i.get("g")));
        this.aggregatedStore.import(n).on("end", () => {
          super.startIterator(t);
        });
      } else
        super.startIterator(t);
    }
    async accumulateMetadata(t, e) {
      return (await this.mediatorMetadataAccumulate.mediate({
        mode: "append",
        accumulatedMetadata: t,
        appendingMetadata: e,
        context: this.context
      })).metadata;
    }
    updateMetadata(t) {
      var e;
      super.updateMetadata(t), (e = this.aggregatedStore) == null || e.setBaseMetadata(t, !0);
    }
  };
  return N3.MediatedLinkedRdfSourcesAsyncRdfIterator = o, N3;
}
var D3 = {}, cf = {}, L3 = {}, FO = {}, fi = {}, df = {}, j3 = {}, fk;
function zZ() {
  if (fk) return j3;
  fk = 1, Object.defineProperty(j3, "__esModule", { value: !0 }), j3.BlankNode = void 0;
  let u = class {
    constructor(o) {
      this.termType = "BlankNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "BlankNode" && o.value === this.value;
    }
  };
  return j3.BlankNode = u, j3;
}
var M3 = {}, C3 = {}, hk;
function kZ() {
  if (hk) return C3;
  hk = 1, Object.defineProperty(C3, "__esModule", { value: !0 }), C3.DefaultGraph = void 0;
  let u = class {
    constructor() {
      this.termType = "DefaultGraph", this.value = "";
    }
    equals(o) {
      return !!o && o.termType === "DefaultGraph";
    }
  };
  return C3.DefaultGraph = u, u.INSTANCE = new u(), C3;
}
var q3 = {}, B3 = {}, pk;
function Z8() {
  if (pk) return B3;
  pk = 1, Object.defineProperty(B3, "__esModule", { value: !0 }), B3.NamedNode = void 0;
  let u = class {
    constructor(o) {
      this.termType = "NamedNode", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "NamedNode" && o.value === this.value;
    }
  };
  return B3.NamedNode = u, B3;
}
var bk;
function XZ() {
  if (bk) return q3;
  bk = 1, Object.defineProperty(q3, "__esModule", { value: !0 }), q3.Literal = void 0;
  const u = Z8();
  let r = class OT {
    constructor(a, t) {
      this.termType = "Literal", this.value = a, typeof t == "string" ? (this.language = t, this.datatype = OT.RDF_LANGUAGE_STRING, this.direction = "") : t ? "termType" in t ? (this.language = "", this.datatype = t, this.direction = "") : (this.language = t.language, this.datatype = t.direction ? OT.RDF_DIRECTIONAL_LANGUAGE_STRING : OT.RDF_LANGUAGE_STRING, this.direction = t.direction || "") : (this.language = "", this.datatype = OT.XSD_STRING, this.direction = "");
    }
    equals(a) {
      return !!a && a.termType === "Literal" && a.value === this.value && a.language === this.language && (a.direction === this.direction || !a.direction && this.direction === "") && this.datatype.equals(a.datatype);
    }
  };
  return q3.Literal = r, r.RDF_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), r.RDF_DIRECTIONAL_LANGUAGE_STRING = new u.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString"), r.XSD_STRING = new u.NamedNode("http://www.w3.org/2001/XMLSchema#string"), q3;
}
var $3 = {}, yk;
function JZ() {
  if (yk) return $3;
  yk = 1, Object.defineProperty($3, "__esModule", { value: !0 }), $3.Quad = void 0;
  let u = class {
    constructor(o, a, t, e) {
      this.termType = "Quad", this.value = "", this.subject = o, this.predicate = a, this.object = t, this.graph = e;
    }
    equals(o) {
      return !!o && (o.termType === "Quad" || !o.termType) && this.subject.equals(o.subject) && this.predicate.equals(o.predicate) && this.object.equals(o.object) && this.graph.equals(o.graph);
    }
  };
  return $3.Quad = u, $3;
}
var U3 = {}, _k;
function KZ() {
  if (_k) return U3;
  _k = 1, Object.defineProperty(U3, "__esModule", { value: !0 }), U3.Variable = void 0;
  let u = class {
    constructor(o) {
      this.termType = "Variable", this.value = o;
    }
    equals(o) {
      return !!o && o.termType === "Variable" && o.value === this.value;
    }
  };
  return U3.Variable = u, U3;
}
var gk;
function O_e() {
  if (gk) return M3;
  gk = 1, Object.defineProperty(M3, "__esModule", { value: !0 }), M3.DataFactory = void 0;
  const u = zZ(), r = kZ(), o = XZ(), a = Z8(), t = JZ(), e = KZ();
  let n = 0, i = class {
    constructor(s) {
      this.blankNodeCounter = 0, s = s || {}, this.blankNodePrefix = s.blankNodePrefix || `df_${n++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(s) {
      return new a.NamedNode(s);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(s) {
      return new u.BlankNode(s || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language, datatype, or directional language.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           If `languageOrDatatype` is a NamedNode, it is used for the value
     *                           of `NamedNode.language`.
     *                           Otherwise, it is used as a directional language,
     *                           from which the language is set to `languageOrDatatype.language`
     *                           and the direction to `languageOrDatatype.direction`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(s, d) {
      return new o.Literal(s, d);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(s) {
      return new e.Variable(s);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
      return r.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(s, d, l, f) {
      return new t.Quad(s, d, l, f || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(s) {
      switch (s.termType) {
        case "NamedNode":
          return this.namedNode(s.value);
        case "BlankNode":
          return this.blankNode(s.value);
        case "Literal":
          return s.language ? this.literal(s.value, s.language) : s.datatype.equals(o.Literal.XSD_STRING) ? this.literal(s.value) : this.literal(s.value, this.fromTerm(s.datatype));
        case "Variable":
          return this.variable(s.value);
        case "DefaultGraph":
          return this.defaultGraph();
        case "Quad":
          return this.quad(this.fromTerm(s.subject), this.fromTerm(s.predicate), this.fromTerm(s.object), this.fromTerm(s.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(s) {
      return this.fromTerm(s);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  };
  return M3.DataFactory = i, M3;
}
var mk;
function WZ() {
  return mk || (mk = 1, function(u) {
    var r = df && df.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = df && df.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(zZ(), u), o(O_e(), u), o(kZ(), u), o(XZ(), u), o(Z8(), u), o(JZ(), u), o(KZ(), u);
  }(df)), df;
}
var vk;
function x_e() {
  if (vk) return fi;
  vk = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.termToString = o, fi.getLiteralValue = a, fi.getLiteralType = t, fi.getLiteralLanguage = e, fi.getLiteralDirection = n, fi.stringToTerm = i, fi.quadToStringQuad = c, fi.stringQuadToQuad = s;
  const u = WZ(), r = new u.DataFactory();
  function o(d) {
    if (d)
      switch (d.termType) {
        case "NamedNode":
          return d.value;
        case "BlankNode":
          return "_:" + d.value;
        case "Literal":
          const l = d;
          return '"' + l.value + '"' + (l.datatype && l.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" && l.datatype.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString" ? "^^" + l.datatype.value : "") + (l.language ? "@" + l.language : "") + (l.direction ? "--" + l.direction : "");
        case "Quad":
          return `<<${o(d.subject)} ${o(d.predicate)} ${o(d.object)}${d.graph.termType === "DefaultGraph" ? "" : " " + o(d.graph)}>>`;
        case "Variable":
          return "?" + d.value;
        case "DefaultGraph":
          return d.value;
      }
  }
  function a(d) {
    const l = /^"([^]*)"/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1];
  }
  function t(d) {
    const l = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    return l[1] || (l[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string");
  }
  function e(d) {
    const l = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(d);
    if (!l)
      throw new Error(d + " is not a literal");
    if (l[1]) {
      let f = l[1].toLowerCase();
      const h = f.indexOf("--");
      return h >= 0 && (f = f.slice(0, h)), f;
    }
    return "";
  }
  function n(d) {
    const l = d.indexOf("--", d.lastIndexOf('"'));
    if (l >= 0) {
      const f = d.slice(l + 2, d.length);
      if (f === "ltr" || f === "rtl")
        return f;
      throw new Error(d + " is not a literal with a valid direction");
    }
    return "";
  }
  function i(d, l) {
    if (l = l || r, !d || !d.length)
      return l.defaultGraph();
    switch (d[0]) {
      case "_":
        return l.blankNode(d.substr(2));
      case "?":
        if (!l.variable)
          throw new Error("Missing 'variable()' method on the given DataFactory");
        return l.variable(d.substr(1));
      case '"':
        const f = e(d), h = n(d), p = l.namedNode(t(d));
        return l.literal(a(d), f ? { language: f, direction: h } : p);
      case "<":
      default:
        if (d[0] === "<" && d.length > 4 && d[1] === "<" && d[d.length - 1] === ">" && d[d.length - 2] === ">") {
          const b = d.slice(2, -2).trim();
          let _ = [], y = 0, m = 0, g = !1;
          for (let T = 0; T < b.length; T++) {
            const v = b[T];
            if (v === "<" && y++, v === ">") {
              if (y === 0)
                throw new Error("Found closing tag without opening tag in " + d);
              y--;
            }
            if (v === '"') {
              let E = !1, R = T;
              for (; R-- > 0 && b[R] === "\\"; )
                E = !E;
              E || (g = !g);
            }
            if (v === " " && !g && y === 0) {
              for (_.push(b.slice(m, T)); b[T + 1] === " "; )
                T += 1;
              m = T + 1;
            }
          }
          if (y !== 0)
            throw new Error("Found opening tag without closing tag in " + d);
          if (_.push(b.slice(m, b.length)), _.length !== 3 && _.length !== 4)
            throw new Error("Nested quad syntax error " + d);
          return _ = _.map((T) => T.startsWith("<") && !T.includes(" ") ? T.slice(1, -1) : T), l.quad(i(_[0]), i(_[1]), i(_[2]), _[3] ? i(_[3]) : void 0);
        }
        return l.namedNode(d);
    }
  }
  function c(d) {
    return {
      subject: o(d.subject),
      predicate: o(d.predicate),
      object: o(d.object),
      graph: o(d.graph)
    };
  }
  function s(d, l) {
    return l = l || r, l.quad(i(d.subject, l), i(d.predicate, l), i(d.object, l), i(d.graph, l));
  }
  return fi;
}
var Tk;
function YZ() {
  return Tk || (Tk = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.termToString = u.stringToTerm = u.stringQuadToQuad = u.quadToStringQuad = u.getLiteralValue = u.getLiteralType = u.getLiteralDirection = u.getLiteralLanguage = void 0;
    const r = x_e();
    Object.defineProperty(u, "getLiteralLanguage", { enumerable: !0, get: function() {
      return r.getLiteralLanguage;
    } }), Object.defineProperty(u, "getLiteralDirection", { enumerable: !0, get: function() {
      return r.getLiteralDirection;
    } }), Object.defineProperty(u, "getLiteralType", { enumerable: !0, get: function() {
      return r.getLiteralType;
    } }), Object.defineProperty(u, "getLiteralValue", { enumerable: !0, get: function() {
      return r.getLiteralValue;
    } }), Object.defineProperty(u, "quadToStringQuad", { enumerable: !0, get: function() {
      return r.quadToStringQuad;
    } }), Object.defineProperty(u, "stringQuadToQuad", { enumerable: !0, get: function() {
      return r.stringQuadToQuad;
    } }), Object.defineProperty(u, "stringToTerm", { enumerable: !0, get: function() {
      return r.stringToTerm;
    } }), Object.defineProperty(u, "termToString", { enumerable: !0, get: function() {
      return r.termToString;
    } });
  }(FO)), FO;
}
var lf = {}, Ct = {}, wk;
function I_e() {
  if (wk) return Ct;
  wk = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.TRIPLE_TERM_NAMES = Ct.QUAD_TERM_NAMES = void 0, Ct.getTerms = o, Ct.getTermsNested = a, Ct.getNamedTerms = t, Ct.collectNamedTerms = e, Ct.forEachTerms = n, Ct.forEachTermsNested = i, Ct.filterTerms = c, Ct.filterTermsNested = s, Ct.filterQuadTermNames = d, Ct.filterQuadTermNamesNested = l, Ct.mapTerms = f, Ct.mapTermsNested = h, Ct.reduceTerms = p, Ct.reduceTermsNested = b, Ct.everyTerms = _, Ct.everyTermsNested = y, Ct.someTerms = m, Ct.someTermsNested = g, Ct.getValueNestedPath = T, Ct.matchTerm = v, Ct.matchPattern = E, Ct.matchPatternComplete = R, Ct.matchPatternMappings = L;
  const u = WZ(), r = new u.DataFactory();
  Ct.QUAD_TERM_NAMES = ["subject", "predicate", "object", "graph"], Ct.TRIPLE_TERM_NAMES = ["subject", "predicate", "object"];
  function o(A, w) {
    return w && A.graph.termType === "DefaultGraph" ? [A.subject, A.predicate, A.object] : [A.subject, A.predicate, A.object, A.graph];
  }
  function a(A, w) {
    const S = [];
    for (const O of o(A, w))
      O.termType === "Quad" ? a(O, w).forEach((x) => S.push(x)) : S.push(O);
    return S;
  }
  function t(A) {
    return [
      { key: "subject", value: A.subject },
      { key: "predicate", value: A.predicate },
      { key: "object", value: A.object },
      { key: "graph", value: A.graph }
    ];
  }
  function e(A, w, S) {
    const O = {};
    return A.forEach((x) => O[x.key] = x.value), w && (O.subject = O.subject || w("subject"), O.predicate = O.predicate || w("predicate"), O.object = O.object || w("object"), O.graph = O.graph || w("graph")), (S || r).quad(O.subject, O.predicate, O.object, O.graph);
  }
  function n(A, w) {
    w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph");
  }
  function i(A, w, S = []) {
    A.subject.termType === "Quad" ? i(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"]), A.predicate.termType === "Quad" ? i(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"]), A.object.termType === "Quad" ? i(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"]), A.graph.termType === "Quad" ? i(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]);
  }
  function c(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push(A.subject), w(A.predicate, "predicate") && S.push(A.predicate), w(A.object, "object") && S.push(A.object), w(A.graph, "graph") && S.push(A.graph), S;
  }
  function s(A, w, S = []) {
    let O = [];
    return A.subject.termType === "Quad" ? O = [...O, ...s(A.subject, w, [...S, "subject"])] : w(A.subject, [...S, "subject"]) && O.push(A.subject), A.predicate.termType === "Quad" ? O = [...O, ...s(A.predicate, w, [...S, "predicate"])] : w(A.predicate, [...S, "predicate"]) && O.push(A.predicate), A.object.termType === "Quad" ? O = [...O, ...s(A.object, w, [...S, "object"])] : w(A.object, [...S, "object"]) && O.push(A.object), A.graph.termType === "Quad" ? O = [...O, ...s(A.graph, w, [...S, "graph"])] : w(A.graph, [...S, "graph"]) && O.push(A.graph), O;
  }
  function d(A, w) {
    const S = [];
    return w(A.subject, "subject") && S.push("subject"), w(A.predicate, "predicate") && S.push("predicate"), w(A.object, "object") && S.push("object"), w(A.graph, "graph") && S.push("graph"), S;
  }
  function l(A, w, S = []) {
    let O = [];
    const x = [...S, "subject"];
    A.subject.termType === "Quad" ? O = [...O, ...l(A.subject, w, x)] : w(A.subject, x) && O.push(x);
    const F = [...S, "predicate"];
    A.predicate.termType === "Quad" ? O = [...O, ...l(A.predicate, w, F)] : w(A.predicate, F) && O.push(F);
    const j = [...S, "object"];
    A.object.termType === "Quad" ? O = [...O, ...l(A.object, w, j)] : w(A.object, j) && O.push(j);
    const q = [...S, "graph"];
    return A.graph.termType === "Quad" ? O = [...O, ...l(A.graph, w, q)] : w(A.graph, q) && O.push(q), O;
  }
  function f(A, w, S) {
    return (S || r).quad(w(A.subject, "subject"), w(A.predicate, "predicate"), w(A.object, "object"), w(A.graph, "graph"));
  }
  function h(A, w, S, O = []) {
    return (S || r).quad(A.subject.termType === "Quad" ? h(A.subject, w, S, [...O, "subject"]) : w(A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? h(A.predicate, w, S, [...O, "predicate"]) : w(A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? h(A.object, w, S, [...O, "object"]) : w(A.object, [...O, "object"]), A.graph.termType === "Quad" ? h(A.graph, w, S, [...O, "graph"]) : w(A.graph, [...O, "graph"]));
  }
  function p(A, w, S) {
    let O = S;
    return O = w(O, A.subject, "subject"), O = w(O, A.predicate, "predicate"), O = w(O, A.object, "object"), w(O, A.graph, "graph");
  }
  function b(A, w, S, O = []) {
    let x = S;
    return A.subject.termType === "Quad" ? x = b(A.subject, w, x, [...O, "subject"]) : x = w(x, A.subject, [...O, "subject"]), A.predicate.termType === "Quad" ? x = b(A.predicate, w, x, [...O, "predicate"]) : x = w(x, A.predicate, [...O, "predicate"]), A.object.termType === "Quad" ? x = b(A.object, w, x, [...O, "object"]) : x = w(x, A.object, [...O, "object"]), A.graph.termType === "Quad" ? x = b(A.graph, w, x, [...O, "graph"]) : x = w(x, A.graph, [...O, "graph"]), x;
  }
  function _(A, w) {
    return w(A.subject, "subject") && w(A.predicate, "predicate") && w(A.object, "object") && w(A.graph, "graph");
  }
  function y(A, w, S = []) {
    return (A.subject.termType === "Quad" ? y(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) && (A.predicate.termType === "Quad" ? y(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) && (A.object.termType === "Quad" ? y(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) && (A.graph.termType === "Quad" ? y(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  function m(A, w) {
    return w(A.subject, "subject") || w(A.predicate, "predicate") || w(A.object, "object") || w(A.graph, "graph");
  }
  function g(A, w, S = []) {
    return (A.subject.termType === "Quad" ? g(A.subject, w, [...S, "subject"]) : w(A.subject, [...S, "subject"])) || (A.predicate.termType === "Quad" ? g(A.predicate, w, [...S, "predicate"]) : w(A.predicate, [...S, "predicate"])) || (A.object.termType === "Quad" ? g(A.object, w, [...S, "object"]) : w(A.object, [...S, "object"])) || (A.graph.termType === "Quad" ? g(A.graph, w, [...S, "graph"]) : w(A.graph, [...S, "graph"]));
  }
  function T(A, w) {
    if (w.length === 0)
      return A;
    if (A.termType === "Quad")
      return T(A[w[0]], w.slice(1));
    throw new Error(`Tried to get ${w[0]} from term of type ${A.termType}`);
  }
  function v(A, w) {
    return !w || w.termType === "Variable" || w.termType === "Quad" && A.termType === "Quad" && R(A, w) || w.equals(A);
  }
  function E(A, w, S, O, x) {
    return v(A.subject, w) && v(A.predicate, S) && v(A.object, O) && v(A.graph, x);
  }
  function R(A, w) {
    return E(A, w.subject, w.predicate, w.object, w.graph);
  }
  function L(A, w, S = {}) {
    const O = {};
    function x(F, j) {
      return _(F, (q, Q) => {
        var G, K;
        const U = j[Q];
        switch (q.termType) {
          case "Variable":
            return S.skipVarMapping && U.termType === "Variable" || ((K = (G = O[q.value]) === null || G === void 0 ? void 0 : G.equals(U)) !== null && K !== void 0 ? K : (O[q.value] = U, !0));
          case "Quad":
            return U.termType === "Quad" && x(q, U);
          default:
            return q.equals(U);
        }
      });
    }
    return x(w, A) && (S.returnMappings ? O : !0);
  }
  return Ct;
}
var Tn = {}, Sk;
function R_e() {
  if (Sk) return Tn;
  Sk = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.TERM_TYPES = void 0, Tn.uniqTerms = r, Tn.getTermsOfType = o, Tn.getNamedNodes = a, Tn.getBlankNodes = t, Tn.getLiterals = e, Tn.getVariables = n, Tn.getDefaultGraphs = i, Tn.getQuads = c;
  const u = YZ();
  Tn.TERM_TYPES = ["NamedNode", "BlankNode", "Literal", "Variable", "DefaultGraph", "Quad"];
  function r(s) {
    const d = {};
    return s.filter((l) => {
      const f = (0, u.termToString)(l);
      return !(f in d) && (d[f] = !0);
    });
  }
  function o(s, d) {
    return s.filter((l) => l.termType === d);
  }
  function a(s) {
    return o(s, "NamedNode");
  }
  function t(s) {
    return o(s, "BlankNode");
  }
  function e(s) {
    return o(s, "Literal");
  }
  function n(s) {
    return o(s, "Variable");
  }
  function i(s) {
    return o(s, "DefaultGraph");
  }
  function c(s) {
    return o(s, "Quad");
  }
  return Tn;
}
var Ak;
function F_e() {
  return Ak || (Ak = 1, function(u) {
    var r = lf && lf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = lf && lf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(I_e(), u), o(R_e(), u);
  }(lf)), lf;
}
var Ek;
function ZZ() {
  if (Ek) return L3;
  Ek = 1, Object.defineProperty(L3, "__esModule", { value: !0 }), L3.PendingStreamsIndex = void 0;
  const u = YZ(), r = F_e();
  let o = class Uf {
    constructor() {
      this.indexedStreams = /* @__PURE__ */ new Map(), this.allStreams = [];
    }
    termToString(t) {
      return t && t.termType !== "Variable" ? (0, u.termToString)(t) : Uf.ID_VARIABLE;
    }
    /**
     * Add a new pending stream for the given quad pattern.
     * @param pendingStream A pending stream.
     * @param subject A term.
     * @param predicate A term.
     * @param object A term.
     * @param graph A term.
     */
    addPatternListener(t, e, n, i, c) {
      this.allStreams.push(t);
      const s = `${this.termToString(e)}${Uf.ID_SEPARATOR}${this.termToString(n)}${Uf.ID_SEPARATOR}${this.termToString(i)}${Uf.ID_SEPARATOR}${this.termToString(c)}`;
      let d = this.indexedStreams.get(s);
      d || (d = [], this.indexedStreams.set(s, d)), d.push(t);
    }
    /**
     * Find all the pending streams from which their quad pattern match the given quad.
     * @param quad The quad to match patterns to.
     */
    getPendingStreamsForQuad(t) {
      let e = [(0, r.getTerms)(t).map((i) => (0, u.termToString)(i))];
      for (let i = 0; i < r.QUAD_TERM_NAMES.length; i++) {
        const c = e;
        e = [];
        for (const s of c) {
          e.push(s);
          const d = [...s];
          d[i] = Uf.ID_VARIABLE, e.push(d);
        }
      }
      const n = [];
      for (const i of e) {
        const c = this.indexedStreams.get(i.join(Uf.ID_SEPARATOR));
        c && n.push(...c);
      }
      return n;
    }
  };
  return o.ID_VARIABLE = "?", o.ID_SEPARATOR = ":", L3.PendingStreamsIndex = o, L3;
}
var hi = {}, Ok;
function N_e() {
  if (Ok) return hi;
  Ok = 1;
  var u = hi && hi.__asyncValues || function(i) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var c = i[Symbol.asyncIterator], s;
    return c ? c.call(i) : (i = typeof __values == "function" ? __values(i) : i[Symbol.iterator](), s = {}, d("next"), d("throw"), d("return"), s[Symbol.asyncIterator] = function() {
      return this;
    }, s);
    function d(f) {
      s[f] = i[f] && function(h) {
        return new Promise(function(p, b) {
          h = i[f](h), l(p, b, h.done, h.value);
        });
      };
    }
    function l(f, h, p, b) {
      Promise.resolve(b).then(function(_) {
        f({ value: _, done: p });
      }, h);
    }
  }, r = hi && hi.__await || function(i) {
    return this instanceof r ? (this.v = i, this) : new r(i);
  }, o = hi && hi.__asyncGenerator || function(i, c, s) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var d = s.apply(i, c || []), l, f = [];
    return l = {}, h("next"), h("throw"), h("return"), l[Symbol.asyncIterator] = function() {
      return this;
    }, l;
    function h(g) {
      d[g] && (l[g] = function(T) {
        return new Promise(function(v, E) {
          f.push([g, T, v, E]) > 1 || p(g, T);
        });
      });
    }
    function p(g, T) {
      try {
        b(d[g](T));
      } catch (v) {
        m(f[0][3], v);
      }
    }
    function b(g) {
      g.value instanceof r ? Promise.resolve(g.value.v).then(_, y) : m(f[0][2], g);
    }
    function _(g) {
      p("next", g);
    }
    function y(g) {
      p("throw", g);
    }
    function m(g, T) {
      g(T), f.shift(), f.length && p(f[0][0], f[0][1]);
    }
  };
  Object.defineProperty(hi, "__esModule", { value: !0 }), hi.StreamingStore = void 0;
  const a = iu, t = Bt(), e = ZZ();
  let n = class eee {
    constructor(c = new a.Store()) {
      this.pendingStreams = new e.PendingStreamsIndex(), this.ended = !1, this.listeners = [], this.store = c;
    }
    addEndListener(c) {
      this.listeners.push(c);
    }
    emitEndEvent() {
      for (const c of this.listeners)
        c();
    }
    hasEnded() {
      return this.ended;
    }
    /**
     * Mark this store as ended.
     *
     * This will make sure that all running and future `match` calls will end,
     * and all next `import` calls to this store will throw an error.
     * It will run all the listeners added with `addEndListener`.
     */
    end() {
      this.ended = !0;
      for (const c of this.pendingStreams.allStreams)
        c.push(null);
      this.emitEndEvent();
    }
    importToListeners(c) {
      c.on("data", (s) => {
        if (!this.ended && !this.store.countQuads(s.subject, s.predicate, s.object, s.graph))
          for (const d of this.pendingStreams.getPendingStreamsForQuad(s))
            d.emit("quad", s), d.isInitialized && d.push(s);
      });
    }
    static concatStreams(c) {
      return o(this, arguments, function* () {
        var d, l, f, h;
        for (const y of c)
          try {
            for (var p = !0, b = (l = void 0, u(y)), _; _ = yield r(b.next()), d = _.done, !d; ) {
              h = _.value, p = !1;
              try {
                yield yield r(h);
              } finally {
                p = !0;
              }
            }
          } catch (m) {
            l = { error: m };
          } finally {
            try {
              !p && !d && (f = b.return) && (yield r(f.call(b)));
            } finally {
              if (l) throw l.error;
            }
          }
      });
    }
    import(c) {
      if (this.ended)
        throw new Error("Attempted to import into an ended StreamingStore");
      return this.importToListeners(c), this.store.import(c);
    }
    match(c, s, d, l) {
      const f = this.store.match(c, s, d, l);
      let h = f;
      if (!this.ended) {
        const p = new t.PassThrough({ objectMode: !0 });
        this.pendingStreams.addPatternListener(p, c, s, d, l), h = t.Readable.from(eee.concatStreams([f, p])), p.on("quad", (_) => {
          h.emit("quad", _);
        }), h._pipeSource = f;
        const b = f._read;
        f._read = (_) => {
          p.isInitialized = !0, b.call(f, _);
        };
      }
      return h;
    }
    /**
     * The internal store with all imported quads.
     */
    getStore() {
      return this.store;
    }
  };
  return hi.StreamingStore = n, hi;
}
var xk;
function P_e() {
  return xk || (xk = 1, function(u) {
    var r = cf && cf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = cf && cf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(ZZ(), u), o(N_e(), u);
  }(cf)), cf;
}
var Ik;
function D_e() {
  if (Ik) return D3;
  Ik = 1, Object.defineProperty(D3, "__esModule", { value: !0 }), D3.StreamingStoreMetadata = void 0;
  const u = /* @__PURE__ */ uu(), r = /* @__PURE__ */ Rr(), o = P_e();
  let a = class extends o.StreamingStore {
    constructor(e, n) {
      super(e), this.started = !1, this.containedSources = /* @__PURE__ */ new Set(), this.runningIterators = /* @__PURE__ */ new Set(), this.iteratorCreatedListeners = /* @__PURE__ */ new Set(), this.baseMetadata = {
        state: new r.MetadataValidationState(),
        cardinality: { type: "exact", value: 0 },
        variables: []
      }, this.metadataAccumulator = n;
    }
    import(e) {
      return this.ended || super.import(e), e;
    }
    hasRunningIterators() {
      return this.runningIterators.size > 0;
    }
    match(e, n, i, c) {
      const s = super.match(e, n, i, c), d = new u.ClosableTransformIterator(s, {
        autoStart: !1,
        onClose: () => {
          this.runningIterators.delete(d);
        }
      });
      let l = this.getStore().countQuads(e, n, i, c);
      const f = {
        state: new r.MetadataValidationState(),
        cardinality: {
          type: "estimate",
          value: l
        }
      };
      d.setProperty("metadata", f), d.setProperty("lastCount", l), s.on("quad", () => {
        d.setProperty("lastCount", ++l), this.updateMetadataState(d, l);
      }), this.runningIterators.add(d);
      for (const h of this.iteratorCreatedListeners)
        h();
      return d;
    }
    setBaseMetadata(e, n) {
      if (this.baseMetadata = { ...e }, this.baseMetadata.cardinality = { type: "exact", value: 0 }, n)
        for (const i of this.runningIterators) {
          const c = i.getProperty("lastCount");
          this.updateMetadataState(i, c);
        }
    }
    updateMetadataState(e, n) {
      const i = {
        state: new r.MetadataValidationState(),
        cardinality: {
          type: "estimate",
          value: n
        },
        variables: []
      };
      this.metadataAccumulator(this.baseMetadata, i).then((c) => {
        c.state = new r.MetadataValidationState();
        const s = e.getProperty("metadata");
        e.setProperty("metadata", c), s == null || s.state.invalidate();
      }).catch(() => {
      });
    }
    addIteratorCreatedListener(e) {
      this.iteratorCreatedListeners.add(e);
    }
    removeIteratorCreatedListener(e) {
      this.iteratorCreatedListeners.delete(e);
    }
  };
  return D3.StreamingStoreMetadata = a, D3;
}
var Rk;
function tee() {
  if (Rk) return F3;
  Rk = 1, Object.defineProperty(F3, "__esModule", { value: !0 }), F3.QuerySourceHypermedia = void 0;
  const u = /* @__PURE__ */ K8(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ yt(), a = /* @__PURE__ */ fh(), t = Bt(), e = ft(), n = /* @__PURE__ */ E_e(), i = /* @__PURE__ */ D_e();
  let c = class {
    constructor(d, l, f, h, p, b, _, y, m) {
      this.referenceValue = l, this.cacheSize = d, this.firstUrl = l, this.forceSourceType = f, this.maxIterators = h, this.mediators = b, this.aggregateStore = p, this.logWarning = _, this.dataFactory = y, this.bindingsFactory = m, this.sourcesState = new a.LRUCache({ max: this.cacheSize });
    }
    async getSelectorShape(d) {
      return (await this.getSourceCached({ url: this.firstUrl }, {}, d, this.getAggregateStore(d))).source.getSelectorShape(d);
    }
    queryBindings(d, l, f) {
      const h = this.getAggregateStore(l);
      if (h && d.type === "pattern" && h.started)
        return new u.QuerySourceRdfJs(h, l.getSafe(r.KeysInitQuery.dataFactory), this.bindingsFactory).queryBindings(d, l);
      this.sourcesState.size === 0 && this.getSourceCached({ url: this.firstUrl }, {}, l, h).catch((y) => _.destroy(y));
      const p = l.getSafe(r.KeysInitQuery.dataFactory), b = new e.Factory(p), _ = new n.MediatedLinkedRdfSourcesAsyncRdfIterator(this.cacheSize, d, f, l, this.forceSourceType, this.firstUrl, this.maxIterators, (y, m) => this.getSourceCached(y, m, l, h), h, this.mediators.mediatorMetadataAccumulate, this.mediators.mediatorRdfResolveHypermediaLinks, this.mediators.mediatorRdfResolveHypermediaLinksQueue, p, b);
      if (h) {
        h.started = !0;
        const y = () => _.kickstart();
        h.addIteratorCreatedListener(y), _.on("end", () => h.removeIteratorCreatedListener(y));
      }
      return _;
    }
    queryQuads(d, l) {
      return new o.TransformIterator(async () => (await this.getSourceCached({ url: this.firstUrl }, {}, l, this.getAggregateStore(l))).source.queryQuads(d, l));
    }
    async queryBoolean(d, l) {
      return await (await this.getSourceCached({ url: this.firstUrl }, {}, l, this.getAggregateStore(l))).source.queryBoolean(d, l);
    }
    async queryVoid(d, l) {
      return await (await this.getSourceCached({ url: this.firstUrl }, {}, l, this.getAggregateStore(l))).source.queryVoid(d, l);
    }
    /**
     * Resolve a source for the given URL.
     * @param link A source link.
     * @param handledDatasets A hash of dataset identifiers that have already been handled.
     * @param context The action context.
     * @param aggregatedStore An optional aggregated store.
     */
    async getSource(d, l, f, h) {
      var g, T;
      d.context && (f = f.merge(d.context));
      let p = d.url, b, _;
      if (this.forceSourceType === "sparql" && ((g = f.get(r.KeysQueryOperation.querySources)) == null ? void 0 : g.length) === 1)
        b = new t.Readable(), b.read = () => null, { metadata: _ } = await this.mediators.mediatorMetadataAccumulate.mediate({ context: f, mode: "initialize" });
      else
        try {
          const v = await this.mediators.mediatorDereferenceRdf.mediate({ context: f, url: p });
          p = v.url;
          const E = await this.mediators.mediatorMetadata.mediate({ context: f, url: p, quads: v.data, triples: (T = v.metadata) == null ? void 0 : T.triples });
          E.data.on("error", () => {
          }), _ = (await this.mediators.mediatorMetadataExtract.mediate({
            context: f,
            url: p,
            // The problem appears to be conflicting metadata keys here
            metadata: E.metadata,
            headers: v.headers,
            requestTime: v.requestTime
          })).metadata, b = E.data, d.transform && (b = await d.transform(b));
        } catch (v) {
          b = new t.Readable(), b.read = () => (setTimeout(() => b.emit("error", v)), null), { metadata: _ } = await this.mediators.mediatorMetadataAccumulate.mediate({ context: f, mode: "initialize" }), this.logWarning(`Metadata extraction for ${p} failed: ${v.message}`);
        }
      h == null || h.setBaseMetadata(_, !1), h == null || h.containedSources.add(d.url), h == null || h.import(b);
      const { source: y, dataset: m } = await this.mediators.mediatorQuerySourceIdentifyHypermedia.mediate({
        context: f,
        forceSourceType: d.url === this.firstUrl ? this.forceSourceType : void 0,
        handledDatasets: l,
        metadata: _,
        quads: b,
        url: p
      });
      return m && (l[m] = !0), { link: d, source: y, metadata: _, handledDatasets: l };
    }
    /**
     * Resolve a source for the given URL.
     * This will first try to retrieve the source from cache.
     * @param link A source ILink.
     * @param handledDatasets A hash of dataset identifiers that have already been handled.
     * @param context The action context.
     * @param aggregatedStore An optional aggregated store.
     */
    getSourceCached(d, l, f, h) {
      let p = this.sourcesState.get(d.url);
      return p || (p = this.getSource(d, l, f, h), (d.url === this.firstUrl || h === void 0) && this.sourcesState.set(d.url, p), p);
    }
    getAggregateStore(d) {
      let l;
      if (this.aggregateStore) {
        const f = d.get(r.KeysQuerySourceIdentify.hypermediaSourcesAggregatedStores);
        if (f)
          return l = f.get(this.firstUrl), l || (l = new i.StreamingStoreMetadata(void 0, async (h, p) => (await this.mediators.mediatorMetadataAccumulate.mediate({
            mode: "append",
            accumulatedMetadata: h,
            appendingMetadata: p,
            context: d
          })).metadata), f.set(this.firstUrl, l)), l;
      }
    }
    toString() {
      return `QuerySourceHypermedia(${this.firstUrl})`;
    }
  };
  return F3.QuerySourceHypermedia = c, F3;
}
var Fk;
function L_e() {
  if (Fk) return R3;
  Fk = 1, Object.defineProperty(R3, "__esModule", { value: !0 }), R3.ActorQuerySourceIdentifyHypermedia = void 0;
  const u = /* @__PURE__ */ Fw(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ tee();
  let e = class extends u.ActorQuerySourceIdentify {
    constructor(i) {
      super(i);
    }
    async test(i) {
      return typeof i.querySourceUnidentified.value != "string" ? (0, o.failTest)(`${this.name} requires a single query source with a URL value to be present in the context.`) : (0, o.passTestVoid)();
    }
    async run(i) {
      var s;
      const c = i.context.getSafe(r.KeysInitQuery.dataFactory);
      return {
        querySource: {
          source: new t.QuerySourceHypermedia(this.cacheSize, i.querySourceUnidentified.value, i.querySourceUnidentified.type, this.maxIterators, this.aggregateTraversalStore && !!((s = i.querySourceUnidentified.context) != null && s.get(r.KeysQuerySourceIdentify.traverse)), {
            mediatorMetadata: this.mediatorMetadata,
            mediatorMetadataExtract: this.mediatorMetadataExtract,
            mediatorMetadataAccumulate: this.mediatorMetadataAccumulate,
            mediatorDereferenceRdf: this.mediatorDereferenceRdf,
            mediatorQuerySourceIdentifyHypermedia: this.mediatorQuerySourceIdentifyHypermedia,
            mediatorRdfResolveHypermediaLinks: this.mediatorRdfResolveHypermediaLinks,
            mediatorRdfResolveHypermediaLinksQueue: this.mediatorRdfResolveHypermediaLinksQueue
          }, (d) => this.logWarn(i.context, d), c, await a.BindingsFactory.create(this.mediatorMergeBindingsContext, i.context, c)),
          context: i.querySourceUnidentified.context ?? new o.ActionContext()
        }
      };
    }
  };
  return R3.ActorQuerySourceIdentifyHypermedia = e, R3;
}
var Nk;
function j_e() {
  return Nk || (Nk = 1, function(u) {
    var r = sf && sf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = sf && sf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ L_e(), u), o(/* @__PURE__ */ tee(), u);
  }(sf)), sf;
}
var ff = {}, V3 = {}, Pk;
function M_e() {
  if (Pk) return V3;
  Pk = 1, Object.defineProperty(V3, "__esModule", { value: !0 }), V3.ActorRdfJoinNone = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ Rr(), e = /* @__PURE__ */ yt();
  let n = class extends u.ActorRdfJoin {
    constructor(c) {
      super(c, {
        logicalType: "inner",
        physicalName: "none",
        limitEntries: 0
      });
    }
    async test(c) {
      return c.entries.length > 0 ? (0, o.failTest)(`Actor ${this.name} can only join zero entries`) : await this.getJoinCoefficients(c, void 0);
    }
    async getOutput(c) {
      const s = c.context.getSafe(r.KeysInitQuery.dataFactory), d = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, c.context, s);
      return {
        result: {
          bindingsStream: new e.ArrayIterator([d.bindings()], { autoStart: !1 }),
          metadata: () => Promise.resolve({
            state: new t.MetadataValidationState(),
            cardinality: { type: "exact", value: 1 },
            variables: []
          }),
          type: "bindings"
        }
      };
    }
    async getJoinCoefficients(c, s) {
      return (0, o.passTestWithSideData)({
        iterations: 0,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: 0
      }, s);
    }
  };
  return V3.ActorRdfJoinNone = n, V3;
}
var Dk;
function C_e() {
  return Dk || (Dk = 1, function(u) {
    var r = ff && ff.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = ff && ff.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ M_e(), u);
  }(ff)), ff;
}
var hf = {}, Q3 = {}, pf = {}, H3 = {}, Lk;
function q_e() {
  if (Lk) return H3;
  Lk = 1, Object.defineProperty(H3, "__esModule", { value: !0 }), H3.ActorRdfJoinMultiBind = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt(), n = ft();
  let i = class ree extends u.ActorRdfJoin {
    constructor(s) {
      super(s, {
        logicalType: "inner",
        physicalName: "bind",
        canHandleUndefs: !0,
        isLeaf: !1
      });
    }
    /**
     * Create a new bindings stream that takes every binding of the base stream
     * and binds it to the remaining patterns, evaluates those patterns, and emits all their bindings.
     *
     * @param bindOrder The order in which elements should be bound.
     * @param baseStream The base stream.
     * @param operations The operations to bind with each binding of the base stream.
     * @param operationBinder A callback to retrieve the bindings stream of bound operations.
     * @param optional If the original bindings should be emitted when the resulting bindings stream is empty.
     * @return {BindingsStream}
     */
    static createBindStream(s, d, l, f, h, p, b) {
      const _ = s === "depth-first", y = (m) => {
        const g = l.map((v) => (0, t.materializeOperation)(v, m, p, b, { bindFilter: !0 })), T = (v) => v.merge(m);
        return new e.TransformIterator(async () => (await f(g, m)).transform({ map: T }), { maxBufferSize: 128, autoStart: _ });
      };
      switch (s) {
        case "depth-first":
          return new e.MultiTransformIterator(d, { autoStart: !1, multiTransform: y, optional: h });
        case "breadth-first":
          return new e.UnionIterator(d.transform({
            map: y,
            optional: h
          }), { autoStart: !1 });
        default:
          throw new Error(`Received request for unknown bind order: ${s}`);
      }
    }
    async getOutput(s, d) {
      const l = s.context.getSafe(r.KeysInitQuery.dataFactory), f = new n.Factory(l), h = await a.BindingsFactory.create(this.mediatorMergeBindingsContext, s.context, l), p = d.entriesSorted;
      this.logDebug(s.context, "First entry for Bind Join: ", () => ({
        entry: p[0].operation,
        cardinality: p[0].metadata.cardinality,
        order: p[0].metadata.order,
        availableOrders: p[0].metadata.availableOrders
      }));
      for (const [g, T] of p.entries())
        g !== 0 && T.output.bindingsStream.close();
      const b = p[0].output, _ = [...p];
      _.splice(0, 1);
      const y = s.context.set(r.KeysQueryOperation.joinLeftMetadata, p[0].metadata).set(r.KeysQueryOperation.joinRightMetadatas, _.map((g) => g.metadata));
      return {
        result: {
          type: "bindings",
          bindingsStream: ree.createBindStream(this.bindOrder, b.bindingsStream, _.map((g) => g.operation), async (g, T) => {
            const v = g.length === 1 ? g[0] : (
              // Flattening should only take place if none of the input operations have associated metadata
              f.createJoin(g, g.every((R) => !R.metadata))
            );
            return (0, t.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: v, context: y == null ? void 0 : y.set(r.KeysQueryOperation.joinBindings, T) })).bindingsStream;
          }, !1, f, h),
          metadata: () => this.constructResultMetadata(p, p.map((g) => g.metadata), s.context)
        },
        physicalPlanMetadata: {
          bindIndex: d.entriesUnsorted.indexOf(p[0]),
          bindOperation: p[0].operation,
          bindOperationCardinality: p[0].metadata.cardinality,
          bindOrder: this.bindOrder
        }
      };
    }
    canBindWithOperation(s) {
      let d = !0;
      return n.Util.recurseOperation(s, {
        [n.Algebra.types.EXTEND]() {
          return d = !1, !1;
        },
        [n.Algebra.types.GROUP]() {
          return d = !1, !1;
        }
      }), d;
    }
    async getJoinCoefficients(s, d) {
      let { metadatas: l } = d;
      const f = s.entries.map((A, w) => ({ ...A, metadata: l[w] })), h = await u.ActorRdfJoin.sortJoinEntries(this.mediatorJoinEntriesSort, f, s.context);
      if (h.isFailed())
        return h;
      const p = h.get();
      l = p.map((A) => A.metadata);
      const b = u.ActorRdfJoin.getRequestInitialTimes(l), _ = u.ActorRdfJoin.getRequestItemTimes(l), y = [...p], m = [...b], g = [..._];
      if (y.splice(0, 1), m.splice(0, 1), g.splice(0, 1), y.some((A) => !this.canBindWithOperation(A.operation)))
        return (0, o.failTest)(`Actor ${this.name} can not bind on Extend and Group operations`);
      if (y.some((A) => A.operationModified))
        return (0, o.failTest)(`Actor ${this.name} can not be used over remaining entries with modified operations`);
      const T = _.some((A) => A > 0);
      if (l[0].cardinality.value * this.minMaxCardinalityRatio / (T ? 1 : 3) > Math.max(...l.map((A) => A.cardinality.value)))
        return (0, o.failTest)(`Actor ${this.name} can only run if the smallest stream is much smaller than largest stream`);
      const v = await Promise.all(y.map(async (A) => (await this.mediatorJoinSelectivity.mediate({
        entries: [p[0], A],
        context: s.context
      })).selectivity * this.selectivityModifier)), E = y.map((A, w) => A.metadata.cardinality.value * v[w]).reduce((A, w) => A + w, 0), R = m.reduce((A, w) => A + w, 0), L = g.reduce((A, w) => A + w, 0);
      return (0, o.passTestWithSideData)({
        iterations: l[0].cardinality.value * E,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: b[0] + l[0].cardinality.value * (_[0] + R + E * L)
      }, { ...d, entriesUnsorted: f, entriesSorted: p });
    }
  };
  return H3.ActorRdfJoinMultiBind = i, H3;
}
var jk;
function nee() {
  return jk || (jk = 1, function(u) {
    var r = pf && pf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = pf && pf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ q_e(), u);
  }(pf)), pf;
}
var Mk;
function B_e() {
  if (Mk) return Q3;
  Mk = 1, Object.defineProperty(Q3, "__esModule", { value: !0 }), Q3.ActorRdfJoinOptionalBind = void 0;
  const u = /* @__PURE__ */ nee(), r = /* @__PURE__ */ cn(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ _e(), t = /* @__PURE__ */ Jt(), e = /* @__PURE__ */ vt(), n = ft();
  let i = class extends r.ActorRdfJoin {
    constructor(s) {
      super(s, {
        logicalType: "optional",
        physicalName: "bind",
        limitEntries: 2,
        canHandleUndefs: !0,
        isLeaf: !1,
        requiresVariableOverlap: !0
      });
    }
    async getOutput(s) {
      const d = s.context.getSafe(o.KeysInitQuery.dataFactory), l = new n.Factory(d), f = await t.BindingsFactory.create(this.mediatorMergeBindingsContext, s.context, d);
      s.entries[1].output.bindingsStream.close();
      const h = s.context.set(o.KeysQueryOperation.joinLeftMetadata, await s.entries[0].output.metadata()).set(o.KeysQueryOperation.joinRightMetadatas, [await s.entries[1].output.metadata()]);
      return {
        result: {
          type: "bindings",
          bindingsStream: u.ActorRdfJoinMultiBind.createBindStream(this.bindOrder, s.entries[0].output.bindingsStream, [s.entries[1].operation], async (b, _) => {
            const y = b[0];
            return (0, e.getSafeBindings)(await this.mediatorQueryOperation.mediate({ operation: y, context: h == null ? void 0 : h.set(o.KeysQueryOperation.joinBindings, _) })).bindingsStream;
          }, !0, l, f),
          metadata: async () => await this.constructResultMetadata(s.entries, await r.ActorRdfJoin.getMetadatas(s.entries), s.context, {}, !0)
        }
      };
    }
    async getJoinCoefficients(s, d) {
      const { metadatas: l } = d, f = r.ActorRdfJoin.getRequestInitialTimes(l), h = r.ActorRdfJoin.getRequestItemTimes(l);
      if (s.entries[1].operation.type === n.Algebra.types.EXTEND || s.entries[1].operation.type === n.Algebra.types.GROUP)
        return (0, a.failTest)(`Actor ${this.name} can not bind on Extend and Group operations`);
      const p = (await this.mediatorJoinSelectivity.mediate({
        entries: s.entries,
        context: s.context
      })).selectivity * this.selectivityModifier;
      return (0, a.passTestWithSideData)({
        iterations: l[0].cardinality.value * l[1].cardinality.value * p,
        persistedItems: 0,
        blockingItems: 0,
        requestTime: f[0] + l[0].cardinality.value * (h[0] + f[1] + p * l[1].cardinality.value * h[1])
      }, d);
    }
  };
  return Q3.ActorRdfJoinOptionalBind = i, Q3;
}
var Ck;
function $_e() {
  return Ck || (Ck = 1, function(u) {
    var r = hf && hf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = hf && hf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ B_e(), u);
  }(hf)), hf;
}
var bf = {}, G3 = {}, yf = {}, z3 = {}, qk;
function U_e() {
  if (qk) return z3;
  qk = 1, Object.defineProperty(z3, "__esModule", { value: !0 }), z3.ActorTermComparatorFactory = void 0;
  const u = /* @__PURE__ */ _e();
  let r = class extends u.Actor {
    /**
     * @param args -
     *  \ @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     *  \ @defaultNested {Creation of term comparator failed} busFailMessage
     */
    constructor(a) {
      super(a), this.mediatorQueryOperation = a.mediatorQueryOperation, this.mediatorFunctionFactory = a.mediatorFunctionFactory, this.mediatorMergeBindingsContext = a.mediatorMergeBindingsContext;
    }
  };
  return z3.ActorTermComparatorFactory = r, z3;
}
var Bk;
function V_e() {
  return Bk || (Bk = 1, function(u) {
    var r = yf && yf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = yf && yf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ U_e(), u);
  }(yf)), yf;
}
var k3 = {}, $k;
function Q_e() {
  if ($k) return k3;
  $k = 1, Object.defineProperty(k3, "__esModule", { value: !0 }), k3.TermComparatorExpressionEvaluator = void 0;
  let u = class {
    constructor(o, a, t) {
      this.internalEvaluator = o, this.equalityFunction = a, this.lessThanFunction = t, this._TERM_ORDERING_PRIORITY = {
        Variable: 0,
        BlankNode: 1,
        NamedNode: 2,
        Literal: 3,
        Quad: 4,
        DefaultGraph: 5
      };
    }
    // Determine the relative numerical order of the two given terms.
    // In accordance with https://www.w3.org/TR/sparql11-query/#modOrderBy
    orderTypes(o, a) {
      if (o === a)
        return 0;
      if (o === void 0)
        return -1;
      if (a === void 0)
        return 1;
      if (o.termType !== a.termType)
        return this._TERM_ORDERING_PRIORITY[o.termType] < this._TERM_ORDERING_PRIORITY[a.termType] ? -1 : 1;
      if (o.equals(a))
        return 0;
      if (o.termType === "Quad" && a.termType === "Quad") {
        const t = this.orderTypes(o.subject, a.subject);
        if (t !== 0)
          return t;
        const e = this.orderTypes(o.predicate, a.predicate);
        if (e !== 0)
          return e;
        const n = this.orderTypes(o.object, a.object);
        return n !== 0 ? n : this.orderTypes(o.graph, a.graph);
      }
      return o.termType === "Literal" ? this.orderLiteralTypes(o, a) : this.comparePrimitives(o.value, a.value);
    }
    orderLiteralTypes(o, a) {
      const t = this.internalEvaluator.transformer.transformLiteral(o), e = this.internalEvaluator.transformer.transformLiteral(a);
      try {
        return this.equalityFunction.applyOnTerms([t, e], this.internalEvaluator).typedValue ? 0 : this.lessThanFunction.applyOnTerms([t, e], this.internalEvaluator).typedValue ? -1 : 1;
      } catch {
        const n = this.comparePrimitives(t.dataType, e.dataType);
        return n !== 0 ? n : this.comparePrimitives(t.str(), e.str());
      }
    }
    comparePrimitives(o, a) {
      return o === a ? 0 : o < a ? -1 : 1;
    }
  };
  return k3.TermComparatorExpressionEvaluator = u, k3;
}
var Uk;
function H_e() {
  if (Uk) return G3;
  Uk = 1, Object.defineProperty(G3, "__esModule", { value: !0 }), G3.ActorTermComparatorFactoryExpressionEvaluator = void 0;
  const u = /* @__PURE__ */ GZ(), r = /* @__PURE__ */ V_e(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ _e(), t = /* @__PURE__ */ Jt(), e = /* @__PURE__ */ ve(), n = /* @__PURE__ */ Q_e();
  let i = class extends r.ActorTermComparatorFactory {
    async test(s) {
      return (0, a.passTestVoid)();
    }
    /**
     * Context item superTypeProvider can be expected here
     * @param context IActionTermComparatorFactory
     * @param context.context IActionContext
     */
    async run({ context: s }) {
      return s = e.prepareEvaluatorActionContext(s), new n.TermComparatorExpressionEvaluator(new u.InternalEvaluator(s, this.mediatorFunctionFactory, this.mediatorQueryOperation, await t.BindingsFactory.create(this.mediatorMergeBindingsContext, s, s.getSafe(o.KeysInitQuery.dataFactory))), await this.mediatorFunctionFactory.mediate({ functionName: e.SparqlOperator.EQUAL, context: s, requireTermExpression: !0 }), await this.mediatorFunctionFactory.mediate({ functionName: e.SparqlOperator.LT, context: s, requireTermExpression: !0 }));
    }
  };
  return G3.ActorTermComparatorFactoryExpressionEvaluator = i, G3;
}
var Vk;
function G_e() {
  return Vk || (Vk = 1, function(u) {
    var r = bf && bf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = bf && bf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ H_e(), u);
  }(bf)), bf;
}
var _f = {}, X3 = {}, Qk;
function z_e() {
  if (Qk) return X3;
  Qk = 1, Object.defineProperty(X3, "__esModule", { value: !0 }), X3.ActorRdfJoinMultiSmallestFilterBindings = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ Jt(), t = /* @__PURE__ */ uu(), e = /* @__PURE__ */ vt(), n = /* @__PURE__ */ yt(), i = ft();
  let c = class extends u.ActorRdfJoin {
    constructor(d) {
      super(d, {
        logicalType: "inner",
        physicalName: "multi-smallest-filter-bindings",
        limitEntries: 2,
        limitEntriesMin: !0,
        isLeaf: !1
      });
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    async sortJoinEntries(d, l) {
      let { entries: f } = await this.mediatorJoinEntriesSort.mediate({ entries: d, context: l });
      f = f.sort((m, g) => m.operationModified && !g.operationModified ? -1 : 0);
      const h = f.splice(0, 1)[0];
      let p, b = -1, _ = 0;
      for (const [m, g] of f.entries()) {
        const T = h.metadata.variables.filter((v) => g.metadata.variables.some((E) => v.variable.equals(E.variable))).length;
        (!p || T > _ || T === _ && (g.metadata.variables.length < p.metadata.variables.length || g.metadata.variables.length === p.metadata.variables.length && g.metadata.cardinality.value < p.metadata.cardinality.value)) && (p = g, b = m, _ = T);
      }
      if (_ === 0)
        return (0, o.failTest)(`Actor ${this.name} can only join with common variables`);
      const y = f;
      return y.splice(b, 1), (0, o.passTest)({ first: h, second: p, remaining: y });
    }
    async getOutput(d) {
      const l = d.context.getSafe(r.KeysInitQuery.dataFactory), f = new i.Factory(l), h = await u.ActorRdfJoin.getEntriesWithMetadatas([...d.entries]), { first: p, second: b, remaining: _ } = (await this.sortJoinEntries(h, d.context)).getOrThrow(), y = p.output.bindingsStream;
      p.output.bindingsStream = y.clone();
      const m = p.metadata.variables.filter((S) => b.metadata.variables.some((O) => S.variable.equals(O.variable))), g = {}, T = y.clone().map((S) => S.filter((O, x) => m.some((F) => F.variable.equals(x)))).filter((S) => {
        const O = (0, a.bindingsToString)(S);
        return !(O in g) && (g[O] = !0);
      }), v = new t.ChunkedIterator(T, this.blockSize, { autoStart: !1 }), E = (0, e.getOperationSource)(b.operation), L = {
        output: {
          type: "bindings",
          bindingsStream: new n.UnionIterator(v.map((S) => E.source.queryBindings(b.operation, E.context ? d.context.merge(E.context) : d.context, { filterBindings: { bindings: S, metadata: p.metadata } }))),
          metadata: b.output.metadata
        },
        operation: b.operation,
        operationModified: !0
      };
      b.output.bindingsStream.destroy();
      const A = {
        output: (0, e.getSafeBindings)(await this.mediatorJoin.mediate({
          type: d.type,
          entries: [p, L],
          context: d.context.set(r.KeysRdfJoin.lastPhysicalJoin, this.physicalName)
        })),
        operation: f.createJoin([p.operation, L.operation], !1),
        operationModified: !0
      }, w = _;
      return w.unshift(A), {
        result: await this.mediatorJoin.mediate({
          type: d.type,
          entries: w,
          context: d.context
        }),
        physicalPlanMetadata: {
          firstIndex: h.indexOf(p),
          secondIndex: h.indexOf(b)
        }
      };
    }
    async getJoinCoefficients(d, l) {
      let { metadatas: f } = l;
      if (d.context.get(r.KeysRdfJoin.lastPhysicalJoin) === this.physicalName)
        return (0, o.failTest)(`Actor ${this.name} can not be called recursively`);
      f = [...f];
      const h = await this.sortJoinEntries(d.entries.map((L, A) => ({ ...L, metadata: f[A] })), d.context);
      if (h.isFailed())
        return h;
      const { first: p, second: b, remaining: _ } = h.get(), y = (0, e.getOperationSource)(b.operation);
      if (!y)
        return (0, o.failTest)(`Actor ${this.name} can only process if entries[1] has a source`);
      const m = b.operation, g = await y.source.getSelectorShape(d.context);
      if (!(0, e.doesShapeAcceptOperation)(g, m, { filterBindings: !0 }))
        return (0, o.failTest)(`Actor ${this.name} can only process if entries[1] accept filterBindings`);
      f = [p.metadata, b.metadata, ..._.map((L) => L.metadata)];
      const T = u.ActorRdfJoin.getRequestInitialTimes(f), v = u.ActorRdfJoin.getRequestItemTimes(f), { selectivity: E } = await this.mediatorJoinSelectivity.mediate({
        entries: [p, b],
        context: d.context
      }), R = _.reduce((L, A) => L * A.metadata.cardinality.value * this.selectivityModifier, 1);
      return (0, o.passTestWithSideData)({
        iterations: E * this.selectivityModifier * b.metadata.cardinality.value * R,
        persistedItems: p.metadata.cardinality.value,
        blockingItems: p.metadata.cardinality.value,
        requestTime: T[0] + f[0].cardinality.value * v[0] + T[1] + R * v[1]
      }, l);
    }
  };
  return X3.ActorRdfJoinMultiSmallestFilterBindings = c, X3;
}
var Hk;
function k_e() {
  return Hk || (Hk = 1, function(u) {
    var r = _f && _f.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = _f && _f.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ z_e(), u);
  }(_f)), _f;
}
var gf = {}, J3 = {}, Gk;
function X_e() {
  if (Gk) return J3;
  Gk = 1, Object.defineProperty(J3, "__esModule", { value: !0 }), J3.ActorQueryProcessExplainLogical = void 0;
  const u = /* @__PURE__ */ h4(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class extends u.ActorQueryProcess {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (e.context.get(r.KeysInitQuery.explain) ?? e.context.get(new o.ActionContextKey("explain"))) !== "logical" ? (0, o.failTest)(`${this.name} can only explain in 'logical' mode.`) : (0, o.passTestVoid)();
    }
    async run(e) {
      let { operation: n, context: i } = await this.queryProcessor.parse(e.query, e.context);
      return { operation: n, context: i } = await this.queryProcessor.optimize(n, i), {
        result: {
          explain: !0,
          type: "logical",
          data: n
        }
      };
    }
  };
  return J3.ActorQueryProcessExplainLogical = a, J3;
}
var zk;
function J_e() {
  return zk || (zk = 1, function(u) {
    var r = gf && gf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = gf && gf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ X_e(), u);
  }(gf)), gf;
}
var mf = {}, K3 = {}, kk;
function K_e() {
  if (kk) return K3;
  kk = 1, Object.defineProperty(K3, "__esModule", { value: !0 }), K3.ActorQueryProcessExplainParsed = void 0;
  const u = /* @__PURE__ */ h4(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class extends u.ActorQueryProcess {
    constructor(e) {
      super(e);
    }
    async test(e) {
      return (e.context.get(r.KeysInitQuery.explain) ?? e.context.get(new o.ActionContextKey("explain"))) !== "parsed" ? (0, o.failTest)(`${this.name} can only explain in 'parsed' mode.`) : (0, o.passTestVoid)();
    }
    async run(e) {
      const { operation: n } = await this.queryProcessor.parse(e.query, e.context);
      return {
        result: {
          explain: !0,
          type: "parsed",
          data: n
        }
      };
    }
  };
  return K3.ActorQueryProcessExplainParsed = a, K3;
}
var Xk;
function W_e() {
  return Xk || (Xk = 1, function(u) {
    var r = mf && mf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = mf && mf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ K_e(), u);
  }(mf)), mf;
}
var vf = {}, W3 = {}, Tf = {}, Jk;
function iee() {
  if (Jk) return Tf;
  Jk = 1, Object.defineProperty(Tf, "__esModule", { value: !0 }), Tf.numberToString = Tf.MemoryPhysicalQueryPlanLogger = void 0;
  const u = lr();
  let r = class {
    constructor() {
      this.planNodes = /* @__PURE__ */ new Map();
    }
    logOperation(t, e, n, i, c, s) {
      const d = {
        actor: c,
        logicalOperator: t,
        physicalOperator: e,
        rawNode: n,
        children: [],
        metadata: s
      };
      if (this.planNodes.set(n, d), this.rootNode) {
        if (!i)
          throw new Error("Detected more than one parent-less node");
        const l = this.planNodes.get(i);
        if (!l)
          throw new Error("Could not find parent node");
        l.children.push(d);
      } else {
        if (i)
          throw new Error("No root node has been set yet, while a parent is being referenced");
        this.rootNode = d;
      }
    }
    stashChildren(t, e) {
      const n = this.planNodes.get(t);
      if (!n)
        throw new Error("Could not find plan node");
      n.children = e ? n.children.filter(e) : [];
    }
    unstashChild(t, e) {
      const n = this.planNodes.get(t);
      if (n) {
        const i = this.planNodes.get(e);
        if (!i)
          throw new Error("Could not find plan parent node");
        i.children.push(n);
      }
    }
    appendMetadata(t, e) {
      const n = this.planNodes.get(t);
      n && (n.metadata = {
        ...n.metadata,
        ...e
      });
    }
    toJson() {
      return this.rootNode ? this.planNodeToJson(this.rootNode) : {};
    }
    planNodeToJson(t) {
      var n;
      const e = {
        logical: t.logicalOperator,
        physical: t.physicalOperator,
        ...this.getLogicalMetadata(t.rawNode),
        ...this.compactMetadata(t.metadata)
      };
      if (t.children.length > 0 && (e.children = t.children.map((i) => this.planNodeToJson(i))), e.physical === "bind" && e.children) {
        const i = {};
        for (const s of e.children) {
          const d = ((n = s.children) == null ? void 0 : n.at(-1)) ?? s, l = this.getPlanHash(d).join(",");
          i[l] || (i[l] = []), i[l].push(s);
        }
        const c = [];
        for (const s of Object.values(i))
          c.push({
            occurrences: s.length,
            firstOccurrence: s[0]
          });
        e.childrenCompact = c, delete e.children;
      }
      return e;
    }
    getPlanHash(t) {
      let e = [`${t.logical}-${t.physical}`];
      return t.children ? e = [
        ...e,
        ...t.children.flatMap((n) => this.getPlanHash(n))
      ] : t.childrenCompact && (e = [
        ...e,
        ...t.childrenCompact.flatMap((n) => this.getPlanHash(n.firstOccurrence))
      ]), e;
    }
    compactMetadata(t) {
      return Object.fromEntries(Object.entries(t).map(([e, n]) => [e, this.compactMetadataValue(n)]));
    }
    compactMetadataValue(t) {
      return t && typeof t == "object" && "termType" in t ? this.getLogicalMetadata(t) : t;
    }
    getLogicalMetadata(t) {
      var n;
      const e = {};
      if ("type" in t) {
        const i = t;
        switch ((n = i.metadata) != null && n.scopedSource && (e.source = i.metadata.scopedSource.source.toString()), i.type) {
          case "pattern":
            e.pattern = this.quadToString(i);
            break;
          case "project":
            e.variables = i.variables.map((c) => c.value);
            break;
        }
      }
      return e;
    }
    quadToString(t) {
      return `${(0, u.termToString)(t.subject)} ${(0, u.termToString)(t.predicate)} ${(0, u.termToString)(t.object)}${t.graph.termType === "DefaultGraph" ? "" : ` ${(0, u.termToString)(t.graph)}`}`;
    }
    toCompactString() {
      const t = this.toJson(), e = [], n = /* @__PURE__ */ new Map();
      if ("logical" in t ? this.nodeToCompactString(e, n, "", t) : e.push("Empty"), n.size > 0) {
        e.push(""), e.push("sources:");
        for (const [i, c] of n.entries())
          e.push(`  ${c}: ${i}`);
      }
      return e.join(`
`);
    }
    nodeToCompactString(t, e, n, i, c) {
      let s;
      i.source && (s = e.get(i.source), s === void 0 && (s = e.size, e.set(i.source, s))), t.push(`${n}${i.logical}${i.physical ? `(${i.physical})` : ""}${i.pattern ? ` (${i.pattern})` : ""}${i.variables ? ` (${i.variables.join(",")})` : ""}${i.bindOperation ? ` bindOperation:(${i.bindOperation.pattern}) bindCardEst:${i.bindOperationCardinality.type === "estimate" ? "~" : ""}${o(i.bindOperationCardinality.value)}` : ""}${i.cardinality ? ` cardEst:${i.cardinality.type === "estimate" ? "~" : ""}${o(i.cardinality.value)}` : ""}${i.source ? ` src:${s}` : ""}${i.cardinalityReal ? ` cardReal:${i.cardinalityReal}` : ""}${i.timeSelf ? ` timeSelf:${o(i.timeSelf)}ms` : ""}${i.timeLife ? ` timeLife:${o(i.timeLife)}ms` : ""}${c ? ` ${c}` : ""}`);
      for (const d of i.children ?? [])
        this.nodeToCompactString(t, e, `${n}  `, d);
      for (const d of i.childrenCompact ?? [])
        this.nodeToCompactString(t, e, `${n}  `, d.firstOccurrence, `compacted-occurrences:${d.occurrences}`);
    }
  };
  Tf.MemoryPhysicalQueryPlanLogger = r;
  function o(a) {
    return a.toLocaleString("en-US", { minimumFractionDigits: 0, maximumFractionDigits: 3 });
  }
  return Tf.numberToString = o, Tf;
}
var Kk;
function Y_e() {
  if (Kk) return W3;
  Kk = 1, Object.defineProperty(W3, "__esModule", { value: !0 }), W3.ActorQueryProcessExplainPhysical = void 0;
  const u = /* @__PURE__ */ h4(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ iee();
  let t = class extends u.ActorQueryProcess {
    constructor(n) {
      super(n);
    }
    async test(n) {
      const i = n.context.get(r.KeysInitQuery.explain) ?? n.context.get(new o.ActionContextKey("explain"));
      return i !== "physical" && i !== "physical-json" ? (0, o.failTest)(`${this.name} can only explain in 'physical' or 'physical-json' mode.`) : (0, o.passTestVoid)();
    }
    async run(n) {
      let { operation: i, context: c } = await this.queryProcessor.parse(n.query, n.context);
      ({ operation: i, context: c } = await this.queryProcessor.optimize(i, c));
      const s = new a.MemoryPhysicalQueryPlanLogger();
      c = c.set(r.KeysInitQuery.physicalQueryPlanLogger, s);
      const d = await this.queryProcessor.evaluate(i, c);
      switch (d.type) {
        case "bindings":
          await d.bindingsStream.toArray();
          break;
        case "quads":
          await d.quadStream.toArray();
          break;
        case "boolean":
          await d.execute();
          break;
        case "void":
          await d.execute();
          break;
      }
      const l = n.context.get(r.KeysInitQuery.explain) ?? n.context.getSafe(new o.ActionContextKey("explain"));
      return {
        result: {
          explain: !0,
          type: l,
          data: l === "physical" ? s.toCompactString() : s.toJson()
        }
      };
    }
  };
  return W3.ActorQueryProcessExplainPhysical = t, W3;
}
var Wk;
function Z_e() {
  return Wk || (Wk = 1, function(u) {
    var r = vf && vf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = vf && vf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Y_e(), u), o(/* @__PURE__ */ iee(), u);
  }(vf)), vf;
}
var wf = {}, Y3 = {}, Yk;
function ege() {
  if (Yk) return Y3;
  Yk = 1, Object.defineProperty(Y3, "__esModule", { value: !0 }), Y3.ActorOptimizeQueryOperationPruneEmptySourceOperations = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ vt(), t = ft();
  let e = class xT extends u.ActorOptimizeQueryOperation {
    constructor(i) {
      super(i);
    }
    async test(i) {
      return (0, a.getOperationSource)(i.operation) ? (0, o.failTest)(`Actor ${this.name} does not work with top-level operation sources.`) : (0, o.passTestVoid)();
    }
    async run(i) {
      const c = i.context.getSafe(r.KeysInitQuery.dataFactory), s = new t.Factory(c);
      let d = i.operation;
      const l = [], f = this;
      t.Util.recurseOperation(d, {
        [t.Algebra.types.UNION](p) {
          return f.collectMultiOperationInputs(p.input, l, t.Algebra.types.PATTERN), !0;
        },
        [t.Algebra.types.ALT](p) {
          return f.collectMultiOperationInputs(p.input, l, t.Algebra.types.LINK), !1;
        },
        [t.Algebra.types.SERVICE]() {
          return !1;
        }
      });
      const h = /* @__PURE__ */ new Set();
      return await Promise.all(l.map(async (p) => {
        const b = p.type === "link" ? s.createPattern(c.variable("s"), p.iri, c.variable("o")) : p;
        await this.hasSourceResults(s, (0, a.getOperationSource)(p), b, i.context) || h.add(p);
      })), h.size > 0 && (this.logDebug(i.context, `Pruning ${h.size} source-specific operations`), d = t.Util.mapOperation(d, {
        [t.Algebra.types.UNION](p, b) {
          return f.mapMultiOperation(p, h, (_) => b.createUnion(_));
        },
        [t.Algebra.types.ALT](p, b) {
          return f.mapMultiOperation(p, h, (_) => b.createAlt(_));
        }
      }, s), d = t.Util.mapOperation(d, {
        [t.Algebra.types.PROJECT](p, b) {
          return xT.hasEmptyOperation(p) ? {
            recurse: !1,
            result: b.createUnion([])
          } : {
            recurse: !0,
            result: p
          };
        },
        [t.Algebra.types.LEFT_JOIN](p) {
          return xT.hasEmptyOperation(p.input[1]) ? {
            recurse: !0,
            result: p.input[0]
          } : {
            recurse: !0,
            result: p
          };
        }
      }, s)), { operation: d, context: i.context };
    }
    static hasEmptyOperation(i) {
      let c = !1;
      return t.Util.recurseOperation(i, {
        [t.Algebra.types.UNION](s) {
          return s.input.every((d) => xT.hasEmptyOperation(d)) && (c = !0), !1;
        },
        [t.Algebra.types.ALT](s) {
          return s.input.length === 0 && (c = !0), !1;
        },
        [t.Algebra.types.LEFT_JOIN](s) {
          return xT.hasEmptyOperation(s.input[0]) && (c = !0), !1;
        }
      }), c;
    }
    collectMultiOperationInputs(i, c, s) {
      for (const d of i)
        (0, a.getOperationSource)(d) && d.type === s && c.push(d);
    }
    mapMultiOperation(i, c, s) {
      const d = i.input.filter((l) => !c.has(l));
      return d.length === i.input.length ? { result: i, recurse: !0 } : d.length === 0 ? { result: s([]), recurse: !1 } : d.length === 1 ? { result: d[0], recurse: !0 } : { result: s(d), recurse: !0 };
    }
    /**
     * Check if the given query operation will produce at least one result in the given source.
     * @param algebraFactory The algebra factory.
     * @param source A query source.
     * @param input A query operation.
     * @param context The query context.
     */
    async hasSourceResults(i, c, s, d) {
      var f;
      if (((f = c.context) == null ? void 0 : f.get(r.KeysQuerySourceIdentify.traverse)) ?? d.get(r.KeysQuerySourceIdentify.traverse))
        return !0;
      if (this.useAskIfSupported) {
        const h = i.createAsk(s);
        if ((0, a.doesShapeAcceptOperation)(await c.source.getSelectorShape(d), h))
          return c.source.queryBoolean(h, d);
      }
      const l = c.source.queryBindings(s, d);
      return new Promise((h, p) => {
        l.on("error", p), l.getProperty("metadata", (b) => {
          l.destroy(), h(b.cardinality.value > 0);
        });
      });
    }
  };
  return Y3.ActorOptimizeQueryOperationPruneEmptySourceOperations = e, Y3;
}
var Zk;
function tge() {
  return Zk || (Zk = 1, function(u) {
    var r = wf && wf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = wf && wf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ege(), u);
  }(wf)), wf;
}
var Sf = {}, Z3 = {}, eX;
function rge() {
  if (eX) return Z3;
  eX = 1, Object.defineProperty(Z3, "__esModule", { value: !0 }), Z3.ActorHttpRetry = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e();
  let a = class Vf extends u.ActorHttp {
    constructor(e) {
      super(e), this.activeDelays = {}, this.httpInvalidator = e.httpInvalidator, this.httpInvalidator.addInvalidateListener((n) => this.handleHttpInvalidateEvent(n)), this.mediatorHttp = e.mediatorHttp;
    }
    async test(e) {
      if (e.context.has(Vf.keyWrapped))
        return (0, o.failTest)(`${this.name} can only wrap a request once`);
      const n = e.context.get(r.KeysHttp.httpRetryCount);
      return !n || n < 1 ? (0, o.failTest)(`${this.name} requires a retry count greater than zero to function`) : (0, o.passTest)({ time: 0 });
    }
    async run(e) {
      const n = u.ActorHttp.getInputUrl(e.input), i = e.context.getSafe(r.KeysHttp.httpRetryCount) + 1, c = e.context.get(r.KeysHttp.httpRetryDelayFallback) ?? 0, s = e.context.get(r.KeysHttp.httpRetryDelayLimit), d = e.context.get(r.KeysHttp.httpRetryStatusCodes);
      for (let l = 1; l <= i; l++) {
        const f = n.host in this.activeDelays ? this.activeDelays[n.host].date.getTime() - Date.now() : c;
        if (s && f > s) {
          this.logWarn(e.context, "Requested delay exceeds the limit", () => ({
            url: n.href,
            delay: f,
            delayDate: this.activeDelays[n.host].date.toISOString(),
            delayLimit: s,
            currentAttempt: `${l} / ${i}`
          }));
          break;
        } else f > 0 && l > 1 && (this.logDebug(e.context, "Delaying request", () => ({
          url: n.href,
          delay: f,
          currentAttempt: `${l} / ${i}`
        })), await Vf.sleep(f));
        const h = await this.mediatorHttp.mediate({
          ...e,
          context: e.context.set(Vf.keyWrapped, !0)
        });
        if (h.ok)
          return h;
        if (d && d.includes(h.status)) {
          this.logDebug(e.context, "Status code in force retry list, forcing retry", () => ({
            url: n.href,
            status: h.status,
            statusText: h.statusText,
            currentAttempt: `${l} / ${i}`
          }));
          continue;
        }
        if (h.status === 504) {
          this.logDebug(e.context, "Received proxy timeout", () => ({
            url: n.href,
            status: h.status,
            statusText: h.statusText,
            currentAttempt: `${l} / ${i}`
          }));
          continue;
        }
        if (
          // Status codes 429 (Too Many Requests) and 503 (Temporarily Unavailable) can have Retry-After
          h.status === 429 || h.status === 503 || // DBPedia SPARQL endpoint uses 405 instead of 429 and sends a Retry-After with it to indicate rate limits
          h.status === 405 && h.headers.has("retry-after")
        ) {
          const p = h.headers.get("retry-after");
          if (p) {
            const b = Vf.parseRetryAfterHeader(p);
            b ? (n.host in this.activeDelays && clearTimeout(this.activeDelays[n.host].timeout), this.activeDelays[n.host] = {
              date: b,
              timeout: setTimeout(() => delete this.activeDelays[n.host], b.getTime() - Date.now())
            }) : this.logDebug(e.context, "Invalid Retry-After header value from server", () => ({
              url: n.href,
              status: h.status,
              statusText: h.statusText,
              retryAfterHeader: p,
              currentAttempt: `${l} / ${i}`
            }));
          }
          this.logDebug(e.context, "Server temporarily unavailable", () => ({
            url: n.href,
            status: h.status,
            statusText: h.statusText,
            currentAttempt: `${l} / ${i}`
          }));
          continue;
        }
        if (h.status >= 400 && h.status < 500) {
          this.logDebug(e.context, "Server reported client-side error", () => ({
            url: n.href,
            status: h.status,
            statusText: h.statusText,
            currentAttempt: `${l} / ${i}`
          }));
          break;
        }
        if (h.status >= 500 && h.status < 600) {
          this.logDebug(e.context, "Server-side error encountered, terminating", () => ({
            url: n.href,
            status: h.status,
            statusText: h.statusText,
            currentAttempt: `${l} / ${i}`
          }));
          break;
        }
        this.logDebug(e.context, "Request failed", () => ({
          url: n.href,
          status: h.status,
          statusText: h.statusText,
          currentAttempt: `${l} / ${i}`
        }));
      }
      throw new Error(`Request failed: ${n.href}`);
    }
    /**
     * Sleeps for the specified amount of time, using a timeout
     * @param {number} ms The amount of milliseconds to sleep
     */
    static async sleep(e) {
      e > 0 && await new Promise((n) => setTimeout(n, e));
    }
    /**
     * Parses a Retry-After HTTP header value following the specification:
     * https://httpwg.org/specs/rfc9110.html#field.retry-after
     * @param {string} retryAfter The raw header value as string
     * @returns The parsed Date object, or undefined in case of invalid header value
     */
    static parseRetryAfterHeader(e) {
      if (Vf.numberRegex.test(e))
        return new Date(Date.now() + Number.parseInt(e, 10) * 1e3);
      if (Vf.dateRegex.test(e))
        return new Date(e);
    }
    /**
     * Handles HTTP cache invalidation events.
     * @param {IActionHttpInvalidate} action The invalidation action
     */
    handleHttpInvalidateEvent(e) {
      const n = e.url ? new URL(e.url).host : void 0;
      for (const i of Object.keys(this.activeDelays))
        (!n || i === n) && (clearTimeout(this.activeDelays[i].timeout), delete this.activeDelays[i]);
    }
  };
  return Z3.ActorHttpRetry = a, a.dateRegex = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), [0-9]{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [0-9]{4} [0-9]{2}:[0-9]{2}:[0-9]{2} GMT$/u, a.numberRegex = /^[0-9]+$/u, a.keyWrapped = new o.ActionContextKey("urn:comunica:actor-http-retry#wrapped"), Z3;
}
var tX;
function nge() {
  return tX || (tX = 1, function(u) {
    var r = Sf && Sf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Sf && Sf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ rge(), u);
  }(Sf)), Sf;
}
var Af = {}, eT = {}, rX;
function ige() {
  if (rX) return eT;
  rX = 1, Object.defineProperty(eT, "__esModule", { value: !0 }), eT.ActorHttpLimitRate = void 0;
  const u = /* @__PURE__ */ Aa(), r = /* @__PURE__ */ _e();
  let o = class _x extends u.ActorHttp {
    constructor(t) {
      super(t), this.mediatorHttp = t.mediatorHttp, this.httpInvalidator = t.httpInvalidator, this.httpInvalidator.addInvalidateListener((e) => this.handleHttpInvalidateEvent(e)), this.correctionMultiplier = t.correctionMultiplier, this.failureMultiplier = t.failureMultiplier, this.limitByDefault = t.limitByDefault, this.allowOverlap = t.allowOverlap, this.hostData = /* @__PURE__ */ new Map();
    }
    async test(t) {
      return t.context.has(_x.keyWrapped) ? (0, r.failTest)(`${this.name} can only wrap a request once`) : (0, r.passTest)({ time: 0 });
    }
    async run(t) {
      const e = u.ActorHttp.getInputUrl(t.input);
      let n = this.hostData.get(e.host);
      n || (n = {
        latestRequestTimestamp: 0,
        rateLimited: this.limitByDefault,
        requestInterval: Number.NEGATIVE_INFINITY
      }, this.hostData.set(e.host, n));
      const i = Date.now();
      let c = 0;
      n.rateLimited && (c = Math.max(0, n.latestRequestTimestamp + n.requestInterval - i)), n.latestRequestTimestamp = i + (this.allowOverlap ? 0 : 1) * c, c > 0 && (this.logDebug(t.context, "Delaying request", () => ({
        url: e.href,
        requestInterval: n.requestInterval,
        currentDelay: c
      })), await new Promise((d) => setTimeout(d, c)));
      const s = (d) => {
        const l = (d ? 1 : this.failureMultiplier) * (Date.now() - i - c);
        n.requestInterval < 0 ? n.requestInterval = Math.round(l * this.correctionMultiplier) : n.requestInterval += Math.round(this.correctionMultiplier * (l - n.requestInterval)), !d && !n.rateLimited && (this.logDebug(t.context, "Marking host as rate-limited", () => ({
          host: e.host
        })), n.rateLimited = !0);
      };
      try {
        const d = await this.mediatorHttp.mediate({
          ...t,
          context: t.context.set(_x.keyWrapped, !0)
        });
        return s(d.ok), d;
      } catch (d) {
        throw s(!1), d;
      }
    }
    /**
     * Handles HTTP cache invalidation events.
     * @param {IActionHttpInvalidate} action The invalidation action
     */
    handleHttpInvalidateEvent(t) {
      if (t.url) {
        const e = new URL(t.url).host;
        this.hostData.delete(e);
      } else
        this.hostData.clear();
    }
  };
  return eT.ActorHttpLimitRate = o, o.keyWrapped = new r.ActionContextKey("urn:comunica:actor-http-limit-rate#wrapped"), eT;
}
var nX;
function age() {
  return nX || (nX = 1, function(u) {
    var r = Af && Af.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Af && Af.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ ige(), u);
  }(Af)), Af;
}
var Ef = {}, tT = {}, iX;
function uge() {
  if (iX) return tT;
  iX = 1, Object.defineProperty(tT, "__esModule", { value: !0 }), tT.ActorQuerySourceIdentifySerialized = void 0;
  const u = /* @__PURE__ */ Fw(), r = /* @__PURE__ */ _e(), o = QZ(), a = Bt();
  let t = class extends u.ActorQuerySourceIdentify {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return this.isStringSource(n.querySourceUnidentified) ? (0, r.passTestVoid)() : (0, r.failTest)(`${this.name} requires a single query source with serialized type to be present in the context.`);
    }
    async run(n) {
      return await this.mediatorQuerySourceIdentify.mediate({
        querySourceUnidentified: {
          type: "rdfjs",
          value: await this.getRdfSource(n.context, n.querySourceUnidentified),
          context: n.querySourceUnidentified.context
        },
        context: n.context
      });
    }
    /**
     * Parses the string data source through the RDF parse bus, returning the RDF source.
     * @param context The run action context
     * @param source The source from the run action context
     * @returns Parsed RDF source that can be passed to quad pattern resolve mediator as an RDF/JS source
     */
    async getRdfSource(n, i) {
      const c = new a.Readable({ objectMode: !0 });
      c._read = () => {
      }, c.push(i.value), c.push(null);
      const s = {
        context: n,
        handle: {
          metadata: { baseIRI: i.baseIRI },
          data: c,
          context: n
        },
        handleMediaType: i.mediaType
      }, d = await this.mediatorRdfParse.mediate(s);
      return await (0, o.storeStream)(d.handle.data);
    }
    isStringSource(n) {
      return "type" in n ? n.type === "serialized" : typeof n.value != "string" ? !1 : "mediaType" in n;
    }
  };
  return tT.ActorQuerySourceIdentifySerialized = t, tT;
}
var aX;
function oge() {
  return aX || (aX = 1, function(u) {
    var r = Ef && Ef.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ef && Ef.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ uge(), u);
  }(Ef)), Ef;
}
var Of = {}, rT = {}, uX;
function sge() {
  if (uX) return rT;
  uX = 1, Object.defineProperty(rT, "__esModule", { value: !0 }), rT.ActorRdfJoinMultiBindSource = void 0;
  const u = /* @__PURE__ */ cn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = /* @__PURE__ */ uu(), t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ yt(), n = ft();
  let i = class extends u.ActorRdfJoin {
    constructor(s) {
      super(s, {
        logicalType: "inner",
        physicalName: "bind-source",
        canHandleUndefs: !0
      });
    }
    async getOutput(s, d) {
      const l = s.context.getSafe(r.KeysInitQuery.dataFactory), f = new n.Factory(l), h = d.entriesSorted;
      this.logDebug(s.context, "First entry for Bind Join Source: ", () => ({
        entry: h[0].operation,
        cardinality: h[0].metadata.cardinality,
        order: h[0].metadata.order,
        availableOrders: h[0].metadata.availableOrders
      }));
      for (const [v, E] of h.entries())
        v !== 0 && E.output.bindingsStream.close();
      const p = h[0].output, b = h[0].metadata, _ = [...h];
      _.splice(0, 1);
      const y = (0, t.getOperationSource)(_[0].operation), m = this.createOperationFromEntries(f, _), g = new a.ChunkedIterator(p.bindingsStream, this.blockSize, { autoStart: !1 });
      return {
        result: {
          type: "bindings",
          bindingsStream: new e.UnionIterator(g.map((v) => y.source.queryBindings(m, y.context ? s.context.merge(y.context) : s.context, { joinBindings: { bindings: v, metadata: b } }))),
          metadata: () => this.constructResultMetadata(h, h.map((v) => v.metadata), s.context)
        },
        physicalPlanMetadata: {
          bindIndex: d.entriesUnsorted.indexOf(h[0])
        }
      };
    }
    async sortJoinEntries(s, d) {
      const l = await u.ActorRdfJoin.sortJoinEntries(this.mediatorJoinEntriesSort, s, d);
      return l.isFailed() ? l : (s = l.get(), s = s.sort((f, h) => f.operationModified && !h.operationModified ? -1 : 0), (0, o.passTest)(s));
    }
    async getJoinCoefficients(s, d) {
      let { metadatas: l } = d;
      const f = s.context.getSafe(r.KeysInitQuery.dataFactory), h = new n.Factory(f), p = s.entries.map((w, S) => ({ ...w, metadata: l[S] })), b = await this.sortJoinEntries(p, s.context);
      if (b.isFailed())
        return b;
      const _ = b.get();
      l = _.map((w) => w.metadata);
      const y = u.ActorRdfJoin.getRequestInitialTimes(l), m = u.ActorRdfJoin.getRequestItemTimes(l), g = [..._];
      [...y], [...m], g.splice(0, 1);
      const T = g.map((w) => (0, t.getOperationSource)(w.operation));
      if (T.some((w) => !w))
        return (0, o.failTest)(`Actor ${this.name} can not bind on remaining operations without source annotation`);
      if (T.some((w) => w !== T[0]))
        return (0, o.failTest)(`Actor ${this.name} can not bind on remaining operations with non-equal source annotation`);
      const v = T[0], E = this.createOperationFromEntries(h, g), R = await v.source.getSelectorShape(s.context);
      if (!(0, t.doesShapeAcceptOperation)(R, E, { joinBindings: !0 }))
        return (0, o.failTest)(`Actor ${this.name} detected a source that can not handle passing down join bindings`);
      const L = await Promise.all(g.map(async (w) => (await this.mediatorJoinSelectivity.mediate({
        entries: [_[0], w],
        context: s.context
      })).selectivity * this.selectivityModifier)), A = g.map((w, S) => w.metadata.cardinality.value * L[S]).reduce((w, S) => w + S, 0);
      return (0, o.passTestWithSideData)({
        iterations: 1,
        persistedItems: l[0].cardinality.value,
        blockingItems: l[0].cardinality.value,
        requestTime: y[0] + l[0].cardinality.value * m[0] + y[1] + A * m[1]
      }, { ...d, entriesUnsorted: p, entriesSorted: _ });
    }
    createOperationFromEntries(s, d) {
      return d.length === 1 ? d[0].operation : s.createJoin(d.map((l) => l.operation), !0);
    }
  };
  return rT.ActorRdfJoinMultiBindSource = i, rT;
}
var oX;
function cge() {
  return oX || (oX = 1, function(u) {
    var r = Of && Of.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Of && Of.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ sge(), u);
  }(Of)), Of;
}
var xf = {}, nT = {}, sX;
function dge() {
  if (sX) return nT;
  sX = 1, Object.defineProperty(nT, "__esModule", { value: !0 }), nT.ActorOptimizeQueryOperationJoinConnected = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class fS extends u.ActorOptimizeQueryOperation {
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i);
      return { operation: a.Util.mapOperation(n.operation, {
        join(d, l) {
          return {
            recurse: !1,
            result: fS.cluster(d, l)
          };
        }
      }, c), context: n.context };
    }
    /**
     * Iteratively cluster join entries based on their overlapping variables.
     * @param op A join operation.
     * @param factory An algebra factory.
     */
    static cluster(n, i) {
      const c = n.input.map((f) => ({
        inScopeVariables: Object.fromEntries(a.Util.inScopeVariables(f).map((h) => [h.value, !0])),
        entries: [f]
      }));
      let s, d = c;
      do
        s = d, d = fS.clusterIteration(s);
      while (s.length !== d.length);
      const l = d.map((f) => f.entries.length === 1 ? f.entries[0] : i.createJoin(f.entries));
      return l.length === 1 ? l[0] : i.createJoin(l, !1);
    }
    /**
     * Perform a single clustering iteration.
     * Clusters will be joined if they have overlapping variables.
     * @param oldCluster
     */
    static clusterIteration(n) {
      const i = [];
      for (const c of n) {
        let s = !1;
        for (const d of i)
          if (fS.haveOverlappingVariables(c.inScopeVariables, d.inScopeVariables)) {
            d.entries = [...d.entries, ...c.entries], d.inScopeVariables = { ...d.inScopeVariables, ...c.inScopeVariables }, s = !0;
            break;
          }
        s || i.push({
          inScopeVariables: c.inScopeVariables,
          entries: c.entries
        });
      }
      return i;
    }
    /**
     * Check if the two given variable objects are overlapping.
     * @param variablesA A variables objects.
     * @param variablesB A variables objects.
     */
    static haveOverlappingVariables(n, i) {
      for (const c of Object.keys(n))
        if (i[c])
          return !0;
      return !1;
    }
  };
  return nT.ActorOptimizeQueryOperationJoinConnected = t, nT;
}
var cX;
function lge() {
  return cX || (cX = 1, function(u) {
    var r = xf && xf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = xf && xf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ dge(), u);
  }(xf)), xf;
}
var If = {}, iT = {}, dX;
function fge() {
  if (dX) return iT;
  dX = 1, Object.defineProperty(iT, "__esModule", { value: !0 }), iT.ActorOptimizeQueryOperationBgpToJoin = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i);
      return { operation: a.Util.mapOperation(n.operation, {
        bgp(d, l) {
          return {
            recurse: !1,
            result: l.createJoin(d.patterns)
          };
        }
      }, c), context: n.context };
    }
  };
  return iT.ActorOptimizeQueryOperationBgpToJoin = t, iT;
}
var lX;
function hge() {
  return lX || (lX = 1, function(u) {
    var r = If && If.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = If && If.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ fge(), u);
  }(If)), If;
}
var Rf = {}, aT = {}, fX;
function pge() {
  if (fX) return aT;
  fX = 1, Object.defineProperty(aT, "__esModule", { value: !0 }), aT.ActorOptimizeQueryOperationJoinBgp = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    async test(n) {
      return (0, o.passTestVoid)();
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i);
      return { operation: a.Util.mapOperation(n.operation, {
        join(d, l) {
          return d.input.every((f) => f.type === "bgp") ? {
            recurse: !1,
            result: l.createBgp(d.input.flatMap((f) => f.patterns))
          } : {
            recurse: !1,
            result: d
          };
        }
      }, c), context: n.context };
    }
  };
  return aT.ActorOptimizeQueryOperationJoinBgp = t, aT;
}
var hX;
function bge() {
  return hX || (hX = 1, function(u) {
    var r = Rf && Rf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Rf && Rf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ pge(), u);
  }(Rf)), Rf;
}
var Ff = {}, uT = {}, pX;
function yge() {
  if (pX) return uT;
  pX = 1, Object.defineProperty(uT, "__esModule", { value: !0 }), uT.ActorOptimizeQueryOperationAssignSourcesExhaustive = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ V8(), o = /* @__PURE__ */ Be(), a = /* @__PURE__ */ _e(), t = /* @__PURE__ */ vt(), e = ft();
  let n = class extends u.ActorOptimizeQueryOperation {
    constructor(c) {
      super(c);
    }
    async test(c) {
      return (0, a.passTestVoid)();
    }
    async run(c) {
      const s = c.context.getSafe(o.KeysInitQuery.dataFactory), d = new e.Factory(s), l = c.context.get(o.KeysQueryOperation.querySources) ?? [];
      if (l.length === 0)
        return { operation: c.operation, context: c.context };
      if (l.length === 1) {
        const f = l[0], h = c.context.get(o.KeysRdfUpdateQuads.destination);
        if (!h || f.source.referenceValue === (0, r.getDataDestinationValue)(h))
          try {
            const p = await f.source.getSelectorShape(c.context);
            if ((0, t.doesShapeAcceptOperation)(p, c.operation))
              return {
                operation: (0, t.assignOperationSource)(c.operation, f),
                context: c.context
              };
          } catch {
          }
      }
      return {
        operation: this.assignExhaustive(d, c.operation, l),
        // We only keep queryString in the context if we only have a single source that accepts the full operation.
        // In that case, the queryString can be sent to the source as-is.
        context: c.context.delete(o.KeysInitQuery.queryString)
      };
    }
    /**
     * Assign the given sources to the leaves in the given query operation.
     * Leaves will be wrapped in a union operation and duplicated for every source.
     * The input operation will not be modified.
     * @param algebraFactory The algebra factory.
     * @param operation The input operation.
     * @param sources The sources to assign.
     */
    assignExhaustive(c, s, d) {
      const l = this;
      return e.Util.mapOperation(s, {
        [e.Algebra.types.PATTERN](f, h) {
          return d.length === 1 ? {
            result: (0, t.assignOperationSource)(f, d[0]),
            recurse: !1
          } : {
            result: h.createUnion(d.map((p) => (0, t.assignOperationSource)(f, p))),
            recurse: !1
          };
        },
        [e.Algebra.types.LINK](f, h) {
          return d.length === 1 ? {
            result: (0, t.assignOperationSource)(f, d[0]),
            recurse: !1
          } : {
            result: h.createAlt(d.map((p) => (0, t.assignOperationSource)(f, p))),
            recurse: !1
          };
        },
        [e.Algebra.types.NPS](f, h) {
          return d.length === 1 ? {
            result: (0, t.assignOperationSource)(f, d[0]),
            recurse: !1
          } : {
            result: h.createAlt(d.map((p) => (0, t.assignOperationSource)(f, p))),
            recurse: !1
          };
        },
        [e.Algebra.types.SERVICE](f) {
          return {
            result: f,
            recurse: !1
          };
        },
        [e.Algebra.types.CONSTRUCT](f, h) {
          return {
            result: h.createConstruct(l.assignExhaustive(c, f.input, d), f.template),
            recurse: !1
          };
        },
        [e.Algebra.types.DELETE_INSERT](f, h) {
          return {
            result: h.createDeleteInsert(f.delete, f.insert, f.where ? l.assignExhaustive(c, f.where, d) : void 0),
            recurse: !1
          };
        }
      }, c);
    }
  };
  return uT.ActorOptimizeQueryOperationAssignSourcesExhaustive = n, uT;
}
var bX;
function _ge() {
  return bX || (bX = 1, function(u) {
    var r = Ff && Ff.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Ff && Ff.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ yge(), u);
  }(Ff)), Ff;
}
var Nf = {}, oT = {}, yX;
function gge() {
  if (yX) return oT;
  yX = 1, Object.defineProperty(oT, "__esModule", { value: !0 }), oT.ActorOptimizeQueryOperationDescribeToConstructsSubject = void 0;
  const u = /* @__PURE__ */ kn(), r = /* @__PURE__ */ Be(), o = /* @__PURE__ */ _e(), a = ft();
  let t = class extends u.ActorOptimizeQueryOperation {
    constructor(n) {
      super(n);
    }
    async test(n) {
      return n.operation.type !== a.Algebra.types.DESCRIBE ? (0, o.failTest)(`Actor ${this.name} only supports describe operations, but got ${n.operation.type}`) : (0, o.passTest)(!0);
    }
    async run(n) {
      const i = n.context.getSafe(r.KeysInitQuery.dataFactory), c = new a.Factory(i), s = n.operation, d = s.terms.filter((f) => f.termType !== "Variable").map((f) => {
        const h = [
          i.quad(f, i.variable("__predicate"), i.variable("__object"))
        ];
        return h.forEach((b) => b.type = "pattern"), {
          input: {
            type: a.Algebra.types.BGP,
            patterns: h
          },
          template: h,
          type: "construct"
        };
      });
      if (d.length !== s.terms.length) {
        let f = [];
        s.terms.filter((h) => h.termType === "Variable").forEach((h, p) => {
          const b = [
            i.quad(h, i.variable(`__predicate${p}`), i.variable(`__object${p}`))
          ];
          b.forEach((_) => _.type = "pattern"), f = [...f, ...b];
        }), d.push({
          input: {
            type: a.Algebra.types.JOIN,
            input: [
              s.input,
              { type: a.Algebra.types.BGP, patterns: f }
            ]
          },
          template: f,
          type: a.Algebra.types.CONSTRUCT
        });
      }
      return { operation: c.createUnion(d, !1), context: n.context };
    }
  };
  return oT.ActorOptimizeQueryOperationDescribeToConstructsSubject = t, oT;
}
var _X;
function mge() {
  return _X || (_X = 1, function(u) {
    var r = Nf && Nf.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = Nf && Nf.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ gge(), u);
  }(Nf)), Nf;
}
var NO, gX;
function vge() {
  return gX || (gX = 1, NO = function(u) {
    const r = new (wne()).LoggerVoid(), o = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-init/^4.0.0/components/ActorInit.jsonld#ActorInit_default_bus"
    }), a = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-context-preprocess/^4.0.0/components/ActorContextPreprocess.jsonld#ActorContextPreprocess_default_bus"
    }), t = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-hash-bindings/^4.0.0/components/ActorHashBindings.jsonld#ActorHashBindings_default_bus"
    }), e = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-hash-quads/^4.0.0/components/ActorHashQuads.jsonld#ActorHashQuads_default_bus"
    }), n = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-optimize-query-operation/^4.0.0/components/ActorOptimizeQueryOperation.jsonld#ActorOptimizeQueryOperation_default_bus"
    }), i = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-parse/^4.0.0/components/ActorQueryParse.jsonld#ActorQueryParse_default_bus"
    }), c = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-result-serialize/^4.0.0/components/ActorQueryResultSerialize.jsonld#ActorQueryResultSerialize_default_bus"
    }), s = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-source-identify-hypermedia/^4.0.0/components/ActorQuerySourceIdentifyHypermedia.jsonld#ActorQuerySourceIdentifyHypermedia_default_bus"
    }), d = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-dereference/^4.0.0/components/ActorDereference.jsonld#ActorDereference_default_bus"
    }), l = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-dereference-rdf/^4.0.0/components/ActorDereferenceRdf.jsonld#ActorDereferenceRdf_default_bus"
    }), f = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join-entries-sort/^4.0.0/components/ActorRdfJoinEntriesSort.jsonld#ActorRdfJoinEntriesSort_default_bus"
    }), h = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join-selectivity/^4.0.0/components/ActorRdfJoinSelectivity.jsonld#ActorRdfJoinSelectivity_default_bus"
    }), p = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-metadata/^4.0.0/components/ActorRdfMetadata.jsonld#ActorRdfMetadata_default_bus"
    }), b = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-metadata-accumulate/^4.0.0/components/ActorRdfMetadataAccumulate.jsonld#ActorRdfMetadataAccumulate_default_bus"
    }), _ = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-metadata-extract/^4.0.0/components/ActorRdfMetadataExtract.jsonld#ActorRdfMetadataExtract_default_bus"
    }), y = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-parse/^4.0.0/components/ActorRdfParse.jsonld#ActorRdfParse_default_bus"
    }), m = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-parse-html/^4.0.0/components/ActorRdfParseHtml.jsonld#ActorRdfParseHtml_default_bus"
    }), g = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-hypermedia-links/^4.0.0/components/ActorRdfResolveHypermediaLinks.jsonld#ActorRdfResolveHypermediaLinks_default_bus"
    }), T = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-hypermedia-links-queue/^4.0.0/components/ActorRdfResolveHypermediaLinksQueue.jsonld#ActorRdfResolveHypermediaLinksQueue_default_bus"
    }), v = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-serialize/^4.0.0/components/ActorRdfSerialize.jsonld#ActorRdfSerialize_default_bus"
    }), E = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-update-hypermedia/^4.0.0/components/ActorRdfUpdateHypermedia.jsonld#ActorRdfUpdateHypermedia_default_bus"
    }), R = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-update-quads/^4.0.0/components/ActorRdfUpdateQuads.jsonld#ActorRdfUpdateQuads_default_bus"
    }), L = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-bindings-aggregator-factory/^4.0.0/components/ActorBindingsAggregatorFactory.jsonld#ActorBindingsAggregatorFactory_default_bus"
    }), A = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-expression-evaluator-factory/^4.0.0/components/ActorExpressionEvaluatorFactory.jsonld#ActorExpressionEvaluatorFactory_default_bus"
    }), w = new (Ae()).BusFunctionFactory({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-function-factory/^4.0.0/components/ActorFunctionFactory.jsonld#ActorFunctionFactory_default_bus"
    }), S = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http/^4.0.0/components/ActorHttp.jsonld#ActorHttp_default_bus"
    }), O = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http/^4.0.0/components/ActorHttp.jsonld#ActorHttp_fallback_bus"
    }), x = new (Ht()).BusQueryOperation({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-operation/^4.0.0/components/ActorQueryOperation.jsonld#ActorQueryOperation_default_bus"
    }), F = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-process/^4.0.0/components/ActorQueryProcess.jsonld#ActorQueryProcess_default_bus"
    }), j = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-source-identify/^4.0.0/components/ActorQuerySourceIdentify.jsonld#ActorQuerySourceIdentify_default_bus"
    }), q = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join/^4.0.0/components/ActorRdfJoin.jsonld#ActorRdfJoin_default_bus"
    }), Q = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-term-comparator-factory/^4.0.0/components/ActorTermComparatorFactory.jsonld#ActorTermComparatorFactory_default_bus"
    }), G = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http-invalidate/^4.0.0/components/ActorHttpInvalidate.jsonld#ActorHttpInvalidate_default_bus"
    }), K = new (_e()).Bus({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-merge-bindings-context/^4.0.0/components/ActorMergeBindingsContext.jsonld#ActorMergeBindingsContext_default_bus"
    });
    new (nie()).ActorContextPreprocessConvertShortcuts({
      contextKeyShortcuts: { baseIRI: "@comunica/actor-init-query:baseIRI", dataFactory: "@comunica/actor-init-query:dataFactory", datetime: "@comunica/actor-http-memento:datetime", destination: "@comunica/bus-rdf-update-quads:destination", distinctConstruct: "@comunica/actor-init-query:distinctConstruct", explain: "@comunica/actor-init-query:explain", extensionFunctionCreator: "@comunica/actor-init-query:extensionFunctionCreator", extensionFunctions: "@comunica/actor-init-query:extensionFunctions", fetch: "@comunica/bus-http:fetch", functionArgumentsCache: "@comunica/actor-init-query:functionArgumentsCache", httpAuth: "@comunica/bus-http:auth", httpBodyTimeout: "@comunica/bus-http:http-body-timeout", httpIncludeCredentials: "@comunica/bus-http:include-credentials", httpProxyHandler: "@comunica/actor-http-proxy:httpProxyHandler", httpRetryCount: "@comunica/bus-http:http-retry-count", httpRetryDelayFallback: "@comunica/bus-http:http-retry-delay-fallback", httpRetryDelayLimit: "@comunica/bus-http:http-retry-delay-limit", httpTimeout: "@comunica/bus-http:http-timeout", initialBindings: "@comunica/actor-init-query:initialBindings", invalidateCache: "@comunica/actor-init-query:invalidateCache", lenient: "@comunica/actor-init-query:lenient", log: "@comunica/core:log", queryFormat: "@comunica/actor-init-query:queryFormat", queryTimestamp: "@comunica/actor-init-query:queryTimestamp", queryTimestampHighResolution: "@comunica/actor-init-query:queryTimestampHighResolution", readOnly: "@comunica/bus-query-operation:readOnly", recoverBrokenLinks: "@comunica/bus-http-wayback:recover-broken-links", sources: "@comunica/actor-init-query:querySourcesUnidentified", traverse: "@comunica/bus-query-source-identify:traverse", unionDefaultGraph: "@comunica/bus-query-operation:unionDefaultGraph" },
      name: "urn:comunica:default:context-preprocess/actors#convert-shortcuts",
      bus: a,
      busFailMessage: "Context preprocessing failed"
    }), new (aie()).ActorContextPreprocessSetDefaults({
      logger: r,
      name: "urn:comunica:default:context-preprocess/actors#set-defaults",
      bus: a,
      busFailMessage: "Context preprocessing failed"
    }), new (oie()).ActorContextPreprocessSourceToDestination({
      name: "urn:comunica:default:context-preprocess/actors#source-to-destination",
      bus: a,
      busFailMessage: "Context preprocessing failed"
    });
    const U = new (tW()).ActorContextPreprocessQuerySourceSkolemize({
      name: "urn:comunica:default:context-preprocess/actors#query-source-skolemize",
      bus: a,
      busFailMessage: "Context preprocessing failed"
    }), ae = new (WF()).MediatorCombinePipeline({
      name: "urn:comunica:default:context-preprocess/mediators#main",
      bus: a
    });
    new (_ie()).ActorHashBindingsMurmur({
      name: "urn:comunica:default:hash-bindings/actors#murmur",
      bus: t,
      busFailMessage: "Failed to obtaining hash functions for bindings"
    });
    const ye = new (xr()).MediatorRace({
      name: "urn:comunica:default:hash-bindings/mediators#main",
      bus: t
    });
    new (wie()).ActorHashQuadsMurmur({
      name: "urn:comunica:default:hash-quads/actors#murmur",
      bus: e,
      busFailMessage: "Failed to obtaining hash functions for quads"
    }), new (Eie()).ActorOptimizeQueryOperationRewriteCopy({
      name: "urn:comunica:default:optimize-query-operation/actors#rewrite-copy",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize"
    }), new (xie()).ActorOptimizeQueryOperationRewriteMove({
      name: "urn:comunica:default:optimize-query-operation/actors#rewrite-move",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize"
    }), new (Rie()).ActorOptimizeQueryOperationRewriteAdd({
      name: "urn:comunica:default:optimize-query-operation/actors#rewrite-add",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize"
    });
    const pe = new (jie()).ActorOptimizeQueryOperationGroupSources({
      name: "urn:comunica:default:optimize-query-operation/actors#group-sources",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize"
    });
    new (Cie()).ActorOptimizeQueryOperationConstructDistinct({
      name: "urn:comunica:default:optimize-query-operation/actors#construct-distinct",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize"
    });
    const ee = new (WF()).MediatorCombinePipeline({
      filterFailures: !0,
      name: "urn:comunica:default:optimize-query-operation/mediators#main",
      bus: n
    });
    new ($ie()).ActorQueryParseSparql({
      prefixes: { dbpedia: "http://dbpedia.org/resource/", "dbpedia-owl": "http://dbpedia.org/ontology/", dbpprop: "http://dbpedia.org/property/", dc: "http://purl.org/dc/terms/", dc11: "http://purl.org/dc/elements/1.1/", dcterms: "http://purl.org/dc/terms/", foaf: "http://xmlns.com/foaf/0.1/", geo: "http://www.w3.org/2003/01/geo/wgs84_pos#", owl: "http://www.w3.org/2002/07/owl#", rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#", rdfs: "http://www.w3.org/2000/01/rdf-schema#", schema: "http://schema.org/", skos: "http://www.w3.org/2008/05/skos#", xsd: "http://www.w3.org/2001/XMLSchema#" },
      name: "urn:comunica:default:query-parse/actors#sparql",
      bus: i,
      busFailMessage: 'Query parsing failed: none of the configured parsers were able to the query "${action.query}"'
    }), new (bue()).ActorQueryParseGraphql({
      name: "urn:comunica:default:query-parse/actors#graphql",
      bus: i,
      busFailMessage: 'Query parsing failed: none of the configured parsers were able to the query "${action.query}"'
    });
    const Te = new (xr()).MediatorRace({
      name: "urn:comunica:default:query-parse/mediators#main",
      bus: i
    });
    new (xue()).ActorQueryResultSerializeJson({
      mediaTypePriorities: { "application/json": 1 },
      mediaTypeFormats: { "application/json": "https://comunica.linkeddatafragments.org/#results_JSON" },
      name: "urn:comunica:default:query-result-serialize/actors#json",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Rue()).ActorQueryResultSerializeSimple({
      mediaTypePriorities: { simple: 0.9 },
      mediaTypeFormats: { simple: "https://comunica.linkeddatafragments.org/#results_simple" },
      name: "urn:comunica:default:query-result-serialize/actors#simple",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Nue()).ActorQueryResultSerializeSparqlCsv({
      mediaTypePriorities: { "text/csv": 0.75 },
      mediaTypeFormats: { "text/csv": "http://www.w3.org/ns/formats/SPARQL_Results_CSV" },
      name: "urn:comunica:default:query-result-serialize/actors#csv",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Lue()).ActorQueryResultSerializeSparqlTsv({
      mediaTypePriorities: { "text/tab-separated-values": 0.75 },
      mediaTypeFormats: { "text/tab-separated-values": "http://www.w3.org/ns/formats/SPARQL_Results_TSV" },
      name: "urn:comunica:default:query-result-serialize/actors#sparql-tsv",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Cue()).ActorQueryResultSerializeSparqlXml({
      mediaTypePriorities: { "application/sparql-results+xml": 0.8 },
      mediaTypeFormats: { "application/sparql-results+xml": "http://www.w3.org/ns/formats/SPARQL_Results_XML" },
      name: "urn:comunica:default:query-result-serialize/actors#sparql-xml",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Bue()).ActorQueryResultSerializeTable({
      columnWidth: 50,
      mediaTypePriorities: { table: 0.6 },
      mediaTypeFormats: { table: "https://comunica.linkeddatafragments.org/#results_table" },
      name: "urn:comunica:default:query-result-serialize/actors#table",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Kue()).ActorQueryResultSerializeTree({
      mediaTypePriorities: { tree: 0.5 },
      mediaTypeFormats: { tree: "https://comunica.linkeddatafragments.org/#results_tree" },
      name: "urn:comunica:default:query-result-serialize/actors#tree",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    });
    const we = new (xr()).MediatorRace({
      name: "urn:comunica:default:query-result-serialize/mediators#serialize",
      bus: c
    }), Oe = new (Ra()).MediatorCombineUnion({
      field: "mediaTypes",
      name: "urn:comunica:default:query-result-serialize/mediators#mediaType",
      bus: c
    }), be = new (Ra()).MediatorCombineUnion({
      field: "mediaTypeFormats",
      name: "urn:comunica:default:query-result-serialize/mediators#mediaTypeFormat",
      bus: c
    }), he = new (m0()).MediatorNumber({
      field: "filterFactor",
      type: "max",
      ignoreFailures: !0,
      name: "urn:comunica:default:query-source-identify-hypermedia/mediators#main",
      bus: s
    }), V = new (roe()).ActorDereferenceFallback({
      name: "urn:comunica:default:dereference/actors#fallback",
      bus: d,
      busFailMessage: "Dereferencing failed: none of the configured actors were able to handle ${action.url}"
    }), N = new (xr()).MediatorRace({
      name: "urn:comunica:default:dereference/mediators#main",
      bus: d
    }), M = new (xr()).MediatorRace({
      name: "urn:comunica:default:dereference-rdf/mediators#main",
      bus: l
    });
    new (aoe()).ActorRdfJoinEntriesSortCardinality({
      name: "urn:comunica:default:rdf-join-entries-sort/actors#cardinality",
      bus: f,
      busFailMessage: "Sorting join entries failed: none of the configured actors were able to sort"
    });
    const I = new (m0()).MediatorNumber({
      field: "accuracy",
      type: "max",
      ignoreFailures: !0,
      name: "urn:comunica:default:rdf-join-entries-sort/mediators#main",
      bus: f
    });
    new (coe()).ActorRdfJoinSelectivityVariableCounting({
      name: "urn:comunica:default:rdf-join-selectivity/actors#variable-counting",
      bus: h,
      busFailMessage: "Determining join selectivity failed: none of the configured actors were able to calculate selectivities"
    });
    const P = new (m0()).MediatorNumber({
      field: "accuracy",
      type: "max",
      ignoreFailures: !0,
      name: "urn:comunica:default:rdf-join-selectivity/mediators#main",
      bus: h
    });
    new (foe()).ActorRdfMetadataPrimaryTopic({
      metadataToData: !1,
      dataToMetadataOnInvalidMetadataGraph: !0,
      name: "urn:comunica:default:rdf-metadata/actors#primary-topic",
      bus: p,
      busFailMessage: "Metadata splicing failed: none of the configured actors were able to splice metadata from ${action.url}"
    }), new (poe()).ActorRdfMetadataAll({
      name: "urn:comunica:default:rdf-metadata/actors#all",
      bus: p,
      busFailMessage: "Metadata splicing failed: none of the configured actors were able to splice metadata from ${action.url}"
    });
    const B = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-metadata/mediators#main",
      bus: p
    });
    new (_oe()).ActorRdfMetadataAccumulateCardinality({
      name: "urn:comunica:default:rdf-metadata-accumulate/actors#cardinality",
      bus: b,
      busFailMessage: "Metadata accumulation failed: none of the configured actors were able to accumulate metadata in mode ${action.mode}"
    }), new (moe()).ActorRdfMetadataAccumulatePageSize({
      name: "urn:comunica:default:rdf-metadata-accumulate/actors#pagesize",
      bus: b,
      busFailMessage: "Metadata accumulation failed: none of the configured actors were able to accumulate metadata in mode ${action.mode}"
    }), new (Toe()).ActorRdfMetadataAccumulateRequestTime({
      name: "urn:comunica:default:rdf-metadata-accumulate/actors#requesttime",
      bus: b,
      busFailMessage: "Metadata accumulation failed: none of the configured actors were able to accumulate metadata in mode ${action.mode}"
    });
    const z = new (Ra()).MediatorCombineUnion({
      field: "metadata",
      name: "urn:comunica:default:rdf-metadata-accumulate/mediators#main",
      bus: b
    });
    new (Eoe()).ActorRdfMetadataExtractHydraControls({
      name: "urn:comunica:default:rdf-metadata-extract/actors#hydra-controls",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (xoe()).ActorRdfMetadataExtractHydraCount({
      predicates: [
        "http://www.w3.org/ns/hydra/core#totalItems",
        "http://rdfs.org/ns/void#triples"
      ],
      name: "urn:comunica:default:rdf-metadata-extract/actors#hydra-count",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Roe()).ActorRdfMetadataExtractHydraPagesize({
      predicates: [
        "http://www.w3.org/ns/hydra/core#itemsPerPage"
      ],
      name: "urn:comunica:default:rdf-metadata-extract/actors#hydra-pagesize",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Noe()).ActorRdfMetadataExtractRequestTime({
      name: "urn:comunica:default:rdf-metadata-extract/actors#request-time",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Doe()).ActorRdfMetadataExtractAllowHttpMethods({
      name: "urn:comunica:default:rdf-metadata-extract/actors#allow-http-methods",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (joe()).ActorRdfMetadataExtractPutAccepted({
      name: "urn:comunica:default:rdf-metadata-extract/actors#put-accepted",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Coe()).ActorRdfMetadataExtractPatchSparqlUpdate({
      name: "urn:comunica:default:rdf-metadata-extract/actors#patch-sparql-update",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Boe()).ActorRdfMetadataExtractSparqlService({
      inferHttpsEndpoint: !0,
      name: "urn:comunica:default:rdf-metadata-extract/actors#sparql-service",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    }), new (Voe()).ActorRdfMetadataExtractVoid({
      name: "urn:comunica:default:rdf-metadata-extract/actors#void",
      bus: _,
      busFailMessage: "Metadata extraction failed: none of the configured actors were able to extract metadata from ${action.url}"
    });
    const H = new (Ra()).MediatorCombineUnion({
      filterFailures: !0,
      field: "metadata",
      name: "urn:comunica:default:rdf-metadata-extract/mediators#main",
      bus: _
    });
    new (pse()).ActorRdfParseN3({
      mediaTypePriorities: { "application/n-quads": 1, "application/n-triples": 0.8, "application/trig": 0.95, "text/n3": 0.35, "text/turtle": 0.6 },
      mediaTypeFormats: { "application/n-quads": "http://www.w3.org/ns/formats/N-Quads", "application/n-triples": "http://www.w3.org/ns/formats/N-Triples", "application/trig": "http://www.w3.org/ns/formats/TriG", "text/n3": "http://www.w3.org/ns/formats/N3", "text/turtle": "http://www.w3.org/ns/formats/Turtle" },
      priorityScale: 1,
      name: "urn:comunica:default:rdf-parse/actors#n3",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (Ase()).ActorRdfParseRdfXml({
      mediaTypePriorities: { "application/rdf+xml": 1 },
      mediaTypeFormats: { "application/rdf+xml": "http://www.w3.org/ns/formats/RDF_XML" },
      priorityScale: 0.5,
      name: "urn:comunica:default:rdf-parse/actors#rdfxml",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (Gse()).ActorRdfParseXmlRdfa({
      mediaTypePriorities: { "application/xml": 1, "image/svg+xml": 1, "text/xml": 1 },
      mediaTypeFormats: { "application/xml": "http://www.w3.org/ns/formats/RDFa", "image/svg+xml": "http://www.w3.org/ns/formats/RDFa", "text/xml": "http://www.w3.org/ns/formats/RDFa" },
      priorityScale: 0.3,
      name: "urn:comunica:default:rdf-parse/actors#xmlrdfa",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (Kse()).ActorRdfParseShaclc({
      mediaTypePriorities: { "text/shaclc": 1, "text/shaclc-ext": 0.5 },
      mediaTypeFormats: { "text/shaclc": "http://www.w3.org/ns/formats/Shaclc", "text/shaclc-ext": "http://www.w3.org/ns/formats/ShaclcExtended" },
      priorityScale: 0.1,
      name: "urn:comunica:default:rdf-parse/actors#shaclc",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    });
    const J = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-parse/mediators#parse",
      bus: y
    }), k = new (Ra()).MediatorCombineUnion({
      field: "mediaTypes",
      name: "urn:comunica:default:rdf-parse/mediators#mediaType",
      bus: y
    });
    new (Zse()).ActorRdfParseHtml({
      busRdfParseHtml: m,
      mediaTypePriorities: { "application/xhtml+xml": 0.9, "text/html": 1 },
      mediaTypeFormats: { "application/xhtml+xml": "http://www.w3.org/ns/formats/HTML", "text/html": "http://www.w3.org/ns/formats/HTML" },
      priorityScale: 0.2,
      name: "urn:comunica:default:rdf-parse/actors#html",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (fce()).ActorRdfParseHtmlMicrodata({
      name: "urn:comunica:default:rdf-parse-html/actors#microdata",
      bus: m,
      busFailMessage: "RDF HTML parsing failed: none of the configured parsers were able to parse RDF in HTML"
    }), new (pce()).ActorRdfParseHtmlRdfa({
      name: "urn:comunica:default:rdf-parse-html/actors#rdfa",
      bus: m,
      busFailMessage: "RDF HTML parsing failed: none of the configured parsers were able to parse RDF in HTML"
    }), new (gce()).ActorRdfResolveHypermediaLinksNext({
      name: "urn:comunica:default:rdf-resolve-hypermedia-links/actors#next",
      bus: g,
      busFailMessage: "Hypermedia link resolution failed: none of the configured actors were able to resolve links from metadata"
    });
    const W = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-resolve-hypermedia-links/mediators#main",
      bus: g
    });
    new (Ace()).ActorRdfResolveHypermediaLinksQueueFifo({
      name: "urn:comunica:default:rdf-resolve-hypermedia-links-queue/actors#fifo",
      bus: T,
      busFailMessage: "Link queue creation failed: none of the configured actors were able to create a link queue starting from ${action.firstUrl}"
    });
    const le = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-resolve-hypermedia-links-queue/mediators#main",
      bus: T
    });
    new (Ice()).ActorRdfSerializeN3({
      mediaTypePriorities: { "application/n-quads": 1, "application/n-triples": 0.8, "application/trig": 0.95, "text/n3": 0.35, "text/turtle": 0.6 },
      mediaTypeFormats: { "application/n-quads": "http://www.w3.org/ns/formats/N-Quads", "application/n-triples": "http://www.w3.org/ns/formats/N-Triples", "application/trig": "http://www.w3.org/ns/formats/TriG", "text/n3": "http://www.w3.org/ns/formats/N3", "text/turtle": "http://www.w3.org/ns/formats/Turtle" },
      name: "urn:comunica:default:rdf-serialize/actors#n3",
      bus: v,
      busFailMessage: "RDF serialization failed: none of the configured serializers were able to handle media type ${action.handleMediaType}"
    }), new (Mce()).ActorRdfSerializeJsonLd({
      jsonStringifyIndentSpaces: 2,
      mediaTypePriorities: { "application/ld+json": 1 },
      mediaTypeFormats: { "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD" },
      priorityScale: 0.9,
      name: "urn:comunica:default:rdf-serialize/actors#jsonld",
      bus: v,
      busFailMessage: "RDF serialization failed: none of the configured serializers were able to handle media type ${action.handleMediaType}"
    }), new (Zce()).ActorRdfSerializeShaclc({
      mediaTypePriorities: { "text/shaclc": 1, "text/shaclc-ext": 0.5 },
      mediaTypeFormats: { "text/shaclc": "http://www.w3.org/ns/formats/Shaclc", "text/shaclc-ext": "http://www.w3.org/ns/formats/ShaclcExtended" },
      priorityScale: 0.1,
      name: "urn:comunica:default:rdf-serialize/actors#shaclc",
      bus: v,
      busFailMessage: "RDF serialization failed: none of the configured serializers were able to handle media type ${action.handleMediaType}"
    });
    const fe = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-serialize/mediators#serialize",
      bus: v
    }), me = new (Ra()).MediatorCombineUnion({
      field: "mediaTypes",
      name: "urn:comunica:default:rdf-serialize/mediators#mediaType",
      bus: v
    }), Ne = new (Ra()).MediatorCombineUnion({
      field: "mediaTypeFormats",
      name: "urn:comunica:default:rdf-serialize/mediators#mediaTypeFormat",
      bus: v
    }), xe = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-update-hypermedia/mediators#main",
      bus: E
    });
    new (ade()).ActorRdfUpdateQuadsRdfJsStore({
      name: "urn:comunica:default:rdf-update-quads/actors#rdfjs-store",
      bus: R,
      busFailMessage: "RDF updating failed: none of the configured actors were able to handle an update"
    });
    const ue = new (xr()).MediatorRace({
      name: "urn:comunica:default:rdf-update-quads/mediators#main",
      bus: R
    }), $ = new (xr()).MediatorRace({
      name: "urn:comunica:default:bindings-aggregator-factory/mediators#main",
      bus: L
    }), D = new (xr()).MediatorRace({
      name: "urn:comunica:default:expression-evaluator-factory/mediators#main",
      bus: A
    });
    new (sde()).ActorFunctionFactoryExpressionBnode({
      name: "urn:comunica:default:function-factory/actors#expression-function-bnode",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (lde()).ActorFunctionFactoryExpressionBound({
      name: "urn:comunica:default:function-factory/actors#expression-function-bound",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (pde()).ActorFunctionFactoryExpressionCoalesce({
      name: "urn:comunica:default:function-factory/actors#expression-function-coalesce",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (_de()).ActorFunctionFactoryExpressionConcat({
      name: "urn:comunica:default:function-factory/actors#expression-function-concat",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (vde()).ActorFunctionFactoryExpressionExtensions({
      name: "urn:comunica:default:function-factory/actors#expression-function-extensions",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Sde()).ActorFunctionFactoryExpressionIf({
      name: "urn:comunica:default:function-factory/actors#expression-function-if",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ode()).ActorFunctionFactoryExpressionLogicalAnd({
      name: "urn:comunica:default:function-factory/actors#expression-function-logical-and",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Rde()).ActorFunctionFactoryExpressionLogicalOr({
      name: "urn:comunica:default:function-factory/actors#expression-function-logical-or",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Pde()).ActorFunctionFactoryExpressionSameTerm({
      name: "urn:comunica:default:function-factory/actors#expression-function-same-term",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (jde()).ActorFunctionFactoryTermAbs({
      name: "urn:comunica:default:function-factory/actors#term-function-abs",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Bde()).ActorFunctionFactoryTermAddition({
      name: "urn:comunica:default:function-factory/actors#term-function-addition",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Vde()).ActorFunctionFactoryTermCeil({
      name: "urn:comunica:default:function-factory/actors#term-function-ceil",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Gde()).ActorFunctionFactoryTermContains({
      name: "urn:comunica:default:function-factory/actors#term-function-contains",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Xde()).ActorFunctionFactoryTermDatatype({
      name: "urn:comunica:default:function-factory/actors#term-function-datatype",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Wde()).ActorFunctionFactoryTermDay({
      name: "urn:comunica:default:function-factory/actors#term-function-day",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ele()).ActorFunctionFactoryTermDivision({
      name: "urn:comunica:default:function-factory/actors#term-function-division",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (nle()).ActorFunctionFactoryTermEncodeForUri({
      name: "urn:comunica:default:function-factory/actors#term-function-encode-for-uri",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ule()).ActorFunctionFactoryTermEquality({
      name: "urn:comunica:default:function-factory/actors#term-function-equality",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (cle()).ActorFunctionFactoryTermFloor({
      name: "urn:comunica:default:function-factory/actors#term-function-floor",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (fle()).ActorFunctionFactoryTermHours({
      name: "urn:comunica:default:function-factory/actors#term-function-hours",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ble()).ActorFunctionFactoryTermIri({
      name: "urn:comunica:default:function-factory/actors#term-function-iri",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (gle()).ActorFunctionFactoryTermIsBlank({
      name: "urn:comunica:default:function-factory/actors#term-function-is-blank",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Tle()).ActorFunctionFactoryTermIsIri({
      name: "urn:comunica:default:function-factory/actors#term-function-is-iri",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ale()).ActorFunctionFactoryTermIsLiteral({
      name: "urn:comunica:default:function-factory/actors#term-function-is-literal",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (xle()).ActorFunctionFactoryTermIsNumeric({
      name: "urn:comunica:default:function-factory/actors#term-function-is-numeric",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Fle()).ActorFunctionFactoryTermIsTriple({
      name: "urn:comunica:default:function-factory/actors#term-function-is-triple",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Dle()).ActorFunctionFactoryTermLang({
      name: "urn:comunica:default:function-factory/actors#term-function-lang",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Mle()).ActorFunctionFactoryTermLangmatches({
      name: "urn:comunica:default:function-factory/actors#term-function-langmatches",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ble()).ActorFunctionFactoryTermLcase({
      name: "urn:comunica:default:function-factory/actors#term-function-lcase",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Qle()).ActorFunctionFactoryTermMd5({
      name: "urn:comunica:default:function-factory/actors#term-function-md5",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (zle()).ActorFunctionFactoryTermMinutes({
      name: "urn:comunica:default:function-factory/actors#term-function-minutes",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Jle()).ActorFunctionFactoryTermMonth({
      name: "urn:comunica:default:function-factory/actors#term-function-month",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Yle()).ActorFunctionFactoryTermMultiplication({
      name: "urn:comunica:default:function-factory/actors#term-function-multiplication",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (tfe()).ActorFunctionFactoryTermNot({
      name: "urn:comunica:default:function-factory/actors#term-function-not",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ife()).ActorFunctionFactoryTermNow({
      name: "urn:comunica:default:function-factory/actors#term-function-now",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ofe()).ActorFunctionFactoryTermObject({
      name: "urn:comunica:default:function-factory/actors#term-function-object",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (dfe()).ActorFunctionFactoryTermPredicate({
      name: "urn:comunica:default:function-factory/actors#term-function-predicate",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (hfe()).ActorFunctionFactoryTermRand({
      name: "urn:comunica:default:function-factory/actors#term-function-rand",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (PY()).ActorFunctionFactoryTermRegex({
      name: "urn:comunica:default:function-factory/actors#term-function-regex",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (_fe()).ActorFunctionFactoryTermReplace({
      name: "urn:comunica:default:function-factory/actors#term-function-replace",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (vfe()).ActorFunctionFactoryTermRound({
      name: "urn:comunica:default:function-factory/actors#term-function-round",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Sfe()).ActorFunctionFactoryTermSeconds({
      name: "urn:comunica:default:function-factory/actors#term-function-seconds",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ofe()).ActorFunctionFactoryTermSha1({
      name: "urn:comunica:default:function-factory/actors#term-function-sha1",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Rfe()).ActorFunctionFactoryTermSha256({
      name: "urn:comunica:default:function-factory/actors#term-function-sha256",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Pfe()).ActorFunctionFactoryTermSha384({
      name: "urn:comunica:default:function-factory/actors#term-function-sha384",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (jfe()).ActorFunctionFactoryTermSha512({
      name: "urn:comunica:default:function-factory/actors#term-function-sha512",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (qfe()).ActorFunctionFactoryTermStrAfter({
      name: "urn:comunica:default:function-factory/actors#term-function-str-after",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ufe()).ActorFunctionFactoryTermStrBefore({
      name: "urn:comunica:default:function-factory/actors#term-function-str-before",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Hfe()).ActorFunctionFactoryTermStrDt({
      name: "urn:comunica:default:function-factory/actors#term-function-str-dt",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (kfe()).ActorFunctionFactoryTermStrEnds({
      name: "urn:comunica:default:function-factory/actors#term-function-str-ends",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Kfe()).ActorFunctionFactoryTermStrLang({
      name: "urn:comunica:default:function-factory/actors#term-function-str-lang",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Zfe()).ActorFunctionFactoryTermStrLen({
      name: "urn:comunica:default:function-factory/actors#term-function-str-len",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (r0e()).ActorFunctionFactoryTermStrStarts({
      name: "urn:comunica:default:function-factory/actors#term-function-str-starts",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (g0e()).ActorFunctionFactoryTermStrUuid({
      name: "urn:comunica:default:function-factory/actors#term-function-str-uuid",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (T0e()).ActorFunctionFactoryTermStr({
      name: "urn:comunica:default:function-factory/actors#term-function-str",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (A0e()).ActorFunctionFactoryTermSubStr({
      name: "urn:comunica:default:function-factory/actors#term-function-sub-str",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (x0e()).ActorFunctionFactoryTermSubject({
      name: "urn:comunica:default:function-factory/actors#term-function-subject",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (F0e()).ActorFunctionFactoryTermSubtraction({
      name: "urn:comunica:default:function-factory/actors#term-function-subtraction",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (D0e()).ActorFunctionFactoryTermTimezone({
      name: "urn:comunica:default:function-factory/actors#term-function-timezone",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (M0e()).ActorFunctionFactoryTermTriple({
      name: "urn:comunica:default:function-factory/actors#term-function-triple",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (B0e()).ActorFunctionFactoryTermTz({
      name: "urn:comunica:default:function-factory/actors#term-function-tz",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (V0e()).ActorFunctionFactoryTermUcase({
      name: "urn:comunica:default:function-factory/actors#term-function-ucase",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (G0e()).ActorFunctionFactoryTermUnaryMinus({
      name: "urn:comunica:default:function-factory/actors#term-function-unary-minus",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (X0e()).ActorFunctionFactoryTermUnaryPlus({
      name: "urn:comunica:default:function-factory/actors#term-function-unary-plus",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (W0e()).ActorFunctionFactoryTermUuid({
      name: "urn:comunica:default:function-factory/actors#term-function-uuid",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ehe()).ActorFunctionFactoryTermXsdToBoolean({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-boolean",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (nhe()).ActorFunctionFactoryTermXsdToDate({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-date",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (uhe()).ActorFunctionFactoryTermXsdToDatetime({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-datetime",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (che()).ActorFunctionFactoryTermXsdToDayTimeDuration({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-day-time-duration",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (fhe()).ActorFunctionFactoryTermXsdToDecimal({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-decimal",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (bhe()).ActorFunctionFactoryTermXsdToDouble({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-double",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (ghe()).ActorFunctionFactoryTermXsdToDuration({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-duration",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (The()).ActorFunctionFactoryTermXsdToFloat({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-float",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Ahe()).ActorFunctionFactoryTermXsdToInteger({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-integer",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (xhe()).ActorFunctionFactoryTermXsdToString({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-string",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Fhe()).ActorFunctionFactoryTermXsdToTime({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-time",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Dhe()).ActorFunctionFactoryTermXsdToYearMonthDuration({
      name: "urn:comunica:default:function-factory/actors#term-function-xsd-to-year-month-duration",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (Mhe()).ActorFunctionFactoryTermYear({
      name: "urn:comunica:default:function-factory/actors#term-function-year",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    });
    const C = new (xr()).MediatorRace({
      name: "urn:comunica:default:function-factory/mediators#main",
      bus: w
    }), X = new (Hhe()).ActorHttpFetch({
      agentOptions: { keepAlive: !0, maxSockets: 5 },
      name: "urn:comunica:default:http/actors#fetch",
      bus: S,
      busFailMessage: "HTTP request failed: none of the configured actors were able to handle ${action.input}"
    }), te = new (m0()).MediatorNumber({
      field: "time",
      type: "min",
      ignoreFailures: !0,
      name: "urn:comunica:default:http/mediators#no-fallback",
      bus: S
    }), de = new (m0()).MediatorNumber({
      field: "time",
      type: "min",
      ignoreFailures: !0,
      name: "urn:comunica:default:http/mediators#main",
      bus: O
    });
    new (zhe()).ActorQueryOperationSource({
      name: "urn:comunica:default:query-operation/actors#source",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    });
    const oe = new (m0()).MediatorNumber({
      field: "httpRequests",
      type: "min",
      ignoreFailures: !0,
      name: "urn:comunica:default:query-operation/mediators#main",
      bus: x
    }), De = new (xr()).MediatorRace({
      name: "urn:comunica:default:query-process/mediators#main",
      bus: F
    }), Ve = new (xr()).MediatorRace({
      name: "urn:comunica:default:query-source-identify/mediators#main",
      bus: j
    }), qe = new (Xhe()).MediatorJoinCoefficientsFixed({
      cpuWeight: 10,
      memoryWeight: 1,
      timeWeight: 2,
      ioWeight: 10,
      name: "urn:comunica:default:rdf-join/mediators#main",
      bus: q
    }), Ke = new (xr()).MediatorRace({
      name: "urn:comunica:default:term-comparator-factory/mediators#main",
      bus: Q
    }), Y = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-context-preprocess-query-source-identify/^4.0.0/components/ActorContextPreprocessQuerySourceIdentify.jsonld#IActorContextPreprocessQuerySourceIdentifyArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), Ee = new (Whe()).MediatorAll({
      name: "urn:comunica:default:http-invalidate/mediators#main",
      bus: G
    }), Ie = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-rdf-update-quads-hypermedia/^4.0.0/components/ActorRdfUpdateQuadsHypermedia.jsonld#IActorRdfUpdateQuadsHypermediaArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), Ue = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-http-retry/^4.0.0/components/ActorHttpRetry.jsonld#IActorHttpQueueArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), Le = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-http-limit-rate/^4.0.0/components/ActorHttpLimitRate.jsonld#IActorHttpLimitRateArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), tt = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-query-result-serialize-sparql-json/^4.0.0/components/ActionObserverHttp.jsonld#IActionObserverHttpArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), it = new (O0()).ActorHttpInvalidateListenable({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-query-result-serialize-stats/^4.0.0/components/ActionObserverHttp.jsonld#IActionObserverHttpArgs_default_invalidator",
      bus: G,
      busFailMessage: "HTTP invalidation failed: none of the configured actors were able to invalidate ${action.url}"
    }), Ye = new (Ra()).MediatorCombineUnion({
      field: "mergeHandlers",
      name: "urn:comunica:default:merge-bindings-context/mediators#main",
      bus: K
    });
    new (Zhe()).ActorRdfJoinEntriesSortSelectivity({
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join-entries-sort/actors#selectivity",
      bus: f,
      busFailMessage: "Sorting join entries failed: none of the configured actors were able to sort"
    }), new (upe()).ActorRdfJoinSingle({
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-single",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (spe()).ActorRdfJoinMultiEmpty({
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-multi-empty",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    });
    const ht = new (NU()).ActorRdfJoinHash({
      mediatorHashBindings: ye,
      canHandleUndefs: !1,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-hash-def",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), ne = new (NU()).ActorRdfJoinHash({
      mediatorHashBindings: ye,
      canHandleUndefs: !0,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-hash-undef",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), ie = new (mpe()).ActorRdfJoinSymmetricHash({
      mediatorHashBindings: ye,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-symmetric-hash",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), je = new (Tpe()).ActorRdfJoinNestedLoop({
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-nested-loop",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    });
    new (G6()).ActorRdfJoinOptionalHash({
      canHandleUndefs: !1,
      blocking: !1,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-hash-def-nonblocking",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (G6()).ActorRdfJoinOptionalHash({
      canHandleUndefs: !1,
      blocking: !0,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-hash-def-blocking",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (G6()).ActorRdfJoinOptionalHash({
      canHandleUndefs: !0,
      blocking: !1,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-hash-undef-nonblocking",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (G6()).ActorRdfJoinOptionalHash({
      canHandleUndefs: !0,
      blocking: !0,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-hash-undef-blocking",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (Epe()).ActorRdfJoinOptionalNestedLoop({
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-nested-loop",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (zU()).ActorRdfJoinMinusHash({
      canHandleUndefs: !1,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#minus-hash-def",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (zU()).ActorRdfJoinMinusHash({
      canHandleUndefs: !0,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#minus-hash-undef",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (Fpe()).ActorDereferenceRdfParse({
      mediatorDereference: N,
      mediatorParse: J,
      mediatorParseMediatypes: k,
      mediaMappings: { htm: "text/html", html: "text/html", json: "application/json", jsonld: "application/ld+json", n3: "text/n3", nq: "application/n-quads", nquads: "application/n-quads", nt: "application/n-triples", ntriples: "application/n-triples", owl: "application/rdf+xml", rdf: "application/rdf+xml", rdfxml: "application/rdf+xml", shaclc: "text/shaclc", shaclce: "text/shaclc-ext", shc: "text/shaclc", shce: "text/shaclc-ext", svg: "image/svg+xml", svgz: "image/svg+xml", trig: "application/trig", ttl: "text/turtle", turtle: "text/turtle", xht: "application/xhtml+xml", xhtml: "application/xhtml+xml", xml: "application/xml" },
      name: "urn:comunica:default:dereference-rdf/actors#parse",
      bus: l,
      busFailMessage: "RDF dereferencing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (Dpe()).ActorRdfParseHtmlScript({
      mediatorRdfParseMediatypes: k,
      mediatorRdfParseHandle: J,
      name: "urn:comunica:default:rdf-parse-html/actors#script",
      bus: m,
      busFailMessage: "RDF HTML parsing failed: none of the configured parsers were able to parse RDF in HTML"
    }), new (jpe()).ActorQueryResultSerializeRdf({
      mediatorRdfSerialize: fe,
      mediatorMediaTypeCombiner: me,
      mediatorMediaTypeFormatCombiner: Ne,
      name: "urn:comunica:default:query-result-serialize/actors#rdf",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (Bpe()).ActorBindingsAggregatorFactoryGroupConcat({
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#group-concat",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (Upe()).ActorBindingsAggregatorFactoryCount({
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#count",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (Qpe()).ActorBindingsAggregatorFactorySample({
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#sample",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (Gpe()).ActorBindingsAggregatorFactoryWildcardCount({
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#wildcard-count",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (kpe()).ActorBindingsAggregatorFactoryAverage({
      mediatorFunctionFactory: C,
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#average",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (Jpe()).ActorBindingsAggregatorFactorySum({
      mediatorFunctionFactory: C,
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#sum",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (Ype()).ActorFunctionFactoryExpressionIn({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#expression-function-in",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (t1e()).ActorFunctionFactoryExpressionNotIn({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#expression-function-not-in",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (i1e()).ActorFunctionFactoryTermGreaterThanEqual({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#term-function-greater-than-equal",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (o1e()).ActorFunctionFactoryTermGreaterThan({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#term-function-greater-than",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (d1e()).ActorFunctionFactoryTermInequality({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#term-function-inequality",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (h1e()).ActorFunctionFactoryTermLesserThanEqual({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#term-function-lesser-than-equal",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (y1e()).ActorFunctionFactoryTermLesserThan({
      mediatorFunctionFactory: C,
      name: "urn:comunica:default:function-factory/actors#term-function-lesser-than",
      bus: w,
      busFailMessage: "Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}"
    }), new (g1e()).ActorHttpWayback({
      mediatorHttp: te,
      name: "urn:comunica:default:http/actors#wayback",
      bus: O,
      busFailMessage: "HTTP request failed: none of the configured actors were able to handle ${action.input}"
    }), new (z1e()).ActorRdfParseJsonLd({
      mediatorHttp: de,
      mediaTypePriorities: { "application/json": 0.15, "application/ld+json": 1 },
      mediaTypeFormats: { "application/json": "http://www.w3.org/ns/formats/JSON-LD", "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD" },
      priorityScale: 0.9,
      name: "urn:comunica:default:rdf-parse/actors#jsonld",
      bus: y,
      busFailMessage: "RDF parsing failed: none of the configured parsers were able to handle the media type ${action.handle.mediaType} for ${action.handle.url}"
    }), new (J1e()).ActorRdfUpdateHypermediaPatchSparqlUpdate({
      mediatorHttp: de,
      name: "urn:comunica:default:rdf-update-hypermedia/actors#patch-sparql-update",
      bus: E,
      busFailMessage: "RDF hypermedia updating failed: none of the configured actors were able to handle an update for ${action.url}"
    }), new (W1e()).ActorRdfUpdateHypermediaPutLdp({
      mediatorHttp: de,
      mediatorRdfSerializeMediatypes: me,
      mediatorRdfSerialize: fe,
      name: "urn:comunica:default:rdf-update-hypermedia/actors#put-ldp",
      bus: E,
      busFailMessage: "RDF hypermedia updating failed: none of the configured actors were able to handle an update for ${action.url}"
    }), new (ibe()).ActorRdfUpdateHypermediaSparql({
      mediatorHttp: de,
      checkUrlSuffixSparql: !0,
      checkUrlSuffixUpdate: !0,
      name: "urn:comunica:default:rdf-update-hypermedia/actors#sparql",
      bus: E,
      busFailMessage: "RDF hypermedia updating failed: none of the configured actors were able to handle an update for ${action.url}"
    }), new (ube()).ActorQueryOperationAsk({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#ask",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (sbe()).ActorQueryOperationBgpJoin({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#bgp",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (yZ()).ActorQueryOperationConstruct({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#construct",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (bbe()).ActorQueryOperationDistinctIdentity({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#distinct",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (_be()).ActorQueryOperationExtend({
      mediatorExpressionEvaluatorFactory: D,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#extend",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (mbe()).ActorQueryOperationFilter({
      mediatorExpressionEvaluatorFactory: D,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#filter",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Tbe()).ActorQueryOperationFromQuad({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#from",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Sbe()).ActorQueryOperationProject({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#project",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Ebe()).ActorQueryOperationReducedHash({
      mediatorHashBindings: ye,
      cacheSize: 100,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#reduced",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (xbe()).ActorQueryOperationSlice({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#slice",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (wZ()).ActorQueryOperationUnion({
      mediatorRdfMetadataAccumulate: z,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#union",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Nbe()).ActorQueryOperationPathAlt({
      mediatorRdfMetadataAccumulate: z,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-alt",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Dbe()).ActorQueryOperationPathInv({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-inv",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (jbe()).ActorQueryOperationPathLink({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-link",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Cbe()).ActorQueryOperationPathNps({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-nps",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Bbe()).ActorQueryOperationClear({
      mediatorUpdateQuads: ue,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-clear",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Ube()).ActorQueryOperationUpdateCompositeUpdate({
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-composite",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Qbe()).ActorQueryOperationCreate({
      mediatorUpdateQuads: ue,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-create",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Gbe()).ActorQueryOperationDrop({
      mediatorUpdateQuads: ue,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-drop",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (kbe()).ActorQueryOperationLoad({
      mediatorUpdateQuads: ue,
      mediatorQuerySourceIdentify: Ve,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-load",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Jbe()).ActorQueryOperationJoin({
      mediatorJoin: qe,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#join",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Wbe()).ActorQueryOperationLeftJoin({
      mediatorJoin: qe,
      mediatorExpressionEvaluatorFactory: D,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#leftjoin",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (Zbe()).ActorQueryOperationMinus({
      mediatorJoin: qe,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#minus",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (tye()).ActorQueryOperationPathSeq({
      mediatorJoin: qe,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-seq",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    });
    const $e = new (nye()).ActorRdfJoinMultiSmallest({
      mediatorJoinEntriesSort: I,
      mediatorJoin: qe,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-multi-smallest",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    });
    new (aye()).ActorBindingsAggregatorFactoryMax({
      mediatorTermComparatorFactory: Ke,
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#max",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (oye()).ActorBindingsAggregatorFactoryMin({
      mediatorTermComparatorFactory: Ke,
      mediatorExpressionEvaluatorFactory: D,
      name: "urn:comunica:default:bindings-aggregator-factory/actors#min",
      bus: L,
      busFailMessage: "Creation of Aggregator failed: none of the configured actors were able to handle ${action.expr.aggregator}"
    }), new (dye()).ActorQueryOperationOrderBy({
      mediatorExpressionEvaluatorFactory: D,
      mediatorTermComparatorFactory: Ke,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#orderby",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    });
    const He = new (fye()).ActorOptimizeQueryOperationFilterPushdown({
      aggressivePushdown: !1,
      maxIterations: 10,
      splitConjunctive: !0,
      mergeConjunctive: !0,
      pushIntoLeftJoins: !0,
      pushEqualityIntoPatterns: !0,
      name: "urn:comunica:default:optimize-query-operation/actors#filter-pushdown",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        pe
      ]
    });
    new (pye()).ActorDereferenceHttp({
      mediatorHttp: de,
      maxAcceptHeaderLength: 1024,
      maxAcceptHeaderLengthBrowser: 128,
      name: "urn:comunica:default:dereference/actors#http",
      bus: d,
      busFailMessage: "Dereferencing failed: none of the configured actors were able to handle ${action.url}",
      beforeActors: [
        V
      ]
    });
    const At = new (_ye()).ActorHttpProxy({
      mediatorHttp: de,
      name: "urn:comunica:default:http/actors#proxy",
      bus: S,
      busFailMessage: "HTTP request failed: none of the configured actors were able to handle ${action.input}",
      beforeActors: [
        X
      ]
    });
    new (mye()).ActorContextPreprocessQuerySourceIdentify({
      cacheSize: 100,
      httpInvalidator: Y,
      mediatorQuerySourceIdentify: Ve,
      mediatorContextPreprocess: ae,
      name: "urn:comunica:default:context-preprocess/actors#query-source-identify",
      bus: a,
      busFailMessage: "Context preprocessing failed",
      beforeActors: [
        U
      ]
    });
    const Qe = new (DK()).ActorInitQuery({
      mediatorQueryProcess: De,
      mediatorQueryResultSerialize: we,
      mediatorQueryResultSerializeMediaTypeCombiner: Oe,
      mediatorQueryResultSerializeMediaTypeFormatCombiner: be,
      mediatorHttpInvalidate: Ee,
      defaultQueryInputFormat: "sparql",
      allowNoSources: !1,
      name: "urn:comunica:default:init/actors#query",
      bus: o,
      busFailMessage: "Initialization failed: none of the configured actors were to initialize"
    });
    new (Tye()).ActorRdfUpdateQuadsHypermedia({
      cacheSize: 100,
      httpInvalidator: Ie,
      mediatorDereferenceRdf: M,
      mediatorMetadata: B,
      mediatorMetadataExtract: H,
      mediatorRdfUpdateHypermedia: xe,
      name: "urn:comunica:default:rdf-update-quads/actors#hypermedia",
      bus: R,
      busFailMessage: "RDF updating failed: none of the configured actors were able to handle an update"
    });
    const bt = new (DG()).ActionObserverHttp({
      httpInvalidator: tt,
      observedActors: [
        "urn:comunica:default:http/actors#fetch"
      ],
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-query-result-serialize-sparql-json/^4.0.0/components/ActorQueryResultSerializeSparqlJson.jsonld#ActorQueryResultSerializeSparqlJson_default_observer",
      bus: S
    }), Ge = new (CG()).ActionObserverHttp({
      httpInvalidator: it,
      observedActors: [
        "urn:comunica:default:http/actors#fetch"
      ],
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-query-result-serialize-stats/^4.0.0/components/ActorQueryResultSerializeStats.jsonld#ActorQueryResultSerializeStats_default_observer",
      bus: S
    });
    new (Fye()).ActorQuerySourceIdentifyHypermediaQpf({
      mediatorMetadata: B,
      mediatorMetadataExtract: H,
      mediatorDereferenceRdf: M,
      mediatorMergeBindingsContext: Ye,
      subjectUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
      predicateUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
      objectUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
      graphUri: "http://www.w3.org/ns/sparql-service-description#graph",
      name: "urn:comunica:default:query-source-identify-hypermedia/actors#qpf",
      bus: s,
      busFailMessage: "Query source hypermedia identification failed: none of the configured actors were able to identify ${action.url}"
    }), new (Pye()).ActorQuerySourceIdentifyHypermediaSparql({
      mediatorHttp: de,
      mediatorMergeBindingsContext: Ye,
      checkUrlSuffix: !0,
      forceHttpGet: !1,
      cacheSize: 1024,
      forceSourceType: !1,
      bindMethod: "values",
      countTimeout: 3e3,
      cardinalityCountQueries: !0,
      cardinalityEstimateConstruction: !1,
      name: "urn:comunica:default:query-source-identify-hypermedia/actors#sparql",
      bus: s,
      busFailMessage: "Query source hypermedia identification failed: none of the configured actors were able to identify ${action.url}"
    }), new (Yye()).ActorQuerySourceIdentifyHypermediaNone({
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:query-source-identify-hypermedia/actors#none",
      bus: s,
      busFailMessage: "Query source hypermedia identification failed: none of the configured actors were able to identify ${action.url}"
    }), new (n_e()).ActorExpressionEvaluatorFactoryDefault({
      mediatorQueryOperation: oe,
      mediatorFunctionFactory: C,
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:expression-evaluator-factory/actors#default",
      bus: A,
      busFailMessage: "Creation of Expression Evaluator failed"
    }), new (u_e()).ActorQueryOperationGroup({
      mediatorMergeBindingsContext: Ye,
      mediatorBindingsAggregatorFactory: $,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#group",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (s_e()).ActorQueryOperationNop({
      mediatorMergeBindingsContext: Ye,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#nop",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (d_e()).ActorQueryOperationService({
      forceSparqlEndpoint: !1,
      mediatorMergeBindingsContext: Ye,
      mediatorQuerySourceIdentify: Ve,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#service",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (f_e()).ActorQueryOperationValues({
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:query-operation/actors#values",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (p_e()).ActorQueryOperationPathOneOrMore({
      mediatorMergeBindingsContext: Ye,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-one-or-more",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (y_e()).ActorQueryOperationPathZeroOrMore({
      mediatorMergeBindingsContext: Ye,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-zero-or-more",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (g_e()).ActorQueryOperationPathZeroOrOne({
      mediatorMergeBindingsContext: Ye,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#path-zero-or-one",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    }), new (v_e()).ActorQueryOperationUpdateDeleteInsert({
      mediatorUpdateQuads: ue,
      mediatorMergeBindingsContext: Ye,
      mediatorQueryOperation: oe,
      name: "urn:comunica:default:query-operation/actors#update-delete-insert",
      bus: x,
      busFailMessage: "Query operation processing failed: none of the configured actors were able to handle the operation type ${action.operation.type}"
    });
    const Je = new (S_e()).ActorQueryProcessSequential({
      mediatorContextPreprocess: ae,
      mediatorQueryParse: Te,
      mediatorOptimizeQueryOperation: ee,
      mediatorQueryOperation: oe,
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:query-process/actors#sequential",
      bus: F,
      busFailMessage: 'Query processing failed: none of the configured actor were process to the query "${action.query}"'
    }), rt = new (j_e()).ActorQuerySourceIdentifyHypermedia({
      cacheSize: 100,
      maxIterators: 64,
      aggregateTraversalStore: !0,
      mediatorDereferenceRdf: M,
      mediatorMetadata: B,
      mediatorMetadataExtract: H,
      mediatorMetadataAccumulate: z,
      mediatorQuerySourceIdentifyHypermedia: he,
      mediatorRdfResolveHypermediaLinks: W,
      mediatorRdfResolveHypermediaLinksQueue: le,
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:query-source-identify/actors#hypermedia",
      bus: j,
      busFailMessage: "Query source identification failed: none of the configured actors were able to identify ${action.querySourceUnidentified.value}"
    });
    new (C_e()).ActorRdfJoinNone({
      mediatorMergeBindingsContext: Ye,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-none",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new ($_e()).ActorRdfJoinOptionalBind({
      bindOrder: "depth-first",
      selectivityModifier: 1e-6,
      mediatorQueryOperation: oe,
      mediatorMergeBindingsContext: Ye,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#optional-bind",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}"
    }), new (G_e()).ActorTermComparatorFactoryExpressionEvaluator({
      mediatorQueryOperation: oe,
      mediatorFunctionFactory: C,
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:term-comparator-factory/actors#expression-evaluator",
      bus: Q,
      busFailMessage: "Creation of term comparator failed"
    });
    const Et = new (nee()).ActorRdfJoinMultiBind({
      bindOrder: "depth-first",
      selectivityModifier: 1e-4,
      minMaxCardinalityRatio: 60,
      mediatorJoinEntriesSort: I,
      mediatorQueryOperation: oe,
      mediatorMergeBindingsContext: Ye,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-multi-bind",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}",
      beforeActors: [
        $e,
        ht,
        ne,
        ie,
        je
      ]
    });
    new (k_e()).ActorRdfJoinMultiSmallestFilterBindings({
      selectivityModifier: 1e-4,
      blockSize: 64,
      mediatorJoinEntriesSort: I,
      mediatorJoin: qe,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-multi-smallest-filter-bindings",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}",
      beforeActors: [
        $e,
        ht,
        ne,
        ie,
        je
      ]
    }), new (DG()).ActorQueryResultSerializeSparqlJson({
      emitMetadata: !0,
      httpObserver: bt,
      mediaTypePriorities: { "application/sparql-results+json": 0.8 },
      mediaTypeFormats: { "application/sparql-results+json": "http://www.w3.org/ns/formats/SPARQL_Results_JSON" },
      name: "urn:comunica:default:query-result-serialize/actors#sparql-json",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (CG()).ActorQueryResultSerializeStats({
      httpObserver: Ge,
      mediaTypePriorities: { stats: 0.5 },
      mediaTypeFormats: { stats: "https://comunica.linkeddatafragments.org/#results_stats" },
      name: "urn:comunica:default:query-result-serialize/actors#stats",
      bus: c,
      busFailMessage: "Query result serialization failed: none of the configured actors were able to serialize for type ${action.handle.type}"
    }), new (J_e()).ActorQueryProcessExplainLogical({
      queryProcessor: Je,
      name: "urn:comunica:default:query-process/actors#explain-logical",
      bus: F,
      busFailMessage: 'Query processing failed: none of the configured actor were process to the query "${action.query}"'
    }), new (W_e()).ActorQueryProcessExplainParsed({
      queryProcessor: Je,
      name: "urn:comunica:default:query-process/actors#explain-parsed",
      bus: F,
      busFailMessage: 'Query processing failed: none of the configured actor were process to the query "${action.query}"'
    }), new (Z_e()).ActorQueryProcessExplainPhysical({
      queryProcessor: Je,
      name: "urn:comunica:default:query-process/actors#explain-physical",
      bus: F,
      busFailMessage: 'Query processing failed: none of the configured actor were process to the query "${action.query}"'
    });
    const ot = new (tge()).ActorOptimizeQueryOperationPruneEmptySourceOperations({
      useAskIfSupported: !1,
      name: "urn:comunica:default:optimize-query-operation/actors#prune-empty-source-operations",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        He
      ]
    });
    new (nge()).ActorHttpRetry({
      mediatorHttp: de,
      httpInvalidator: Ue,
      name: "urn:comunica:default:http/actors#retry",
      bus: S,
      busFailMessage: "HTTP request failed: none of the configured actors were able to handle ${action.input}",
      beforeActors: [
        At
      ]
    }), new (age()).ActorHttpLimitRate({
      mediatorHttp: de,
      httpInvalidator: Le,
      correctionMultiplier: 0.1,
      failureMultiplier: 10,
      limitByDefault: !1,
      allowOverlap: !1,
      name: "urn:comunica:default:http/actors#limit-rate",
      bus: S,
      busFailMessage: "HTTP request failed: none of the configured actors were able to handle ${action.input}",
      beforeActors: [
        At
      ]
    }), new (K8()).ActorQuerySourceIdentifyRdfJs({
      mediatorMergeBindingsContext: Ye,
      name: "urn:comunica:default:query-source-identify/actors#rdfjs",
      bus: j,
      busFailMessage: "Query source identification failed: none of the configured actors were able to identify ${action.querySourceUnidentified.value}",
      beforeActors: [
        rt
      ]
    }), new (oge()).ActorQuerySourceIdentifySerialized({
      mediatorRdfParse: J,
      mediatorQuerySourceIdentify: Ve,
      name: "urn:comunica:default:query-source-identify/actors#serialized",
      bus: j,
      busFailMessage: "Query source identification failed: none of the configured actors were able to identify ${action.querySourceUnidentified.value}",
      beforeActors: [
        rt
      ]
    }), new (cge()).ActorRdfJoinMultiBindSource({
      selectivityModifier: 1e-4,
      blockSize: 16,
      mediatorJoinEntriesSort: I,
      mediatorJoinSelectivity: P,
      name: "urn:comunica:default:rdf-join/actors#inner-multi-bind-source",
      bus: q,
      busFailMessage: "RDF joining failed: none of the configured actors were able to handle the join type ${action.type}",
      beforeActors: [
        $e,
        Et,
        ht,
        ne,
        ie,
        je
      ]
    });
    const Xe = new (lge()).ActorOptimizeQueryOperationJoinConnected({
      name: "urn:comunica:default:optimize-query-operation/actors#join-connected",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        ot
      ]
    }), Ur = new (hge()).ActorOptimizeQueryOperationBgpToJoin({
      name: "urn:comunica:default:optimize-query-operation/actors#bgp-to-join",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        Xe
      ]
    }), ze = new (bge()).ActorOptimizeQueryOperationJoinBgp({
      name: "urn:comunica:default:optimize-query-operation/actors#join-bgp",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        Ur
      ]
    }), se = new (_ge()).ActorOptimizeQueryOperationAssignSourcesExhaustive({
      name: "urn:comunica:default:optimize-query-operation/actors#assign-sources-exhaustive",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        ze
      ]
    });
    return new (mge()).ActorOptimizeQueryOperationDescribeToConstructsSubject({
      name: "urn:comunica:default:optimize-query-operation/actors#describe-to-constructs-subject",
      bus: n,
      busFailMessage: "Query optimization failed: none of the configured actors were able to optimize",
      beforeActors: [
        se
      ]
    }), Qe;
  }), NO;
}
var mX;
function Tge() {
  if (mX) return Oh;
  mX = 1, Object.defineProperty(Oh, "__esModule", { value: !0 }), Oh.QueryEngine = void 0;
  const u = /* @__PURE__ */ DK(), r = /* @__PURE__ */ vge();
  let o = class extends u.QueryEngineBase {
    constructor(t = r()) {
      super(t);
    }
  };
  return Oh.QueryEngine = o, Oh;
}
var vX;
function wge() {
  return vX || (vX = 1, function(u) {
    var r = mu && mu.__createBinding || (Object.create ? function(a, t, e, n) {
      n === void 0 && (n = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
        return t[e];
      } }), Object.defineProperty(a, n, i);
    } : function(a, t, e, n) {
      n === void 0 && (n = e), a[n] = t[e];
    }), o = mu && mu.__exportStar || function(a, t) {
      for (var e in a) e !== "default" && !Object.prototype.hasOwnProperty.call(t, e) && r(t, a, e);
    };
    Object.defineProperty(u, "__esModule", { value: !0 }), o(/* @__PURE__ */ Tge(), u);
  }(mu)), mu;
}
var Sge = /* @__PURE__ */ wge();
let aee = 100;
const TX = [
  "http://www.w3.org/2002/07/owl#",
  "http://www.w3.org/2000/01/rdf-schema#",
  "http://www.w3.org/ns/sparql-service-description#",
  "http://www.openlinksw.com/schemas/virtrdf#",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
];
async function eI(u, r, o) {
  console.log("Esecuzione query SPARQL:", u);
  const a = new Sge.QueryEngine(), t = [{ type: "sparql", value: r }];
  try {
    const n = await (await a.queryBindings(u, { sources: t })).toArray();
    return console.log("Query eseguita con successo. Numero di binding:", n.length), console.log(n), n;
  } catch (e) {
    throw console.error("Errore durante l'esecuzione della query SPARQL:", e), e.message && console.error("Messaggio di errore:", e.message), e.cause && console.error("Causa dell'errore:", e.cause), e.response && (console.error("Risposta HTTP (se disponibile):", e.response), console.error("Status HTTP:", e.response.status), console.error("Testo risposta HTTP:", await e.response.text())), e;
  }
}
async function Age(u, r, o = !0) {
  let a = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX owl: <http://www.w3.org/2002/07/owl#>
        SELECT ?class (COUNT(?instance) AS ?count) WHERE {
    `;
  r && (a += `    GRAPH <${r}> { `), a += `
            { # Trova classi dedotte da istanze e conta le loro occorrenze
                ?instance rdf:type ?class .
                FILTER (isIRI(?class)) # Assicurati che il tipo sia un IRI
            }
            # Puoi riattivare i UNION qui se necessario
            # UNION { ?class a rdfs:Class . OPTIONAL { ?instance rdf:type ?class . } }
            # UNION { ?class a owl:Class . OPTIONAL { ?instance rdf:type ?class . } }
    `, r && (a += "    }"), a += `
        }
        GROUP BY ?class
        ORDER BY DESC(?count)
        LIMIT ${aee}
    `;
  try {
    const t = await eI(a, u, r);
    let e = t.map((n) => ({
      classURI: n.get("class").value,
      count: parseInt(n.get("count").value, 10)
    }));
    return o && TX.length > 0 && (e = e.filter((n) => {
      const i = n.classURI;
      return !TX.some(
        (c) => i.startsWith(c)
      );
    }), console.log(`Filtrate ${t.length - e.length} classi di sistema.`)), e;
  } catch (t) {
    return console.error("Errore durante il recupero delle classi e conteggi:", t), [];
  }
}
async function Ege(u, r, o) {
  const a = r.map((e) => `<${e}>`).join(" ");
  let t = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT ?sourceClass ?property ?targetClass (COUNT(*) AS ?count) WHERE {
    `;
  o && (t += `    GRAPH <${o}> { `), t += `
            VALUES ?sourceClass { ${a} }
            VALUES ?targetClass { ${a} }

            ?instance1 rdf:type ?sourceClass .
            ?instance1 ?property ?instance2 .
            ?instance2 rdf:type ?targetClass .

            FILTER (isIRI(?property)) # Assicurati che la proprietÃ  sia un IRI
            FILTER (?property != rdf:type) # Escludi rdf:type

            # Opzionale: Se non vuoi relazioni da una classe a se stessa al livello di classe
            # FILTER (?sourceClass != ?targetClass)
    `, o && (t += "    }"), t += `
        }
        GROUP BY ?sourceClass ?property ?targetClass
        ORDER BY DESC(?count) # Ordina per conteggio per vedere le relazioni piÃ¹ frequenti
        LIMIT ${aee} # Limita i risultati per evitare query troppo lunghe o lente
    `;
  try {
    return (await eI(t, u, o)).map((n) => ({
      sourceClass: n.get("sourceClass").value,
      propertyURI: n.get("property").value,
      targetClass: n.get("targetClass").value,
      count: parseInt(n.get("count").value, 10)
    }));
  } catch (e) {
    return console.error("Errore durante il recupero e il conteggio di tutte le relazioni:", e), [];
  }
}
async function Oge(u, r, o) {
  let a = `
        SELECT ?property (COUNT(?property) AS ?countProperty) WHERE {
    `;
  o && (a += `    GRAPH <${o}> { `), a += `
            ?instance a <${r}> .
            ?instance ?property ?value .
            FILTER(isLiteral(?value))
    `, o && (a += "    }"), a += `
        }
        GROUP BY ?property
        ORDER BY DESC(?countProperty)
    `;
  try {
    return (await eI(a, u, o)).map((e) => ({
      propertyURI: e.get("property").value,
      countProperty: parseInt(e.get("countProperty").value, 10)
    }));
  } catch (t) {
    return console.error("Errore durante il recupero delle dataproperty della classe:", t), [];
  }
}
const $t = kte({
  graphElements: { nodes: [], edges: [] },
  selectedNodes: [],
  // Array di ID dei nodi selezionati globalmente (con CTRL+click)
  selectedEdges: [],
  // Array di ID degli archi selezionati globalmente (con CTRL+click)
  dataPropertiesCache: /* @__PURE__ */ new Map(),
  // Cache delle data properties disponibili per classe
  currentSelectedNodeId: null,
  // ID del nodo attualmente cliccato per il pannello dettagli
  // NUOVO: Stato delle selezioni per il nodo attualmente visualizzato nel pannello
  // Questo sarÃ  un oggetto singolo, non una Map di tutti i nodi.
  currentPanelNodeSelection: {
    selectedDataProperties: [],
    includeIRI: !0,
    dataPropertiesFilters: {}
  }
}), xge = {
  name: "cola",
  animate: !0,
  // whether to show the layout as it's running
  refresh: 1,
  // number of ticks per frame; higher is faster but more jerky
  maxSimulationTime: 1e4,
  // max length in ms to run the layout
  ungrabifyWhileSimulating: !1,
  // so you can't drag nodes during layout
  fit: !1,
  // on every layout reposition of nodes, fit the viewport
  padding: 30,
  // padding around the simulation
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  nodeDimensionsIncludeLabels: !1,
  // whether labels should be included in determining the space used by a node
  // layout event callbacks
  ready: function() {
  },
  // on layoutready
  stop: function() {
  },
  // on layoutstop
  // positioning options
  randomize: !1,
  // use random node positions at beginning of layout
  avoidOverlap: !0,
  // if true, prevents overlap of node bounding boxes
  handleDisconnected: !0,
  // if true, avoids disconnected components from overlapping
  convergenceThreshold: 0.01,
  // when the alpha value (system energy) falls below this value, the layout stops
  nodeSpacing: function(u) {
    return 50;
  },
  // extra spacing around nodes
  flow: void 0,
  // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
  alignment: void 0,
  // relative alignment constraints on nodes, e.g. {vertical: [[{node: node1, offset: 0}, {node: node2, offset: 5}]], horizontal: [[{node: node3}, {node: node4}], [{node: node5}, {node: node6}]]}
  gapInequalities: void 0,
  // list of inequality constraints for the gap between the nodes, e.g. [{"axis":"y", "left":node1, "right":node2, "gap":25}]
  centerGraph: !0,
  // adjusts the node positions initially to center the graph (pass false if you want to start the layout from the current position)
  // different methods of specifying edge length
  // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
  edgeLength: 200,
  // sets edge length directly in simulation
  edgeSymDiffLength: void 0,
  // symmetric diff edge length in simulation
  edgeJaccardLength: void 0,
  // jaccard edge length in simulation
  // iterations of cola algorithm; uses default values on undefined
  unconstrIter: void 0,
  // unconstrained initial layout iterations
  userConstIter: void 0,
  // initial layout iterations with user-specified constraints
  allConstIter: void 0
  // initial layout iterations with all constraints including non-overlap
}, Ige = [
  {
    selector: "node",
    style: {
      "background-color": "#337ab7",
      label: "data(label)",
      "font-size": "12px",
      "text-valign": "center",
      "text-halign": "center",
      color: "#fff",
      "text-outline-width": 2,
      "text-outline-color": "#333",
      width: "mapData(count, 0, 100, 30, 80)",
      // Esempio: dimensione basata sul conteggio
      height: "mapData(count, 0, 100, 30, 80)",
      "border-width": 1,
      "border-color": "#555",
      "shadow-blur": 10,
      "shadow-offset-x": 3,
      "shadow-offset-y": 3,
      "shadow-opacity": 0.3,
      "shadow-color": "#000"
    }
  },
  {
    selector: "node[color]",
    style: {
      "background-color": "data(color)"
    }
  },
  {
    selector: "edge",
    style: {
      width: 2,
      "line-color": "#ccc",
      "target-arrow-color": "#ccc",
      "target-arrow-shape": "triangle",
      "curve-style": "bezier",
      label: "data(label)",
      // Assumi che gli archi abbiano una label
      "font-size": "8px",
      color: "#555",
      "text-background-opacity": 0.7,
      "text-background-color": "#fff",
      "text-background-padding": "3px",
      "text-border-width": 0.5,
      "text-border-color": "#ccc",
      "text-border-opacity": 1,
      "text-wrap": "wrap"
      // Permette al testo di andare a capo
    }
  },
  {
    selector: ".selected-custom",
    // Classe per nodi/archi selezionati con CTRL+click
    style: {
      "overlay-color": "#99ccff",
      "overlay-padding": 5,
      "overlay-opacity": 0.4,
      "border-width": 5,
      "border-color": "#d6012e",
      "shadow-blur": 15,
      "shadow-color": "#007bff",
      "shadow-opacity": 0.6,
      "line-color": "#f00",
      "target-arrow-color": "#f00"
    }
  },
  {
    selector: "node.highlight",
    // Esempio: per evidenziare nodi in ricerca
    style: {
      "background-color": "yellow",
      "line-color": "yellow",
      "target-arrow-color": "yellow",
      "transition-property": "background-color, line-color, target-arrow-color",
      "transition-duration": "0.3s"
    }
  },
  {
    selector: "edge.highlight",
    // Esempio: per evidenziare archi in ricerca
    style: {
      "line-color": "yellow",
      "target-arrow-color": "yellow",
      "transition-property": "line-color, target-arrow-color",
      "transition-duration": "0.3s"
    }
  },
  {
    selector: ".faded",
    // Per nodi/archi che non sono highlightati
    style: {
      opacity: 0.2,
      "text-opacity": 0
    }
  }
];
var Rge = /* @__PURE__ */ OJ('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-blue-600"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-2.72 2.72a.75.75 0 1 0 1.06 1.06L12 13.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L13.06 12l2.72-2.72a.75.75 0 0 0-1.06-1.06L12 10.94l-2.72-2.72Z" clip-rule="evenodd"></path></svg>'), Fge = /* @__PURE__ */ OJ('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-500"><path fill-rule="evenodd" d="M3.792 2.938A49.069 49.069 0 0 1 12 2.25c2.797 0 5.54.236 8.209.672.112.036.214.092.303.167A3.75 3.75 0 0 1 24 5.25v13.5a3.75 3.75 0 0 1-2.791 3.675 48.36 48.36 0 0 1-3.513.666c-1.789.245-3.599.345-5.4.345a48.36 48.36 0 0 1-5.4-.345 48.36 48.36 0 0 1-3.513-.666 3.75 3.75 0 0 1-2.79-3.675V5.25c0-1.036.784-1.91 1.838-2.083ZM12 6a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0V6.75A.75.75 0 0 1 12 6Zm3 3.75a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5a.75.75 0 0 1 .75-.75Zm-6 0a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5a.75.75 0 0 1 .75-.75Zm3 6a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5a.75.75 0 0 1 .75-.75Z" clip-rule="evenodd"></path></svg>'), Nge = /* @__PURE__ */ Qn("<option> </option>"), Pge = /* @__PURE__ */ Qn('<div class="filter-controls svelte-jctfaq"><select class="filter-select svelte-jctfaq"></select> <input type="text" class="filter-input svelte-jctfaq" placeholder="Valore filtro"/></div>'), Dge = /* @__PURE__ */ Qn('<div class="data-property-row svelte-jctfaq"><label class="flex items-center space-x-2 py-1 cursor-pointer text-sm flex-grow svelte-jctfaq"><input type="checkbox" class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out"/> <span class="text-gray-700 property-label svelte-jctfaq"> </span></label> <button class="filter-icon svelte-jctfaq" title="Applica filtro"><!></button></div> <!> <br/>', 1), Lge = /* @__PURE__ */ Qn('<div class="max-h-32 overflow-y-auto border border-gray-200 rounded-md p-2 bg-gray-50 svelte-jctfaq"></div>'), jge = /* @__PURE__ */ Qn(`<p class="text-gray-500 text-sm">Nessuna Data Property trovata per questa classe o caricamento in
                    corso...</p>`), Mge = /* @__PURE__ */ Qn('<div><div class="header-band svelte-jctfaq"><h3 class="text-lg font-semibold text-white svelte-jctfaq"> </h3></div> <div class="panel-content svelte-jctfaq"><label class="flex items-center space-x-2 mb-3 cursor-pointer svelte-jctfaq"><input type="checkbox" class="form-checkbox h-4 w-4 text-green-600 transition duration-150 ease-in-out"/> <span class="text-gray-700">Proietta IRI della Classe</span></label> <h4 class="text-md font-medium mb-2 text-gray-800">Proietta proprietÃ :</h4> <!></div></div>');
const Cge = {
  hash: "svelte-jctfaq",
  code: `\r
    /* Stili base comuni a tutti i pannelli */.node-detail-panel.svelte-jctfaq {position:fixed;z-index:1000;max-width:90%;width:400px;background-color:rgba(255, 255, 255, 0.9);border:1px solid rgba(200, 200, 200, 0.6);border-radius:15px;box-shadow:0 4px 12px rgba(0, 0, 0, 0.15);backdrop-filter:blur(5px);margin:4px;overflow:hidden;transition:all 0.3s ease-in-out;}.header-band.svelte-jctfaq {background-color:#ef4444; /* Rosso vibrante (tailwind red-500) */color:white;padding:10px 20px;border-top-left-radius:14px;border-top-right-radius:14px;margin-bottom:10px;display:flex;align-items:center;}.header-band.svelte-jctfaq h3:where(.svelte-jctfaq) {margin:0;}.panel-content.svelte-jctfaq {padding:0 20px 20px 20px;}\r
\r
/* --- Stili per la riga della proprietÃ  e il filtro --- */.data-property-row.svelte-jctfaq {display:flex;align-items:center;justify-content:space-between; /* Sposta l'icona del filtro a destra */gap:10px; /* Spazio tra etichetta e icona */padding:4px 0; /* Un po' di padding verticale per la riga */}.data-property-row.svelte-jctfaq label:where(.svelte-jctfaq) {margin-bottom:0; /* Rimuove il margine inferiore predefinito della label */flex-grow:1; /* Permette alla label di occupare lo spazio disponibile */display:flex;align-items:center;}.property-label.svelte-jctfaq {white-space:nowrap; /* Impedisce al testo di andare a capo */overflow:hidden; /* Nasconde il testo in eccesso */text-overflow:ellipsis; /* Aggiunge i puntini di sospensione */max-width:calc(100% - 24px); /* Limita la larghezza per fare spazio al checkbox */}.filter-icon.svelte-jctfaq {background:none;border:none;cursor:pointer;padding:0;display:flex; /* Assicura che l'SVG sia centrata se il bottone ha dimensioni fisse */align-items:center;justify-content:center;width:24px; /* Dimensione fissa per l'icona */height:24px; /* Dimensione fissa per l'icona */flex-shrink:0; /* Impedisce all'icona di restringersi */}.filter-controls.svelte-jctfaq {display:flex;gap:8px; /* Spazio tra select e input */margin-top:5px; /* Spazio tra la riga della proprietÃ  e i controlli del filtro */margin-left:24px; /* Allinea con il contenuto della label, considerando il checkbox */width:calc(100% - 24px); /* Per compensare il margin-left */}.filter-select.svelte-jctfaq,\r
.filter-input.svelte-jctfaq {padding:6px 10px;border:1px solid #d1d5db; /* gray-300 */border-radius:6px;font-size:0.875rem; /* text-sm */box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.05);}.filter-select.svelte-jctfaq {flex:1; /* Permette alla select di crescere */min-width:100px; /* Larghezza minima per la select */}.filter-input.svelte-jctfaq {flex:2; /* Permette all'input di crescere di piÃ¹ */min-width:120px; /* Larghezza minima per l'input */}\r
\r
/* --- Posizioni specifiche (rimangono invariate) --- */.node-detail-panel.bottom-center.svelte-jctfaq {bottom:20px;left:50%;transform:translateX(-50%);}.node-detail-panel.top-center.svelte-jctfaq {top:20px;left:50%;transform:translateX(-50%);}.node-detail-panel.bottom-left.svelte-jctfaq {bottom:20px;left:20px;transform:none;}.node-detail-panel.bottom-right.svelte-jctfaq {bottom:20px;right:20px;transform:none;}.node-detail-panel.top-left.svelte-jctfaq {top:20px;left:20px;transform:none;}.node-detail-panel.top-right.svelte-jctfaq {top:20px;right:20px;transform:none;}.node-detail-panel.middle-left.svelte-jctfaq {top:50%;left:20px;transform:translateY(-50%);}.node-detail-panel.middle-right.svelte-jctfaq {top:50%;right:20px;transform:translateY(-50%);}\r
\r
/* --- Stili per la scrollbar (rimangono invariate) --- */.max-h-32.svelte-jctfaq::-webkit-scrollbar {width:8px;}.max-h-32.svelte-jctfaq::-webkit-scrollbar-track {background:rgba(241, 241, 241, 0.5);border-radius:10px;}.max-h-32.svelte-jctfaq::-webkit-scrollbar-thumb {background:rgba(189, 189, 189, 0.7);border-radius:10px;}.max-h-32.svelte-jctfaq::-webkit-scrollbar-thumb:hover {background:rgba(150, 150, 150, 0.8);}`
};
function qge(u, r) {
  RS(r, !1), LS(u, Cge);
  const [o, a] = DJ(), t = () => PJ($t, "$graphState", o);
  let e = ca(r, "currentSelectedNode", 8, null), n = ca(r, "currentPanelDataProperties", 24, () => []), i = ca(r, "toggleIncludeIRI", 8), c = ca(r, "toggleDataProperty", 8), s = ca(r, "updateFilterValue", 8), d = ca(r, "updateFilterType", 8), l = ca(r, "panelPosition", 8, "bottom-center"), f = /* @__PURE__ */ kr({});
  const h = [
    { value: "contains", label: "Contiene" },
    { value: "greater", label: "Maggiore di" },
    { value: "less", label: "Minore di" },
    { value: "equals", label: "Uguale a" }
  ];
  function p(T) {
    var v, E;
    return ((E = (v = t().currentPanelNodeSelection) == null ? void 0 : v.dataPropertiesFilters) == null ? void 0 : E[T]) || { type: "contains", value: "" };
  }
  function b(T) {
    St(f, {
      ...Pe(f),
      [T]: !Pe(f)[T]
    }), Pe(f)[T] || (d()(e().id(), T, "contains"), s()(e().id(), T, ""));
  }
  let _ = /* @__PURE__ */ kr(null);
  qO(
    () => (j0(e()), Pe(_), t(), j0(n()), Pe(f)),
    () => {
      var T;
      if (e() && e().id() !== Pe(_)) {
        const v = ((T = t().currentPanelNodeSelection) == null ? void 0 : T.dataPropertiesFilters) || {}, E = {};
        n().forEach((R) => {
          v[R.propertyURI] && v[R.propertyURI].value !== "" ? E[R.propertyURI] = !0 : E[R.propertyURI] = !1;
        }), St(f, E), St(_, e().id()), console.log("Inizializzato filterVisibility per nuovo nodo:", Pe(f));
      } else !e() && Pe(_) !== null && (St(f, {}), St(_, null), console.log("Reset filterVisibility al chiudere del pannello."));
    }
  ), cJ(), Lx();
  var y = Rte(), m = _S(y);
  {
    var g = (T) => {
      var v = Mge(), E = Ar(v), R = Ar(E), L = Ar(R);
      _r(R), _r(E);
      var A = pi(E, 2), w = Ar(A), S = Ar(w);
      J6(S), BI(2), _r(w);
      var O = pi(w, 4);
      {
        var x = (j) => {
          var q = Lge();
          HI(q, 5, n, (Q) => Q.propertyURI, (Q, G) => {
            var K = Dge(), U = _S(K), ae = Ar(U), ye = Ar(ae);
            J6(ye);
            var pe = pi(ye, 2), ee = Ar(pe);
            _r(pe), _r(ae);
            var Te = pi(ae, 2), we = Ar(Te);
            {
              var Oe = (N) => {
                var M = Rge();
                zr(N, M);
              }, be = (N) => {
                var M = Fge();
                zr(N, M);
              };
              Pi(we, (N) => {
                Pe(f), Pe(G), nt(() => Pe(f)[Pe(G).propertyURI]) ? N(Oe) : N(be, !1);
              });
            }
            _r(Te), _r(U);
            var he = pi(U, 2);
            {
              var V = (N) => {
                var M = Pge(), I = Ar(M);
                HI(I, 5, () => h, Mte, (z, H) => {
                  var J = Nge(), k = Ar(J, !0);
                  _r(J);
                  var W = {};
                  Gf(() => {
                    RT(k, (Pe(H), nt(() => Pe(H).label))), W !== (W = (Pe(H), nt(() => Pe(H).value))) && (J.value = (J.__value = (Pe(H), nt(() => Pe(H).value))) ?? "");
                  }), zr(z, J);
                }), _r(I);
                var P;
                Ute(I);
                var B = pi(I, 2);
                J6(B), _r(M), Gf(
                  (z, H) => {
                    P !== (P = z) && (I.value = (I.__value = z) ?? "", FJ(I, z)), Hte(B, H);
                  },
                  [
                    () => (Pe(G), nt(() => p(Pe(G).propertyURI).type)),
                    () => (Pe(G), nt(() => p(Pe(G).propertyURI).value))
                  ],
                  B0
                ), jn("change", I, (z) => d()(e().id(), Pe(G).propertyURI, z.target.value)), jn("input", B, (z) => s()(e().id(), Pe(G).propertyURI, z.target.value)), jn("click", B, Yw(function(z) {
                  Zw.call(this, r, z);
                })), jn("mousedown", B, Yw(function(z) {
                  Zw.call(this, r, z);
                })), jn("keydown", B, Yw(function(z) {
                  Zw.call(this, r, z);
                })), jn("keyup", B, Yw(function(z) {
                  Zw.call(this, r, z);
                })), zr(N, M);
              };
              Pi(he, (N) => {
                Pe(f), Pe(G), nt(() => Pe(f)[Pe(G).propertyURI]) && N(V);
              });
            }
            BI(2), Gf(
              (N, M) => {
                XI(ye, N), RT(ee, `${M ?? ""} (${Pe(G), nt(() => Pe(G).countProperty) ?? ""})`);
              },
              [
                () => (t(), Pe(G), nt(() => {
                  var N;
                  return (N = t().currentPanelNodeSelection.selectedDataProperties) == null ? void 0 : N.includes(Pe(G).propertyURI);
                })),
                () => (Pe(G), nt(() => Pe(G).propertyURI.split("/").pop().split("#").pop()))
              ],
              B0
            ), jn("change", ye, (N) => c()(e().id(), Pe(G).propertyURI, N.target.checked)), jn("click", Te, () => b(Pe(G).propertyURI)), zr(Q, K);
          }), _r(q), zr(j, q);
        }, F = (j) => {
          var q = jge();
          zr(j, q);
        };
        Pi(O, (j) => {
          j0(n()), nt(() => n().length > 0) ? j(x) : j(F, !1);
        });
      }
      _r(A), _r(v), Gf(
        (j) => {
          UO(v, 1, `node-detail-panel ${l() ?? ""}`, "svelte-jctfaq"), RT(L, `Nodo: ${j ?? ""}`), XI(S, (t(), nt(() => t().currentPanelNodeSelection.includeIRI)));
        },
        [
          () => (j0(e()), nt(() => e().data("label").split(" (")[0]))
        ],
        B0
      ), jn("change", S, (j) => i()(e().id(), j.target.checked)), zr(T, v);
    };
    Pi(m, (T) => {
      e() && T(g);
    });
  }
  zr(u, y), FS(), a();
}
var hS = { exports: {} }, PO = {}, Pf = {}, DO = {}, ia = {}, wX;
function uee() {
  if (wX) return ia;
  wX = 1, Object.defineProperty(ia, "__esModule", { value: !0 });
  var u = /* @__PURE__ */ function() {
    function c(s, d, l) {
      this.source = s, this.target = d, this.type = l;
    }
    return c;
  }();
  ia.PowerEdge = u;
  var r = function() {
    function c(s, d, l, f) {
      var h = this;
      if (this.linkAccessor = l, this.modules = new Array(s), this.roots = [], f)
        this.initModulesFromGroup(f);
      else {
        this.roots.push(new e());
        for (var p = 0; p < s; ++p)
          this.roots[0].add(this.modules[p] = new a(p));
      }
      this.R = d.length, d.forEach(function(b) {
        var _ = h.modules[l.getSourceIndex(b)], y = h.modules[l.getTargetIndex(b)], m = l.getType(b);
        _.outgoing.add(m, y), y.incoming.add(m, _);
      });
    }
    return c.prototype.initModulesFromGroup = function(s) {
      var d = new e();
      this.roots.push(d);
      for (var l = 0; l < s.leaves.length; ++l) {
        var f = s.leaves[l], h = new a(f.id);
        this.modules[f.id] = h, d.add(h);
      }
      if (s.groups)
        for (var p = 0; p < s.groups.length; ++p) {
          var b = s.groups[p], _ = {};
          for (var y in b)
            y !== "leaves" && y !== "groups" && b.hasOwnProperty(y) && (_[y] = b[y]);
          d.add(new a(-1 - p, new n(), new n(), this.initModulesFromGroup(b), _));
        }
      return d;
    }, c.prototype.merge = function(s, d, l) {
      l === void 0 && (l = 0);
      var f = s.incoming.intersection(d.incoming), h = s.outgoing.intersection(d.outgoing), p = new e();
      p.add(s), p.add(d);
      var b = new a(this.modules.length, h, f, p);
      this.modules.push(b);
      var _ = function(y, m, g) {
        y.forAll(function(T, v) {
          T.forAll(function(E) {
            var R = E[m];
            R.add(v, b), R.remove(v, s), R.remove(v, d), s[g].remove(v, E), d[g].remove(v, E);
          });
        });
      };
      return _(h, "incoming", "outgoing"), _(f, "outgoing", "incoming"), this.R -= f.count() + h.count(), this.roots[l].remove(s), this.roots[l].remove(d), this.roots[l].add(b), b;
    }, c.prototype.rootMerges = function(s) {
      s === void 0 && (s = 0);
      for (var d = this.roots[s].modules(), l = d.length, f = new Array(l * (l - 1)), h = 0, p = 0, b = l - 1; p < b; ++p)
        for (var _ = p + 1; _ < l; ++_) {
          var y = d[p], m = d[_];
          f[h] = { id: h, nEdges: this.nEdges(y, m), a: y, b: m }, h++;
        }
      return f;
    }, c.prototype.greedyMerge = function() {
      for (var s = 0; s < this.roots.length; ++s)
        if (!(this.roots[s].modules().length < 2)) {
          var d = this.rootMerges(s).sort(function(f, h) {
            return f.nEdges == h.nEdges ? f.id - h.id : f.nEdges - h.nEdges;
          }), l = d[0];
          if (!(l.nEdges >= this.R))
            return this.merge(l.a, l.b, s), !0;
        }
    }, c.prototype.nEdges = function(s, d) {
      var l = s.incoming.intersection(d.incoming), f = s.outgoing.intersection(d.outgoing);
      return this.R - l.count() - f.count();
    }, c.prototype.getGroupHierarchy = function(s) {
      var d = this, l = [], f = {};
      o(this.roots[0], f, l);
      var h = this.allEdges();
      return h.forEach(function(p) {
        var b = d.modules[p.source], _ = d.modules[p.target];
        s.push(new u(typeof b.gid > "u" ? p.source : l[b.gid], typeof _.gid > "u" ? p.target : l[_.gid], p.type));
      }), l;
    }, c.prototype.allEdges = function() {
      var s = [];
      return c.getEdges(this.roots[0], s), s;
    }, c.getEdges = function(s, d) {
      s.forAll(function(l) {
        l.getEdges(d), c.getEdges(l.children, d);
      });
    }, c;
  }();
  ia.Configuration = r;
  function o(c, s, d) {
    c.forAll(function(l) {
      if (l.isLeaf())
        s.leaves || (s.leaves = []), s.leaves.push(l.id);
      else {
        var f = s;
        if (l.gid = d.length, !l.isIsland() || l.isPredefined()) {
          if (f = { id: l.gid }, l.isPredefined())
            for (var h in l.definition)
              f[h] = l.definition[h];
          s.groups || (s.groups = []), s.groups.push(l.gid), d.push(f);
        }
        o(l.children, f, d);
      }
    });
  }
  var a = function() {
    function c(s, d, l, f, h) {
      d === void 0 && (d = new n()), l === void 0 && (l = new n()), f === void 0 && (f = new e()), this.id = s, this.outgoing = d, this.incoming = l, this.children = f, this.definition = h;
    }
    return c.prototype.getEdges = function(s) {
      var d = this;
      this.outgoing.forAll(function(l, f) {
        l.forAll(function(h) {
          s.push(new u(d.id, h.id, f));
        });
      });
    }, c.prototype.isLeaf = function() {
      return this.children.count() === 0;
    }, c.prototype.isIsland = function() {
      return this.outgoing.count() === 0 && this.incoming.count() === 0;
    }, c.prototype.isPredefined = function() {
      return typeof this.definition < "u";
    }, c;
  }();
  ia.Module = a;
  function t(c, s) {
    var d = {};
    for (var l in c)
      l in s && (d[l] = c[l]);
    return d;
  }
  var e = function() {
    function c() {
      this.table = {};
    }
    return c.prototype.count = function() {
      return Object.keys(this.table).length;
    }, c.prototype.intersection = function(s) {
      var d = new c();
      return d.table = t(this.table, s.table), d;
    }, c.prototype.intersectionCount = function(s) {
      return this.intersection(s).count();
    }, c.prototype.contains = function(s) {
      return s in this.table;
    }, c.prototype.add = function(s) {
      this.table[s.id] = s;
    }, c.prototype.remove = function(s) {
      delete this.table[s.id];
    }, c.prototype.forAll = function(s) {
      for (var d in this.table)
        s(this.table[d]);
    }, c.prototype.modules = function() {
      var s = [];
      return this.forAll(function(d) {
        d.isPredefined() || s.push(d);
      }), s;
    }, c;
  }();
  ia.ModuleSet = e;
  var n = function() {
    function c() {
      this.sets = {}, this.n = 0;
    }
    return c.prototype.count = function() {
      return this.n;
    }, c.prototype.contains = function(s) {
      var d = !1;
      return this.forAllModules(function(l) {
        !d && l.id == s && (d = !0);
      }), d;
    }, c.prototype.add = function(s, d) {
      var l = s in this.sets ? this.sets[s] : this.sets[s] = new e();
      l.add(d), ++this.n;
    }, c.prototype.remove = function(s, d) {
      var l = this.sets[s];
      l.remove(d), l.count() === 0 && delete this.sets[s], --this.n;
    }, c.prototype.forAll = function(s) {
      for (var d in this.sets)
        s(this.sets[d], Number(d));
    }, c.prototype.forAllModules = function(s) {
      this.forAll(function(d, l) {
        return d.forAll(s);
      });
    }, c.prototype.intersection = function(s) {
      var d = new c();
      return this.forAll(function(l, f) {
        if (f in s.sets) {
          var h = l.intersection(s.sets[f]), p = h.count();
          p > 0 && (d.sets[f] = h, d.n += p);
        }
      }), d;
    }, c;
  }();
  ia.LinkSets = n;
  function i(c, s, d, l) {
    for (var f = c.length, h = new r(f, s, d, l); h.greedyMerge(); )
      ;
    var p = [], b = h.getGroupHierarchy(p);
    return p.forEach(function(_) {
      var y = function(m) {
        var g = _[m];
        typeof g == "number" && (_[m] = c[g]);
      };
      y("source"), y("target");
    }), { groups: b, powerEdges: p };
  }
  return ia.getGroups = i, ia;
}
var Df = {}, SX;
function tI() {
  if (SX) return Df;
  SX = 1, Object.defineProperty(Df, "__esModule", { value: !0 });
  function u(c, s) {
    var d = {};
    for (var l in c)
      d[l] = {};
    for (var l in s)
      d[l] = {};
    return Object.keys(d).length;
  }
  function r(c, s) {
    var d = 0;
    for (var l in c)
      typeof s[l] < "u" && ++d;
    return d;
  }
  function o(c, s) {
    var d = {}, l = function(f, h) {
      typeof d[f] > "u" && (d[f] = {}), d[f][h] = {};
    };
    return c.forEach(function(f) {
      var h = s.getSourceIndex(f), p = s.getTargetIndex(f);
      l(h, p), l(p, h);
    }), d;
  }
  function a(c, s, d, l) {
    var f = o(c, l);
    c.forEach(function(h) {
      var p = f[l.getSourceIndex(h)], b = f[l.getTargetIndex(h)];
      l.setLength(h, 1 + s * d(p, b));
    });
  }
  function t(c, s, d) {
    d === void 0 && (d = 1), a(c, d, function(l, f) {
      return Math.sqrt(u(l, f) - r(l, f));
    }, s);
  }
  Df.symmetricDiffLinkLengths = t;
  function e(c, s, d) {
    d === void 0 && (d = 1), a(c, d, function(l, f) {
      return Math.min(Object.keys(l).length, Object.keys(f).length) < 1.1 ? 0 : r(l, f) / u(l, f);
    }, s);
  }
  Df.jaccardLinkLengths = e;
  function n(c, s, d, l) {
    var f = i(c, s, l), h = {};
    f.forEach(function(b, _) {
      return b.forEach(function(y) {
        return h[y] = _;
      });
    });
    var p = [];
    return s.forEach(function(b) {
      var _ = l.getSourceIndex(b), y = l.getTargetIndex(b), m = h[_], g = h[y];
      m !== g && p.push({
        axis: d,
        left: _,
        right: y,
        gap: l.getMinSeparation(b)
      });
    }), p;
  }
  Df.generateDirectedEdgeConstraints = n;
  function i(c, s, d) {
    var l = [], f = 0, h = [], p = [];
    function b(A) {
      A.index = A.lowlink = f++, h.push(A), A.onStack = !0;
      for (var w = 0, S = A.out; w < S.length; w++) {
        var O = S[w];
        typeof O.index > "u" ? (b(O), A.lowlink = Math.min(A.lowlink, O.lowlink)) : O.onStack && (A.lowlink = Math.min(A.lowlink, O.index));
      }
      if (A.lowlink === A.index) {
        for (var x = []; h.length && (O = h.pop(), O.onStack = !1, x.push(O), O !== A); )
          ;
        p.push(x.map(function(F) {
          return F.id;
        }));
      }
    }
    for (var _ = 0; _ < c; _++)
      l.push({ id: _, out: [] });
    for (var y = 0, m = s; y < m.length; y++) {
      var g = m[y], T = l[d.getSourceIndex(g)], v = l[d.getTargetIndex(g)];
      T.out.push(v);
    }
    for (var E = 0, R = l; E < R.length; E++) {
      var L = R[E];
      typeof L.index > "u" && b(L);
    }
    return p;
  }
  return Df.stronglyConnectedComponents = i, Df;
}
var x0 = {}, AX;
function rI() {
  if (AX) return x0;
  AX = 1, Object.defineProperty(x0, "__esModule", { value: !0 });
  var u = function() {
    function a() {
      this.locks = {};
    }
    return a.prototype.add = function(t, e) {
      this.locks[t] = e;
    }, a.prototype.clear = function() {
      this.locks = {};
    }, a.prototype.isEmpty = function() {
      for (var t in this.locks)
        return !1;
      return !0;
    }, a.prototype.apply = function(t) {
      for (var e in this.locks)
        t(Number(e), this.locks[e]);
    }, a;
  }();
  x0.Locks = u;
  var r = function() {
    function a(t, e, n) {
      n === void 0 && (n = null), this.D = e, this.G = n, this.threshold = 1e-4, this.numGridSnapNodes = 0, this.snapGridSize = 100, this.snapStrength = 1e3, this.scaleSnapByMaxH = !1, this.random = new o(), this.project = null, this.x = t, this.k = t.length;
      var i = this.n = t[0].length;
      this.H = new Array(this.k), this.g = new Array(this.k), this.Hd = new Array(this.k), this.a = new Array(this.k), this.b = new Array(this.k), this.c = new Array(this.k), this.d = new Array(this.k), this.e = new Array(this.k), this.ia = new Array(this.k), this.ib = new Array(this.k), this.xtmp = new Array(this.k), this.locks = new u(), this.minD = Number.MAX_VALUE;
      for (var c = i, s; c--; )
        for (s = i; --s > c; ) {
          var d = e[c][s];
          d > 0 && d < this.minD && (this.minD = d);
        }
      for (this.minD === Number.MAX_VALUE && (this.minD = 1), c = this.k; c--; ) {
        for (this.g[c] = new Array(i), this.H[c] = new Array(i), s = i; s--; )
          this.H[c][s] = new Array(i);
        this.Hd[c] = new Array(i), this.a[c] = new Array(i), this.b[c] = new Array(i), this.c[c] = new Array(i), this.d[c] = new Array(i), this.e[c] = new Array(i), this.ia[c] = new Array(i), this.ib[c] = new Array(i), this.xtmp[c] = new Array(i);
      }
    }
    return a.createSquareMatrix = function(t, e) {
      for (var n = new Array(t), i = 0; i < t; ++i) {
        n[i] = new Array(t);
        for (var c = 0; c < t; ++c)
          n[i][c] = e(i, c);
      }
      return n;
    }, a.prototype.offsetDir = function() {
      for (var t = this, e = new Array(this.k), n = 0, i = 0; i < this.k; ++i) {
        var c = e[i] = this.random.getNextBetween(0.01, 1) - 0.5;
        n += c * c;
      }
      return n = Math.sqrt(n), e.map(function(s) {
        return s *= t.minD / n;
      });
    }, a.prototype.computeDerivatives = function(t) {
      var e = this, n = this.n;
      if (!(n < 1)) {
        for (var i, c = new Array(this.k), s = new Array(this.k), d = new Array(this.k), l = 0, f = 0; f < n; ++f) {
          for (i = 0; i < this.k; ++i)
            d[i] = this.g[i][f] = 0;
          for (var h = 0; h < n; ++h)
            if (f !== h) {
              for (var p = n; p--; ) {
                var b = 0;
                for (i = 0; i < this.k; ++i) {
                  var _ = c[i] = t[i][f] - t[i][h];
                  b += s[i] = _ * _;
                }
                if (b > 1e-9)
                  break;
                var y = this.offsetDir();
                for (i = 0; i < this.k; ++i)
                  t[i][h] += y[i];
              }
              var m = Math.sqrt(b), g = this.D[f][h], T = this.G != null ? this.G[f][h] : 1;
              if (T > 1 && m > g || !isFinite(g)) {
                for (i = 0; i < this.k; ++i)
                  this.H[i][f][h] = 0;
                continue;
              }
              T > 1 && (T = 1);
              var v = g * g, E = 2 * T * (m - g) / (v * m), R = m * m * m, L = 2 * -T / (v * R);
              for (isFinite(E) || console.log(E), i = 0; i < this.k; ++i)
                this.g[i][f] += c[i] * E, d[i] -= this.H[i][f][h] = L * (R + g * (s[i] - b) + m * b);
            }
          for (i = 0; i < this.k; ++i)
            l = Math.max(l, this.H[i][f][f] = d[i]);
        }
        for (var A = this.snapGridSize / 2, w = this.snapGridSize, S = this.snapStrength, O = S / (A * A), x = this.numGridSnapNodes, f = 0; f < x; ++f)
          for (i = 0; i < this.k; ++i) {
            var F = this.x[i][f], j = F / w, q = j % 1, Q = j - q, G = Math.abs(q), _ = G <= 0.5 ? F - Q * w : F > 0 ? F - (Q + 1) * w : F - (Q - 1) * w;
            -A < _ && _ <= A && (this.scaleSnapByMaxH ? (this.g[i][f] += l * O * _, this.H[i][f][f] += l * O) : (this.g[i][f] += O * _, this.H[i][f][f] += O));
          }
        this.locks.isEmpty() || this.locks.apply(function(K, U) {
          for (i = 0; i < e.k; ++i)
            e.H[i][K][K] += l, e.g[i][K] -= l * (U[i] - t[i][K]);
        });
      }
    }, a.dotProd = function(t, e) {
      for (var n = 0, i = t.length; i--; )
        n += t[i] * e[i];
      return n;
    }, a.rightMultiply = function(t, e, n) {
      for (var i = t.length; i--; )
        n[i] = a.dotProd(t[i], e);
    }, a.prototype.computeStepSize = function(t) {
      for (var e = 0, n = 0, i = 0; i < this.k; ++i)
        e += a.dotProd(this.g[i], t[i]), a.rightMultiply(this.H[i], t[i], this.Hd[i]), n += a.dotProd(t[i], this.Hd[i]);
      return n === 0 || !isFinite(n) ? 0 : 1 * e / n;
    }, a.prototype.reduceStress = function() {
      this.computeDerivatives(this.x);
      for (var t = this.computeStepSize(this.g), e = 0; e < this.k; ++e)
        this.takeDescentStep(this.x[e], this.g[e], t);
      return this.computeStress();
    }, a.copy = function(t, e) {
      for (var n = t.length, i = e[0].length, c = 0; c < n; ++c)
        for (var s = 0; s < i; ++s)
          e[c][s] = t[c][s];
    }, a.prototype.stepAndProject = function(t, e, n, i) {
      a.copy(t, e), this.takeDescentStep(e[0], n[0], i), this.project && this.project[0](t[0], t[1], e[0]), this.takeDescentStep(e[1], n[1], i), this.project && this.project[1](e[0], t[1], e[1]);
      for (var c = 2; c < this.k; c++)
        this.takeDescentStep(e[c], n[c], i);
    }, a.mApply = function(t, e, n) {
      for (var i = t; i-- > 0; )
        for (var c = e; c-- > 0; )
          n(i, c);
    }, a.prototype.matrixApply = function(t) {
      a.mApply(this.k, this.n, t);
    }, a.prototype.computeNextPosition = function(t, e) {
      var n = this;
      this.computeDerivatives(t);
      var i = this.computeStepSize(this.g);
      if (this.stepAndProject(t, e, this.g, i), this.project) {
        this.matrixApply(function(s, d) {
          return n.e[s][d] = t[s][d] - e[s][d];
        });
        var c = this.computeStepSize(this.e);
        c = Math.max(0.2, Math.min(c, 1)), this.stepAndProject(t, e, this.e, c);
      }
    }, a.prototype.run = function(t) {
      for (var e = Number.MAX_VALUE, n = !1; !n && t-- > 0; ) {
        var i = this.rungeKutta();
        n = Math.abs(e / i - 1) < this.threshold, e = i;
      }
      return e;
    }, a.prototype.rungeKutta = function() {
      var t = this;
      this.computeNextPosition(this.x, this.a), a.mid(this.x, this.a, this.ia), this.computeNextPosition(this.ia, this.b), a.mid(this.x, this.b, this.ib), this.computeNextPosition(this.ib, this.c), this.computeNextPosition(this.c, this.d);
      var e = 0;
      return this.matrixApply(function(n, i) {
        var c = (t.a[n][i] + 2 * t.b[n][i] + 2 * t.c[n][i] + t.d[n][i]) / 6, s = t.x[n][i] - c;
        e += s * s, t.x[n][i] = c;
      }), e;
    }, a.mid = function(t, e, n) {
      a.mApply(t.length, t[0].length, function(i, c) {
        return n[i][c] = t[i][c] + (e[i][c] - t[i][c]) / 2;
      });
    }, a.prototype.takeDescentStep = function(t, e, n) {
      for (var i = 0; i < this.n; ++i)
        t[i] = t[i] - n * e[i];
    }, a.prototype.computeStress = function() {
      for (var t = 0, e = 0, n = this.n - 1; e < n; ++e)
        for (var i = e + 1, c = this.n; i < c; ++i) {
          for (var s = 0, d = 0; d < this.k; ++d) {
            var l = this.x[d][e] - this.x[d][i];
            s += l * l;
          }
          s = Math.sqrt(s);
          var f = this.D[e][i];
          if (isFinite(f)) {
            var h = f - s, p = f * f;
            t += h * h / p;
          }
        }
      return t;
    }, a.zeroDistance = 1e-10, a;
  }();
  x0.Descent = r;
  var o = function() {
    function a(t) {
      t === void 0 && (t = 1), this.seed = t, this.a = 214013, this.c = 2531011, this.m = 2147483648, this.range = 32767;
    }
    return a.prototype.getNext = function() {
      return this.seed = (this.seed * this.a + this.c) % this.m, (this.seed >> 16) / this.range;
    }, a.prototype.getNextBetween = function(t, e) {
      return t + this.getNext() * (e - t);
    }, a;
  }();
  return x0.PseudoRandom = o, x0;
}
var Qr = {}, Ii = {}, EX;
function nI() {
  if (EX) return Ii;
  EX = 1, Object.defineProperty(Ii, "__esModule", { value: !0 });
  var u = function() {
    function i(c) {
      this.scale = c, this.AB = 0, this.AD = 0, this.A2 = 0;
    }
    return i.prototype.addVariable = function(c) {
      var s = this.scale / c.scale, d = c.offset / c.scale, l = c.weight;
      this.AB += l * s * d, this.AD += l * s * c.desiredPosition, this.A2 += l * s * s;
    }, i.prototype.getPosn = function() {
      return (this.AD - this.AB) / this.A2;
    }, i;
  }();
  Ii.PositionStats = u;
  var r = function() {
    function i(c, s, d, l) {
      l === void 0 && (l = !1), this.left = c, this.right = s, this.gap = d, this.equality = l, this.active = !1, this.unsatisfiable = !1, this.left = c, this.right = s, this.gap = d, this.equality = l;
    }
    return i.prototype.slack = function() {
      return this.unsatisfiable ? Number.MAX_VALUE : this.right.scale * this.right.position() - this.gap - this.left.scale * this.left.position();
    }, i;
  }();
  Ii.Constraint = r;
  var o = function() {
    function i(c, s, d) {
      s === void 0 && (s = 1), d === void 0 && (d = 1), this.desiredPosition = c, this.weight = s, this.scale = d, this.offset = 0;
    }
    return i.prototype.dfdv = function() {
      return 2 * this.weight * (this.position() - this.desiredPosition);
    }, i.prototype.position = function() {
      return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
    }, i.prototype.visitNeighbours = function(c, s) {
      var d = function(l, f) {
        return l.active && c !== f && s(l, f);
      };
      this.cOut.forEach(function(l) {
        return d(l, l.right);
      }), this.cIn.forEach(function(l) {
        return d(l, l.left);
      });
    }, i;
  }();
  Ii.Variable = o;
  var a = function() {
    function i(c) {
      this.vars = [], c.offset = 0, this.ps = new u(c.scale), this.addVariable(c);
    }
    return i.prototype.addVariable = function(c) {
      c.block = this, this.vars.push(c), this.ps.addVariable(c), this.posn = this.ps.getPosn();
    }, i.prototype.updateWeightedPosition = function() {
      this.ps.AB = this.ps.AD = this.ps.A2 = 0;
      for (var c = 0, s = this.vars.length; c < s; ++c)
        this.ps.addVariable(this.vars[c]);
      this.posn = this.ps.getPosn();
    }, i.prototype.compute_lm = function(c, s, d) {
      var l = this, f = c.dfdv();
      return c.visitNeighbours(s, function(h, p) {
        var b = l.compute_lm(p, c, d);
        p === h.right ? (f += b * h.left.scale, h.lm = b) : (f += b * h.right.scale, h.lm = -b), d(h);
      }), f / c.scale;
    }, i.prototype.populateSplitBlock = function(c, s) {
      var d = this;
      c.visitNeighbours(s, function(l, f) {
        f.offset = c.offset + (f === l.right ? l.gap : -l.gap), d.addVariable(f), d.populateSplitBlock(f, c);
      });
    }, i.prototype.traverse = function(c, s, d, l) {
      var f = this;
      d === void 0 && (d = this.vars[0]), l === void 0 && (l = null), d.visitNeighbours(l, function(h, p) {
        s.push(c(h)), f.traverse(c, s, p, d);
      });
    }, i.prototype.findMinLM = function() {
      var c = null;
      return this.compute_lm(this.vars[0], null, function(s) {
        !s.equality && (c === null || s.lm < c.lm) && (c = s);
      }), c;
    }, i.prototype.findMinLMBetween = function(c, s) {
      this.compute_lm(c, null, function() {
      });
      var d = null;
      return this.findPath(c, null, s, function(l, f) {
        !l.equality && l.right === f && (d === null || l.lm < d.lm) && (d = l);
      }), d;
    }, i.prototype.findPath = function(c, s, d, l) {
      var f = this, h = !1;
      return c.visitNeighbours(s, function(p, b) {
        !h && (b === d || f.findPath(b, c, d, l)) && (h = !0, l(p, b));
      }), h;
    }, i.prototype.isActiveDirectedPathBetween = function(c, s) {
      if (c === s)
        return !0;
      for (var d = c.cOut.length; d--; ) {
        var l = c.cOut[d];
        if (l.active && this.isActiveDirectedPathBetween(l.right, s))
          return !0;
      }
      return !1;
    }, i.split = function(c) {
      return c.active = !1, [i.createSplitBlock(c.left), i.createSplitBlock(c.right)];
    }, i.createSplitBlock = function(c) {
      var s = new i(c);
      return s.populateSplitBlock(c, null), s;
    }, i.prototype.splitBetween = function(c, s) {
      var d = this.findMinLMBetween(c, s);
      if (d !== null) {
        var l = i.split(d);
        return { constraint: d, lb: l[0], rb: l[1] };
      }
      return null;
    }, i.prototype.mergeAcross = function(c, s, d) {
      s.active = !0;
      for (var l = 0, f = c.vars.length; l < f; ++l) {
        var h = c.vars[l];
        h.offset += d, this.addVariable(h);
      }
      this.posn = this.ps.getPosn();
    }, i.prototype.cost = function() {
      for (var c = 0, s = this.vars.length; s--; ) {
        var d = this.vars[s], l = d.position() - d.desiredPosition;
        c += l * l * d.weight;
      }
      return c;
    }, i;
  }();
  Ii.Block = a;
  var t = function() {
    function i(c) {
      this.vs = c;
      var s = c.length;
      for (this.list = new Array(s); s--; ) {
        var d = new a(c[s]);
        this.list[s] = d, d.blockInd = s;
      }
    }
    return i.prototype.cost = function() {
      for (var c = 0, s = this.list.length; s--; )
        c += this.list[s].cost();
      return c;
    }, i.prototype.insert = function(c) {
      c.blockInd = this.list.length, this.list.push(c);
    }, i.prototype.remove = function(c) {
      var s = this.list.length - 1, d = this.list[s];
      this.list.length = s, c !== d && (this.list[c.blockInd] = d, d.blockInd = c.blockInd);
    }, i.prototype.merge = function(c) {
      var s = c.left.block, d = c.right.block, l = c.right.offset - c.left.offset - c.gap;
      s.vars.length < d.vars.length ? (d.mergeAcross(s, c, l), this.remove(s)) : (s.mergeAcross(d, c, -l), this.remove(d));
    }, i.prototype.forEach = function(c) {
      this.list.forEach(c);
    }, i.prototype.updateBlockPositions = function() {
      this.list.forEach(function(c) {
        return c.updateWeightedPosition();
      });
    }, i.prototype.split = function(c) {
      var s = this;
      this.updateBlockPositions(), this.list.forEach(function(d) {
        var l = d.findMinLM();
        l !== null && l.lm < e.LAGRANGIAN_TOLERANCE && (d = l.left.block, a.split(l).forEach(function(f) {
          return s.insert(f);
        }), s.remove(d), c.push(l));
      });
    }, i;
  }();
  Ii.Blocks = t;
  var e = function() {
    function i(c, s) {
      this.vs = c, this.cs = s, this.vs = c, c.forEach(function(d) {
        d.cIn = [], d.cOut = [];
      }), this.cs = s, s.forEach(function(d) {
        d.left.cOut.push(d), d.right.cIn.push(d);
      }), this.inactive = s.map(function(d) {
        return d.active = !1, d;
      }), this.bs = null;
    }
    return i.prototype.cost = function() {
      return this.bs.cost();
    }, i.prototype.setStartingPositions = function(c) {
      this.inactive = this.cs.map(function(s) {
        return s.active = !1, s;
      }), this.bs = new t(this.vs), this.bs.forEach(function(s, d) {
        return s.posn = c[d];
      });
    }, i.prototype.setDesiredPositions = function(c) {
      this.vs.forEach(function(s, d) {
        return s.desiredPosition = c[d];
      });
    }, i.prototype.mostViolated = function() {
      for (var c = Number.MAX_VALUE, s = null, d = this.inactive, l = d.length, f = l, h = 0; h < l; ++h) {
        var p = d[h];
        if (!p.unsatisfiable) {
          var b = p.slack();
          if ((p.equality || b < c) && (c = b, s = p, f = h, p.equality))
            break;
        }
      }
      return f !== l && (c < i.ZERO_UPPERBOUND && !s.active || s.equality) && (d[f] = d[l - 1], d.length = l - 1), s;
    }, i.prototype.satisfy = function() {
      this.bs == null && (this.bs = new t(this.vs)), this.bs.split(this.inactive);
      for (var c = null; (c = this.mostViolated()) && (c.equality || c.slack() < i.ZERO_UPPERBOUND && !c.active); ) {
        var s = c.left.block, d = c.right.block;
        if (s !== d)
          this.bs.merge(c);
        else {
          if (s.isActiveDirectedPathBetween(c.right, c.left)) {
            c.unsatisfiable = !0;
            continue;
          }
          var l = s.splitBetween(c.left, c.right);
          if (l !== null)
            this.bs.insert(l.lb), this.bs.insert(l.rb), this.bs.remove(s), this.inactive.push(l.constraint);
          else {
            c.unsatisfiable = !0;
            continue;
          }
          c.slack() >= 0 ? this.inactive.push(c) : this.bs.merge(c);
        }
      }
    }, i.prototype.solve = function() {
      this.satisfy();
      for (var c = Number.MAX_VALUE, s = this.bs.cost(); Math.abs(c - s) > 1e-4; )
        this.satisfy(), c = s, s = this.bs.cost();
      return s;
    }, i.LAGRANGIAN_TOLERANCE = -1e-4, i.ZERO_UPPERBOUND = -1e-10, i;
  }();
  Ii.Solver = e;
  function n(i, c, s) {
    for (var d = i.map(function(R) {
      return new o(R.desiredCenter);
    }), l = [], f = i.length, h = 0; h < f - 1; h++) {
      var p = i[h], b = i[h + 1];
      l.push(new r(d[h], d[h + 1], (p.size + b.size) / 2));
    }
    var _ = d[0], y = d[f - 1], m = i[0].size / 2, g = i[f - 1].size / 2, T = null, v = null;
    c && (T = new o(c, _.weight * 1e3), d.push(T), l.push(new r(T, _, m))), s && (v = new o(s, y.weight * 1e3), d.push(v), l.push(new r(y, v, g)));
    var E = new e(d, l);
    return E.solve(), {
      newCenters: d.slice(0, i.length).map(function(R) {
        return R.position();
      }),
      lowerBound: T ? T.position() : _.position() - m,
      upperBound: v ? v.position() : y.position() + g
    };
  }
  return Ii.removeOverlapInOneDimension = n, Ii;
}
var Pa = {}, OX;
function oee() {
  if (OX) return Pa;
  OX = 1;
  var u = Pa && Pa.__extends || /* @__PURE__ */ function() {
    var e = function(n, i) {
      return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, s) {
        c.__proto__ = s;
      } || function(c, s) {
        for (var d in s) s.hasOwnProperty(d) && (c[d] = s[d]);
      }, e(n, i);
    };
    return function(n, i) {
      e(n, i);
      function c() {
        this.constructor = n;
      }
      n.prototype = i === null ? Object.create(i) : (c.prototype = i.prototype, new c());
    };
  }();
  Object.defineProperty(Pa, "__esModule", { value: !0 });
  var r = function() {
    function e() {
      this.findIter = function(n) {
        for (var i = this._root, c = this.iterator(); i !== null; ) {
          var s = this._comparator(n, i.data);
          if (s === 0)
            return c._cursor = i, c;
          c._ancestors.push(i), i = i.get_child(s > 0);
        }
        return null;
      };
    }
    return e.prototype.clear = function() {
      this._root = null, this.size = 0;
    }, e.prototype.find = function(n) {
      for (var i = this._root; i !== null; ) {
        var c = this._comparator(n, i.data);
        if (c === 0)
          return i.data;
        i = i.get_child(c > 0);
      }
      return null;
    }, e.prototype.lowerBound = function(n) {
      return this._bound(n, this._comparator);
    }, e.prototype.upperBound = function(n) {
      var i = this._comparator;
      function c(s, d) {
        return i(d, s);
      }
      return this._bound(n, c);
    }, e.prototype.min = function() {
      var n = this._root;
      if (n === null)
        return null;
      for (; n.left !== null; )
        n = n.left;
      return n.data;
    }, e.prototype.max = function() {
      var n = this._root;
      if (n === null)
        return null;
      for (; n.right !== null; )
        n = n.right;
      return n.data;
    }, e.prototype.iterator = function() {
      return new o(this);
    }, e.prototype.each = function(n) {
      for (var i = this.iterator(), c; (c = i.next()) !== null; )
        n(c);
    }, e.prototype.reach = function(n) {
      for (var i = this.iterator(), c; (c = i.prev()) !== null; )
        n(c);
    }, e.prototype._bound = function(n, i) {
      for (var c = this._root, s = this.iterator(); c !== null; ) {
        var d = this._comparator(n, c.data);
        if (d === 0)
          return s._cursor = c, s;
        s._ancestors.push(c), c = c.get_child(d > 0);
      }
      for (var l = s._ancestors.length - 1; l >= 0; --l)
        if (c = s._ancestors[l], i(n, c.data) > 0)
          return s._cursor = c, s._ancestors.length = l, s;
      return s._ancestors.length = 0, s;
    }, e;
  }();
  Pa.TreeBase = r;
  var o = function() {
    function e(n) {
      this._tree = n, this._ancestors = [], this._cursor = null;
    }
    return e.prototype.data = function() {
      return this._cursor !== null ? this._cursor.data : null;
    }, e.prototype.next = function() {
      if (this._cursor === null) {
        var n = this._tree._root;
        n !== null && this._minNode(n);
      } else if (this._cursor.right === null) {
        var i;
        do
          if (i = this._cursor, this._ancestors.length)
            this._cursor = this._ancestors.pop();
          else {
            this._cursor = null;
            break;
          }
        while (this._cursor.right === i);
      } else
        this._ancestors.push(this._cursor), this._minNode(this._cursor.right);
      return this._cursor !== null ? this._cursor.data : null;
    }, e.prototype.prev = function() {
      if (this._cursor === null) {
        var n = this._tree._root;
        n !== null && this._maxNode(n);
      } else if (this._cursor.left === null) {
        var i;
        do
          if (i = this._cursor, this._ancestors.length)
            this._cursor = this._ancestors.pop();
          else {
            this._cursor = null;
            break;
          }
        while (this._cursor.left === i);
      } else
        this._ancestors.push(this._cursor), this._maxNode(this._cursor.left);
      return this._cursor !== null ? this._cursor.data : null;
    }, e.prototype._minNode = function(n) {
      for (; n.left !== null; )
        this._ancestors.push(n), n = n.left;
      this._cursor = n;
    }, e.prototype._maxNode = function(n) {
      for (; n.right !== null; )
        this._ancestors.push(n), n = n.right;
      this._cursor = n;
    }, e;
  }();
  Pa.Iterator = o;
  var a = function() {
    function e(n) {
      this.data = n, this.left = null, this.right = null, this.red = !0;
    }
    return e.prototype.get_child = function(n) {
      return n ? this.right : this.left;
    }, e.prototype.set_child = function(n, i) {
      n ? this.right = i : this.left = i;
    }, e;
  }(), t = function(e) {
    u(n, e);
    function n(i) {
      var c = e.call(this) || this;
      return c._root = null, c._comparator = i, c.size = 0, c;
    }
    return n.prototype.insert = function(i) {
      var c = !1;
      if (this._root === null)
        this._root = new a(i), c = !0, this.size++;
      else {
        var s = new a(void 0), d = !1, l = !1, f = null, h = s, p = null, b = this._root;
        for (h.right = this._root; ; ) {
          if (b === null ? (b = new a(i), p.set_child(d, b), c = !0, this.size++) : n.is_red(b.left) && n.is_red(b.right) && (b.red = !0, b.left.red = !1, b.right.red = !1), n.is_red(b) && n.is_red(p)) {
            var _ = h.right === f;
            b === p.get_child(l) ? h.set_child(_, n.single_rotate(f, !l)) : h.set_child(_, n.double_rotate(f, !l));
          }
          var y = this._comparator(b.data, i);
          if (y === 0)
            break;
          l = d, d = y < 0, f !== null && (h = f), f = p, p = b, b = b.get_child(d);
        }
        this._root = s.right;
      }
      return this._root.red = !1, c;
    }, n.prototype.remove = function(i) {
      if (this._root === null)
        return !1;
      var c = new a(void 0), s = c;
      s.right = this._root;
      for (var d = null, l = null, f = null, h = !0; s.get_child(h) !== null; ) {
        var p = h;
        l = d, d = s, s = s.get_child(h);
        var b = this._comparator(i, s.data);
        if (h = b > 0, b === 0 && (f = s), !n.is_red(s) && !n.is_red(s.get_child(h))) {
          if (n.is_red(s.get_child(!h))) {
            var _ = n.single_rotate(s, h);
            d.set_child(p, _), d = _;
          } else if (!n.is_red(s.get_child(!h))) {
            var y = d.get_child(!p);
            if (y !== null)
              if (!n.is_red(y.get_child(!p)) && !n.is_red(y.get_child(p)))
                d.red = !1, y.red = !0, s.red = !0;
              else {
                var m = l.right === d;
                n.is_red(y.get_child(p)) ? l.set_child(m, n.double_rotate(d, p)) : n.is_red(y.get_child(!p)) && l.set_child(m, n.single_rotate(d, p));
                var g = l.get_child(m);
                g.red = !0, s.red = !0, g.left.red = !1, g.right.red = !1;
              }
          }
        }
      }
      return f !== null && (f.data = s.data, d.set_child(d.right === s, s.get_child(s.left === null)), this.size--), this._root = c.right, this._root !== null && (this._root.red = !1), f !== null;
    }, n.is_red = function(i) {
      return i !== null && i.red;
    }, n.single_rotate = function(i, c) {
      var s = i.get_child(!c);
      return i.set_child(!c, s.get_child(c)), s.set_child(c, i), i.red = !0, s.red = !1, s;
    }, n.double_rotate = function(i, c) {
      return i.set_child(!c, n.single_rotate(i.get_child(!c), !c)), n.single_rotate(i, c);
    }, n;
  }(r);
  return Pa.RBTree = t, Pa;
}
var xX;
function Pw() {
  if (xX) return Qr;
  xX = 1;
  var u = Qr && Qr.__extends || /* @__PURE__ */ function() {
    var L = function(A, w) {
      return L = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(S, O) {
        S.__proto__ = O;
      } || function(S, O) {
        for (var x in O) O.hasOwnProperty(x) && (S[x] = O[x]);
      }, L(A, w);
    };
    return function(A, w) {
      L(A, w);
      function S() {
        this.constructor = A;
      }
      A.prototype = w === null ? Object.create(w) : (S.prototype = w.prototype, new S());
    };
  }();
  Object.defineProperty(Qr, "__esModule", { value: !0 });
  var r = nI(), o = oee();
  function a(L) {
    return L.bounds = typeof L.leaves < "u" ? L.leaves.reduce(function(A, w) {
      return w.bounds.union(A);
    }, t.empty()) : t.empty(), typeof L.groups < "u" && (L.bounds = L.groups.reduce(function(A, w) {
      return a(w).union(A);
    }, L.bounds)), L.bounds = L.bounds.inflate(L.padding), L.bounds;
  }
  Qr.computeGroupBounds = a;
  var t = function() {
    function L(A, w, S, O) {
      this.x = A, this.X = w, this.y = S, this.Y = O;
    }
    return L.empty = function() {
      return new L(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }, L.prototype.cx = function() {
      return (this.x + this.X) / 2;
    }, L.prototype.cy = function() {
      return (this.y + this.Y) / 2;
    }, L.prototype.overlapX = function(A) {
      var w = this.cx(), S = A.cx();
      return w <= S && A.x < this.X ? this.X - A.x : S <= w && this.x < A.X ? A.X - this.x : 0;
    }, L.prototype.overlapY = function(A) {
      var w = this.cy(), S = A.cy();
      return w <= S && A.y < this.Y ? this.Y - A.y : S <= w && this.y < A.Y ? A.Y - this.y : 0;
    }, L.prototype.setXCentre = function(A) {
      var w = A - this.cx();
      this.x += w, this.X += w;
    }, L.prototype.setYCentre = function(A) {
      var w = A - this.cy();
      this.y += w, this.Y += w;
    }, L.prototype.width = function() {
      return this.X - this.x;
    }, L.prototype.height = function() {
      return this.Y - this.y;
    }, L.prototype.union = function(A) {
      return new L(Math.min(this.x, A.x), Math.max(this.X, A.X), Math.min(this.y, A.y), Math.max(this.Y, A.Y));
    }, L.prototype.lineIntersections = function(A, w, S, O) {
      for (var x = [
        [this.x, this.y, this.X, this.y],
        [this.X, this.y, this.X, this.Y],
        [this.X, this.Y, this.x, this.Y],
        [this.x, this.Y, this.x, this.y]
      ], F = [], j = 0; j < 4; ++j) {
        var q = L.lineIntersection(A, w, S, O, x[j][0], x[j][1], x[j][2], x[j][3]);
        q !== null && F.push({ x: q.x, y: q.y });
      }
      return F;
    }, L.prototype.rayIntersection = function(A, w) {
      var S = this.lineIntersections(this.cx(), this.cy(), A, w);
      return S.length > 0 ? S[0] : null;
    }, L.prototype.vertices = function() {
      return [
        { x: this.x, y: this.y },
        { x: this.X, y: this.y },
        { x: this.X, y: this.Y },
        { x: this.x, y: this.Y }
      ];
    }, L.lineIntersection = function(A, w, S, O, x, F, j, q) {
      var Q = S - A, G = j - x, K = O - w, U = q - F, ae = U * Q - G * K;
      if (ae == 0)
        return null;
      var ye = A - x, pe = w - F, ee = G * pe - U * ye, Te = ee / ae, we = Q * pe - K * ye, Oe = we / ae;
      return Te >= 0 && Te <= 1 && Oe >= 0 && Oe <= 1 ? {
        x: A + Te * Q,
        y: w + Te * K
      } : null;
    }, L.prototype.inflate = function(A) {
      return new L(this.x - A, this.X + A, this.y - A, this.Y + A);
    }, L;
  }();
  Qr.Rectangle = t;
  function e(L, A, w) {
    var S = L.rayIntersection(A.cx(), A.cy()) || { x: L.cx(), y: L.cy() }, O = A.rayIntersection(L.cx(), L.cy()) || { x: A.cx(), y: A.cy() }, x = O.x - S.x, F = O.y - S.y, j = Math.sqrt(x * x + F * F), q = j - w;
    return {
      sourceIntersection: S,
      targetIntersection: O,
      arrowStart: { x: S.x + q * x / j, y: S.y + q * F / j }
    };
  }
  Qr.makeEdgeBetween = e;
  function n(L, A, w) {
    var S = A.rayIntersection(L.x, L.y);
    S || (S = { x: A.cx(), y: A.cy() });
    var O = S.x - L.x, x = S.y - L.y, F = Math.sqrt(O * O + x * x);
    return { x: S.x - w * O / F, y: S.y - w * x / F };
  }
  Qr.makeEdgeTo = n;
  var i = /* @__PURE__ */ function() {
    function L(A, w, S) {
      this.v = A, this.r = w, this.pos = S, this.prev = d(), this.next = d();
    }
    return L;
  }(), c = /* @__PURE__ */ function() {
    function L(A, w, S) {
      this.isOpen = A, this.v = w, this.pos = S;
    }
    return L;
  }();
  function s(L, A) {
    return L.pos > A.pos ? 1 : L.pos < A.pos || L.isOpen ? -1 : A.isOpen ? 1 : 0;
  }
  function d() {
    return new o.RBTree(function(L, A) {
      return L.pos - A.pos;
    });
  }
  var l = {
    getCentre: function(L) {
      return L.cx();
    },
    getOpen: function(L) {
      return L.y;
    },
    getClose: function(L) {
      return L.Y;
    },
    getSize: function(L) {
      return L.width();
    },
    makeRect: function(L, A, w, S) {
      return new t(w - S / 2, w + S / 2, L, A);
    },
    findNeighbours: b
  }, f = {
    getCentre: function(L) {
      return L.cy();
    },
    getOpen: function(L) {
      return L.x;
    },
    getClose: function(L) {
      return L.X;
    },
    getSize: function(L) {
      return L.height();
    },
    makeRect: function(L, A, w, S) {
      return new t(L, A, w - S / 2, w + S / 2);
    },
    findNeighbours: _
  };
  function h(L, A, w, S) {
    S === void 0 && (S = !1);
    var O = L.padding, x = typeof L.groups < "u" ? L.groups.length : 0, F = typeof L.leaves < "u" ? L.leaves.length : 0, j = x ? L.groups.reduce(function(he, V) {
      return he.concat(h(V, A, w, !0));
    }, []) : [], q = (S ? 2 : 0) + F + x, Q = new Array(q), G = new Array(q), K = 0, U = function(he, V) {
      G[K] = he, Q[K++] = V;
    };
    if (S) {
      var ae = L.bounds, ye = A.getCentre(ae), pe = A.getSize(ae) / 2, ee = A.getOpen(ae), Te = A.getClose(ae), we = ye - pe + O / 2, Oe = ye + pe - O / 2;
      L.minVar.desiredPosition = we, U(A.makeRect(ee, Te, we, O), L.minVar), L.maxVar.desiredPosition = Oe, U(A.makeRect(ee, Te, Oe, O), L.maxVar);
    }
    F && L.leaves.forEach(function(he) {
      return U(he.bounds, he.variable);
    }), x && L.groups.forEach(function(he) {
      var V = he.bounds;
      U(A.makeRect(A.getOpen(V), A.getClose(V), A.getCentre(V), A.getSize(V)), he.minVar);
    });
    var be = p(G, Q, A, w);
    return x && (Q.forEach(function(he) {
      he.cOut = [], he.cIn = [];
    }), be.forEach(function(he) {
      he.left.cOut.push(he), he.right.cIn.push(he);
    }), L.groups.forEach(function(he) {
      var V = (he.padding - A.getSize(he.bounds)) / 2;
      he.minVar.cIn.forEach(function(N) {
        return N.gap += V;
      }), he.minVar.cOut.forEach(function(N) {
        N.left = he.maxVar, N.gap += V;
      });
    })), j.concat(be);
  }
  function p(L, A, w, S) {
    var O, x = L.length, F = 2 * x;
    console.assert(A.length >= x);
    var j = new Array(F);
    for (O = 0; O < x; ++O) {
      var q = L[O], Q = new i(A[O], q, w.getCentre(q));
      j[O] = new c(!0, Q, w.getOpen(q)), j[O + x] = new c(!1, Q, w.getClose(q));
    }
    j.sort(s);
    var G = new Array(), K = d();
    for (O = 0; O < F; ++O) {
      var U = j[O], Q = U.v;
      if (U.isOpen)
        K.insert(Q), w.findNeighbours(Q, K);
      else {
        K.remove(Q);
        var ae = function(ee, Te) {
          var we = (w.getSize(ee.r) + w.getSize(Te.r)) / 2 + S;
          G.push(new r.Constraint(ee.v, Te.v, we));
        }, ye = function(ee, Te, we) {
          for (var Oe, be = Q[ee].iterator(); (Oe = be[ee]()) !== null; )
            we(Oe, Q), Oe[Te].remove(Q);
        };
        ye("prev", "next", function(ee, Te) {
          return ae(ee, Te);
        }), ye("next", "prev", function(ee, Te) {
          return ae(Te, ee);
        });
      }
    }
    return console.assert(K.size === 0), G;
  }
  function b(L, A) {
    var w = function(S, O) {
      for (var x = A.findIter(L), F; (F = x[S]()) !== null; ) {
        var j = F.r.overlapX(L.r);
        if ((j <= 0 || j <= F.r.overlapY(L.r)) && (L[S].insert(F), F[O].insert(L)), j <= 0)
          break;
      }
    };
    w("next", "prev"), w("prev", "next");
  }
  function _(L, A) {
    var w = function(S, O) {
      var x = A.findIter(L)[S]();
      x !== null && x.r.overlapX(L.r) > 0 && (L[S].insert(x), x[O].insert(L));
    };
    w("next", "prev"), w("prev", "next");
  }
  function y(L, A) {
    return p(L, A, l, 1e-6);
  }
  Qr.generateXConstraints = y;
  function m(L, A) {
    return p(L, A, f, 1e-6);
  }
  Qr.generateYConstraints = m;
  function g(L) {
    return h(L, l, 1e-6);
  }
  Qr.generateXGroupConstraints = g;
  function T(L) {
    return h(L, f, 1e-6);
  }
  Qr.generateYGroupConstraints = T;
  function v(L) {
    var A = L.map(function(O) {
      return new r.Variable(O.cx());
    }), w = y(L, A), S = new r.Solver(A, w);
    S.solve(), A.forEach(function(O, x) {
      return L[x].setXCentre(O.position());
    }), A = L.map(function(O) {
      return new r.Variable(O.cy());
    }), w = m(L, A), S = new r.Solver(A, w), S.solve(), A.forEach(function(O, x) {
      return L[x].setYCentre(O.position());
    });
  }
  Qr.removeOverlaps = v;
  var E = function(L) {
    u(A, L);
    function A(w, S) {
      var O = L.call(this, 0, S) || this;
      return O.index = w, O;
    }
    return A;
  }(r.Variable);
  Qr.IndexedVariable = E;
  var R = function() {
    function L(A, w, S, O, x) {
      var F = this;
      if (S === void 0 && (S = null), O === void 0 && (O = null), x === void 0 && (x = !1), this.nodes = A, this.groups = w, this.rootGroup = S, this.avoidOverlaps = x, this.variables = A.map(function(q, Q) {
        return q.variable = new E(Q, 1);
      }), O && this.createConstraints(O), x && S && typeof S.groups < "u") {
        A.forEach(function(q) {
          if (!q.width || !q.height) {
            q.bounds = new t(q.x, q.x, q.y, q.y);
            return;
          }
          var Q = q.width / 2, G = q.height / 2;
          q.bounds = new t(q.x - Q, q.x + Q, q.y - G, q.y + G);
        }), a(S);
        var j = A.length;
        w.forEach(function(q) {
          F.variables[j] = q.minVar = new E(j++, typeof q.stiffness < "u" ? q.stiffness : 0.01), F.variables[j] = q.maxVar = new E(j++, typeof q.stiffness < "u" ? q.stiffness : 0.01);
        });
      }
    }
    return L.prototype.createSeparation = function(A) {
      return new r.Constraint(this.nodes[A.left].variable, this.nodes[A.right].variable, A.gap, typeof A.equality < "u" ? A.equality : !1);
    }, L.prototype.makeFeasible = function(A) {
      var w = this;
      if (this.avoidOverlaps) {
        var S = "x", O = "width";
        A.axis === "x" && (S = "y", O = "height");
        var x = A.offsets.map(function(j) {
          return w.nodes[j.node];
        }).sort(function(j, q) {
          return j[S] - q[S];
        }), F = null;
        x.forEach(function(j) {
          if (F) {
            var q = F[S] + F[O];
            q > j[S] && (j[S] = q);
          }
          F = j;
        });
      }
    }, L.prototype.createAlignment = function(A) {
      var w = this, S = this.nodes[A.offsets[0].node].variable;
      this.makeFeasible(A);
      var O = A.axis === "x" ? this.xConstraints : this.yConstraints;
      A.offsets.slice(1).forEach(function(x) {
        var F = w.nodes[x.node].variable;
        O.push(new r.Constraint(S, F, x.offset, !0));
      });
    }, L.prototype.createConstraints = function(A) {
      var w = this, S = function(O) {
        return typeof O.type > "u" || O.type === "separation";
      };
      this.xConstraints = A.filter(function(O) {
        return O.axis === "x" && S(O);
      }).map(function(O) {
        return w.createSeparation(O);
      }), this.yConstraints = A.filter(function(O) {
        return O.axis === "y" && S(O);
      }).map(function(O) {
        return w.createSeparation(O);
      }), A.filter(function(O) {
        return O.type === "alignment";
      }).forEach(function(O) {
        return w.createAlignment(O);
      });
    }, L.prototype.setupVariablesAndBounds = function(A, w, S, O) {
      this.nodes.forEach(function(x, F) {
        x.fixed ? (x.variable.weight = x.fixedWeight ? x.fixedWeight : 1e3, S[F] = O(x)) : x.variable.weight = 1;
        var j = (x.width || 0) / 2, q = (x.height || 0) / 2, Q = A[F], G = w[F];
        x.bounds = new t(Q - j, Q + j, G - q, G + q);
      });
    }, L.prototype.xProject = function(A, w, S) {
      !this.rootGroup && !(this.avoidOverlaps || this.xConstraints) || this.project(A, w, A, S, function(O) {
        return O.px;
      }, this.xConstraints, g, function(O) {
        return O.bounds.setXCentre(S[O.variable.index] = O.variable.position());
      }, function(O) {
        var x = S[O.minVar.index] = O.minVar.position(), F = S[O.maxVar.index] = O.maxVar.position(), j = O.padding / 2;
        O.bounds.x = x - j, O.bounds.X = F + j;
      });
    }, L.prototype.yProject = function(A, w, S) {
      !this.rootGroup && !this.yConstraints || this.project(A, w, w, S, function(O) {
        return O.py;
      }, this.yConstraints, T, function(O) {
        return O.bounds.setYCentre(S[O.variable.index] = O.variable.position());
      }, function(O) {
        var x = S[O.minVar.index] = O.minVar.position(), F = S[O.maxVar.index] = O.maxVar.position(), j = O.padding / 2;
        O.bounds.y = x - j, O.bounds.Y = F + j;
      });
    }, L.prototype.projectFunctions = function() {
      var A = this;
      return [
        function(w, S, O) {
          return A.xProject(w, S, O);
        },
        function(w, S, O) {
          return A.yProject(w, S, O);
        }
      ];
    }, L.prototype.project = function(A, w, S, O, x, F, j, q, Q) {
      this.setupVariablesAndBounds(A, w, O, x), this.rootGroup && this.avoidOverlaps && (a(this.rootGroup), F = F.concat(j(this.rootGroup))), this.solve(this.variables, F, S, O), this.nodes.forEach(q), this.rootGroup && this.avoidOverlaps && (this.groups.forEach(Q), a(this.rootGroup));
    }, L.prototype.solve = function(A, w, S, O) {
      var x = new r.Solver(A, w);
      x.setStartingPositions(S), x.setDesiredPositions(O), x.solve();
    }, L;
  }();
  return Qr.Projection = R, Qr;
}
var k6 = {}, sT = {}, IX;
function see() {
  if (IX) return sT;
  IX = 1, Object.defineProperty(sT, "__esModule", { value: !0 });
  var u = function() {
    function o(a) {
      this.elem = a, this.subheaps = [];
    }
    return o.prototype.toString = function(a) {
      for (var t = "", e = !1, n = 0; n < this.subheaps.length; ++n) {
        var i = this.subheaps[n];
        if (!i.elem) {
          e = !1;
          continue;
        }
        e && (t = t + ","), t = t + i.toString(a), e = !0;
      }
      return t !== "" && (t = "(" + t + ")"), (this.elem ? a(this.elem) : "") + t;
    }, o.prototype.forEach = function(a) {
      this.empty() || (a(this.elem, this), this.subheaps.forEach(function(t) {
        return t.forEach(a);
      }));
    }, o.prototype.count = function() {
      return this.empty() ? 0 : 1 + this.subheaps.reduce(function(a, t) {
        return a + t.count();
      }, 0);
    }, o.prototype.min = function() {
      return this.elem;
    }, o.prototype.empty = function() {
      return this.elem == null;
    }, o.prototype.contains = function(a) {
      if (this === a)
        return !0;
      for (var t = 0; t < this.subheaps.length; t++)
        if (this.subheaps[t].contains(a))
          return !0;
      return !1;
    }, o.prototype.isHeap = function(a) {
      var t = this;
      return this.subheaps.every(function(e) {
        return a(t.elem, e.elem) && e.isHeap(a);
      });
    }, o.prototype.insert = function(a, t) {
      return this.merge(new o(a), t);
    }, o.prototype.merge = function(a, t) {
      return this.empty() ? a : a.empty() ? this : t(this.elem, a.elem) ? (this.subheaps.push(a), this) : (a.subheaps.push(this), a);
    }, o.prototype.removeMin = function(a) {
      return this.empty() ? null : this.mergePairs(a);
    }, o.prototype.mergePairs = function(a) {
      if (this.subheaps.length == 0)
        return new o(null);
      if (this.subheaps.length == 1)
        return this.subheaps[0];
      var t = this.subheaps.pop().merge(this.subheaps.pop(), a), e = this.mergePairs(a);
      return t.merge(e, a);
    }, o.prototype.decreaseKey = function(a, t, e, n) {
      var i = a.removeMin(n);
      a.elem = i.elem, a.subheaps = i.subheaps, e !== null && i.elem !== null && e(a.elem, a);
      var c = new o(t);
      return e !== null && e(t, c), this.merge(c, n);
    }, o;
  }();
  sT.PairingHeap = u;
  var r = function() {
    function o(a) {
      this.lessThan = a;
    }
    return o.prototype.top = function() {
      return this.empty() ? null : this.root.elem;
    }, o.prototype.push = function() {
      for (var a = [], t = 0; t < arguments.length; t++)
        a[t] = arguments[t];
      for (var e, n = 0, i; i = a[n]; ++n)
        e = new u(i), this.root = this.empty() ? e : this.root.merge(e, this.lessThan);
      return e;
    }, o.prototype.empty = function() {
      return !this.root || !this.root.elem;
    }, o.prototype.isHeap = function() {
      return this.root.isHeap(this.lessThan);
    }, o.prototype.forEach = function(a) {
      this.root.forEach(a);
    }, o.prototype.pop = function() {
      if (this.empty())
        return null;
      var a = this.root.min();
      return this.root = this.root.removeMin(this.lessThan), a;
    }, o.prototype.reduceKey = function(a, t, e) {
      e === void 0 && (e = null), this.root = this.root.decreaseKey(a, t, e, this.lessThan);
    }, o.prototype.toString = function(a) {
      return this.root.toString(a);
    }, o.prototype.count = function() {
      return this.root.count();
    }, o;
  }();
  return sT.PriorityQueue = r, sT;
}
var RX;
function p4() {
  if (RX) return k6;
  RX = 1, Object.defineProperty(k6, "__esModule", { value: !0 });
  var u = see(), r = /* @__PURE__ */ function() {
    function e(n, i) {
      this.id = n, this.distance = i;
    }
    return e;
  }(), o = /* @__PURE__ */ function() {
    function e(n) {
      this.id = n, this.neighbours = [];
    }
    return e;
  }(), a = /* @__PURE__ */ function() {
    function e(n, i, c) {
      this.node = n, this.prev = i, this.d = c;
    }
    return e;
  }(), t = function() {
    function e(n, i, c, s, d) {
      this.n = n, this.es = i, this.neighbours = new Array(this.n);
      for (var l = this.n; l--; )
        this.neighbours[l] = new o(l);
      for (l = this.es.length; l--; ) {
        var f = this.es[l], h = c(f), p = s(f), b = d(f);
        this.neighbours[h].neighbours.push(new r(p, b)), this.neighbours[p].neighbours.push(new r(h, b));
      }
    }
    return e.prototype.DistanceMatrix = function() {
      for (var n = new Array(this.n), i = 0; i < this.n; ++i)
        n[i] = this.dijkstraNeighbours(i);
      return n;
    }, e.prototype.DistancesFromNode = function(n) {
      return this.dijkstraNeighbours(n);
    }, e.prototype.PathFromNodeToNode = function(n, i) {
      return this.dijkstraNeighbours(n, i);
    }, e.prototype.PathFromNodeToNodeWithPrevCost = function(n, i, c) {
      var s = new u.PriorityQueue(function(T, v) {
        return T.d <= v.d;
      }), d = this.neighbours[n], l = new a(d, null, 0), f = {};
      for (s.push(l); !s.empty() && (l = s.pop(), d = l.node, d.id !== i); )
        for (var h = d.neighbours.length; h--; ) {
          var p = d.neighbours[h], b = this.neighbours[p.id];
          if (!(l.prev && b.id === l.prev.node.id)) {
            var _ = b.id + "," + d.id;
            if (!(_ in f && f[_] <= l.d)) {
              var y = l.prev ? c(l.prev.node.id, d.id, b.id) : 0, m = l.d + p.distance + y;
              f[_] = m, s.push(new a(b, l, m));
            }
          }
        }
      for (var g = []; l.prev; )
        l = l.prev, g.push(l.node.id);
      return g;
    }, e.prototype.dijkstraNeighbours = function(n, i) {
      i === void 0 && (i = -1);
      for (var c = new u.PriorityQueue(function(y, m) {
        return y.d <= m.d;
      }), s = this.neighbours.length, d = new Array(s); s--; ) {
        var l = this.neighbours[s];
        l.d = s === n ? 0 : Number.POSITIVE_INFINITY, l.q = c.push(l);
      }
      for (; !c.empty(); ) {
        var f = c.pop();
        if (d[f.id] = f.d, f.id === i) {
          for (var h = [], p = f; typeof p.prev < "u"; )
            h.push(p.prev.id), p = p.prev;
          return h;
        }
        for (s = f.neighbours.length; s--; ) {
          var b = f.neighbours[s], p = this.neighbours[b.id], _ = f.d + b.distance;
          f.d !== Number.MAX_VALUE && p.d > _ && (p.d = _, p.prev = f, c.reduceKey(p.q, p, function(m, g) {
            return m.q = g;
          }));
        }
      }
      return d;
    }, e;
  }();
  return k6.Calculator = t, k6;
}
var ir = {}, FX;
function cee() {
  if (FX) return ir;
  FX = 1;
  var u = ir && ir.__extends || /* @__PURE__ */ function() {
    var x = function(F, j) {
      return x = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(q, Q) {
        q.__proto__ = Q;
      } || function(q, Q) {
        for (var G in Q) Q.hasOwnProperty(G) && (q[G] = Q[G]);
      }, x(F, j);
    };
    return function(F, j) {
      x(F, j);
      function q() {
        this.constructor = F;
      }
      F.prototype = j === null ? Object.create(j) : (q.prototype = j.prototype, new q());
    };
  }();
  Object.defineProperty(ir, "__esModule", { value: !0 });
  var r = Pw(), o = /* @__PURE__ */ function() {
    function x() {
    }
    return x;
  }();
  ir.Point = o;
  var a = /* @__PURE__ */ function() {
    function x(F, j, q, Q) {
      this.x1 = F, this.y1 = j, this.x2 = q, this.y2 = Q;
    }
    return x;
  }();
  ir.LineSegment = a;
  var t = function(x) {
    u(F, x);
    function F() {
      return x !== null && x.apply(this, arguments) || this;
    }
    return F;
  }(o);
  ir.PolyPoint = t;
  function e(x, F, j) {
    return (F.x - x.x) * (j.y - x.y) - (j.x - x.x) * (F.y - x.y);
  }
  ir.isLeft = e;
  function n(x, F, j) {
    return e(x, F, j) > 0;
  }
  function i(x, F, j) {
    return e(x, F, j) < 0;
  }
  function c(x) {
    var F = x.slice(0).sort(function(Te, we) {
      return Te.x !== we.x ? we.x - Te.x : we.y - Te.y;
    }), j = x.length, q, Q = 0, G = F[0].x;
    for (q = 1; q < j && F[q].x === G; ++q)
      ;
    var K = q - 1, U = [];
    if (U.push(F[Q]), K === j - 1)
      F[K].y !== F[Q].y && U.push(F[K]);
    else {
      var ae, ye = j - 1, pe = F[j - 1].x;
      for (q = j - 2; q >= 0 && F[q].x === pe; q--)
        ;
      for (ae = q + 1, q = K; ++q <= ae; )
        if (!(e(F[Q], F[ae], F[q]) >= 0 && q < ae)) {
          for (; U.length > 1 && !(e(U[U.length - 2], U[U.length - 1], F[q]) > 0); )
            U.length -= 1;
          q != Q && U.push(F[q]);
        }
      ye != ae && U.push(F[ye]);
      var ee = U.length;
      for (q = ae; --q >= K; )
        if (!(e(F[ye], F[K], F[q]) >= 0 && q > K)) {
          for (; U.length > ee && !(e(U[U.length - 2], U[U.length - 1], F[q]) > 0); )
            U.length -= 1;
          q != Q && U.push(F[q]);
        }
    }
    return U;
  }
  ir.ConvexHull = c;
  function s(x, F, j) {
    F.slice(0).sort(function(q, Q) {
      return Math.atan2(q.y - x.y, q.x - x.x) - Math.atan2(Q.y - x.y, Q.x - x.x);
    }).forEach(j);
  }
  ir.clockwiseRadialSweep = s;
  function d(x, F) {
    var j = F.slice(0);
    return j.push(F[0]), { rtan: l(x, j), ltan: f(x, j) };
  }
  function l(x, F) {
    var j = F.length - 1, q, Q, G, K, U;
    if (i(x, F[1], F[0]) && !n(x, F[j - 1], F[0]))
      return 0;
    for (q = 0, Q = j; ; ) {
      if (Q - q === 1)
        return n(x, F[q], F[Q]) ? q : Q;
      if (G = Math.floor((q + Q) / 2), U = i(x, F[G + 1], F[G]), U && !n(x, F[G - 1], F[G]))
        return G;
      K = n(x, F[q + 1], F[q]), K ? U || n(x, F[q], F[G]) ? Q = G : q = G : U && i(x, F[q], F[G]) ? Q = G : q = G;
    }
  }
  function f(x, F) {
    var j = F.length - 1, q, Q, G, K, U;
    if (n(x, F[j - 1], F[0]) && !i(x, F[1], F[0]))
      return 0;
    for (q = 0, Q = j; ; ) {
      if (Q - q === 1)
        return i(x, F[q], F[Q]) ? q : Q;
      if (G = Math.floor((q + Q) / 2), U = i(x, F[G + 1], F[G]), n(x, F[G - 1], F[G]) && !U)
        return G;
      K = i(x, F[q + 1], F[q]), K ? U ? i(x, F[q], F[G]) ? Q = G : q = G : Q = G : U ? q = G : n(x, F[q], F[G]) ? Q = G : q = G;
    }
  }
  function h(x, F, j, q, Q, G) {
    var K, U;
    K = j(F[0], x), U = q(x[K], F);
    for (var ae = !1; !ae; ) {
      for (ae = !0; K === x.length - 1 && (K = 0), !Q(F[U], x[K], x[K + 1]); )
        ++K;
      for (; U === 0 && (U = F.length - 1), !G(x[K], F[U], F[U - 1]); )
        --U, ae = !1;
    }
    return { t1: K, t2: U };
  }
  ir.tangent_PolyPolyC = h;
  function p(x, F) {
    var j = b(F, x);
    return { t1: j.t2, t2: j.t1 };
  }
  ir.LRtangent_PolyPolyC = p;
  function b(x, F) {
    return h(x, F, l, f, n, i);
  }
  ir.RLtangent_PolyPolyC = b;
  function _(x, F) {
    return h(x, F, f, f, i, i);
  }
  ir.LLtangent_PolyPolyC = _;
  function y(x, F) {
    return h(x, F, l, l, n, n);
  }
  ir.RRtangent_PolyPolyC = y;
  var m = /* @__PURE__ */ function() {
    function x(F, j) {
      this.t1 = F, this.t2 = j;
    }
    return x;
  }();
  ir.BiTangent = m;
  var g = /* @__PURE__ */ function() {
    function x() {
    }
    return x;
  }();
  ir.BiTangents = g;
  var T = function(x) {
    u(F, x);
    function F() {
      return x !== null && x.apply(this, arguments) || this;
    }
    return F;
  }(o);
  ir.TVGPoint = T;
  var v = /* @__PURE__ */ function() {
    function x(F, j, q, Q) {
      this.id = F, this.polyid = j, this.polyvertid = q, this.p = Q, Q.vv = this;
    }
    return x;
  }();
  ir.VisibilityVertex = v;
  var E = function() {
    function x(F, j) {
      this.source = F, this.target = j;
    }
    return x.prototype.length = function() {
      var F = this.source.p.x - this.target.p.x, j = this.source.p.y - this.target.p.y;
      return Math.sqrt(F * F + j * j);
    }, x;
  }();
  ir.VisibilityEdge = E;
  var R = function() {
    function x(F, j) {
      if (this.P = F, this.V = [], this.E = [], j)
        this.V = j.V.slice(0), this.E = j.E.slice(0);
      else {
        for (var q = F.length, Q = 0; Q < q; Q++) {
          for (var G = F[Q], K = 0; K < G.length; ++K) {
            var U = G[K], ae = new v(this.V.length, Q, K, U);
            this.V.push(ae), K > 0 && this.E.push(new E(G[K - 1].vv, ae));
          }
          G.length > 1 && this.E.push(new E(G[0].vv, G[G.length - 1].vv));
        }
        for (var Q = 0; Q < q - 1; Q++)
          for (var ye = F[Q], K = Q + 1; K < q; K++) {
            var pe = F[K], ee = A(ye, pe);
            for (var Te in ee) {
              var we = ee[Te], Oe = ye[we.t1], be = pe[we.t2];
              this.addEdgeIfVisible(Oe, be, Q, K);
            }
          }
      }
    }
    return x.prototype.addEdgeIfVisible = function(F, j, q, Q) {
      this.intersectsPolys(new a(F.x, F.y, j.x, j.y), q, Q) || this.E.push(new E(F.vv, j.vv));
    }, x.prototype.addPoint = function(F, j) {
      var q = this.P.length;
      this.V.push(new v(this.V.length, q, 0, F));
      for (var Q = 0; Q < q; ++Q)
        if (Q !== j) {
          var G = this.P[Q], K = d(F, G);
          this.addEdgeIfVisible(F, G[K.ltan], j, Q), this.addEdgeIfVisible(F, G[K.rtan], j, Q);
        }
      return F.vv;
    }, x.prototype.intersectsPolys = function(F, j, q) {
      for (var Q = 0, G = this.P.length; Q < G; ++Q)
        if (Q != j && Q != q && L(F, this.P[Q]).length > 0)
          return !0;
      return !1;
    }, x;
  }();
  ir.TangentVisibilityGraph = R;
  function L(x, F) {
    for (var j = [], q = 1, Q = F.length; q < Q; ++q) {
      var G = r.Rectangle.lineIntersection(x.x1, x.y1, x.x2, x.y2, F[q - 1].x, F[q - 1].y, F[q].x, F[q].y);
      G && j.push(G);
    }
    return j;
  }
  function A(x, F) {
    for (var j = x.length - 1, q = F.length - 1, Q = new g(), G = 0; G < j; ++G)
      for (var K = 0; K < q; ++K) {
        var U = x[G == 0 ? j - 1 : G - 1], ae = x[G], ye = x[G + 1], pe = F[K == 0 ? q - 1 : K - 1], ee = F[K], Te = F[K + 1], we = e(U, ae, ee), Oe = e(ae, pe, ee), be = e(ae, ee, Te), he = e(pe, ee, ae), V = e(ee, U, ae), N = e(ee, ae, ye);
        we >= 0 && Oe >= 0 && be < 0 && he >= 0 && V >= 0 && N < 0 ? Q.ll = new m(G, K) : we <= 0 && Oe <= 0 && be > 0 && he <= 0 && V <= 0 && N > 0 ? Q.rr = new m(G, K) : we <= 0 && Oe > 0 && be <= 0 && he >= 0 && V < 0 && N >= 0 ? Q.rl = new m(G, K) : we >= 0 && Oe < 0 && be >= 0 && he <= 0 && V > 0 && N <= 0 && (Q.lr = new m(G, K));
      }
    return Q;
  }
  ir.tangents = A;
  function w(x, F) {
    for (var j = 1, q = F.length; j < q; ++j)
      if (i(F[j - 1], F[j], x))
        return !1;
    return !0;
  }
  function S(x, F) {
    return !x.every(function(j) {
      return !w(j, F);
    });
  }
  function O(x, F) {
    if (S(x, F) || S(F, x))
      return !0;
    for (var j = 1, q = x.length; j < q; ++j) {
      var Q = x[j], G = x[j - 1];
      if (L(new a(G.x, G.y, Q.x, Q.y), F).length > 0)
        return !0;
    }
    return !1;
  }
  return ir.polysOverlap = O, ir;
}
var cT = {}, NX;
function dee() {
  if (NX) return cT;
  NX = 1, Object.defineProperty(cT, "__esModule", { value: !0 });
  var u = {
    PADDING: 10,
    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
    FLOAT_EPSILON: 1e-4
  };
  function r(a, t, e, p, h, c) {
    h === void 0 && (h = 1), c === void 0 && (c = !0);
    var s = 0, d = 0, l = t, f = e, h = typeof h < "u" ? h : 1, p = typeof p < "u" ? p : 0, b = 0, _ = 0, y = 0, m = 0, g = [];
    if (a.length == 0)
      return;
    T(a), E(a), c && v(a);
    function T(S) {
      S.forEach(function(x) {
        O(x);
      });
      function O(x) {
        var F = Number.MAX_VALUE, j = Number.MAX_VALUE, q = 0, Q = 0;
        x.array.forEach(function(G) {
          var K = typeof G.width < "u" ? G.width : p, U = typeof G.height < "u" ? G.height : p;
          K /= 2, U /= 2, q = Math.max(G.x + K, q), F = Math.min(G.x - K, F), Q = Math.max(G.y + U, Q), j = Math.min(G.y - U, j);
        }), x.width = q - F, x.height = Q - j;
      }
    }
    function v(S) {
      S.forEach(function(O) {
        var x = { x: 0, y: 0 };
        O.array.forEach(function(q) {
          x.x += q.x, x.y += q.y;
        }), x.x /= O.array.length, x.y /= O.array.length;
        var F = { x: x.x - O.width / 2, y: x.y - O.height / 2 }, j = { x: O.x - F.x + l / 2 - b / 2, y: O.y - F.y + f / 2 - _ / 2 };
        O.array.forEach(function(q) {
          q.x += j.x, q.y += j.y;
        });
      });
    }
    function E(S, O) {
      var x = Number.POSITIVE_INFINITY, F = 0;
      S.sort(function(Te, we) {
        return we.height - Te.height;
      }), y = S.reduce(function(Te, we) {
        return Te.width < we.width ? Te.width : we.width;
      });
      for (var j = pe = y, q = ee = A(S), Q = 0, G = Number.MAX_VALUE, K = Number.MAX_VALUE, U = -1, ae = Number.MAX_VALUE, ye = Number.MAX_VALUE; ae > y || ye > u.FLOAT_EPSILON; ) {
        if (U != 1)
          var pe = q - (q - j) / u.GOLDEN_SECTION, G = R(S, pe);
        if (U != 0)
          var ee = j + (q - j) / u.GOLDEN_SECTION, K = R(S, ee);
        if (ae = Math.abs(pe - ee), ye = Math.abs(G - K), G < x && (x = G, F = pe), K < x && (x = K, F = ee), G > K ? (j = pe, pe = ee, G = K, U = 1) : (q = ee, ee = pe, K = G, U = 0), Q++ > 100)
          break;
      }
      R(S, F);
    }
    function R(S, O) {
      g = [], b = 0, _ = 0, m = d;
      for (var x = 0; x < S.length; x++) {
        var F = S[x];
        L(F, O);
      }
      return Math.abs(w() - h);
    }
    function L(S, O) {
      for (var x = void 0, F = 0; F < g.length; F++)
        if (g[F].space_left >= S.height && g[F].x + g[F].width + S.width + u.PADDING - O <= u.FLOAT_EPSILON) {
          x = g[F];
          break;
        }
      g.push(S), x !== void 0 ? (S.x = x.x + x.width + u.PADDING, S.y = x.bottom, S.space_left = S.height, S.bottom = S.y, x.space_left -= S.height + u.PADDING, x.bottom += S.height + u.PADDING) : (S.y = m, m += S.height + u.PADDING, S.x = s, S.bottom = S.y, S.space_left = S.height), S.y + S.height - _ > -1e-4 && (_ = S.y + S.height - d), S.x + S.width - b > -1e-4 && (b = S.x + S.width - s);
    }
    function A(S) {
      var O = 0;
      return S.forEach(function(x) {
        return O += x.width + u.PADDING;
      }), O;
    }
    function w() {
      return b / _;
    }
  }
  cT.applyPacking = r;
  function o(a, t) {
    for (var e = {}, n = {}, i = [], c = 0, s = 0; s < t.length; s++) {
      var d = t[s], l = d.source, f = d.target;
      n[l.index] ? n[l.index].push(f) : n[l.index] = [f], n[f.index] ? n[f.index].push(l) : n[f.index] = [l];
    }
    for (var s = 0; s < a.length; s++) {
      var h = a[s];
      e[h.index] || p(h, !0);
    }
    function p(b, _) {
      if (e[b.index] === void 0) {
        _ && (c++, i.push({ array: [] })), e[b.index] = c, i[c - 1].array.push(b);
        var y = n[b.index];
        if (y)
          for (var m = 0; m < y.length; m++)
            p(y[m], !1);
      }
    }
    return i;
  }
  return cT.separateGraphs = o, cT;
}
var PX;
function Dw() {
  return PX || (PX = 1, function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 });
    var r = uee(), o = tI(), a = rI(), t = Pw(), e = p4(), n = cee(), i = dee(), c;
    (function(l) {
      l[l.start = 0] = "start", l[l.tick = 1] = "tick", l[l.end = 2] = "end";
    })(c = u.EventType || (u.EventType = {}));
    function s(l) {
      return typeof l.leaves < "u" || typeof l.groups < "u";
    }
    var d = function() {
      function l() {
        var f = this;
        this._canvasSize = [1, 1], this._linkDistance = 20, this._defaultNodeSize = 10, this._linkLengthCalculator = null, this._linkType = null, this._avoidOverlaps = !1, this._handleDisconnected = !0, this._running = !1, this._nodes = [], this._groups = [], this._rootGroup = null, this._links = [], this._constraints = [], this._distanceMatrix = null, this._descent = null, this._directedLinkConstraints = null, this._threshold = 0.01, this._visibilityGraph = null, this._groupCompactness = 1e-6, this.event = null, this.linkAccessor = {
          getSourceIndex: l.getSourceIndex,
          getTargetIndex: l.getTargetIndex,
          setLength: l.setLinkLength,
          getType: function(h) {
            return typeof f._linkType == "function" ? f._linkType(h) : 0;
          }
        };
      }
      return l.prototype.on = function(f, h) {
        return this.event || (this.event = {}), typeof f == "string" ? this.event[c[f]] = h : this.event[f] = h, this;
      }, l.prototype.trigger = function(f) {
        this.event && typeof this.event[f.type] < "u" && this.event[f.type](f);
      }, l.prototype.kick = function() {
        for (; !this.tick(); )
          ;
      }, l.prototype.tick = function() {
        if (this._alpha < this._threshold)
          return this._running = !1, this.trigger({ type: c.end, alpha: this._alpha = 0, stress: this._lastStress }), !0;
        var f = this._nodes.length;
        this._links.length;
        var h, p;
        for (this._descent.locks.clear(), p = 0; p < f; ++p)
          if (h = this._nodes[p], h.fixed) {
            (typeof h.px > "u" || typeof h.py > "u") && (h.px = h.x, h.py = h.y);
            var b = [h.px, h.py];
            this._descent.locks.add(p, b);
          }
        var _ = this._descent.rungeKutta();
        return _ === 0 ? this._alpha = 0 : typeof this._lastStress < "u" && (this._alpha = _), this._lastStress = _, this.updateNodePositions(), this.trigger({ type: c.tick, alpha: this._alpha, stress: this._lastStress }), !1;
      }, l.prototype.updateNodePositions = function() {
        for (var f = this._descent.x[0], h = this._descent.x[1], p, b = this._nodes.length; b--; )
          p = this._nodes[b], p.x = f[b], p.y = h[b];
      }, l.prototype.nodes = function(f) {
        if (!f) {
          if (this._nodes.length === 0 && this._links.length > 0) {
            var h = 0;
            this._links.forEach(function(b) {
              h = Math.max(h, b.source, b.target);
            }), this._nodes = new Array(++h);
            for (var p = 0; p < h; ++p)
              this._nodes[p] = {};
          }
          return this._nodes;
        }
        return this._nodes = f, this;
      }, l.prototype.groups = function(f) {
        var h = this;
        return f ? (this._groups = f, this._rootGroup = {}, this._groups.forEach(function(p) {
          typeof p.padding > "u" && (p.padding = 1), typeof p.leaves < "u" && p.leaves.forEach(function(b, _) {
            typeof b == "number" && ((p.leaves[_] = h._nodes[b]).parent = p);
          }), typeof p.groups < "u" && p.groups.forEach(function(b, _) {
            typeof b == "number" && ((p.groups[_] = h._groups[b]).parent = p);
          });
        }), this._rootGroup.leaves = this._nodes.filter(function(p) {
          return typeof p.parent > "u";
        }), this._rootGroup.groups = this._groups.filter(function(p) {
          return typeof p.parent > "u";
        }), this) : this._groups;
      }, l.prototype.powerGraphGroups = function(f) {
        var h = r.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        return this.groups(h.groups), f(h), this;
      }, l.prototype.avoidOverlaps = function(f) {
        return arguments.length ? (this._avoidOverlaps = f, this) : this._avoidOverlaps;
      }, l.prototype.handleDisconnected = function(f) {
        return arguments.length ? (this._handleDisconnected = f, this) : this._handleDisconnected;
      }, l.prototype.flowLayout = function(f, h) {
        return arguments.length || (f = "y"), this._directedLinkConstraints = {
          axis: f,
          getMinSeparation: typeof h == "number" ? function() {
            return h;
          } : h
        }, this;
      }, l.prototype.links = function(f) {
        return arguments.length ? (this._links = f, this) : this._links;
      }, l.prototype.constraints = function(f) {
        return arguments.length ? (this._constraints = f, this) : this._constraints;
      }, l.prototype.distanceMatrix = function(f) {
        return arguments.length ? (this._distanceMatrix = f, this) : this._distanceMatrix;
      }, l.prototype.size = function(f) {
        return f ? (this._canvasSize = f, this) : this._canvasSize;
      }, l.prototype.defaultNodeSize = function(f) {
        return f ? (this._defaultNodeSize = f, this) : this._defaultNodeSize;
      }, l.prototype.groupCompactness = function(f) {
        return f ? (this._groupCompactness = f, this) : this._groupCompactness;
      }, l.prototype.linkDistance = function(f) {
        return f ? (this._linkDistance = typeof f == "function" ? f : +f, this._linkLengthCalculator = null, this) : this._linkDistance;
      }, l.prototype.linkType = function(f) {
        return this._linkType = f, this;
      }, l.prototype.convergenceThreshold = function(f) {
        return f ? (this._threshold = typeof f == "function" ? f : +f, this) : this._threshold;
      }, l.prototype.alpha = function(f) {
        return arguments.length ? (f = +f, this._alpha ? f > 0 ? this._alpha = f : this._alpha = 0 : f > 0 && (this._running || (this._running = !0, this.trigger({ type: c.start, alpha: this._alpha = f }), this.kick())), this) : this._alpha;
      }, l.prototype.getLinkLength = function(f) {
        return typeof this._linkDistance == "function" ? +this._linkDistance(f) : this._linkDistance;
      }, l.setLinkLength = function(f, h) {
        f.length = h;
      }, l.prototype.getLinkType = function(f) {
        return typeof this._linkType == "function" ? this._linkType(f) : 0;
      }, l.prototype.symmetricDiffLinkLengths = function(f, h) {
        var p = this;
        return h === void 0 && (h = 1), this.linkDistance(function(b) {
          return f * b.length;
        }), this._linkLengthCalculator = function() {
          return o.symmetricDiffLinkLengths(p._links, p.linkAccessor, h);
        }, this;
      }, l.prototype.jaccardLinkLengths = function(f, h) {
        var p = this;
        return h === void 0 && (h = 1), this.linkDistance(function(b) {
          return f * b.length;
        }), this._linkLengthCalculator = function() {
          return o.jaccardLinkLengths(p._links, p.linkAccessor, h);
        }, this;
      }, l.prototype.start = function(f, h, p, b, _, y) {
        var m = this;
        f === void 0 && (f = 0), h === void 0 && (h = 0), p === void 0 && (p = 0), b === void 0 && (b = 0), _ === void 0 && (_ = !0), y === void 0 && (y = !0);
        var g, T = this.nodes().length, v = T + 2 * this._groups.length;
        this._links.length;
        var E = this._canvasSize[0], R = this._canvasSize[1], L = new Array(v), A = new Array(v), w = null, S = this._avoidOverlaps;
        this._nodes.forEach(function(K, U) {
          K.index = U, typeof K.x > "u" && (K.x = E / 2, K.y = R / 2), L[U] = K.x, A[U] = K.y;
        }), this._linkLengthCalculator && this._linkLengthCalculator();
        var O;
        this._distanceMatrix ? O = this._distanceMatrix : (O = new e.Calculator(v, this._links, l.getSourceIndex, l.getTargetIndex, function(K) {
          return m.getLinkLength(K);
        }).DistanceMatrix(), w = a.Descent.createSquareMatrix(v, function() {
          return 2;
        }), this._links.forEach(function(K) {
          typeof K.source == "number" && (K.source = m._nodes[K.source]), typeof K.target == "number" && (K.target = m._nodes[K.target]);
        }), this._links.forEach(function(K) {
          var U = l.getSourceIndex(K), ae = l.getTargetIndex(K);
          w[U][ae] = w[ae][U] = K.weight || 1;
        }));
        var x = a.Descent.createSquareMatrix(v, function(K, U) {
          return O[K][U];
        });
        if (this._rootGroup && typeof this._rootGroup.groups < "u") {
          var g = T, F = function(U, ae, ye, pe) {
            w[U][ae] = w[ae][U] = ye, x[U][ae] = x[ae][U] = pe;
          };
          this._groups.forEach(function(U) {
            F(g, g + 1, m._groupCompactness, 0.1), L[g] = 0, A[g++] = 0, L[g] = 0, A[g++] = 0;
          });
        } else
          this._rootGroup = { leaves: this._nodes, groups: [] };
        var j = this._constraints || [];
        this._directedLinkConstraints && (this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation, j = j.concat(o.generateDirectedEdgeConstraints(T, this._links, this._directedLinkConstraints.axis, this.linkAccessor))), this.avoidOverlaps(!1), this._descent = new a.Descent([L, A], x), this._descent.locks.clear();
        for (var g = 0; g < T; ++g) {
          var q = this._nodes[g];
          if (q.fixed) {
            q.px = q.x, q.py = q.y;
            var Q = [q.x, q.y];
            this._descent.locks.add(g, Q);
          }
        }
        if (this._descent.threshold = this._threshold, this.initialLayout(f, L, A), j.length > 0 && (this._descent.project = new t.Projection(this._nodes, this._groups, this._rootGroup, j).projectFunctions()), this._descent.run(h), this.separateOverlappingComponents(E, R, y), this.avoidOverlaps(S), S && (this._nodes.forEach(function(K, U) {
          K.x = L[U], K.y = A[U];
        }), this._descent.project = new t.Projection(this._nodes, this._groups, this._rootGroup, j, !0).projectFunctions(), this._nodes.forEach(function(K, U) {
          L[U] = K.x, A[U] = K.y;
        })), this._descent.G = w, this._descent.run(p), b) {
          this._descent.snapStrength = 1e3, this._descent.snapGridSize = this._nodes[0].width, this._descent.numGridSnapNodes = T, this._descent.scaleSnapByMaxH = T != v;
          var G = a.Descent.createSquareMatrix(v, function(K, U) {
            return K >= T || U >= T ? w[K][U] : 0;
          });
          this._descent.G = G, this._descent.run(b);
        }
        return this.updateNodePositions(), this.separateOverlappingComponents(E, R, y), _ ? this.resume() : this;
      }, l.prototype.initialLayout = function(f, h, p) {
        if (this._groups.length > 0 && f > 0) {
          var b = this._nodes.length, _ = this._links.map(function(m) {
            return { source: m.source.index, target: m.target.index };
          }), y = this._nodes.map(function(m) {
            return { index: m.index };
          });
          this._groups.forEach(function(m, g) {
            y.push({ index: m.index = b + g });
          }), this._groups.forEach(function(m, g) {
            typeof m.leaves < "u" && m.leaves.forEach(function(T) {
              return _.push({ source: m.index, target: T.index });
            }), typeof m.groups < "u" && m.groups.forEach(function(T) {
              return _.push({ source: m.index, target: T.index });
            });
          }), new l().size(this.size()).nodes(y).links(_).avoidOverlaps(!1).linkDistance(this.linkDistance()).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(f, 0, 0, 0, !1), this._nodes.forEach(function(m) {
            h[m.index] = y[m.index].x, p[m.index] = y[m.index].y;
          });
        } else
          this._descent.run(f);
      }, l.prototype.separateOverlappingComponents = function(f, h, p) {
        var b = this;
        if (p === void 0 && (p = !0), !this._distanceMatrix && this._handleDisconnected) {
          var _ = this._descent.x[0], y = this._descent.x[1];
          this._nodes.forEach(function(g, T) {
            g.x = _[T], g.y = y[T];
          });
          var m = i.separateGraphs(this._nodes, this._links);
          i.applyPacking(m, f, h, this._defaultNodeSize, 1, p), this._nodes.forEach(function(g, T) {
            b._descent.x[0][T] = g.x, b._descent.x[1][T] = g.y, g.bounds && (g.bounds.setXCentre(g.x), g.bounds.setYCentre(g.y));
          });
        }
      }, l.prototype.resume = function() {
        return this.alpha(0.1);
      }, l.prototype.stop = function() {
        return this.alpha(0);
      }, l.prototype.prepareEdgeRouting = function(f) {
        f === void 0 && (f = 0), this._visibilityGraph = new n.TangentVisibilityGraph(this._nodes.map(function(h) {
          return h.bounds.inflate(-f).vertices();
        }));
      }, l.prototype.routeEdge = function(f, h, p) {
        h === void 0 && (h = 5);
        var b = [], _ = new n.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), y = { x: f.source.x, y: f.source.y }, m = { x: f.target.x, y: f.target.y }, g = _.addPoint(y, f.source.index), T = _.addPoint(m, f.target.index);
        _.addEdgeIfVisible(y, m, f.source.index, f.target.index), typeof p < "u" && p(_);
        var v = function(j) {
          return j.source.id;
        }, E = function(j) {
          return j.target.id;
        }, R = function(j) {
          return j.length();
        }, L = new e.Calculator(_.V.length, _.E, v, E, R), A = L.PathFromNodeToNode(g.id, T.id);
        if (A.length === 1 || A.length === _.V.length) {
          var w = t.makeEdgeBetween(f.source.innerBounds, f.target.innerBounds, h);
          b = [w.sourceIntersection, w.arrowStart];
        } else {
          for (var S = A.length - 2, O = _.V[A[S]].p, x = _.V[A[0]].p, b = [f.source.innerBounds.rayIntersection(O.x, O.y)], F = S; F >= 0; --F)
            b.push(_.V[A[F]].p);
          b.push(t.makeEdgeTo(x, f.target.innerBounds, h));
        }
        return b;
      }, l.getSourceIndex = function(f) {
        return typeof f.source == "number" ? f.source : f.source.index;
      }, l.getTargetIndex = function(f) {
        return typeof f.target == "number" ? f.target : f.target.index;
      }, l.linkId = function(f) {
        return l.getSourceIndex(f) + "-" + l.getTargetIndex(f);
      }, l.dragStart = function(f) {
        s(f) ? l.storeOffset(f, l.dragOrigin(f)) : (l.stopNode(f), f.fixed |= 2);
      }, l.stopNode = function(f) {
        f.px = f.x, f.py = f.y;
      }, l.storeOffset = function(f, h) {
        typeof f.leaves < "u" && f.leaves.forEach(function(p) {
          p.fixed |= 2, l.stopNode(p), p._dragGroupOffsetX = p.x - h.x, p._dragGroupOffsetY = p.y - h.y;
        }), typeof f.groups < "u" && f.groups.forEach(function(p) {
          return l.storeOffset(p, h);
        });
      }, l.dragOrigin = function(f) {
        return s(f) ? {
          x: f.bounds.cx(),
          y: f.bounds.cy()
        } : f;
      }, l.drag = function(f, h) {
        s(f) ? (typeof f.leaves < "u" && f.leaves.forEach(function(p) {
          f.bounds.setXCentre(h.x), f.bounds.setYCentre(h.y), p.px = p._dragGroupOffsetX + h.x, p.py = p._dragGroupOffsetY + h.y;
        }), typeof f.groups < "u" && f.groups.forEach(function(p) {
          return l.drag(p, h);
        })) : (f.px = h.x, f.py = h.y);
      }, l.dragEnd = function(f) {
        s(f) ? (typeof f.leaves < "u" && f.leaves.forEach(function(h) {
          l.dragEnd(h), delete h._dragGroupOffsetX, delete h._dragGroupOffsetY;
        }), typeof f.groups < "u" && f.groups.forEach(l.dragEnd)) : f.fixed &= -7;
      }, l.mouseOver = function(f) {
        f.fixed |= 4, f.px = f.x, f.py = f.y;
      }, l.mouseOut = function(f) {
        f.fixed &= -5;
      }, l;
    }();
    u.Layout = d;
  }(DO)), DO;
}
var DX;
function Bge() {
  if (DX) return Pf;
  DX = 1;
  var u = Pf && Pf.__extends || /* @__PURE__ */ function() {
    var t = function(e, n) {
      return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, c) {
        i.__proto__ = c;
      } || function(i, c) {
        for (var s in c) c.hasOwnProperty(s) && (i[s] = c[s]);
      }, t(e, n);
    };
    return function(e, n) {
      t(e, n);
      function i() {
        this.constructor = e;
      }
      e.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
    };
  }();
  Object.defineProperty(Pf, "__esModule", { value: !0 });
  var r = Dw(), o = function(t) {
    u(e, t);
    function e(n) {
      var i = t.call(this) || this, c = n;
      return c.trigger && (i.trigger = c.trigger), c.kick && (i.kick = c.kick), c.drag && (i.drag = c.drag), c.on && (i.on = c.on), i.dragstart = i.dragStart = r.Layout.dragStart, i.dragend = i.dragEnd = r.Layout.dragEnd, i;
    }
    return e.prototype.trigger = function(n) {
    }, e.prototype.kick = function() {
    }, e.prototype.drag = function() {
    }, e.prototype.on = function(n, i) {
      return this;
    }, e;
  }(r.Layout);
  Pf.LayoutAdaptor = o;
  function a(t) {
    return new o(t);
  }
  return Pf.adaptor = a, Pf;
}
var X6 = {}, Lf = {}, LX;
function $ge() {
  if (LX) return Lf;
  LX = 1;
  var u = Lf && Lf.__extends || /* @__PURE__ */ function() {
    var t = function(e, n) {
      return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, c) {
        i.__proto__ = c;
      } || function(i, c) {
        for (var s in c) c.hasOwnProperty(s) && (i[s] = c[s]);
      }, t(e, n);
    };
    return function(e, n) {
      t(e, n);
      function i() {
        this.constructor = e;
      }
      e.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
    };
  }();
  Object.defineProperty(Lf, "__esModule", { value: !0 });
  var r = Dw(), o = function(t) {
    u(e, t);
    function e() {
      var n = t.call(this) || this;
      n.event = d3.dispatch(r.EventType[r.EventType.start], r.EventType[r.EventType.tick], r.EventType[r.EventType.end]);
      var i = n;
      return n.drag = function() {
        if (!c)
          var c = d3.behavior.drag().origin(r.Layout.dragOrigin).on("dragstart.d3adaptor", r.Layout.dragStart).on("drag.d3adaptor", function(s) {
            r.Layout.drag(s, d3.event), i.resume();
          }).on("dragend.d3adaptor", r.Layout.dragEnd);
        if (!arguments.length)
          return c;
        this.call(c);
      }, n;
    }
    return e.prototype.trigger = function(n) {
      var i = { type: r.EventType[n.type], alpha: n.alpha, stress: n.stress };
      this.event[i.type](i);
    }, e.prototype.kick = function() {
      var n = this;
      d3.timer(function() {
        return t.prototype.tick.call(n);
      });
    }, e.prototype.on = function(n, i) {
      return typeof n == "string" ? this.event.on(n, i) : this.event.on(r.EventType[n], i), this;
    }, e;
  }(r.Layout);
  Lf.D3StyleLayoutAdaptor = o;
  function a() {
    return new o();
  }
  return Lf.d3adaptor = a, Lf;
}
var I0 = {}, jX;
function Uge() {
  if (jX) return I0;
  jX = 1;
  var u = I0 && I0.__extends || /* @__PURE__ */ function() {
    var a = function(t, e) {
      return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
        n.__proto__ = i;
      } || function(n, i) {
        for (var c in i) i.hasOwnProperty(c) && (n[c] = i[c]);
      }, a(t, e);
    };
    return function(t, e) {
      a(t, e);
      function n() {
        this.constructor = t;
      }
      t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
    };
  }();
  Object.defineProperty(I0, "__esModule", { value: !0 });
  var r = Dw(), o = function(a) {
    u(t, a);
    function t(e) {
      var n = a.call(this) || this;
      n.d3Context = e, n.event = e.dispatch(r.EventType[r.EventType.start], r.EventType[r.EventType.tick], r.EventType[r.EventType.end]);
      var i = n;
      return n.drag = function() {
        if (!c)
          var c = e.drag().subject(r.Layout.dragOrigin).on("start.d3adaptor", r.Layout.dragStart).on("drag.d3adaptor", function(s) {
            r.Layout.drag(s, e.event), i.resume();
          }).on("end.d3adaptor", r.Layout.dragEnd);
        if (!arguments.length)
          return c;
        arguments[0].call(c);
      }, n;
    }
    return t.prototype.trigger = function(e) {
      var n = { type: r.EventType[e.type], alpha: e.alpha, stress: e.stress };
      this.event.call(n.type, n);
    }, t.prototype.kick = function() {
      var e = this, n = this.d3Context.timer(function() {
        return a.prototype.tick.call(e) && n.stop();
      });
    }, t.prototype.on = function(e, n) {
      return typeof e == "string" ? this.event.on(e, n) : this.event.on(r.EventType[e], n), this;
    }, t;
  }(r.Layout);
  return I0.D3StyleLayoutAdaptor = o, I0;
}
var MX;
function Vge() {
  if (MX) return X6;
  MX = 1, Object.defineProperty(X6, "__esModule", { value: !0 });
  var u = $ge(), r = Uge();
  function o(t) {
    return !t || a(t) ? new u.D3StyleLayoutAdaptor() : new r.D3StyleLayoutAdaptor(t);
  }
  X6.d3adaptor = o;
  function a(t) {
    var e = /^3\./;
    return t.version && t.version.match(e) !== null;
  }
  return X6;
}
var jf = {}, CX;
function lee() {
  if (CX) return jf;
  CX = 1, Object.defineProperty(jf, "__esModule", { value: !0 });
  var u = Pw(), r = nI(), o = p4(), a = /* @__PURE__ */ function() {
    function i(c, s, d) {
      this.id = c, this.rect = s, this.children = d, this.leaf = typeof d > "u" || d.length === 0;
    }
    return i;
  }();
  jf.NodeWrapper = a;
  var t = /* @__PURE__ */ function() {
    function i(c, s, d, l, f) {
      l === void 0 && (l = null), f === void 0 && (f = null), this.id = c, this.x = s, this.y = d, this.node = l, this.line = f;
    }
    return i;
  }();
  jf.Vert = t;
  var e = function() {
    function i(c, s) {
      this.s = c, this.t = s;
      var d = i.findMatch(c, s), l = s.slice(0).reverse(), f = i.findMatch(c, l);
      d.length >= f.length ? (this.length = d.length, this.si = d.si, this.ti = d.ti, this.reversed = !1) : (this.length = f.length, this.si = f.si, this.ti = s.length - f.ti - f.length, this.reversed = !0);
    }
    return i.findMatch = function(c, s) {
      for (var d = c.length, l = s.length, f = { length: 0, si: -1, ti: -1 }, h = new Array(d), p = 0; p < d; p++) {
        h[p] = new Array(l);
        for (var b = 0; b < l; b++)
          if (c[p] === s[b]) {
            var _ = h[p][b] = p === 0 || b === 0 ? 1 : h[p - 1][b - 1] + 1;
            _ > f.length && (f.length = _, f.si = p - _ + 1, f.ti = b - _ + 1);
          } else
            h[p][b] = 0;
      }
      return f;
    }, i.prototype.getSequence = function() {
      return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
    }, i;
  }();
  jf.LongestCommonSubsequence = e;
  var n = function() {
    function i(c, s, d) {
      var l = this;
      d === void 0 && (d = 12), this.originalnodes = c, this.groupPadding = d, this.leaves = null, this.nodes = c.map(function(E, R) {
        return new a(R, s.getBounds(E), s.getChildren(E));
      }), this.leaves = this.nodes.filter(function(E) {
        return E.leaf;
      }), this.groups = this.nodes.filter(function(E) {
        return !E.leaf;
      }), this.cols = this.getGridLines("x"), this.rows = this.getGridLines("y"), this.groups.forEach(function(E) {
        return E.children.forEach(function(R) {
          return l.nodes[R].parent = E;
        });
      }), this.root = { children: [] }, this.nodes.forEach(function(E) {
        typeof E.parent > "u" && (E.parent = l.root, l.root.children.push(E.id)), E.ports = [];
      }), this.backToFront = this.nodes.slice(0), this.backToFront.sort(function(E, R) {
        return l.getDepth(E) - l.getDepth(R);
      });
      var f = this.backToFront.slice(0).reverse().filter(function(E) {
        return !E.leaf;
      });
      f.forEach(function(E) {
        var R = u.Rectangle.empty();
        E.children.forEach(function(L) {
          return R = R.union(l.nodes[L].rect);
        }), E.rect = R.inflate(l.groupPadding);
      });
      var h = this.midPoints(this.cols.map(function(E) {
        return E.pos;
      })), p = this.midPoints(this.rows.map(function(E) {
        return E.pos;
      })), b = h[0], _ = h[h.length - 1], y = p[0], m = p[p.length - 1], g = this.rows.map(function(E) {
        return { x1: b, x2: _, y1: E.pos, y2: E.pos };
      }).concat(p.map(function(E) {
        return { x1: b, x2: _, y1: E, y2: E };
      })), T = this.cols.map(function(E) {
        return { x1: E.pos, x2: E.pos, y1: y, y2: m };
      }).concat(h.map(function(E) {
        return { x1: E, x2: E, y1: y, y2: m };
      })), v = g.concat(T);
      v.forEach(function(E) {
        return E.verts = [];
      }), this.verts = [], this.edges = [], g.forEach(function(E) {
        return T.forEach(function(R) {
          var L = new t(l.verts.length, R.x1, E.y1);
          E.verts.push(L), R.verts.push(L), l.verts.push(L);
          for (var A = l.backToFront.length; A-- > 0; ) {
            var w = l.backToFront[A], S = w.rect, O = Math.abs(L.x - S.cx()), x = Math.abs(L.y - S.cy());
            if (O < S.width() / 2 && x < S.height() / 2) {
              L.node = w;
              break;
            }
          }
        });
      }), v.forEach(function(E, R) {
        l.nodes.forEach(function(x, F) {
          x.rect.lineIntersections(E.x1, E.y1, E.x2, E.y2).forEach(function(j, q) {
            var Q = new t(l.verts.length, j.x, j.y, x, E);
            l.verts.push(Q), E.verts.push(Q), x.ports.push(Q);
          });
        });
        var L = Math.abs(E.y1 - E.y2) < 0.1, A = function(x, F) {
          return L ? F.x - x.x : F.y - x.y;
        };
        E.verts.sort(A);
        for (var w = 1; w < E.verts.length; w++) {
          var S = E.verts[w - 1], O = E.verts[w];
          S.node && S.node === O.node && S.node.leaf || l.edges.push({ source: S.id, target: O.id, length: Math.abs(A(S, O)) });
        }
      });
    }
    return i.prototype.avg = function(c) {
      return c.reduce(function(s, d) {
        return s + d;
      }) / c.length;
    }, i.prototype.getGridLines = function(c) {
      for (var s = [], d = this.leaves.slice(0, this.leaves.length); d.length > 0; ) {
        var l = d.filter(function(h) {
          return h.rect["overlap" + c.toUpperCase()](d[0].rect);
        }), f = {
          nodes: l,
          pos: this.avg(l.map(function(h) {
            return h.rect["c" + c]();
          }))
        };
        s.push(f), f.nodes.forEach(function(h) {
          return d.splice(d.indexOf(h), 1);
        });
      }
      return s.sort(function(h, p) {
        return h.pos - p.pos;
      }), s;
    }, i.prototype.getDepth = function(c) {
      for (var s = 0; c.parent !== this.root; )
        s++, c = c.parent;
      return s;
    }, i.prototype.midPoints = function(c) {
      for (var s = c[1] - c[0], d = [c[0] - s / 2], l = 1; l < c.length; l++)
        d.push((c[l] + c[l - 1]) / 2);
      return d.push(c[c.length - 1] + s / 2), d;
    }, i.prototype.findLineage = function(c) {
      var s = [c];
      do
        c = c.parent, s.push(c);
      while (c !== this.root);
      return s.reverse();
    }, i.prototype.findAncestorPathBetween = function(c, s) {
      for (var d = this.findLineage(c), l = this.findLineage(s), f = 0; d[f] === l[f]; )
        f++;
      return { commonAncestor: d[f - 1], lineages: d.slice(f).concat(l.slice(f)) };
    }, i.prototype.siblingObstacles = function(c, s) {
      var d = this, l = this.findAncestorPathBetween(c, s), f = {};
      l.lineages.forEach(function(p) {
        return f[p.id] = {};
      });
      var h = l.commonAncestor.children.filter(function(p) {
        return !(p in f);
      });
      return l.lineages.filter(function(p) {
        return p.parent !== l.commonAncestor;
      }).forEach(function(p) {
        return h = h.concat(p.parent.children.filter(function(b) {
          return b !== p.id;
        }));
      }), h.map(function(p) {
        return d.nodes[p];
      });
    }, i.getSegmentSets = function(c, s, d) {
      for (var l = [], f = 0; f < c.length; f++)
        for (var h = c[f], p = 0; p < h.length; p++) {
          var b = h[p];
          b.edgeid = f, b.i = p;
          var _ = b[1][s] - b[0][s];
          Math.abs(_) < 0.1 && l.push(b);
        }
      l.sort(function(T, v) {
        return T[0][s] - v[0][s];
      });
      for (var y = [], m = null, g = 0; g < l.length; g++) {
        var b = l[g];
        (!m || Math.abs(b[0][s] - m.pos) > 0.1) && (m = { pos: b[0][s], segments: [] }, y.push(m)), m.segments.push(b);
      }
      return y;
    }, i.nudgeSegs = function(c, s, d, l, f, h) {
      var p = l.length;
      if (!(p <= 1)) {
        for (var b = l.map(function(w) {
          return new r.Variable(w[0][c]);
        }), _ = [], y = 0; y < p; y++)
          for (var m = 0; m < p; m++)
            if (y !== m) {
              var g = l[y], T = l[m], v = g.edgeid, E = T.edgeid, R = -1, L = -1;
              c == "x" ? f(v, E) && (g[0][s] < g[1][s] ? (R = m, L = y) : (R = y, L = m)) : f(v, E) && (g[0][s] < g[1][s] ? (R = y, L = m) : (R = m, L = y)), R >= 0 && _.push(new r.Constraint(b[R], b[L], h));
            }
        var A = new r.Solver(b, _);
        A.solve(), b.forEach(function(w, S) {
          var O = l[S], x = w.position();
          O[0][c] = O[1][c] = x;
          var F = d[O.edgeid];
          O.i > 0 && (F[O.i - 1][1][c] = x), O.i < F.length - 1 && (F[O.i + 1][0][c] = x);
        });
      }
    }, i.nudgeSegments = function(c, s, d, l, f) {
      for (var h = i.getSegmentSets(c, s, d), p = 0; p < h.length; p++) {
        for (var b = h[p], _ = [], y = 0; y < b.segments.length; y++) {
          var m = b.segments[y];
          _.push({ type: 0, s: m, pos: Math.min(m[0][d], m[1][d]) }), _.push({ type: 1, s: m, pos: Math.max(m[0][d], m[1][d]) });
        }
        _.sort(function(v, E) {
          return v.pos - E.pos + v.type - E.type;
        });
        var g = [], T = 0;
        _.forEach(function(v) {
          v.type === 0 ? (g.push(v.s), T++) : T--, T == 0 && (i.nudgeSegs(s, d, c, g, l, f), g = []);
        });
      }
    }, i.prototype.routeEdges = function(c, s, d, l) {
      var f = this, h = c.map(function(_) {
        return f.route(d(_), l(_));
      }), p = i.orderEdges(h), b = h.map(function(_) {
        return i.makeSegments(_);
      });
      return i.nudgeSegments(b, "x", "y", p, s), i.nudgeSegments(b, "y", "x", p, s), i.unreverseEdges(b, h), b;
    }, i.unreverseEdges = function(c, s) {
      c.forEach(function(d, l) {
        var f = s[l];
        f.reversed && (d.reverse(), d.forEach(function(h) {
          h.reverse();
        }));
      });
    }, i.angleBetween2Lines = function(c, s) {
      var d = Math.atan2(c[0].y - c[1].y, c[0].x - c[1].x), l = Math.atan2(s[0].y - s[1].y, s[0].x - s[1].x), f = d - l;
      return (f > Math.PI || f < -Math.PI) && (f = l - d), f;
    }, i.isLeft = function(c, s, d) {
      return (s.x - c.x) * (d.y - c.y) - (s.y - c.y) * (d.x - c.x) <= 0;
    }, i.getOrder = function(c) {
      for (var s = {}, d = 0; d < c.length; d++) {
        var l = c[d];
        typeof s[l.l] > "u" && (s[l.l] = {}), s[l.l][l.r] = !0;
      }
      return function(f, h) {
        return typeof s[f] < "u" && s[f][h];
      };
    }, i.orderEdges = function(c) {
      for (var s = [], d = 0; d < c.length - 1; d++)
        for (var l = d + 1; l < c.length; l++) {
          var f = c[d], h = c[l], p = new e(f, h), b, _, y;
          if (p.length !== 0) {
            if (p.reversed && (h.reverse(), h.reversed = !0, p = new e(f, h)), (p.si <= 0 || p.ti <= 0) && (p.si + p.length >= f.length || p.ti + p.length >= h.length)) {
              s.push({ l: d, r: l });
              continue;
            }
            p.si + p.length >= f.length || p.ti + p.length >= h.length ? (b = f[p.si + 1], y = f[p.si - 1], _ = h[p.ti - 1]) : (b = f[p.si + p.length - 2], _ = f[p.si + p.length], y = h[p.ti + p.length]), i.isLeft(b, _, y) ? s.push({ l, r: d }) : s.push({ l: d, r: l });
          }
        }
      return i.getOrder(s);
    }, i.makeSegments = function(c) {
      function s(_) {
        return { x: _.x, y: _.y };
      }
      for (var d = function(_, y, m) {
        return Math.abs((y.x - _.x) * (m.y - _.y) - (y.y - _.y) * (m.x - _.x)) < 1e-3;
      }, l = [], f = s(c[0]), h = 1; h < c.length; h++) {
        var p = s(c[h]), b = h < c.length - 1 ? c[h + 1] : null;
        (!b || !d(f, p, b)) && (l.push([f, p]), f = p);
      }
      return l;
    }, i.prototype.route = function(c, s) {
      var d = this, l = this.nodes[c], f = this.nodes[s];
      this.obstacles = this.siblingObstacles(l, f);
      var h = {};
      this.obstacles.forEach(function(L) {
        return h[L.id] = L;
      }), this.passableEdges = this.edges.filter(function(L) {
        var A = d.verts[L.source], w = d.verts[L.target];
        return !(A.node && A.node.id in h || w.node && w.node.id in h);
      });
      for (var p = 1; p < l.ports.length; p++) {
        var b = l.ports[0].id, _ = l.ports[p].id;
        this.passableEdges.push({
          source: b,
          target: _,
          length: 0
        });
      }
      for (var p = 1; p < f.ports.length; p++) {
        var b = f.ports[0].id, _ = f.ports[p].id;
        this.passableEdges.push({
          source: b,
          target: _,
          length: 0
        });
      }
      var y = function(L) {
        return L.source;
      }, m = function(L) {
        return L.target;
      }, g = function(L) {
        return L.length;
      }, T = new o.Calculator(this.verts.length, this.passableEdges, y, m, g), v = function(L, A, w) {
        var S = d.verts[L], O = d.verts[A], x = d.verts[w], F = Math.abs(x.x - S.x), j = Math.abs(x.y - S.y);
        return S.node === l && S.node === O.node || O.node === f && O.node === x.node ? 0 : F > 1 && j > 1 ? 1e3 : 0;
      }, E = T.PathFromNodeToNodeWithPrevCost(l.ports[0].id, f.ports[0].id, v), R = E.reverse().map(function(L) {
        return d.verts[L];
      });
      return R.push(this.nodes[f.id].ports[0]), R.filter(function(L, A) {
        return !(A < R.length - 1 && R[A + 1].node === l && L.node === l || A > 0 && L.node === f && R[A - 1].node === f);
      });
    }, i.getRoutePath = function(c, s, d, l) {
      var f = {
        routepath: "M " + c[0][0].x + " " + c[0][0].y + " ",
        arrowpath: ""
      };
      if (c.length > 1)
        for (var h = 0; h < c.length; h++) {
          var p = c[h], b = p[1].x, _ = p[1].y, y = b - p[0].x, m = _ - p[0].y;
          if (h < c.length - 1) {
            Math.abs(y) > 0 ? b -= y / Math.abs(y) * s : _ -= m / Math.abs(m) * s, f.routepath += "L " + b + " " + _ + " ";
            var g = c[h + 1], T = g[0].x, v = g[0].y, E = g[1].x, R = g[1].y;
            y = E - T, m = R - v;
            var L = i.angleBetween2Lines(p, g) < 0 ? 1 : 0, A, w;
            Math.abs(y) > 0 ? (A = T + y / Math.abs(y) * s, w = v) : (A = T, w = v + m / Math.abs(m) * s);
            var S = Math.abs(A - b), O = Math.abs(w - _);
            f.routepath += "A " + S + " " + O + " 0 0 " + L + " " + A + " " + w + " ";
          } else {
            var x = [b, _], F, j;
            Math.abs(y) > 0 ? (b -= y / Math.abs(y) * l, F = [b, _ + d], j = [b, _ - d]) : (_ -= m / Math.abs(m) * l, F = [b + d, _], j = [b - d, _]), f.routepath += "L " + b + " " + _ + " ", l > 0 && (f.arrowpath = "M " + x[0] + " " + x[1] + " L " + F[0] + " " + F[1] + " L " + j[0] + " " + j[1]);
          }
        }
      else {
        var p = c[0], b = p[1].x, _ = p[1].y, y = b - p[0].x, m = _ - p[0].y, x = [b, _], F, j;
        Math.abs(y) > 0 ? (b -= y / Math.abs(y) * l, F = [b, _ + d], j = [b, _ - d]) : (_ -= m / Math.abs(m) * l, F = [b + d, _], j = [b - d, _]), f.routepath += "L " + b + " " + _ + " ", l > 0 && (f.arrowpath = "M " + x[0] + " " + x[1] + " L " + F[0] + " " + F[1] + " L " + j[0] + " " + j[1]);
      }
      return f;
    }, i;
  }();
  return jf.GridRouter = n, jf;
}
var R0 = {}, qX;
function Qge() {
  if (qX) return R0;
  qX = 1, Object.defineProperty(R0, "__esModule", { value: !0 });
  var u = p4(), r = rI(), o = Pw(), a = tI(), t = function() {
    function c(s, d) {
      this.source = s, this.target = d;
    }
    return c.prototype.actualLength = function(s) {
      var d = this;
      return Math.sqrt(s.reduce(function(l, f) {
        var h = f[d.target] - f[d.source];
        return l + h * h;
      }, 0));
    }, c;
  }();
  R0.Link3D = t;
  var e = /* @__PURE__ */ function() {
    function c(s, d, l) {
      s === void 0 && (s = 0), d === void 0 && (d = 0), l === void 0 && (l = 0), this.x = s, this.y = d, this.z = l;
    }
    return c;
  }();
  R0.Node3D = e;
  var n = function() {
    function c(s, d, l) {
      var f = this;
      l === void 0 && (l = 1), this.nodes = s, this.links = d, this.idealLinkLength = l, this.constraints = null, this.useJaccardLinkLengths = !0, this.result = new Array(c.k);
      for (var h = 0; h < c.k; ++h)
        this.result[h] = new Array(s.length);
      s.forEach(function(p, b) {
        for (var _ = 0, y = c.dims; _ < y.length; _++) {
          var m = y[_];
          typeof p[m] > "u" && (p[m] = Math.random());
        }
        f.result[0][b] = p.x, f.result[1][b] = p.y, f.result[2][b] = p.z;
      });
    }
    return c.prototype.linkLength = function(s) {
      return s.actualLength(this.result);
    }, c.prototype.start = function(s) {
      var d = this;
      s === void 0 && (s = 100);
      var l = this.nodes.length, f = new i();
      this.useJaccardLinkLengths && a.jaccardLinkLengths(this.links, f, 1.5), this.links.forEach(function(m) {
        return m.length *= d.idealLinkLength;
      });
      var h = new u.Calculator(l, this.links, function(m) {
        return m.source;
      }, function(m) {
        return m.target;
      }, function(m) {
        return m.length;
      }).DistanceMatrix(), p = r.Descent.createSquareMatrix(l, function(m, g) {
        return h[m][g];
      }), b = r.Descent.createSquareMatrix(l, function() {
        return 2;
      });
      this.links.forEach(function(m) {
        var g = m.source, T = m.target;
        return b[g][T] = b[T][g] = 1;
      }), this.descent = new r.Descent(this.result, p), this.descent.threshold = 1e-3, this.descent.G = b, this.constraints && (this.descent.project = new o.Projection(this.nodes, null, null, this.constraints).projectFunctions());
      for (var _ = 0; _ < this.nodes.length; _++) {
        var y = this.nodes[_];
        y.fixed && this.descent.locks.add(_, [y.x, y.y, y.z]);
      }
      return this.descent.run(s), this;
    }, c.prototype.tick = function() {
      this.descent.locks.clear();
      for (var s = 0; s < this.nodes.length; s++) {
        var d = this.nodes[s];
        d.fixed && this.descent.locks.add(s, [d.x, d.y, d.z]);
      }
      return this.descent.rungeKutta();
    }, c.dims = ["x", "y", "z"], c.k = c.dims.length, c;
  }();
  R0.Layout3D = n;
  var i = function() {
    function c() {
    }
    return c.prototype.getSourceIndex = function(s) {
      return s.source;
    }, c.prototype.getTargetIndex = function(s) {
      return s.target;
    }, c.prototype.getLength = function(s) {
      return s.length;
    }, c.prototype.setLength = function(s, d) {
      s.length = d;
    }, c;
  }();
  return R0;
}
var dT = {}, BX;
function Hge() {
  if (BX) return dT;
  BX = 1, Object.defineProperty(dT, "__esModule", { value: !0 });
  var u = Dw(), r = lee();
  function o(e, n, i, c) {
    e.cola.start(0, 0, 0, 10, !1);
    var s = a(e.cola.nodes(), e.cola.groups(), i, c);
    return s.routeEdges(e.powerGraph.powerEdges, n, function(d) {
      return d.source.routerNode.id;
    }, function(d) {
      return d.target.routerNode.id;
    });
  }
  dT.gridify = o;
  function a(e, n, i, c) {
    e.forEach(function(d) {
      d.routerNode = {
        name: d.name,
        bounds: d.bounds.inflate(-i)
      };
    }), n.forEach(function(d) {
      d.routerNode = {
        bounds: d.bounds.inflate(-c),
        children: (typeof d.groups < "u" ? d.groups.map(function(l) {
          return e.length + l.id;
        }) : []).concat(typeof d.leaves < "u" ? d.leaves.map(function(l) {
          return l.index;
        }) : [])
      };
    });
    var s = e.concat(n).map(function(d, l) {
      return d.routerNode.id = l, d.routerNode;
    });
    return new r.GridRouter(s, {
      getChildren: function(d) {
        return d.children;
      },
      getBounds: function(d) {
        return d.bounds;
      }
    }, i - c);
  }
  function t(e, n, i) {
    var c;
    e.nodes.forEach(function(f, h) {
      return f.index = h;
    }), new u.Layout().avoidOverlaps(!1).nodes(e.nodes).links(e.links).powerGraphGroups(function(f) {
      c = f, c.groups.forEach(function(h) {
        return h.padding = i;
      });
    });
    var s = e.nodes.length, d = [], l = e.nodes.slice(0);
    return l.forEach(function(f, h) {
      return f.index = h;
    }), c.groups.forEach(function(f) {
      var h = f.index = f.id + s;
      l.push(f), typeof f.leaves < "u" && f.leaves.forEach(function(p) {
        return d.push({ source: h, target: p.index });
      }), typeof f.groups < "u" && f.groups.forEach(function(p) {
        return d.push({ source: h, target: p.id + s });
      });
    }), c.powerEdges.forEach(function(f) {
      d.push({ source: f.source.index, target: f.target.index });
    }), new u.Layout().size(n).nodes(l).links(d).avoidOverlaps(!1).linkDistance(30).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(100, 0, 0, 0, !1), {
      cola: new u.Layout().convergenceThreshold(1e-3).size(n).avoidOverlaps(!0).nodes(e.nodes).links(e.links).groupCompactness(1e-4).linkDistance(30).symmetricDiffLinkLengths(5).powerGraphGroups(function(f) {
        c = f, c.groups.forEach(function(h) {
          h.padding = i;
        });
      }).start(50, 0, 100, 0, !1),
      powerGraph: c
    };
  }
  return dT.powerGraphGridLayout = t, dT;
}
var $X;
function Gge() {
  return $X || ($X = 1, function(u) {
    function r(o) {
      for (var a in o) u.hasOwnProperty(a) || (u[a] = o[a]);
    }
    Object.defineProperty(u, "__esModule", { value: !0 }), r(Bge()), r(Vge()), r(rI()), r(cee()), r(lee()), r(dee()), r(Dw()), r(Qge()), r(tI()), r(uee()), r(see()), r(oee()), r(Pw()), r(p4()), r(nI()), r(Hge());
  }(PO)), PO;
}
var zge = hS.exports, UX;
function kge() {
  return UX || (UX = 1, function(u, r) {
    (function(a, t) {
      u.exports = t(Gge());
    })(zge, function(o) {
      return (
        /******/
        function(a) {
          var t = {};
          function e(n) {
            if (t[n])
              return t[n].exports;
            var i = t[n] = {
              /******/
              i: n,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return a[n].call(i.exports, i, i.exports, e), i.l = !0, i.exports;
          }
          return e.m = a, e.c = t, e.i = function(n) {
            return n;
          }, e.d = function(n, i, c) {
            e.o(n, i) || Object.defineProperty(n, i, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: c
              /******/
            });
          }, e.n = function(n) {
            var i = n && n.__esModule ? (
              /******/
              function() {
                return n.default;
              }
            ) : (
              /******/
              function() {
                return n;
              }
            );
            return e.d(i, "a", i), i;
          }, e.o = function(n, i) {
            return Object.prototype.hasOwnProperty.call(n, i);
          }, e.p = "", e(e.s = 3);
        }([
          /* 0 */
          /***/
          function(a, t, e) {
            var n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
              return typeof m;
            } : function(m) {
              return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
            }, i = e(1), c = e(2), s = e(5) || (typeof window < "u" ? window.cola : null), d = e(4), l = function(g) {
              return (typeof g > "u" ? "undefined" : n(g)) === n("");
            }, f = function(g) {
              return (typeof g > "u" ? "undefined" : n(g)) === n(0);
            }, h = function(g) {
              return g != null && (typeof g > "u" ? "undefined" : n(g)) === n({});
            }, p = function(g) {
              return g != null && (typeof g > "u" ? "undefined" : n(g)) === n(function() {
              });
            }, b = function() {
            }, _ = function(g, T) {
              if (p(g)) {
                var v = g;
                return v.apply(T, [T]);
              } else
                return g;
            };
            function y(m) {
              this.options = i({}, c, m);
            }
            y.prototype.run = function() {
              var m = this, g = this.options;
              m.manuallyStopped = !1;
              var T = g.cy, v = g.eles, E = v.nodes(), R = v.edges(), L = !1, A = function(M) {
                return M.isParent();
              }, w = E.filter(A), S = E.subtract(w), O = g.boundingBox || { x1: 0, y1: 0, w: T.width(), h: T.height() };
              O.x2 === void 0 && (O.x2 = O.x1 + O.w), O.w === void 0 && (O.w = O.x2 - O.x1), O.y2 === void 0 && (O.y2 = O.y1 + O.h), O.h === void 0 && (O.h = O.y2 - O.y1);
              var x = function() {
                for (var M = 0; M < E.length; M++) {
                  var I = E[M], P = I.layoutDimensions(g), B = I.scratch("cola");
                  if (!B.updatedDims) {
                    var z = _(g.nodeSpacing, I);
                    B.width = P.w + 2 * z, B.height = P.h + 2 * z;
                  }
                }
                E.positions(function(H) {
                  var J = H.scratch().cola, k = void 0;
                  return !H.grabbed() && S.contains(H) && (k = {
                    x: O.x1 + J.x,
                    y: O.y1 + J.y
                  }, (!f(k.x) || !f(k.y)) && (k = void 0)), k;
                }), E.updateCompoundBounds(), L || (j(), L = !0), g.fit && T.fit(g.padding);
              }, F = function() {
                g.ungrabifyWhileSimulating && G.grabify(), T.off("destroy", K), E.off("grab free position", U), E.off("lock unlock", ae), m.one("layoutstop", g.stop), m.trigger({ type: "layoutstop", layout: m });
              }, j = function() {
                m.one("layoutready", g.ready), m.trigger({ type: "layoutready", layout: m });
              }, q = g.refresh;
              g.refresh < 0 ? q = 1 : q = Math.max(1, q);
              var Q = m.adaptor = s.adaptor({
                trigger: function(M) {
                  var I = s.EventType ? s.EventType.tick : null, P = s.EventType ? s.EventType.end : null;
                  switch (M.type) {
                    case "tick":
                    case I:
                      g.animate && x();
                      break;
                    case "end":
                    case P:
                      x(), g.infinite || F();
                      break;
                  }
                },
                kick: function() {
                  var M = !0, I = function() {
                    if (m.manuallyStopped)
                      return F(), !0;
                    var H = Q.tick();
                    return !g.infinite && !M && Q.convergenceThreshold(g.convergenceThreshold), M = !1, H && g.infinite && Q.resume(), H;
                  }, P = function() {
                    for (var H = void 0, J = 0; J < q && !H; J++)
                      H = H || I();
                    return H;
                  };
                  if (g.animate) {
                    var B = function z() {
                      P() || d(z);
                    };
                    d(B);
                  } else
                    for (; !I(); )
                      ;
                },
                on: b,
                // dummy; not needed
                drag: b
                // not needed for our case
              });
              m.adaptor = Q;
              var G = E.filter(":grabbable");
              g.ungrabifyWhileSimulating && G.ungrabify();
              var K = void 0;
              T.one("destroy", K = function() {
                m.stop();
              });
              var U = void 0;
              E.on("grab free position", U = function(M) {
                var I = this, P = I.scratch().cola, B = I.position(), z = M.cyTarget === I || M.target === I;
                if (z)
                  switch (M.type) {
                    case "grab":
                      Q.dragstart(P);
                      break;
                    case "free":
                      Q.dragend(P);
                      break;
                    case "position":
                      (P.px !== B.x - O.x1 || P.py !== B.y - O.y1) && (P.px = B.x - O.x1, P.py = B.y - O.y1);
                      break;
                  }
              });
              var ae = void 0;
              E.on("lock unlock", ae = function() {
                var M = this, I = M.scratch().cola;
                I.fixed = M.locked(), M.locked() ? Q.dragstart(I) : Q.dragend(I);
              }), Q.nodes(S.map(function(N, M) {
                var I = _(g.nodeSpacing, N), P = N.position(), B = N.layoutDimensions(g), z = N.scratch().cola = {
                  x: g.randomize && !N.locked() || P.x === void 0 ? Math.round(Math.random() * O.w) : P.x,
                  y: g.randomize && !N.locked() || P.y === void 0 ? Math.round(Math.random() * O.h) : P.y,
                  width: B.w + 2 * I,
                  height: B.h + 2 * I,
                  index: M,
                  fixed: N.locked()
                };
                return z;
              }));
              var ye = [];
              if (g.alignment) {
                if (g.alignment.vertical) {
                  var pe = g.alignment.vertical;
                  pe.forEach(function(N) {
                    var M = [];
                    N.forEach(function(I) {
                      var P = I.node, B = P.scratch().cola, z = B.index;
                      M.push({
                        node: z,
                        offset: I.offset ? I.offset : 0
                      });
                    }), ye.push({
                      type: "alignment",
                      axis: "x",
                      offsets: M
                    });
                  });
                }
                if (g.alignment.horizontal) {
                  var ee = g.alignment.horizontal;
                  ee.forEach(function(N) {
                    var M = [];
                    N.forEach(function(I) {
                      var P = I.node, B = P.scratch().cola, z = B.index;
                      M.push({
                        node: z,
                        offset: I.offset ? I.offset : 0
                      });
                    }), ye.push({
                      type: "alignment",
                      axis: "y",
                      offsets: M
                    });
                  });
                }
              }
              g.gapInequalities && g.gapInequalities.forEach(function(N) {
                var M = N.left.scratch().cola.index, I = N.right.scratch().cola.index;
                ye.push({
                  axis: N.axis,
                  left: M,
                  right: I,
                  gap: N.gap,
                  equality: N.equality
                });
              }), ye.length > 0 && Q.constraints(ye), Q.groups(w.map(function(N, M) {
                var I = _(g.nodeSpacing, N), P = function(W) {
                  return parseFloat(N.style("padding-" + W));
                }, B = P("left") + I, z = P("right") + I, H = P("top") + I, J = P("bottom") + I;
                return N.scratch().cola = {
                  index: M,
                  padding: Math.max(B, z, H, J),
                  // leaves should only contain direct descendants (children),
                  // not the leaves of nested compound nodes or any nodes that are compounds themselves
                  leaves: N.children().intersection(S).map(function(k) {
                    return k[0].scratch().cola.index;
                  }),
                  fixed: N.locked()
                }, N;
              }).map(function(N) {
                return N.scratch().cola.groups = N.children().intersection(w).map(function(M) {
                  return M.scratch().cola.index;
                }), N.scratch().cola;
              }));
              var Te = void 0, we = void 0;
              g.edgeLength != null ? (Te = g.edgeLength, we = "linkDistance") : g.edgeSymDiffLength != null ? (Te = g.edgeSymDiffLength, we = "symmetricDiffLinkLengths") : g.edgeJaccardLength != null ? (Te = g.edgeJaccardLength, we = "jaccardLinkLengths") : (Te = 100, we = "linkDistance");
              var Oe = function(M) {
                return M.calcLength;
              };
              if (Q.links(R.stdFilter(function(N) {
                return S.contains(N.source()) && S.contains(N.target());
              }).map(function(N) {
                var M = N.scratch().cola = {
                  source: N.source()[0].scratch().cola.index,
                  target: N.target()[0].scratch().cola.index
                };
                return Te != null && (M.calcLength = _(Te, N)), M;
              })), Q.size([O.w, O.h]), Te != null && Q[we](Oe), g.flow) {
                var be = void 0, he = "y", V = 50;
                l(g.flow) ? be = {
                  axis: g.flow,
                  minSeparation: V
                } : f(g.flow) ? be = {
                  axis: he,
                  minSeparation: g.flow
                } : h(g.flow) ? (be = g.flow, be.axis = be.axis || he, be.minSeparation = be.minSeparation != null ? be.minSeparation : V) : be = {
                  axis: he,
                  minSeparation: V
                }, Q.flowLayout(be.axis, be.minSeparation);
              }
              return m.trigger({ type: "layoutstart", layout: m }), Q.avoidOverlaps(g.avoidOverlap).handleDisconnected(g.handleDisconnected).start(
                g.unconstrIter,
                g.userConstIter,
                g.allConstIter,
                void 0,
                // gridSnapIterations = 0
                void 0,
                // keepRunning = true
                g.centerGraph
              ), g.infinite || setTimeout(function() {
                m.manuallyStopped || Q.stop();
              }, g.maxSimulationTime), this;
            }, y.prototype.stop = function() {
              return this.adaptor && (this.manuallyStopped = !0, this.adaptor.stop()), this;
            }, a.exports = y;
          },
          /* 1 */
          /***/
          function(a, t, e) {
            a.exports = Object.assign != null ? Object.assign.bind(Object) : function(n) {
              for (var i = arguments.length, c = Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)
                c[s - 1] = arguments[s];
              return c.filter(function(d) {
                return d != null;
              }).forEach(function(d) {
                Object.keys(d).forEach(function(l) {
                  return n[l] = d[l];
                });
              }), n;
            };
          },
          /* 2 */
          /***/
          function(a, t, e) {
            var n = {
              animate: !0,
              // whether to show the layout as it's running
              refresh: 1,
              // number of ticks per frame; higher is faster but more jerky
              maxSimulationTime: 4e3,
              // max length in ms to run the layout
              ungrabifyWhileSimulating: !1,
              // so you can't drag nodes during layout
              fit: !0,
              // on every layout reposition of nodes, fit the viewport
              padding: 30,
              // padding around the simulation
              boundingBox: void 0,
              // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
              nodeDimensionsIncludeLabels: !1,
              // whether labels should be included in determining the space used by a node
              // layout event callbacks
              ready: function() {
              },
              // on layoutready
              stop: function() {
              },
              // on layoutstop
              // positioning options
              randomize: !1,
              // use random node positions at beginning of layout
              avoidOverlap: !0,
              // if true, prevents overlap of node bounding boxes
              handleDisconnected: !0,
              // if true, avoids disconnected components from overlapping
              convergenceThreshold: 0.01,
              // when the alpha value (system energy) falls below this value, the layout stops
              nodeSpacing: function(c) {
                return 10;
              },
              // extra spacing around nodes
              flow: void 0,
              // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
              alignment: void 0,
              // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }
              gapInequalities: void 0,
              // list of inequality constraints for the gap between the nodes, e.g. [{"axis":"y", "left":node1, "right":node2, "gap":25}]
              centerGraph: !0,
              // adjusts the node positions initially to center the graph (pass false if you want to start the layout from the current position)
              // different methods of specifying edge length
              // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
              edgeLength: void 0,
              // sets edge length directly in simulation
              edgeSymDiffLength: void 0,
              // symmetric diff edge length in simulation
              edgeJaccardLength: void 0,
              // jaccard edge length in simulation
              // iterations of cola algorithm; uses default values on undefined
              unconstrIter: void 0,
              // unconstrained initial layout iterations
              userConstIter: void 0,
              // initial layout iterations with user-specified constraints
              allConstIter: void 0,
              // initial layout iterations with all constraints including non-overlap
              // infinite layout options
              infinite: !1
              // overrides all other options for a forces-all-the-time mode
            };
            a.exports = n;
          },
          /* 3 */
          /***/
          function(a, t, e) {
            var n = e(0), i = function(s) {
              s && s("layout", "cola", n);
            };
            typeof cytoscape < "u" && i(cytoscape), a.exports = i;
          },
          /* 4 */
          /***/
          function(a, t, e) {
            var n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(c) {
              return typeof c;
            } : function(c) {
              return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
            }, i = void 0;
            (typeof window > "u" ? "undefined" : n(window)) !== "undefined" ? i = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(c) {
              return setTimeout(c, 16);
            } : i = function(s) {
              s();
            }, a.exports = i;
          },
          /* 5 */
          /***/
          function(a, t) {
            a.exports = o;
          }
          /******/
        ])
      );
    });
  }(hS)), hS.exports;
}
var Xge = kge();
const Jge = /* @__PURE__ */ ere(Xge);
var Mf = zte(() => xge), Kge = /* @__PURE__ */ Qn('<div class="flex justify-center items-center h-full"><p class="text-gray-600">Caricamento del grafo...</p></div>'), Wge = /* @__PURE__ */ Qn('<div class="flex justify-center items-center h-full"><p class="text-red-500 text-center"> </p></div>'), Yge = /* @__PURE__ */ Qn(`<div class="flex justify-center items-center h-full"><p class="text-gray-600">Nessun dato del grafo da visualizzare. Prova con un endpoint
                    SPARQL e un URI del sottografo validi.</p></div>`), Zge = /* @__PURE__ */ Qn('<div class="relative p-4 bg-gray-50 min-h-screen flex flex-col items-center font-inter rounded-lg shadow-md"><div id="cy" class="w-full h-[600px] bg-white rounded-lg shadow-lg border border-gray-200 svelte-1joiizr" style="min-height: 400px;"><!></div> <!></div> <div class="slider-group"><label for="distanceSlider"> </label> <input id="distanceSlider" type="range" min="100" max="1000" step="100"/></div>', 1);
const eme = {
  hash: "svelte-1joiizr",
  code: `\r
    /* Tailwind CSS classes sono usate, aggiungendo stili custom di base qui */body {margin:0;font-family:"Inter", sans-serif;background-color:#f0f2f5;}#cy.svelte-1joiizr {width:100%;height:600px;display:block;border-radius:0.5rem;}`
};
function tme(u, r) {
  RS(r, !1), LS(u, eme);
  const [o, a] = DJ(), t = () => PJ($t, "$graphState", o);
  let e, n = /* @__PURE__ */ kr(), i = "https://dati.emilia-romagna.it/sparql", c = "http://ibc-luoghiCultura/", s = /* @__PURE__ */ kr(!1), d = /* @__PURE__ */ kr(""), l = /* @__PURE__ */ kr(), f = /* @__PURE__ */ kr(), h = /* @__PURE__ */ kr(null), p = /* @__PURE__ */ kr([]), b = /* @__PURE__ */ kr(!1), _;
  function y(V) {
    _ && _.stop(), _ = Pe(l).layout(Mf()).run();
  }
  Px(async () => {
    e = (await import("./cytoscape.esm-Cqddr6w8.js")).default, e.use(Jge), (t().graphElements.nodes.length > 0 || t().graphElements.edges.length > 0) && m();
  });
  function m() {
    Pe(l) && Pe(l).destroy(), v(), t().selectedNodes.forEach((V) => {
      const N = Pe(l).$id(V);
      N && N.addClass("selected-custom");
    }), t().selectedEdges.forEach((V) => {
      const N = Pe(l).$id(V);
      N && N.addClass("selected-custom");
    });
  }
  function g({ endpoint: V, subgraph: N }) {
    E(V, N);
  }
  function T() {
    Pe(l) && (console.log("resize"), Pe(l).resize());
  }
  function v() {
    St(l, e({
      container: Pe(f),
      // Contenitore DOM per il grafo
      elements: t().graphElements,
      // Usa gli elementi dallo store
      style: Ige,
      // Stili CSS per gli elementi del grafo
      layout: Mf(),
      minZoom: 0.1,
      maxZoom: 2,
      wheelSensitivity: 1,
      zoomingEnabled: !0,
      userZoomingEnabled: !0,
      panningEnabled: !0,
      userPanningEnabled: !0,
      boxSelectionEnabled: !1,
      autounselectify: !1
      // Consentiamo la deselezione manuale con Ctrl+click
    })), Pe(l).on("tap", "node", function(M) {
      const I = M.target;
      if (fr($t, nt(t).currentSelectedNodeId = I.id(), nt(t)), M.originalEvent.ctrlKey) {
        let P = new Set(t().selectedNodes);
        P.has(I.id()) ? (P.delete(I.id()), I.removeClass("selected-custom"), t().currentSelectedNodeId === I.id() && fr($t, nt(t).currentSelectedNodeId = null, nt(t))) : (P.add(I.id()), I.addClass("selected-custom")), fr($t, nt(t).selectedNodes = Array.from(P), nt(t));
      }
      Pe(n).dispatchEvent(new CustomEvent("nodeClicked", {
        detail: {
          id: I.id(),
          label: I.data("label"),
          selected: t().selectedNodes.includes(I.id())
          // Legge lo stato aggiornato
        },
        bubbles: !0,
        composed: !0
      }));
    }), Pe(l).on("tap", "edge", function(M) {
      const I = M.target;
      if (fr($t, nt(t).currentSelectedNodeId = null, nt(t)), M.originalEvent.ctrlKey) {
        let P = new Set(t().selectedEdges);
        P.has(I.id()) ? (P.delete(I.id()), I.removeClass("selected-custom")) : (P.add(I.id()), I.addClass("selected-custom")), fr($t, nt(t).selectedEdges = Array.from(P), nt(t));
      }
      Pe(n).dispatchEvent(new CustomEvent("edgeClicked", {
        detail: {
          id: I.id(),
          label: I.data("label"),
          selected: t().selectedEdges.includes(I.id())
          // Legge lo stato aggiornato
        },
        bubbles: !0,
        composed: !0
      }));
    });
    var V = 250, N;
    Pe(l).on("tap", function(M) {
      if (M.target === Pe(l)) {
        var I = M.timeStamp, P = I - N;
        P < V ? (Pe(l).resize(), Pe(l).fit()) : Pe(h) ? fr($t, nt(t).currentSelectedNodeId = null, nt(t)) : (Pe(l).elements().removeClass("selected-custom"), fr($t, nt(t).selectedNodes = [], nt(t)), fr($t, nt(t).selectedEdges = [], nt(t))), N = I;
      }
    });
  }
  async function E(V, N) {
    if (i = V, c = N, !i) {
      St(d, "Per favore, inserisci un URL per l'endpoint SPARQL.");
      return;
    }
    St(s, !0), St(d, ""), Eh($t, {
      graphElements: { nodes: [], edges: [] },
      selectedNodes: [],
      selectedEdges: [],
      dataPropertiesCache: /* @__PURE__ */ new Map(),
      currentSelectedNodeId: null
    });
    try {
      const M = await Age(i, c), I = M.map((H) => {
        const J = H.classURI.split("/").pop().split("#").pop();
        return {
          data: {
            id: H.classURI,
            label: `${J} (${H.count})`,
            count: H.count,
            selectedDataProperties: [],
            // Inizializza con un array vuoto
            includeIRI: !0,
            // Inizializza con true
            dataPropertiesFilters: {}
          }
        };
      }), P = M.map((H) => H.classURI), z = (await Ege(i, P, c)).map((H) => {
        const J = H.propertyURI.split("/").pop().split("#").pop();
        return {
          data: {
            id: `${H.sourceClass}-${H.propertyURI}-${H.targetClass}`,
            source: H.sourceClass,
            target: H.targetClass,
            label: `${J} (${H.count})`,
            propertyURI: H.propertyURI
            // Aggiungiamo la propertyURI ai dati dell'arco
          }
        };
      });
      fr($t, nt(t).graphElements = { nodes: I, edges: z }, nt(t)), Pe(l) && Pe(l).destroy(), v();
    } catch (M) {
      console.error("Errore durante la costruzione del grafo:", M), St(d, `Si Ã¨ verificato un errore: ${M.message}. Assicurati che l'endpoint sia corretto e accessibile.`);
    } finally {
      St(s, !1);
    }
  }
  function R(V, N, M) {
    const I = Pe(l).$id(V);
    I && I.data(N, M);
  }
  async function L(V) {
    if (t().dataPropertiesCache.has(V)) {
      console.log(`Data properties per ${V} recuperate dalla cache.`);
      return;
    }
    console.log(`Caricamento data properties per ${V} dall'endpoint SPARQL...`);
    try {
      const N = await Oge(i, V, c);
      fr($t, nt(t).dataPropertiesCache = new Map(t().dataPropertiesCache.set(V, N)), nt(t));
    } catch (N) {
      console.error(`Errore nel caricamento delle data properties per ${V}:`, N), fr($t, nt(t).dataPropertiesCache = new Map(t().dataPropertiesCache.set(V, [])), nt(t));
    }
  }
  function A(V, N, M) {
    Eh($t, {
      ...t(),
      // Copia lo stato globale
      currentPanelNodeSelection: (() => {
        const I = { ...t().currentPanelNodeSelection };
        let P = new Set(I.selectedDataProperties || []), B = {
          ...I.dataPropertiesFilters || {}
        };
        return M ? (P.add(N), B[N] || (B[N] = { type: "contains", value: "" })) : P.delete(N), I.selectedDataProperties = Array.from(P), I.dataPropertiesFilters = B, I;
      })()
    }), R(V, "selectedDataProperties", t().currentPanelNodeSelection.selectedDataProperties), R(V, "dataPropertiesFilters", t().currentPanelNodeSelection.dataPropertiesFilters);
  }
  function w(V, N) {
    Eh($t, {
      ...t(),
      currentPanelNodeSelection: {
        ...t().currentPanelNodeSelection,
        includeIRI: N
      }
    }), R(V, "includeIRI", t().currentPanelNodeSelection.includeIRI);
  }
  function S(V, N, M) {
    Eh($t, {
      ...t(),
      currentPanelNodeSelection: (() => {
        const I = { ...t().currentPanelNodeSelection }, P = {
          ...I.dataPropertiesFilters || {}
        };
        return P[N] || (P[N] = { value: "" }), P[N].type = M, I.dataPropertiesFilters = P, I;
      })()
    }), R(V, "dataPropertiesFilters", t().currentPanelNodeSelection.dataPropertiesFilters);
  }
  function O(V, N, M) {
    Eh($t, {
      ...t(),
      currentPanelNodeSelection: (() => {
        const I = { ...t().currentPanelNodeSelection }, P = {
          ...I.dataPropertiesFilters || {}
        };
        return P[N] || (P[N] = { type: "contains" }), P[N].value = M, I.dataPropertiesFilters = P, I;
      })()
    }), R(V, "dataPropertiesFilters", t().currentPanelNodeSelection.dataPropertiesFilters);
  }
  function x() {
    var W;
    if (t().selectedNodes.length === 0)
      return {
        res: !1,
        value: "Nessun nodo selezionato. Selezionare almeno un nodo."
      };
    let V = [], N = /* @__PURE__ */ new Set();
    const M = /* @__PURE__ */ new Map();
    let I = 1, P = 1;
    t().selectedNodes.forEach((le) => {
      const fe = Pe(l).$id(le);
      if (!fe) return;
      const me = `?i${I++}`;
      M.set(le, me), fe.data("includeIRI") && N.add(me), V.push(`   ${me} a <${le}> .`);
      const Ne = fe.data("dataPropertiesFilters") || {}, xe = fe.data("selectedDataProperties") || [];
      (/* @__PURE__ */ new Set([
        ...Object.keys(Ne),
        // Tutte le proprietÃ  che hanno un filtro
        ...xe
        // Tutte le proprietÃ  selezionate per la proiezione
      ])).forEach(($) => {
        const D = `?dp_${fe.id().split("/").pop().split("#").pop()}_${P++}`;
        V.push(`   ${me} <${$}> ${D} .`), xe.includes($) && N.add(D);
        const C = Ne[$];
        if (C && C.value !== "") {
          let X = "";
          const te = C.value.replace(/["\\]/g, "\\$&");
          switch (C.type) {
            case "contains":
              X = `FILTER regex(${D}, "${te}", "i")`;
              break;
            case "equals":
              !isNaN(parseFloat(C.value)) && isFinite(C.value) ? X = `FILTER (${D} = ${C.value})` : X = `FILTER (${D} = "${te}")`;
              break;
            case "greater":
              X = `FILTER (${D} > ${C.value})`;
              break;
            case "less":
              X = `FILTER (${D} < ${C.value})`;
              break;
          }
          X && V.push(`   ${X}`);
        }
      });
    });
    const B = /* @__PURE__ */ new Set();
    t().selectedNodes.length === 1 && B.add(t().selectedNodes[0]);
    for (const le of t().selectedEdges) {
      const fe = Pe(l).$id(le);
      if (fe) {
        const me = fe.source().id(), Ne = fe.target().id(), xe = fe.data("propertyURI");
        if (!t().selectedNodes.includes(me) || !t().selectedNodes.includes(Ne))
          return {
            res: !1,
            value: `L'arco "${fe.data("label")}" Ã¨ selezionato, ma i suoi nodi sorgente e/o destinazione non lo sono. Si prega di selezionare anche i nodi collegati.`
          };
        B.add(me), B.add(Ne);
        const ue = M.get(me), $ = M.get(Ne);
        V.push(`  ${ue} <${xe}> ${$} .`);
        const D = Pe(l).$id(me), C = Pe(l).$id(Ne);
        D && D.data("includeIRI") && N.add(ue), C && C.data("includeIRI") && N.add($);
      }
    }
    if (t().selectedNodes.length > 1) {
      for (const le of t().selectedNodes)
        if (!B.has(le))
          return {
            res: !1,
            value: `Il nodo "${((W = Pe(l).$id(le)) == null ? void 0 : W.data("label")) || le}" Ã¨ selezionato ma Ã¨ isolato (non connesso ad altri nodi selezionati tramite un arco selezionato). Si prega di selezionare anche gli archi di collegamento.`
          };
    }
    const z = Array.from(N).sort().join(" "), J = `${z.length > 0 ? `SELECT ${z}` : "SELECT *"}
WHERE {
${V.join(`
`)}
}`;
    return { res: !0, value: F(J) };
  }
  function F(V) {
    const N = /* @__PURE__ */ new Map();
    let M = [], I = V;
    const P = /^(PREFIX\s+([^:]+):\s+<([^>]+)>\s*[\r\n]*)/gm;
    let B, z = 0;
    const H = new RegExp(P);
    for (; (B = H.exec(V)) !== null; )
      M.push(B[1].trim()), N.set(B[2], B[3]), z = H.lastIndex;
    I = V.substring(z).trim();
    const J = /* @__PURE__ */ new Map();
    let k = 1;
    const W = (C) => {
      const X = C.lastIndexOf("#"), te = C.lastIndexOf("/"), de = Math.max(X, te), oe = de > -1 ? C.substring(0, de + 1) : C, De = de > -1 ? C.substring(de + 1) : C;
      for (const [Ee, Ie] of N.entries())
        if (oe === Ie)
          return {
            prefix: Ee,
            localName: De,
            fullUri: C
          };
      if (J.has(oe))
        return {
          prefix: J.get(oe),
          localName: De,
          fullUri: C
        };
      let Ve;
      const qe = oe.match(/\/\/([^\/]+)\/|#$/);
      if (qe && qe[1]) {
        const Ee = qe[1].split(".");
        Ve = Ee[Ee.length - 2] || Ee[Ee.length - 1], Ve && (Ve = Ve.toLowerCase().replace(/[^a-z0-9]/g, ""));
      } else if (te > -1) {
        const Ee = oe.slice(0, -1).split("/");
        Ve = Ee[Ee.length - 1];
      } else
        Ve = `p${k}`;
      let Ke = Ve, Y = 1;
      for (; N.has(Ke) || Array.from(J.values()).includes(Ke); )
        Ke = `${Ve}${Y++}`;
      return J.set(oe, Ke), {
        prefix: Ke,
        localName: De,
        fullUri: C
      };
    }, le = /* @__PURE__ */ new Set(), fe = /<([^>]+)>/g;
    let me;
    for (fe.lastIndex = 0; (me = fe.exec(I)) !== null; )
      le.add(me[1]);
    const Ne = /* @__PURE__ */ new Map();
    le.forEach((C) => {
      const { prefix: X, localName: te, fullUri: de } = W(C);
      Ne.set(de, `${X}:${te}`);
    });
    let xe = I.replace(fe, (C) => {
      const X = C.substring(1, C.length - 1);
      return Ne.has(X) ? Ne.get(X) : C;
    }), ue = [];
    J.forEach((C, X) => {
      let te = !1;
      for (const [de, oe] of N.entries())
        if (oe === X) {
          te = !0;
          break;
        }
      te || ue.push(`PREFIX ${C}: <${X}>`);
    });
    const $ = M.concat(ue).sort().join(`
`);
    let D = "";
    return $.length > 0 && (D += $ + `

`), D += xe, D;
  }
  function j() {
    if (Pe(l)) {
      const V = Pe(l).json(), N = {
        sparqlEndpoint: i,
        subgraphURI: c,
        graphData: V,
        selectedNodes: t().selectedNodes,
        selectedEdges: t().selectedEdges,
        zoom: Pe(l).zoom(),
        pan: Pe(l).pan()
      };
      return JSON.stringify(N, null, 2);
    }
    return null;
  }
  async function q(V) {
    var N, M, I, P;
    try {
      St(s, !0), St(d, "");
      const B = JSON.parse(V);
      if (B.sparqlEndpoint && (i = B.sparqlEndpoint), B.subgraphURI && (c = B.subgraphURI), fr($t, nt(t).graphElements = ((N = B.graphData) == null ? void 0 : N.elements) || { nodes: [], edges: [] }, nt(t)), fr($t, nt(t).selectedNodes = B.selectedNodes || [], nt(t)), B.selectedEdges && Array.isArray(B.selectedEdges))
        fr($t, nt(t).selectedEdges = B.selectedEdges, nt(t));
      else {
        const z = (M = B.graphData) == null ? void 0 : M.edges;
        Array.isArray(z) ? fr(
          $t,
          nt(t).selectedEdges = z.filter((H) => {
            var J;
            return (J = H.data) == null ? void 0 : J.selected;
          }).map((H) => H.data.id),
          nt(t)
        ) : fr($t, nt(t).selectedEdges = [], nt(t));
      }
      fr($t, nt(t).dataPropertiesCache = /* @__PURE__ */ new Map(), nt(t)), fr($t, nt(t).currentSelectedNodeId = null, nt(t)), fr(
        $t,
        nt(t).currentPanelNodeSelection = {
          selectedDataProperties: [],
          includeIRI: !0,
          dataPropertiesFilters: {}
        },
        nt(t)
      ), m(), Pe(l) && B.zoom !== void 0 && B.pan ? (Pe(l).zoom(B.zoom), Pe(l).pan(B.pan)) : Pe(l) && ((I = B.graphData) == null ? void 0 : I.zoom) !== void 0 && ((P = B.graphData) != null && P.pan) && (Pe(l).zoom(B.graphData.zoom), Pe(l).pan(B.graphData.pan)), Pe(n).dispatchEvent(new CustomEvent("graphLoaded", { bubbles: !0, composed: !0 }));
    } catch (B) {
      console.error("Errore durante l'importazione del grafo:", B), St(d, `Errore durante l'importazione: ${B.message}. Assicurati che il file sia un JSON valido e contenga la struttura del grafo.`);
    } finally {
      St(s, !1);
    }
  }
  Lte(() => {
    Pe(l) && Pe(l).destroy();
  }), qO(
    () => (Pe(l), t(), Pe(b), Pe(h)),
    () => {
      if (Pe(l) && t().currentSelectedNodeId)
        if (St(b, t().dataPropertiesCache.has(t().currentSelectedNodeId)), console.log("1Â° blocco reattivo, isPanelDataReady:", Pe(b)), St(h, Pe(l).$id(t().currentSelectedNodeId)), L(t().currentSelectedNodeId), St(p, t().dataPropertiesCache.get(t().currentSelectedNodeId) || []), Pe(h)) {
          const V = Pe(h).data("selectedDataProperties") || [], N = Pe(h).data("includeIRI") !== void 0 ? Pe(h).data("includeIRI") : !0, M = Pe(h).data("dataPropertiesFilters") || {};
          fr(
            $t,
            nt(t).currentPanelNodeSelection = {
              selectedDataProperties: V,
              includeIRI: N,
              dataPropertiesFilters: M
            },
            nt(t)
          );
        } else
          fr(
            $t,
            nt(t).currentPanelNodeSelection = {
              nodeId: null,
              // Aggiungi nodeId per chiarezza, o assicurati che sia gestito altrove
              selectedDataProperties: [],
              includeIRI: !0,
              dataPropertiesFilters: {}
            },
            nt(t)
          );
      else
        St(h, null), St(p, []), fr(
          $t,
          nt(t).currentPanelNodeSelection = {
            nodeId: null,
            // Aggiungi nodeId per chiarezza
            selectedDataProperties: [],
            includeIRI: !0,
            dataPropertiesFilters: {}
          },
          nt(t)
        );
    }
  ), qO(
    () => (t(), Pe(b)),
    () => {
      t().currentSelectedNodeId && t().dataPropertiesCache.has(t().currentSelectedNodeId) && (St(b, t().dataPropertiesCache.has(t().currentSelectedNodeId)), console.log("2Â° blocco reattivo, isPanelDataReady:", Pe(b)));
    }
  ), cJ(), Lx();
  var Q = Zge(), G = _S(Q), K = Ar(G), U = Ar(K);
  {
    var ae = (V) => {
      var N = Kge();
      zr(V, N);
    }, ye = (V, N) => {
      {
        var M = (P) => {
          var B = Wge(), z = Ar(B), H = Ar(z, !0);
          _r(z), _r(B), Gf(() => RT(H, Pe(d))), zr(P, B);
        }, I = (P, B) => {
          {
            var z = (H) => {
              var J = Yge();
              zr(H, J);
            };
            Pi(
              P,
              (H) => {
                t(), nt(() => t().graphElements.nodes.length === 0 && t().graphElements.edges.length === 0) && H(z);
              },
              B
            );
          }
        };
        Pi(
          V,
          (P) => {
            Pe(d) ? P(M) : P(I, !1);
          },
          N
        );
      }
    };
    Pi(U, (V) => {
      Pe(s) ? V(ae) : V(ye, !1);
    });
  }
  _r(K), VO(K, (V) => St(f, V), () => Pe(f));
  var pe = pi(K, 2);
  {
    var ee = (V) => {
      qge(V, {
        get currentSelectedNode() {
          return Pe(h);
        },
        get currentPanelDataProperties() {
          return Pe(p);
        },
        toggleIncludeIRI: w,
        toggleDataProperty: A,
        updateFilterValue: O,
        updateFilterType: S,
        panelPosition: "middle-right",
        ";": !0
      });
    };
    Pi(pe, (V) => {
      Pe(h) && Pe(b) && V(ee);
    });
  }
  _r(G), VO(G, (V) => St(n, V), () => Pe(n));
  var Te = pi(G, 2), we = Ar(Te), Oe = Ar(we);
  _r(we);
  var be = pi(we, 2);
  J6(be), _r(Te), Gf(() => RT(Oe, `Distanza tra i nodi: ${j0(Mf()), nt(() => Mf().edgeLength) ?? ""}`)), Gte(be, () => Mf().edgeLength, (V) => Mf(Mf().edgeLength = V)), jn("input", be, y), zr(u, Q), Cn(r, "setSource", g), Cn(r, "resizeGraph", T), Cn(r, "getQuery", x), Cn(r, "exportGraph", j), Cn(r, "importGraph", q);
  var he = FS({
    setSource: g,
    resizeGraph: T,
    getQuery: x,
    exportGraph: j,
    importGraph: q
  });
  return a(), he;
}
var rme = /* @__PURE__ */ Qn(`<div class="help-container svelte-1ms4804" style="max-height: 100%; max-width: 100%; overflow: auto;"><h1 class="help-title svelte-1ms4804">Come Interagire con il Grafo per Creare Query SPARQL</h1> <p class="help-intro svelte-1ms4804">Questa guida ti aiuterÃ  a capire come utilizzare l'interfaccia grafica per esplorare i dati e costruire le tue query SPARQL in modo intuitivo, senza dover scrivere una singola riga di codice.</p> <hr class="help-separator svelte-1ms4804"/> <h2 class="help-section-title svelte-1ms4804">1. Esplorare il Grafo</h2> <ul class="help-list svelte-1ms4804"><li class="svelte-1ms4804"><strong class="svelte-1ms4804">Nodi (Classi/Risorse):</strong> I cerchi rappresentano le classi (o tipi di risorse) nel tuo dataset. Ogni nodo ha un'etichetta che ne identifica il nome.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Archi (ProprietÃ ):</strong> Le linee tra i nodi rappresentano le relazioni (o proprietÃ ) che esistono tra le classi. Anche gli archi hanno un'etichetta che descrive la relazione.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Navigazione:</strong> Puoi trascinare il grafo per muoverti, usare la rotellina del mouse per lo zoom avanti/indietro e fare doppio clic su un'area vuota per ricentrare la vista.</li></ul> <hr class="help-separator svelte-1ms4804"/> <h2 class="help-section-title svelte-1ms4804">2. Selezionare Elementi per la Query</h2> <p>La parte piÃ¹ importante per creare una query Ã¨ la selezione degli elementi sul grafo:</p> <ul class="help-list svelte-1ms4804"><li class="svelte-1ms4804"><strong class="svelte-1ms4804">Selezionare un singolo Nodo:</strong> Clicca su un nodo per selezionarlo. VerrÃ  evidenziato e apparirÃ  un pannello con le opzioni del nodo.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Selezionare Multipli Nodi/Archi:</strong> Tieni premuto il tasto <kbd class="svelte-1ms4804">CTRL</kbd> (o <kbd class="svelte-1ms4804">CMD</kbd> su Mac) e clicca su piÃ¹ nodi o archi per aggiungerli o rimuoverli dalla selezione.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Deselezionare:</strong> Clicca su un nodo/arco selezionato tenendo premuto <kbd class="svelte-1ms4804">CTRL</kbd>/<kbd class="svelte-1ms4804">CMD</kbd> per deselezionarlo. Cliccando su un'area vuota deselezionerai tutto.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Modificare la disposizione:</strong> Puoi modificare la disposizione dei nodi del grafo, se questo Ã¨ particolarmente complesso ed intricato (a volte capita per modelli complessi) agendo sullo sider che regola la forza con cui si attraggono i nodi nel layout di visualizzazione, in questo modo puoi scogliere dei "grovigli" per poi tornare ad una visualizzazione piÃ¹ compatta.</li></ul> <hr class="help-separator svelte-1ms4804"/> <h2 class="help-section-title svelte-1ms4804">3. Gestire le ProprietÃ  dei Nodi (Pannello Dettagli)</h2> <p>Quando selezioni un nodo, appare un pannello "Opzioni per il Nodo", simile a una piccola finestra.</p> <ul class="help-list svelte-1ms4804"><li class="svelte-1ms4804"><strong class="svelte-1ms4804">Chiudere il Pannello:</strong> Puoi chiudere questo pannello cliccando sul pannello del grafo. Si riaprirÃ  automaticamente se selezioni un altro nodo.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Proietta IRI della Classe:</strong> Questa casella di controllo ti permette di includere l'URI completo della classe nella query.</li> <li class="svelte-1ms4804"><strong class="svelte-1ms4804">Data Properties Disponibili:</strong> Qui trovi un elenco delle proprietÃ  dati (come nome, data di nascita, descrizione) associate alla classe del nodo selezionato. <ul class="svelte-1ms4804"><li class="svelte-1ms4804">Seleziona le caselle di controllo accanto alle proprietÃ  che vuoi includere nella query. La query cercherÃ  istanze di questa classe che hanno queste proprietÃ .</li> <li class="svelte-1ms4804">Il numero tra parentesi \`(nome classe: XX)\` indica quante istanze della classe hanno effettivamente quella proprietÃ  nel dataset.</li></ul></li></ul> <hr class="help-separator svelte-1ms4804"/> <h2 class="help-section-title svelte-1ms4804">4. Generare e Visualizzare la Query</h2> <ul class="help-list svelte-1ms4804"><li class="svelte-1ms4804">Una volta selezionati i nodi e gli archi desiderati, e impostate le proprietÃ  per i nodi selezionati, clicca sul pulsante "Ottieni Query".</li> <li class="svelte-1ms4804">La query SPARQL generata apparirÃ  nel campo di testo dedicato alla query, da li puoi editarla a tuo piacimento. Le modifiche effettuate sulla query testuale non vengono riportate nel grafo.</li> <li class="svelte-1ms4804">La query SPARQL ottenuta puÃ² essere eseguita sull'endpoint SPARQL premendo iltasto "Esegui Query".</li></ul></div>`);
const nme = {
  hash: "svelte-1ms4804",
  code: ".help-container.svelte-1ms4804 {font-family:'Inter', sans-serif;line-height:1.6;color:#333;max-width:800px;margin:2rem auto;padding:1.5rem;background-color:#f9f9f9;border-radius:8px;box-shadow:0 4px 8px rgba(0, 0, 0, 0.1);}.help-title.svelte-1ms4804 {font-size:2.2em;color:#2c3e50;text-align:center;margin-bottom:1.5rem;border-bottom:2px solid #eee;padding-bottom:1rem;}.help-intro.svelte-1ms4804 {font-size:1.1em;text-align:center;margin-bottom:2rem;color:#555;}.help-separator.svelte-1ms4804 {border:0;height:1px;background:#ddd;margin:2.5rem 0;}.help-section-title.svelte-1ms4804 {font-size:1.6em;color:#34495e;margin-bottom:1rem;padding-left:0.5rem;border-left:4px solid #3498db;}.help-list.svelte-1ms4804 {list-style:disc;margin-left:25px;margin-bottom:1.5rem;}.help-list.svelte-1ms4804 li:where(.svelte-1ms4804) {margin-bottom:0.8rem;}.help-list.svelte-1ms4804 li:where(.svelte-1ms4804) strong:where(.svelte-1ms4804) {color:#2c3e50;}.help-list.svelte-1ms4804 ul:where(.svelte-1ms4804) { /* per le liste annidate */list-style:circle;margin-top:0.5rem;margin-left:20px;}kbd.svelte-1ms4804 {background-color:#eee;border-radius:3px;border:1px solid #b4b4b4;box-shadow:0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;color:#333;display:inline-block;font-size:0.85em;font-weight:700;line-height:1;padding:2px 4px;white-space:nowrap;}"
};
function ime(u) {
  LS(u, nme);
  var r = rme();
  zr(u, r);
}
var ame = /* @__PURE__ */ Qn('<div class="tab-header svelte-1t4olc8"><button>Grafo</button> <button>Istruzioni</button></div> <div class="tab-content svelte-1t4olc8"><!></div>', 1);
const ume = {
  hash: "svelte-1t4olc8",
  code: `\r
    /* Stili per il contenitore del Web Component */:host {display:flex;flex-direction:column;width:100%;min-height:550px; /* Altezza minima per il contenuto */border:1px solid #000;border-radius:0px;font-family:"Titillium Web", sans-serif;overflow:hidden; /* Assicura che i bordi arrotondati funzionino */}.tab-header.svelte-1t4olc8 {display:flex;justify-content:space-around;background-color:#ecf0f1;}.tab-button.svelte-1t4olc8 {flex:1;padding:12px 0;background:none;border:none;cursor:pointer;font-size:16px;font-weight:bold;color:#6c757d;transition:color 0.3s,\r
            background-color 0.3s;outline:none;position:relative;border-bottom:2px solid #bdc3c7;}.tab-button.svelte-1t4olc8:hover:not(.active) {background-color:#dfe6e9;}.tab-button.active.svelte-1t4olc8 {color:#a50d26;background-color:white;border:none;border-bottom:2px solid #a50d26 !important;}.tab-content.svelte-1t4olc8 {flex-grow:1;padding:20px;background-color:white;overflow-y:auto; /* Se il contenuto del tab Ã¨ troppo grande */}`
};
function ome(u, r) {
  RS(r, !1), LS(u, ume), ca(r, "appTitle", 8, "Graph App");
  let o = ca(r, "initialTab", 8, "graph"), a = /* @__PURE__ */ kr(o()), t = /* @__PURE__ */ kr();
  function e(E) {
    ["graph", "query", "result"].includes(E) ? (St(a, E), console.log(`Web Component: Changed tab to ${E}`)) : console.warn(`Web Component: Invalid tab name received: ${E}`);
  }
  function n(E) {
    if (Pe(t) && typeof Pe(t).addNode == "function") {
      const R = Pe(t).addNode(E);
      return dispatchEvent(new CustomEvent("nodeAddedInternal", {
        detail: { id: R, from: "web-component" },
        bubbles: !0,
        composed: !0
      })), R;
    } else
      return console.error("Graph component not ready to add node."), null;
  }
  Px(() => {
    console.log("MyTabsAppComponent (Web Component) mounted.");
  });
  function i(E) {
    return Pe(t).setSource(E);
  }
  function c() {
    return Pe(t).getQuery();
  }
  function s() {
    return Pe(t).exportGraph();
  }
  function d(E) {
    return Pe(t).importGraph(E);
  }
  function l() {
    return Pe(t).resizeGraph();
  }
  Lx();
  var f = ame(), h = _S(f), p = Ar(h);
  let b;
  var _ = pi(p, 2);
  let y;
  _r(h);
  var m = pi(h, 2), g = Ar(m);
  {
    var T = (E) => {
      VO(tme(E, { title: "Il Tuo Grafo", $$legacy: !0 }), (R) => St(t, R), () => Pe(t));
    }, v = (E, R) => {
      {
        var L = (A) => {
          ime(A);
        };
        Pi(
          E,
          (A) => {
            Pe(a) === "help" && A(L);
          },
          R
        );
      }
    };
    Pi(g, (E) => {
      Pe(a) === "graph" ? E(T) : E(v, !1);
    });
  }
  return _r(m), Gf(
    (E, R) => {
      b = UO(p, 1, "tab-button svelte-1t4olc8", null, b, E), y = UO(_, 1, "tab-button svelte-1t4olc8", null, y, R);
    },
    [
      () => ({ active: Pe(a) === "graph" }),
      () => ({ active: Pe(a) === "help" })
    ],
    B0
  ), jn("click", p, () => St(a, "graph")), jn("click", _, () => St(a, "help")), zr(u, f), Cn(r, "setActiveTab", e), Cn(r, "addNodeToGraph", n), Cn(r, "setSource", i), Cn(r, "getQuery", c), Cn(r, "exportGraph", s), Cn(r, "importGraph", d), Cn(r, "resizeGraph", l), FS({
    setActiveTab: e,
    addNodeToGraph: n,
    setSource: i,
    getQuery: c,
    exportGraph: s,
    importGraph: d,
    resizeGraph: l
  });
}
customElements.define("svelte-comp", Zte(
  ome,
  { appTitle: {}, initialTab: {} },
  [],
  [
    "setActiveTab",
    "addNodeToGraph",
    "setSource",
    "getQuery",
    "exportGraph",
    "importGraph",
    "resizeGraph"
  ],
  !0
));
